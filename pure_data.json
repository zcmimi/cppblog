[{"categories":[],"content":"\n\n## 问题\n\n求$\\displaystyle \\sum\\limits_{i=1}^n i^k$\n\n## 普通求法:\n\n$$\n(n+1)^{k+1}-n^{k+1}=\n{k+1\\choose 1}n^k+{k+1\\choose 2}n^{k-1}+\\dots+{k+1\\choose k}n+1\n$$\n\n累加$n=1,2,3,\\dots$的结果\n\n$$\n(n+1)^{k+1}-1={k+1\\choose 1}\\sum_{i=1}^n i^k + {k+1\\choose 2}\\sum_{i=1}^n i^{k-1} + \\dots + {k+1\\choose k}\\sum_{i=1}^n i^k + n\n$$\n\n移项\n\n$$\n\\sum_{i=1}^n i^k=\n\\frac 1{k+1}\\left[\n(n+1)^{k+1}-1\n-{k+1\\choose 2}\\sum_{i=1}^n i^{k-1}\n-{k+1\\choose 3}\\sum_{i=1}^n i^{k-2}\n-\\dots\n-{k+1\\choose k}\\sum_{i=1}^n i\n-n\n\\right]\n$$\n\n设$S(n,k)=\\sum\\limits_{i=1}^n i^k$,那么\n\n$$\nS(n,k)=\\frac 1{k+1}\\left[\n(n+1)^{k+1}-1\n-{k+1\\choose 2}S(n,k-1)\n-{k+1\\choose 3}S(n,k-2)\n-\\dots\n-{k+1\\choose k}S(n,1)\n-n\n\\right]\n$$\n\n其中$S(n,1)=\\frac{n(n+1)}2$\n\n我们可以通过动态规划或记忆化搜索的方式求解,复杂度为$O(k^2)$\n\n## 斯特林数\n\n## 伯努利数\n\n## 拉格朗日插值法","link":null,"tags":[],"title":"自然数幂和"},{"categories":[["刷题记录"]],"content":"\n$$f(n)=\\sum_{i=0}^n \\sum_{j=0}^i \\begin{Bmatrix}i\\\\j\\end{Bmatrix} 2^j j!$$\n\n考虑到$i<j$时$\\begin{Bmatrix}i\\\\j\\end{Bmatrix}=0$ :\n\n$$\nf(n)=\\sum_{j=0}^n 2^j j! \\sum_{i=0}^n \\begin{Bmatrix}i\\\\j\\end{Bmatrix}\\\\\n=\\sum_{j=0}^n 2^j j! \\sum_{i=0}^n \\sum_{k=0}^j \\frac{(-1)^k}{k!} \\frac{(j-k)^i}{(j-k)!}\\\\\n=\\sum_{j=0}^n 2^j j! \\sum_{k=0}^j \\frac{(-1)^k}{k!} \\frac{\\sum_{i=0}^n (j-k)^i}{(j-k)!}\n$$\n\n设$\\displaystyle g(k)=\\frac{(-1)^k}{k!}, h(k)=\\frac{\\sum_{i=0}^n k^i}{k!}=\\frac{k^{n+1}-1}{(k-1)k!}$ ,\n\n特别的: $h(0)=1,h(1)=n+1$\n\n那么\n\n$$f(n)=\\sum_{j=0}^n 2^j j! (g\\times h)(j)$$\n\n卷积后即可计算\n```cpp\n#include<bits\/stdc++.h>\nconst int N=262144,P=998244353,G=3,Gi=332748118;\nint fac[N],ifac[N],inv[N],L,r[N],h[N],g[N];\nint pw(int x,int b){\n    int res=1;\n    while(b){\n        if(b&1)res=1ll*res*x%P;\n        b>>=1;x=1ll*x*x%P;\n    }\n    return res;\n}\nvoid getL(int n){\n    for(L=1;L<n;L<<=1);\n    for(int i=0;i<L;++i)\n        r[i]=(r[i>>1]>>1)|((i&1)?(L>>1):0);\n}\nvoid swap(int&x,int&y){x^=y,y^=x,x^=y;}\nvoid ntt(int*A,int typ){\n    for(int i=0;i<L;++i)\n        if(i<r[i])swap(A[i],A[r[i]]);\n    for(int len=1;len<L;len<<=1){\n        int Wn=pw(~typ?G:Gi,(P-1)\/(len<<1));\n        for(int i=0;i<L;i+=len<<1){\n            int w=1;\n            for(int k=0;k<len;++k){\n                int t=1ll*A[i+k+len]*w%P;\n                A[i+k+len]=(A[i+k]-t+P)%P;\n                A[i+k]=(A[i+k]+t)%P;\n                w=1ll*w*Wn%P;\n            }\n        }\n    }\n    if(~typ)return;\n    int iL=pw(L,P-2);\n    for(int i=0;i<L;++i)A[i]=1ll*A[i]*iL%P;\n}\nint main(){\n    int n;scanf(\"%d\",&n);\n\n    inv[1]=1;\n    for(int i=2;i<=n;++i)inv[i]=1ll*(P-P\/i)*inv[P%i]%P;\n\n    fac[0]=1;\n    for(int i=1;i<=n;++i)fac[i]=1ll*fac[i-1]*i%P;\n    ifac[n]=pw(fac[n],P-2);\n    for(int i=n;i;--i)ifac[i-1]=1ll*ifac[i]*i%P;\n\n    g[0]=1,g[1]=P-1;\n    h[0]=1,h[1]=n+1;\n    for(int i=2;i<=n;++i)\n        g[i]=(i&1)?P-ifac[i]:ifac[i],\n        h[i]=1ll*(pw(i,n+1)-1)*ifac[i]%P*inv[i-1]%P;\n    \n    getL(n<<1);\n    ntt(g,1),ntt(h,1);\n    for(int i=0;i<L;++i)\n        g[i]=1ll*g[i]*h[i]%P;\n    ntt(g,-1);\n    \n    int ans=0;\n    for(int i=0,p2=1;i<=n;++i,p2=(p2+p2)%P)\n        (ans+=1ll*p2*fac[i]%P*g[i]%P)%=P;\n    printf(\"%d\\n\",ans);\n}\n```\n","link":null,"tags":["数论","斯特林数"],"title":"LG 4091[TJOI2016]求和"},{"categories":[["note"]],"content":"\n\n## 第一类斯特林数\n\n### 定义\n\n- $s(n,m)$表示将$n$个元素分成$m$个圆排列的方案数\n\n- 记作$\\begin{bmatrix}n\\\\m\\end{bmatrix}$\n\n### 递推式\n\n$$\n\\begin{bmatrix}n\\\\m\\end{bmatrix}=\\begin{bmatrix}n-1\\\\m-1\\end{bmatrix}+(n-1)\\begin{bmatrix}n-1\\\\m\\end{bmatrix}\n$$\n\n(当前元素可以建一个新环或放在已有的任意元素前面)\n\n### 性质\n\n$$\n\\sum_{i=0}^n \\begin{bmatrix}n\\\\i\\end{bmatrix} = n!\n$$\n\n证明: 每个排列实际上对应着一个置换\n\n考虑$s(n,i)$分成的$i$个环,实际上就是对应着循环节个数为$i$的一种置换,一一对应过去就是所有置换方案就是全排列了\n\n\n\n> 阶乘幂\n> \n> 上升阶乘幂:\n>\n> $\\begin{aligned}x^{\\overline{n}}&=x(x+1)(x+2)\\cdots(x+n-1)\\\\&=\\frac{(x+n-1)!}{(x-1)!}\\end{aligned}$\n> \n> 下降阶乘幂:\n> \n> $\\begin{aligned}x^{\\underline{n}}&=x(x-1)(x-2)\\cdots(x-n+1)\\\\&=\\frac{x!}{(x-n)!}\\end{aligned}$\n\n- **上升阶乘幂**\n\n  $\\displaystyle x^{\\overline n}=\\sum_{i=0}^n \\begin{bmatrix}n\\\\i\\end{bmatrix}x^i$\n  \n  证明:\n  \n  $\n  \\begin{aligned}\n  x^{\\overline{n+1}}\n  &=(x+n)\\sum_{i=0}^n \\begin{bmatrix}n\\\\i\\end{bmatrix}x^i\\\\\n  &=\\sum_{i=0}^{n+1}\\begin{bmatrix}n\\\\i-1\\end{bmatrix}x^i+n\\sum_{i=0}^{n+1}\\begin{bmatrix}n\\\\i\\end{bmatrix}x^i\\\\\n  &=\\sum_{i=0}^{n+1}\\left( \\begin{bmatrix}n\\\\i-1\\end{bmatrix}+n\\begin{bmatrix}n\\\\i\\end{bmatrix}\\right)x^i\\\\\n  &=\\sum_{i=0}^{n+1}\\begin{bmatrix}n+1\\\\i\\end{bmatrix}x^i\n  \\end{aligned}\n  $\n\n- 下降阶乘幂\n  \n  $\\displaystyle x^{\\underline{n}}=\\sum_{i=0}^n \\begin{bmatrix}n\\\\i\\end{bmatrix}(-1)^{n-i}x^i$\n  \n  证明(数学归纳法):\n  \n  $n=1$时,成立\n  \n  $n>1$时:\n  \n  $\n  \\begin{aligned}\n  x^{\\underline{n+1}}\n  &=(x-n)x^{\\underline{n}}\\\\\n  &=(x-n)\\sum_{i=0}^n \\begin{bmatrix}n\\\\i\\end{bmatrix}(-1)^{n-i}x^i\\\\\n  &=\\sum_{i=0}^{n+1} \\begin{bmatrix}n\\\\i-1\\end{bmatrix}(-1)^{n-i-1}x^i\n  +n\\sum_{i=0}^{n+1} \\begin{bmatrix}n\\\\i\\end{bmatrix}(-1)^{n-i+1}x^i\\\\\n  &=\\sum_{i=0}^{n+1}\\left( \\begin{bmatrix}n\\\\i-1\\end{bmatrix} + n\\begin{bmatrix}n\\\\i\\end{bmatrix}\\right)(-1)^{n-i+1}x^i\\\\\n  &=\\sum_{i=0}^{n+1}\\begin{bmatrix}n+1\\\\i\\end{bmatrix}(-1)^{n+1-i}x^i\n  \\end{aligned}\n  $\n\n### 快速计算\n\n构造第一类斯特林数生成函数:\n\n$\\displaystyle\n\\sum_{i=0}^n \\begin{bmatrix}n\\\\i\\end{bmatrix} x^i\n=\\prod_{i=0}^{n-1} (x+i)\n$\n\n倍增:\n\n设$\\displaystyle F_n(x)=\\prod_{i=0}^{n-1} (x+i)$\n\n那么$F_{2n}=F_n(x)F_n(x+n)$\n\n可以递归求解$F_n(x)$\n\n考虑快速计算$F_n(x+n)$:\n\n设$a_i=[x_i]F_n(x)=\\begin{bmatrix}n\\\\i\\end{bmatrix}$,(也就是上一次计算出的结果)\n\n$\\displaystyle\n\\begin{aligned}\nF_n(x+n)\n&=\\sum_{i=0}^{n-1} a_i (x+n)^i\\\\\n&=\\sum_{i=0}^{n-1} a_i \\sum_{j=0}^i {i\\choose j} n^{i-j}x^j\\\\\n&=\\sum_{i=0}^{n-1}x^i \\sum_{j=i}^n {j\\choose i} n^{j-i} a_j\\\\\n&=\\sum_{i=0}^{n-1}\\frac{x^i}{i!} \\sum_{j=i}^n (a_j j!)\\frac{n^{j-i}}{(j-i)!}\n\\end{aligned}\n$\n\n设$A(i)=a_i i!,B(i)=\\frac{x^i}{i!}$,那么:\n\n$\\displaystyle\n\\begin{aligned}\nF_n(x+n)\n&=\\sum_{i=0}^{n-1}\\frac{x^i}{i!} \\sum_{j=i}^n A(j)B(j-i)\\\\\n&=\\sum_{i=0}^{n-1}\\frac{x^i}{i!} \\sum_{j=0}^{n-i} A(i+j)B(j)\\\\\n&=\\sum_{i=0}^{n-1}\\frac{x^i}{i!} \\sum_{j=0}^{n-i} A'(n-i-j)B(j)\\\\\n&=\\sum_{i=0}^{n-1}\\frac{x^i}{i!} \\sum_{x+y=n-i} A'(x)B(y)\n\\end{aligned}\n$\n\n可以发现后面是卷积的形式\n\n模板: \n\n[LG 5408 第一类斯特林数·行](https:\/\/www.luogu.com.cn\/problem\/P5408)\n\n```cpp#include<bits\/stdc++.h>\nconst int N=1200000,P=167772161,G=3,Gi=55924054;\nint L,l,r[N],fac[N],inv[N];\nvoid swap(int&x,int&y){int t=x;x=y;y=t;}\nint pw(int x,int b){\n    int res=1;\n    while(b){\n        if(b&1)res=1ll*res*x%P;\n        b>>=1,x=1ll*x*x%P;\n    }\n    return res;\n}\nvoid getL(int n){\n    for(L=1;L<n;L<<=1,++l);\n    for(int i=0;i<L;++i)\n        r[i]=(r[i>>1]>>1)|((i&1)?(L>>1):0);\n}\nvoid ntt(int*A,int typ){\n    for(int i=0;i<L;++i)\n        if(i<r[i])swap(A[i],A[r[i]]);\n    for(int len=1;len<L;len<<=1){\n        int Wn=pw(~typ?G:Gi,(P-1)\/(len<<1));\n        for(int i=0;i<L;i+=len<<1){\n            int w=1;\n            for(int k=0;k<len;++k){\n                int t=1ll*w*A[i+k+len]%P;\n                A[i+k+len]=(A[i+k]-t+P)%P;\n                A[i+k]=(A[i+k]+t)%P;\n                w=1ll*w*Wn%P;\n            }\n        }\n    }\n    if(~typ)return;\n    for(int i=0,iL=pw(L,P-2);i<L;++i)\n        A[i]=1ll*A[i]*iL%P;\n}\nint s[N],a[N],b[N],g[N];\nvoid mul(int*f,int*g){\n    ntt(f,1),ntt(g,1);\n    for(int i=0;i<L;++i)f[i]=1ll*f[i]*g[i]%P;\n    ntt(f,-1);\n}\nvoid solve(int n){\n    if(n==1){s[1]=1;return;}\n    if(n&1){\n        solve(n-1);\n        for(int i=n;i;--i)\n            s[i]=(s[i-1]+1ll*s[i]*(n-1)%P)%P;\n        s[0]=1ll*s[0]*(n-1)%P;\n        return;\n    }\n    int m=n>>1,res=1;\n    solve(m);\n    for(int i=0;i<=m;++i)\n        a[i]=1ll*s[i]*fac[i]%P,\n        b[i]=1ll*res*inv[i]%P,\n        res=1ll*res*m%P;;\n    std::reverse(a,a+m+1);\n    getL((m+1)*2);\n    mul(a,b);\n    for(int i=0;i<=m;++i)\n        g[i]=1ll*inv[i]*a[m-i]%P;\n    mul(s,g);\n    for(int i=m+1;i<L;++i)a[i]=b[i]=g[i]=0;\n    for(int i=n+1;i<L;++i)s[i]=0;\n}\nvoid init(int n){\n    fac[0]=1;\n    for(int i=1;i<=n;++i)fac[i]=1ll*fac[i-1]*i%P;\n    inv[n]=pw(fac[n],P-2);\n    for(int i=n-1;i>=0;--i)inv[i]=1ll*inv[i+1]*(i+1)%P;\n}\nint main(){\n    int n;\n    scanf(\"%d\",&n);\n    init(n+n);\n    solve(n);\n    for(int i=0;i<=n;++i)\n        printf(\"%d \",s[i]);\n}\n```\n\n[LG 5409 第一类斯特林数·列](https:\/\/www.luogu.com.cn\/problem\/P5409)\n\n### 自然数幂和\n\n设$\\displaystyle S_k(n)=\\sum_{i=1}^n i^k$\n\n$\n\\begin{aligned}\nS_k(n)\n&=\\sum_{i=1}^n i^k\\\\\n&=\\sum_{i=1}^n \\left( i^{\\underline{k}} - \\sum_{j=0}^{k-1} \\begin{bmatrix}k\\\\j\\end{bmatrix}(-1)^{k-j}i^j\\right)\\\\\n&=\\sum_{i=1}^n i^{\\underline{k}} - \\sum_{j=0}^{k-1}(-1)^{k-j}\\left( \\sum_{x=1}^n x^j \\right)\\\\\n&=\\frac{(n+1)^{\\underline{k+1}}}{k+1} - \\sum_{j=0}^{k-1} \\begin{bmatrix}k\\\\j\\end{bmatrix}(-1)^{k-j}S_j(n)\n\\end{aligned}\n$\n\n$\n\\begin{aligned}\nS_k(n)\n&=\\sum_{i=1}^n i^k\\\\\n&=\\sum_{i=1}^n \\left( i^{\\overline{k}} - \\sum_{j=0}^{k-1} \\begin{bmatrix}k\\\\j\\end{bmatrix}i^j\\right)\\\\\n&=\\sum_{i=1}^n i^{\\overline{k}} - \\sum_{j=0}^{k-1}\\left( \\sum_{x=1}^n x^j \\right)\\\\\n&=\\frac{(n+1)^{\\overline{k+1}}}{k+1} - \\sum_{j=0}^{k-1}\\begin{bmatrix}k\\\\j\\end{bmatrix}S_j(n)\n\\end{aligned}\n$\n\n复杂度$O(k^2)$\n\n## 第二类斯特林数\n\n### 定义\n\n$S(n,m)$表示把$n$个元素划分成$m$个子集的方案数\n\n记作$\\begin{Bmatrix}n\\\\m\\end{Bmatrix}$\n\n### 递推式\n\n$$\n\\begin{Bmatrix}n\\\\m\\end{Bmatrix}\n=\\begin{Bmatrix}n-1\\\\m-1\\end{Bmatrix}\n+m\\cdot\\begin{Bmatrix}n-1\\\\m\\end{Bmatrix}\n$$\n\n(分到一个新的子集或者插入到已有的子集中)\n\n### 性质\n\n$\\displaystyle\n\\begin{aligned}\n\\begin{Bmatrix}n\\\\m\\end{Bmatrix}\n&=\\frac 1{m!} \\sum_{i=0}^m(-1)^i {m\\choose i}(m-i)^n\\\\\n&=\\sum_{i=0}^m \\frac{(-1)^i}{i!}\\cdot \\frac{(m-i)^n}{(m-i)!}\n\\end{aligned}$\n\n(可以看做进行容斥, 枚举多少个集合是空的, 其余的集合随便放置, 最后每一种情况会统计$m!$次)\n\n可以卷积求解\n\n\n\n$\\displaystyle\nm^n=\\sum_{i=0}^m \\begin{Bmatrix} n\\\\i \\end{Bmatrix} m^{\\underline{i}}\n$\n\n证明:\n\n$\\displaystyle\n\\begin{aligned}\nm^n\n&=\\sum_{i=0}^m \\begin{Bmatrix} n\\\\i \\end{Bmatrix} {m\\choose i} i!\\\\\n&=\\sum_{i=0}^m \\begin{Bmatrix} n\\\\i \\end{Bmatrix} m^{\\underline{i}}\n\\end{aligned}\n$\n\n(可以看作将$n$个求放到$m$个带标号的盒子内,枚举哪些盒子不为空)\n\n参考资料:\n\n- https:\/\/zh.wikipedia.org\/zh-cn\/斯特林数\n- https:\/\/ac.nowcoder.com\/discuss\/184169\n\n","link":null,"tags":["数论"],"title":"斯特林数"},{"categories":[["刷题记录"]],"content":"\n设通配符的数值为$0$,定义匹配函数$C(x,y)=[A(x)-B(y)]^2A(x)B(y)$,那么$\\displaystyle P(x)=\\sum_{i=0}^{m-1}[A(i)-B(x-m+i+1)]^2A(i)B(x-m+i+1)$\n\n按照套路,翻转$A$串得到$S$串:\n\n$\\displaystyle\n\\begin{aligned}\nP(x)\n&=\\sum_{i=0}^{m-1}[A(i)-B(x-m+i+1)]^2A(i)B(x-m+i+1)\\\\\n&=\\sum_{i=0}^{m-1}[S(m-i+1)-B(x-m+i+1)]^2S(m-i+1)B(x-m+i+1)\\\\\n&=\\sum_{i=0}^{m-1}S(m-i+1)^3B(x-m+i+1)+\\\\\n&\\quad\\sum_{i=0}^{m-1}B(x-m+i+1)^3S(m-i+1)-\\\\\n&\\quad2\\sum_{i=0}^{m-1}S(m-i+1)^2B(x-m+i+1)^2\n\\end{aligned}$\n\n写为卷积形式:\n\n$\\displaystyle P(x)=\\sum_{i+j=x}S(i)^3B(j)+S(i)B(j)^3-2S(i)^2B(j)^2$\n```cpp\n#include<bits\/stdc++.h>\nconst int N=1100011;\nint n,m,L,r[N],l,a[N],b[N],ans[N],tt;\nchar s1[N],s2[N];\ntypedef double db;\nconst db Pi=acos(-1);\nstruct cp{db r,i;cp(db R=0,db I=0){r=R,i=I;}}A[N],B[N],AS[N];\ncp operator+(cp a,cp b){return cp(a.r+b.r,a.i+b.i);}\ncp operator-(cp a,cp b){return cp(a.r-b.r,a.i-b.i);}\ncp operator*(cp a,cp b){return cp(a.r*b.r-a.i*b.i,a.r*b.i+a.i*b.r);}\nvoid swap(cp&x,cp&y){cp t=x;x=y;y=t;}\nvoid fft(cp*A,int typ){\n    for(int i=0;i<L;++i)\n        if(i<r[i])swap(A[i],A[r[i]]);\n    for(int len=1;len<L;len<<=1){\n        cp Wn(cos(Pi\/len),typ*sin(Pi\/len));\n        for(int i=0;i<L;i+=len<<1){\n            cp w(1,0);\n            for(int k=0;k<len;++k){\n                cp t=w*A[i+k+len];\n                A[i+k+len]=A[i+k]-t;\n                A[i+k]=A[i+k]+t;\n                w=w*Wn;\n            }\n        }\n    }\n    if(~typ)return;\n    for(int i=0;i<L;++i)\n        A[i].r\/=L,A[i].i\/=L;\n}\nint main(){\n    scanf(\"%d%d%s%s\",&m,&n,s1,s2);\n    std::reverse(s1,s1+m);\n    for(int i=0;i<m;++i)a[i]=s1[i]=='*'?0:s1[i]-'a'+1;\n    for(int i=0;i<n;++i)b[i]=s2[i]=='*'?0:s2[i]-'a'+1;\n\n    for(L=1,l=0;L<n+n;L<<=1,++l);\n    for(int i=0;i<L;++i)\n        r[i]=(r[i>>1]>>1)|((i&1)<<(l-1));\n    \n    for(int i=0;i<L;++i)\n        A[i]=cp(a[i]*a[i]*a[i],0),\n        B[i]=cp(b[i],0);\n    fft(A,1),fft(B,1);\n    for(int i=0;i<L;++i)AS[i]=AS[i]+A[i]*B[i];\n\n    for(int i=0;i<L;++i)\n        A[i]=cp(a[i],0),\n        B[i]=cp(b[i]*b[i]*b[i],0);\n    fft(A,1),fft(B,1);\n    for(int i=0;i<L;++i)AS[i]=AS[i]+A[i]*B[i];\n\n    for(int i=0;i<L;++i)\n        A[i]=cp(a[i]*a[i],0),\n        B[i]=cp(b[i]*b[i],0);\n    fft(A,1),fft(B,1);\n    for(int i=0;i<L;++i)AS[i]=AS[i]-A[i]*B[i]*cp(2,0);\n\n    fft(AS,-1);\n    for(int i=m-1;i<n;i++)\n        if(fabs(AS[i].r)<0.5)ans[++tt]=i-m+2;\n    printf(\"%d\\n\",tt);\n    for(int i=1;i<=tt;++i)printf(\"%d \",ans[i]);\n}\n```\n","link":null,"tags":["fft","字符串"],"title":"LG 4173 残缺的字符串"},{"categories":[["note"],["算法","字符串"]],"content":"\n\n## 普通的单模式串匹配\n\n> 给定模式串$A(|A|=m)$、文本串$B(|B|=n)$，需要求出所有位置$p$,满足$B$串从第$p$个字符开始的连续$m$个字符，与$A$串完全相同\n\n定义匹配函数$C(x,y)=[A(x)-B(y)]^2$,若$A$的第$x$个字符与$B$的第$y$个字符匹配,那么$C(x,y)=0$\n\n再定义完全匹配函数$\\displaystyle P(x)=\\sum_{i=0}^{m-1}[A(i)-B(x-m+i+1)]^2$,若$P(x)=0$,则称$B$以第$x$位结束的连续$m$位,与$A$完全匹配  \n\n咋一看似乎没有什么优化方法  \n\n我们翻转$A$串得到$S$串  \n\n那么  \n\n$\\displaystyle\n\\begin{aligned}\nP(x)\n&=\\sum_{i=0}^{m-1}[A(i)-B(x-m+i+1)]^2\\\\\n&=\\sum_{i=0}^{m-1}[S(m-i+1)-B(x-m+i+1)]^2\\\\\n&=\\sum_{i=0}^{m-1}[S(m-i+1)^2+B(x-m+i+1)^2-2S(m-i+1)B(x-m+i+1)]\\\\\n&=\\sum_{i=0}^{m-1}S(m-i+1)^2+\\sum_{i=0}^{m-1}B(x-m+i+1)^2-\\sum_{i=0}^{m-1}2S(m-i+1)B(x-m+i+1)]\n\\end{aligned}$\n\n第一项是定值,第二项可以预处理前缀和解决,第三项可以卷积\n \n$\\displaystyle  \\sum_{i=0}^{m-1}2S(m-i+1)B(x-m+i+1)]=\\sum_{i+j=x}2S(i)B(j)$\n\n设$T=\\sum_{i=0}^{m-1} S(i)^2,f(x)=\\sum_{i=0}^x B(i)^2,g(x)=\\sum_{i+j=x}2S(i)B(j)$\n\n那么$P(x)=T+f(x)-f(x-m)-2g(x)$  \n\n这样可以$O(n)$得到所有$P(x)$的值  \n\n## 带通配符的单模式串匹配  \n\n设通配符的数值为$0$,定义匹配函数$C(x,y)=[A(x)-B(y)]^2A(x)B(y)$,那么$\\displaystyle P(x)=\\sum_{i=0}^{m-1}[A(i)-B(x-m+i+1)]^2A(i)B(x-m+i+1)$\n\n按照套路,翻转$A$串得到$S$串:\n\n$\\displaystyle\n\\begin{aligned}\nP(x)\n&=\\sum_{i=0}^{m-1}[A(i)-B(x-m+i+1)]^2A(i)B(x-m+i+1)\\\\\n&=\\sum_{i=0}^{m-1}[S(m-i+1)-B(x-m+i+1)]^2S(m-i+1)B(x-m+i+1)\\\\\n&=\\sum_{i=0}^{m-1}S(m-i+1)^3B(x-m+i+1)+\\\\\n&\\quad\\sum_{i=0}^{m-1}B(x-m+i+1)^3S(m-i+1)-\\\\\n&\\quad2\\sum_{i=0}^{m-1}S(m-i+1)^2B(x-m+i+1)^2\n\\end{aligned}$\n\n写为卷积形式:\n\n$\\displaystyle P(x)=\\sum_{i+j=x}S(i)^3B(j)+S(i)B(j)^3-2S(i)^2B(j)^2$","link":null,"tags":["字符串","数论"],"title":"fft与字符串匹配"},{"categories":[["刷题记录"]],"content":"\n题意: \n\n1. 区间加\n2. 求序列最大前缀和\n\n区间加，相当于前缀和加上一个等差数列\n\n而等差数列加上一个等差数列还是等差数列\n\n考虑将每个位置的前缀和转化为一个一次函数$kx+b$\n\n分块,对每个块维护一个上凸壳单调栈,可以二分找到最大值\n```cpp\n#include<bits\/stdc++.h>\nconst int N=100011;\nint n,q,blk,bl[N],L[320],R[320],st[320][320],cnt[320];\ntypedef long long ll;\nconst ll inf=-1ull>>1;\nll a[N],k[320],add[320];\nvoid cmax(ll&x,ll y){if(x<y)x=y;}\nbool cmp(int x,int y,int X,int Y){return (a[x]-a[y])*(X-Y)<(a[X]-a[Y])*(x-y);}\nvoid build(int x){\n    int*sta=st[x];int&tp=cnt[x];\n    sta[tp=1]=L[x];\n    for(int i=L[x]+1;i<=R[x];++i){\n        while(tp>1&&cmp(sta[tp-1],sta[tp],sta[tp-1],i))--tp;\n        sta[++tp]=i;\n    }\n    sta[0]=0,sta[++tp]=n+1;\n}\nvoid pd(int x){\n    ll s=0;\n    for(int i=L[x];i<=R[x];++i)\n        a[i]+=s,s+=k[x],a[i]+=add[x];\n    k[x]=add[x]=0;\n}\nvoid upd(int l,int r,ll v){\n    ll s=0;\n    if(bl[l]==bl[r]){\n        pd(bl[l]);\n        for(int i=l;i<=r;++i)a[i]+=s+=v;\n\n        s=v*(r-l+1);\n        for(int i=r+1;i<=R[bl[r]];++i)a[i]+=s;\n        build(bl[l]);\n        for(int i=bl[l]+1;i<=bl[n];++i)add[i]+=s;\n        return;\n    }\n    s=v*(L[bl[l]+1]-l+1);\n    for(int i=bl[l]+1;i<bl[r];++i)\n        add[i]+=s,k[i]+=v,s+=blk*v;\n\n    pd(bl[l]);\n    s=0;for(int i=l;i<=R[bl[l]];++i)a[i]+=s+=v;\n    build(bl[l]);\n\n    pd(bl[r]);\n    s=v*(L[bl[r]]-l+1);\n    for(int i=L[bl[r]];i<=r;++i)a[i]+=s,s+=v;\n\n    s=v*(r-l+1);\n    for(int i=r+1;i<=R[bl[r]];++i)a[i]+=s;\n\n    build(bl[r]);\n    for(int i=bl[r]+1;i<=bl[n];++i)add[i]+=s;\n}\nll get(int x){return a[x]+k[bl[x]]*(x-L[bl[x]])+add[bl[x]];}\nll qry(int x){\n    int l=1,r=cnt[x],m;\n    int*sta=st[x];\n    while(l<=r){\n        m=l+r>>1;\n        ll t1=get(sta[m-1]),t2=get(sta[m]),t3=get(sta[m+1]);\n        if(t1<t2&&t2<t3)l=m+1;\n        else{\n            if(t1>t2&&t2>t3)r=m-1;\n            else return t2;\n        }\n    }\n}\nll ask(int l,int r){\n    ll res=-inf;\n    if(bl[l]==bl[r]){\n        for(int i=l;i<=r;++i)cmax(res,get(i));\n        return res;\n    }\n    for(int i=l;i<=R[bl[l]];++i)cmax(res,get(i));\n    for(int i=bl[l]+1;i<bl[r];++i)cmax(res,qry(i));\n    for(int i=r;i>=L[bl[r]];--i)cmax(res,get(i));\n    return res;\n}\nint main(){\n    scanf(\"%d\",&n);blk=sqrt(n);\n    for(int i=1;i<=n;++i)\n        scanf(\"%lld\",a+i),a[i]+=a[i-1],\n        bl[i]=(i-1)\/blk+1;\n    a[0]=a[n+1]=-inf;\n    for(int i=1;i<=bl[n];++i)\n        L[i]=R[i-1]+1,R[i]=R[i-1]+blk;\n    R[bl[n]]=n;\n    for(int i=1;i<=bl[n];++i)build(i);\n    scanf(\"%d\",&q);\n    while(q--){\n        int opt,x,y;ll k;\n        scanf(\"%d%d%d\",&opt,&x,&y);\n        if(opt==1)printf(\"%lld\\n\",ask(x,y));\n        else scanf(\"%lld\",&k),upd(x,y,k);\n    }\n}\n```\n","link":null,"tags":["分块","前缀和","凸包"],"title":"LG 4192 旅行规划"},{"categories":[["刷题记录"]],"content":"\n异或一个数两次,可以抵消\n\n我们可以给区间中所有相同的数都赋一个新的随机数值,防止异或时出现干扰\n\n设$pre_i$为$i$位置的数上一次出现的数,$v_i$为位置$i$新赋值的数,$S_i$为异或前缀和\n\n若区间$[l,r]$中所有数出现的数出现的次数是奇数,那么$S_r\\oplus S_{l-1}$等于$\\{v_i|pre_i<x,i\\in [l,r]\\}$的异或和\n\n枚举$r$,设$p_x$为$\\{v_i|pre_i<x,i\\in [x,r]\\}$异或和\n\n那么相当于求满足$S_r\\oplus S_{x-1}\\oplus p_x=0$\n\n当$r$变为$r+1$,$\\{p_i|i\\in [pre_{r+1}+1,r]\\}$异或上$v_{r+1}$\n\n问题也就转化为了: 区间异或,区间查询某个数出现次数\n\n使用分块+hash解决\n```cpp\n#include<bits\/stdc++.h>\nnamespace IO{\n\tchar buf[1<<20|5];\n\tconst char *ed=buf+(1<<20);\n\tchar *st=buf+(1<<20);\n\t#define gc() (((st==ed)?(fread(buf,1,1<<20,stdin),st=buf):0),*st++)\n\ttemplate<class T>inline void rd(T &x){\n    \tchar ch;x=0;\n    \tdo ch = gc();while(ch<'0' or ch>'9');\n    \twhile(ch>='0' and ch<= '9')x=x*10+(ch&15),ch=gc();\n    }\n    #undef gc\n};\ntypedef unsigned long long ll;\nconst int N=200011,P=10007;\nstruct hash{\n\tint head[P+1],cnt;\n\tstruct edge{int nxt;ll to,w;}e[20000];\n\thash(){cnt=0;}\n\tll&operator()(ll n,bool t=1){\n\t\tint x=n%P+1;\n\t\tfor(int i=head[x];i;i=e[i].nxt)\n\t\t\tif(e[i].to==n)return e[i].w;\n\t\tif(t){\n\t\t\te[++cnt].to=n,e[cnt].nxt=head[x],head[x]=cnt;\n\t\t\treturn e[cnt].w=0;\n\t\t}\n\t\telse return e[0].w;\n\t}\n\tvoid init(){while(cnt)head[e[cnt--].to%P+1]=0;}\n}T[450];\nint n,blk,pre[N],b[1000001],bl[N],L[450],R[450];\nll a[N],s[N],laz[450],p[N],rnd[1000001];\nvoid build(int k){\n\tT[k].init();\n\tfor(int i=L[k];i<=R[k];++i)++T[k](p[i]);\n}\nvoid add(int l,int r,ll v){\n\tif(bl[l]==bl[r]){\n\t\tfor(int i=l;i<=r;++i)p[i]^=v;\n\t\tbuild(bl[l]);\n\t\treturn;\n\t}\n\tfor(int i=l;bl[i]==bl[l];++i)p[i]^=v;\n\tfor(int i=bl[l]+1;i<bl[r];++i)laz[i]^=v;\n\tfor(int i=r;bl[i]==bl[r];--i)p[i]^=v;\n\tbuild(bl[l]),build(bl[r]);\n}\nint ask(int r){\n\tint res=0;ll v=s[r];\n\tfor(int i=1;i<bl[r];++i)\n\t\tres+=T[i](v^laz[i],0);\n\tv^=laz[bl[r]];\n\tfor(int i=r;bl[i]==bl[r];--i)\n\t\tif(v==p[i])++res;\n\treturn res;\n}\nint main(){\n\tll ans=0;\n\tIO::rd(n);blk=sqrt(n);\n\trnd[0]=233;\n\tfor(int i=1;i<=1000000;++i)rnd[i]=rnd[i-1]*482711ll;\n\tfor(int i=1;i<=n;++i){\n\t\tll x;IO::rd(x);\n\t\tpre[i]=b[x],b[x]=i;\n\t\ts[i]=s[i-1]^(a[i]=rnd[x]);\n\t\tbl[i]=(i-1)\/blk+1;\n\t\t++T[bl[i]](p[i]=s[i-1]);\n\t}\n\tfor(int i=1;i<=bl[n];++i)\n\t\tL[i]=R[i-1]+1,R[i]=R[i-1]+blk;\n\tR[bl[n]]=n;\n\t\n\tfor(int i=1;i<=n;++i)\n\t\tadd(pre[i]+1,i,a[i]),\n\t\tans+=ask(i);\n\t\t\n\tprintf(\"%lld\\n\",ans);\n}\n```\n","link":null,"tags":["hash","分块","随机"],"title":"LOJ 6187 Odd"},{"categories":[["刷题记录"]],"content":"\n分块好题\n\n> $\\gcd$有个性质: 一旦变动则小于原来的$\\frac 12$(最小的质因子为$2$)\n> \n> 那么总共最多$\\log_2 n$个不同的$\\gcd$\n\n每个块记录的信息:\n\n- 块内前缀gcd\n- 块内前缀xor和\n\n然后对块内元素按前缀xor和排序\n\n修改操作: 修改对应元素,并重构元素所在块\n\n查询操作：\n\n枚举每个块,若前缀gcd不变,则直接在排序好的元素中二分查找\n\n否则枚举判断\n\n复杂度$O(n\\sqrt n \\log n)$\n```cpp\n#include<bits\/stdc++.h>\nconst int N=100011;\nint gcd(int a,int b){return b?gcd(b,a%b):a;}\nint n,m,blk,a[N],bl[N],sx[N],sg[N],L[N],R[N];\nstruct node{\n    int v,id;\n    bool operator<(node t){\n        return v!=t.v?v<t.v:id<t.id;\n    }\n}b[N];\nvoid build(int k){\n    int l=L[k],r=R[k];\n    sg[l]=sx[l]=a[l];\n    b[l]=(node){a[l],l};\n    for(int i=l+1;i<=r;++i){\n        sx[i]=sx[i-1]^a[i];\n        sg[i]=gcd(sg[i-1],a[i]);\n        b[i]=(node){sx[i],i};\n    }\n    std::sort(b+l,b+r+1);\n}\ntypedef long long ll;\nvoid ask(){\n    ll v;scanf(\"%lld\",&v);\n    int ans=-1,G=a[1],X=0;\n    for(int i=1;i<=bl[n]&&ans==-1;++i)\n        if(gcd(sg[R[i]],G)!=G){\n            for(int j=L[i];j<=R[i];++j){\n                G=gcd(a[j],G),X^=a[j];\n                if(1ll*G*X==v){ans=j;break;}\n            }\n        }\n        else if(v%G==0){\n            ll c=v\/G^X;\n            int l=L[i],r=R[i],p=l;\n            while(l<=r){\n                int m=l+r>>1;\n                if(b[m].v>=c)p=m,r=m-1;\n                else l=m+1;\n            }\n            if(b[p].v==c){ans=b[p].id;break;}\n            G=gcd(sg[R[i]],G),X^=sx[R[i]];\n        }\n        else G=gcd(sg[R[i]],G),X^=sx[R[i]];\n    if(ans==-1)puts(\"no\");\n    else printf(\"%d\\n\",ans-1);\n}\nint main(){\n    scanf(\"%d\",&n);blk=sqrt(n);\n    for(int i=1;i<=n;++i){\n        scanf(\"%d\",a+i);\n        bl[i]=(i-1)\/blk+1;\n        if(!L[bl[i]])L[bl[i]]=i;\n        R[bl[i]]=i;\n    }\n    for(int i=1;i<=bl[n];++i)build(i);\n    scanf(\"%d\",&m);\n    char opt[10];\n    for(int i=1;i<=m;++i){\n        scanf(\"%s\",opt);\n        if(opt[0]=='M'){\n            int x,y;scanf(\"%d%d\",&x,&y);\n            ++x,a[x]=y,\n            build(bl[x]);\n        }\n        else ask();\n    }\n}\n```\n","link":null,"tags":["分块","数论","二分"],"title":"LG 4108 [HEOI2015]公约数数列"},{"categories":[["刷题记录"]],"content":"\n有$n$个人和$m$种物品,第$i$种物品有$a_i$个,同种物品之间没有区别。现在要将这些物品分给这些人,使得每个人至少分到一个物品\n\n每个同学都必须**至少**分得一个\n\n可以通过 **恰好**没有同学没有分得 来反演\n\n设$f_i$为钦定$i$个人没有分到,\n\n钦定的方案数为${n\\choose i}$,这时第$j$种物品分给$n-i$个人,使用隔板法,方案数为${n-i+a_j-1\\choose n-i-1}$\n\n$$\nf_i={n\\choose i}\\prod_{j=1}^m{n-i+a_j-1\\choose n-i-1}\n$$\n\n设$g_i$为恰好$i$个人没有分到,反演:\n\n$$\ng_k=\\sum_{i=k}^n(-1)^{i-k}{i \\choose k}f_i\n$$\n\n那么:\n\n$$\n\\begin{aligned}\nans\n&=g_0\\\\\n&=\\sum_{i=0}^n(-1)^if_i\\\\\n&=\\sum_{i=0}^n(-1)^i{n\\choose i}\\prod_{j=1}^m{n-i+a_j-1\\choose n-i-1}\n\\end{aligned}\n$$\n```cpp\n#include<bits\/stdc++.h>\nconst int N=1001,P=1000000007;\nint n,m,a[N],ans,c[N*2][N*2];\nvoid mod(int&x){if(x>=P)x-=P;}\nint main(){\n    scanf(\"%d%d\",&n,&m);\n    for(int i=0;i<=2000;++i){\n        c[i][0]=c[i][i]=1;\n        for(int j=1;j<i;++j)\n            mod(c[i][j]=c[i-1][j-1]+c[i-1][j]);\n    }\n    for(int i=1;i<=m;++i)scanf(\"%d\",a+i);\n    for(int i=0;i<=n;++i){\n        long long res=c[n][i];\n        for(int j=1;j<=m;++j)\n            (res*=c[n-i+a[j]-1][n-i-1])%=P;\n        if(i&1)mod(ans+=P-res);\n        else mod(ans+=res);\n    }\n    printf(\"%d\\n\",ans);\n}\n```\n","link":null,"tags":["二项式反演","容斥","数论"],"title":"LG 5505 [JSOI2011]分特产"},{"categories":[["刷题记录"]],"content":"\nhttps:\/\/zoj.pintia.cn\/problem-sets\/91827364500\/problems\/91827370149\n\n题意:\n\n给一个序列A,要求支持以下操作:\n\n1. 区间乘\n   \n2. 区间里所有数都变成自己的$k$次幂\n   \n3. 求区间乘积(mod 10000000007)\n\n由于模数是质数,所以可以将每个数都变成原根的次幂\n\n这样区间乘转化为区间加,区间次幂转化为区间乘,求区间乘积转化为求区间和\n```cpp\n#include<bits\/stdc++.h>\nconst int N=100011,p=1000000007,P=p-1,G=5;\nint rd(){int x=0;char c;bool f=0;for(c=getchar();c<'0'||'9'<c;c=getchar())f^=c=='-';for(x=c-48,c=getchar();'0'<=c&&c<='9';x=x*10+c-48,c=getchar());return f?-x:x;}\nint n,q,s[N<<2],add[N<<2],mul[N<<2];\nint v[]={0,0,381838282,884237698,763676564,1,266075974,936544532,145514840,768475390,381838283,649233168,647914256,144547565,318382808,884237699,527353122,895459693,150313666,701153241,763676565,820782224,31071444,82047235,29752532,2,526385847,652713082,700221090,347375814,266075975,198670980,909191404,533470860,277297969,936544533,532151948,289190395,82991517,28785257,145514841,802264261,202620500,24616936,412909726,768475391,463885517,730741137,411590814,873089058,381838284,779697385,908224129,616590335,34551358,649233169,82059366,585390933,729214096,178404868,647914257,234516540,580509262,705019916,291029680,144547566,915309142,351358075,659136251,966284933,318382809,557546595,913990230,559624399,671028677,884237700,464829799,585777694,410623539,414776906,527353123,536950774,184102537,809672376,584458782,895459694,406455218,231613506,794748008,689565125,150313667,81092091,845723799,82908672,112579413,701153242,793429096,993378125,254927334,417708552,763676566,495914368,161535661,991051336,290062405,820782225,998428617,326036185,416389640,525353314,31071445,173428087,463897648,429750477,967229215,82047236,111052372,913022955,560243150,832004219,29752533,298466330,616354822,686501953,962347544,3,86858192,155622902,672867962,908854634,526385848,26958408,297147418,637697767,733196357,652713083,40974527,540374100,348123209,293399235,700221091,614978829,939384877,793780733,295828506,347375815,941462681,757326750,52866953,109607515,266075976,468364065,846668081,663935077,967615976,198670981,792461821,967234449,796615188,500828027,909191405,18591761,918789056,238291131,565940819,533470861,191510652,98758628,966297064,289095130,277297970,469628625,788293500,328851128,613451788,936544534,176586284,62642560,71403401,492996069,532151949,546888614,462930373,118754232,227562075,289190396,464746954,544692855,494417695,589257608,82991518,366164793,175267372,23539458,375216401,28785258,636765616,829772542,799546834,912024915,145514842,235595767,877752650,283920340,543373943,802264262,372889612,850522625,671900687,350386403,202620501,437098732,380266893,441784287,707874467,24616937,798227922,135215506,907191596,443862091,412909727,40007252,555266369,768794522,845735930,768475392,811588759,342799273,349067491,566661897,463885518,470015386,492890654,924677391,294861231,730741138,942081432,299014598,213842495,732754158,411590815,733768720,680304612,421188466,998193104,873089059,68340229,845700806,344185820,693910068,381838285,241119035,468696474,731280403,537461184,779697386,54706238,17661842,290692910,225734921,908224130,115851198,408796690,872301485,678985700,616590336,19536043,573802817,115034633,298959763,34551359,462560014,422812809,965329789,922212382,649233170,729961491,31035300,675237517,967146370,82059367,345578910,996817111,82704431,321223153,585390934,175619009,738808787,677666788,790919380,729214097,877615817,323300957,912101836,139165026,178404869,434705235,301946244,491445797,226594800,647914258,961161468,850202347,380152060,228506357,234516541,45773353,235180417,349454252,875289028,580509263,800796434,174300097,489302579,349072725,705019917,178453464,145590444,882666309,996608982,291029681,210273877,400430043,596612928,300627332,144547567,620129413,409591006,947779101,667285663,915309143,602268191,573348934,57665779,480596910,351358076,348135340,319223134,670933412,313988169,659136252,847904148,851466907,809633584,170131776,966284934,710689410,312731484,995290070,329982019,318382810,797260647,558424566,533507235,444480842,557546596,453241683,716241911,874834351,366249874,913990231,402306476,928726896,182704022,844768655,559624400,500592514,368582295,609400357,570739645,671028678,553134861,846585236,624185975,926531137,884237701,876255977,491923379,971095890,18654643,464829800,39860594,748003075,970055489,557105654,585777695,405377740,793092326,757054683,720569060,410623540,977506928,18603892,911196106,211610818,414776907,181385110,648104085,293863191,521935459,527353124,574882870,617434049,343218545,259590926,536950775,665758622,938423563,925212225,324474452,184102538,424611792,754727894,114949394,232360901,809672377,53738963,177636927,732224685,247548773,584458783,485092561,818937014,499216521,762105175,895459695,823622569,171061066,89712743,678018425,406455219,22572234,180066198,946054688,517053788,231613507,289029872,783200476,825700373,340871020,794748009,641564442,421845534,129669796,937104651,689565126,150632798,993845213,227574206,977541982,150313668,451497423,193427035,352601757,724637555,81092092,730905773,761838722,948500179,548172769,845723800,475803029,851853668,919505556,874728936,82908673,306515667,410804030,676699513,287902601,112579414,851472141,323919708,673850104,680852880,701153243,595680777,385065719,114592434,146327964,793429097,433737960,115606996,902829459,62142888,993378126,803026748,727424537,380031380,122528823,254927335,687842587,450178511,242835501,227539082,417708553,726024102,494091121,75748344,615613462,763676567,982996326,622957317,192803239,850534756,495914369,113118679,173332822,919299466,734145295,161535662,496168925,436544520,353866317,399500124,991051337,672531192,379974299,607573203,213088820,290062406,486914916,497689480,636072233,790634972,820782226,254139761,94130667,60823976,164094470,998428618,946880258,401374325,946811826,955641099,326036186,496872915,377233761,680798045,522322220,416389641,794831137,844398296,431126306,804651091,525353315,347168065,659991722,304050658,2991924,31071446,48529049,111799767,351321432,412873582,173428088,57075793,377246546,348984646,169164501,463897649,428930547,727417192,427073348,378655387,429750478,464542713,473495300,703061435,835310771,967229216,678916854,557457291,250402485,120647063,82047237,59505064,298408322,172757656,907777156,111052373,746216902,259454093,265823497,705139239,913022956,293940112,195024716,521003308,899824221,560243151,714010234,816543517,708296745,683784526,832004220,873284079,796262607,608433082,696897442,29752534,748641546,342999744,119833459,232040623,298466331,761990342,986766785,610344639,168158032,616354823,875288702,427611635,307293942,617018699,686501954,731292534,368755462,257127304,314280758,962347545,734760317,182634710,626109651,556138379,4,871140861,234624095,730911007,184650082,86858193,385696585,560291746,321336424,527428726,155622903,264504585,17636617,378447258,326021979,672867963,81412879,592112159,158329748,782268325,908854635,978451210,614024899,682465614,827638036,526385849,19453198,1967689,443555346,791429288,26958409,329617377,328099783,49123939,342531174,297147419,491028875,984106473,924244950,955187216,637697768,439504061,429423049,862435192,653032214,733196358,883749708,729973622,247787358,701061416,652713084,52771688,936414888,695826451,929922651,40974528,227036965,229742424,656202916,233305183,540374101,191471860,450899589,551970058,761137900,348123210,957940143,92527686,354253078,694569766,293399236,377128346,697723948,711820301,808915083,700221092,421457424,179098923,990343636,940262848,614978830,915345517,432458894,826319124,696576885,939384878,183252290,835079965,280718215,98080187,793780734,256672627,616991850,748088156,544104739,295828507,927595862,784144758,618006412,310565172,347375816,564542304,978569639,226606931,305426158,941462682,920076629,882430796,921332824,750420577,757326751,991238639,591237,952577927,114605847,52866954,729938498,934973143,695101199,228423512,109607516,6024251,578147760,308369413,262580711,266075977,709275566,258094253,125356727,873761661,468364066,352934166,539586166,400492925,615518095,846668082,319462292,421698876,461897840,129841351,663935078,351893765,322952433,938943936,518957057,967615977,901899540,787216022,791579360,174930602,198670982,138892959,109972613,102407336,503417496,792461822,206779757,359345204,88890,400442174,967234450,293034382,270431985,593449100,756539177,796615189,366295003,563223392,379064105,29942361,500828028,675701473,941189873,903773741,626200824,909191406,458040509,956721152,208857561,999272331,18591762,725056827,183197455,641429208,378740433,918789057,171504504,47596898,346797706,320261839,238291132,307050501,725770177,706312734,849567481,565940820,607079689,806450074,891734457,136566170,533470862,496787676,689646277,614199183,613043530,191510653,915272998,435577245,768548745,559475209,98758629,114062961,851384062,629387055,164451860,966297065,694751628,866930843,229816602,200775290,289095131,881054803,235010856,143943451,966942129,277297971,371237630,205460845,516096998,552899348,469628626,471551025,241952849,59856701,239248300,788293501,623046479,404410516,937618645,561904480,328851129,327892964,675157072,898892070,64010068,613451789,495905640,670868154,761853509,165038752,936544535,207538649,403193844,722709302,796339528,176586285,903509641,23402718,991122233,803683816,62642561,511508078,310672493,318942927,92167428,71403402,186183936,532471080,431894372,375683489,492996070,609412488,110832492,359380258,546046794,532151950,512050022,833335705,845399160,575265317,546888615,734440039,668881664,106475831,264389752,462930374,700685266,112744049,458905538,143676998,118754233,330338455,963502940,930011051,492514271,227562076,119418109,857641311,702094160,233691944,289190397,301343832,759526720,256567212,798432364,464746955,574242293,688353949,685034126,792642312,544692856,58537789,889171523,669740883,373540271,494417696,630233002,233310417,884311496,705757990,589257609,55688380,964453890,62691156,704171964,82991519,29828136,977519059,772408781,766904001,366164794,496430716,880846674,528166246,476918626,175267373,397341960,815576242,94511569,497445278,23539459,284667735,815035131,443981170,480850620,375216402,962094621,184865024,229943761,109262813,28785259,761869662,545661558,504367105,338798287,636765617,293828698,69680863,331110272,832016793,829772543,624673783,551523355,609377364,106664171,799546835,728364560,107862378,486505883,875929403,912024916,457586626,65098646,997451744,941903477,145514843,730325259,364834602,73864555,4795593,235595768,574641521,317743570,232373032,990413208,877752651,203460826,494956961};\n#define ls rt<<1\n#define rs rt<<1|1\nvoid mod(int&x){if(x>=P)x-=P;}\nvoid Mul(int&x,int y){x=1ll*x*y%P;}\nvoid pu(int rt){mod(s[rt]=s[ls]+s[rs]);}\nvoid build(int l,int r,int rt){\n    add[rt]=0,mul[rt]=1;\n    if(l==r){\n        s[rt]=v[rd()];\n        return;\n    }\n    int m=l+r>>1;\n    build(l,m,ls),build(m+1,r,rs);\n    pu(rt);\n}\nvoid pd(int rt,int ln,int rn){\n    if(mul[rt]^1){\n        Mul(s[ls],mul[rt]);\n        Mul(s[rs],mul[rt]);\n        Mul(mul[ls],mul[rt]);\n        Mul(mul[rs],mul[rt]);\n        Mul(add[ls],mul[rt]);\n        Mul(add[rs],mul[rt]);\n        mul[rt]=1;\n    }\n    if(add[rt]){\n        mod(s[ls]+=1ll*add[rt]*ln%P);\n        mod(s[rs]+=1ll*add[rt]*rn%P);\n        mod(add[ls]+=add[rt]);\n        mod(add[rs]+=add[rt]);\n        add[rt]=0;\n    }\n}\nvoid updm(int L,int R,int v,int l,int r,int rt){\n    if(L<=l&&r<=R){\n        Mul(s[rt],v),Mul(mul[rt],v),Mul(add[rt],v);\n        return;\n    }\n    int m=l+r>>1;\n    pd(rt,m-l+1,r-m);\n    if(L<=m)updm(L,R,v,l,m,ls);\n    if(R>m)updm(L,R,v,m+1,r,rs);\n    pu(rt);\n}\nvoid upda(int L,int R,int v,int l,int r,int rt){\n    if(L<=l&&r<=R){\n        mod(s[rt]+=1ll*v*(r-l+1)%P),mod(add[rt]+=v);\n        return;\n    }\n    int m=l+r>>1;\n    pd(rt,m-l+1,r-m);\n    if(L<=m)upda(L,R,v,l,m,ls);\n    if(R>m)upda(L,R,v,m+1,r,rs);\n    pu(rt);\n}\nint ask(int L,int R,int l,int r,int rt){\n    if(L<=l&&r<=R)return s[rt];\n    int m=l+r>>1,ans=0;\n    pd(rt,m-l+1,r-m);\n    if(L<=m)ans=ask(L,R,l,m,ls);\n    if(R>m)mod(ans+=ask(L,R,m+1,r,rs));\n    return ans;\n}\nint pw(int x,int b){\n    int res=1;\n    while(b){\n        if(b&1)res=1ll*res*x%p;\n        b>>=1,x=1ll*x*x%p;\n    }\n    return res;\n}\nvoid solve(){\n    n=rd(),q=rd();\n    build(1,n,1);\n    while(q--){\n        int opt=rd(),l=rd(),r=rd();\n        if(opt==1)upda(l,r,v[rd()],1,n,1);\n        else if(opt==2)updm(l,r,rd(),1,n,1);\n        else printf(\"%lld\\n\",pw(G,ask(l,r,1,n,1)));\n    }\n}\nint main(){for(int T=rd();T--;)solve();}\n```\n","link":null,"tags":["线段树","原根","数论"],"title":"ZOJ 3998 Yet Another Data Structure Problem"},{"categories":[["刷题记录"]],"content":"\n题意:\n\n给出$n$个点$m$条边的无向图,每条边$u\\leftrightarrow v$有两个权值$a,b$\n\n$q$个询问,给出$u,v,A,B$求$u,v$间是否存在路径$\\max\\{a\\}=A$且$\\max\\{b\\}=B$\n\n先考虑最暴力的做法:\n\n把所有符合条件的边($a\\le A,b\\le B$)添加到并查集,\n\n然后判断最大值是不是$A,B$、$u,v$是否连通\n\n接着对边排序、回滚莫队,使用按秩合并并查集(可撤销并查集)\n\n对$m$条边按$a$进行排序\n\n对询问按$b$进行排序\n\n对$m$条边进行分块\n\n对每个块处理符合$a$大于等于该块$\\max\\{a\\}$的询问\n\n把当前块前面的点按照$b$排序(使$b$单调递增)\n\n开始处理询问:\n\n当前块前面的点的$b$是单调递增的,而$a$一定符合条件\n,所以可以一直右移指针添加符合条件的边\n\n然后枚举块中的边,添加符合当前询问的边,得到当前询问答案,回滚,删掉当前询问添加的边\n\n下一个询问\n\n处理完当前块后,暴力清空并查集\n\n分块大小为$\\sqrt{m\\log n}$时复杂度最优\n```cpp\n#include<bits\/stdc++.h>\nconst int N=100011;\nint n,m,k,blk,f[N],siz[N],ma[N],mb[N],tp=0;\nbool ans[N];\nint gf(int x){return x==f[x]?x:gf(f[x]);}\nstruct edge{\n    int u,v,a,b,k;\n    void in(){scanf(\"%d%d%d%d\",&u,&v,&a,&b);}\n}a[N],q[N],c[N],d[N];\nvoid cmax(int&x,int y){if(y>x)x=y;}\nvoid mg(edge x,bool typ=0){\n    int u=gf(x.u),v=gf(x.v);\n    if(siz[u]>siz[v])u^=v,v^=u,u^=v;\n    if(typ)d[++tp]=(edge){u,v,ma[v],mb[v],siz[v]};\n    if(u!=v)\n        f[u]=v,siz[v]+=siz[u],\n        cmax(ma[v],ma[u]),cmax(mb[v],mb[u]);\n    cmax(ma[v],x.a),cmax(mb[v],x.b);\n}\nvoid br(edge x){\n    f[x.u]=x.u;\n    ma[x.v]=x.a,mb[x.v]=x.b,siz[x.v]=x.k;\n}\nbool cmpa(edge x,edge y){return x.a==y.a?x.b<y.b:x.a<y.a;}\nbool cmpb(edge x,edge y){return x.b==y.b?x.a<y.a:x.b<y.b;}\nint main(){\n    scanf(\"%d%d\",&n,&m);blk=sqrt(m*log2(n));\n    for(int i=1;i<=m;++i)a[i].in();\n    scanf(\"%d\",&k);\n    for(int i=1;i<=k;++i)q[i].in(),q[i].k=i;\n    std::sort(a+1,a+m+1,cmpa);\n    std::sort(q+1,q+k+1,cmpb);\n    for(int i=blk;i<=m;i+=blk){\n        for(int j=1;j<=n;++j)\n            f[j]=j,siz[j]=1,ma[j]=mb[j]=-1;\n        int tt=0;\n        for(int j=1;j<=k;++j)\n            if(a[i].a<=q[j].a&&(a[i+blk].a>q[j].a||i+blk>m))\n                c[++tt]=q[j];\n        if(!tt)continue;\n        std::sort(a+1,a+i,cmpb);\n        for(int j=1,t=1;j<=tt;++j){\n            for(;t<i&&a[t].b<=c[j].b;++t)mg(a[t]);\n            for(int l=i;l<i+blk&&l<=m;++l)\n                if(a[l].a<=c[j].a&&a[l].b<=c[j].b)mg(a[l],1);\n            int u=gf(c[j].u),v=gf(c[j].v);\n            ans[c[j].k]=(u==v&&ma[u]==c[j].a&&mb[u]==c[j].b);\n            while(tp)br(d[tp--]);\n        }\n    }\n    for(int i=1;i<=k;++i)puts(ans[i]?\"Yes\":\"No\");\n}\n```\n","link":null,"tags":["数论","莫队","回滚莫队","离线","并查集"],"title":"LG 3247 [HNOI2016]最小公倍数"},{"categories":[["刷题记录"]],"content":"\n首先了解原根\n\n这里利用到原根的一个性质:\n\n> 设$g$为$m$的一个原根\n>    \n> $g^0,g^1,g^2,\\dots,g^{\\varphi(m)-1}$构成模$m$的简化剩余系\n\n这样我们可以把序列中所有数变成原根的次幂,\n\n那么序列中所有数的乘积就可以转化为他们的和\n\n设这个和为$sum$\n\n设生成函数:$\\displaystyle f(x)=\\sum_{i=0}^m [i\\in S]x^i$\n\n可以发现$f(x)^n$次数为$sum$的那一项的系数就是答案\n\n使用快速幂+快速数论变换\n```cpp\n#include<bits\/stdc++.h>\nconst int N=3000010,P=1004535809,G=3,Gi=334845270;\nint n,m,X,S,f[N],F[N],l,r[N],b[N],L;\nvoid mod(int&x){if(x>=P)x-=P;}\nvoid swap(int&x,int&y){x^=y,y^=x,x^=y;}\nint pw(int x,int b,int p=P){\n    int res=1;\n    while(b){\n        if(b&1)res=1ll*res*x%p;\n        b>>=1;x=1ll*x*x%p;\n    }\n    return res;\n}\nvoid ntt(int*A,int typ){\n    for(int i=0;i<L;++i)\n        if(i<r[i])swap(A[i],A[r[i]]);\n    for(int len=1;len<L;len<<=1){\n        int Wn=pw(~typ?G:Gi,(P-1)\/(len<<1));\n        for(int i=0;i<L;i+=len<<1){\n            int w=1;\n            for(int k=0;k<len;++k){\n                int t=1ll*w*A[i+k+len]%P;\n                mod(A[i+k+len]=A[i+k]-t+P);\n                mod(A[i+k]+=t);\n                w=1ll*w*Wn%P;\n            }\n        }\n    }\n    if(~typ)return;\n    int inv=pw(L,P-2);\n    for(int i=0;i<L;++i)\n        A[i]=1ll*A[i]*inv%P;\n}\nint a[N],tt;\nint getg(){\n    for(int i=2;i<=m-2;++i)\n        if((m-1)%i==0)a[++tt]=i;\n    for(int i=2;;++i){\n        bool ff=1;\n        for(int j=1;j<=tt;++j)\n            if(pw(i,a[j],m)==1){ff=0;break;}\n        if(ff)return i;\n    }\n}\nint main(){\n    scanf(\"%d%d%d%d\",&n,&m,&X,&S);\n    for(int i=1,x=1,g=getg();i<=m-2;++i)\n        b[x=1ll*x*g%m]=i;\n    for(int i=1,t;i<=S;++i){\n        scanf(\"%d\",&t);\n        if(t)F[b[t]]=1;\n    }\n    \n    for(L=1;L<m;L<<=1,++l);\n    L<<=1,++l;\n\n    for(int i=0;i<L;++i)\n        r[i]=(r[i>>1]>>1)|((i&1)<<(l-1));\n    f[0]=1;\n    while(n){\n        ntt(F,1);\n        if(n&1){\n            ntt(f,1);\n            for(int i=0;i<L;++i)\n                f[i]=1ll*f[i]*F[i]%P;\n            ntt(f,-1);\n            for(int i=L-1;i>=m-1;--i)\n                mod(f[i-m+1]+=f[i]),f[i]=0;\n        }\n        n>>=1;\n        for(int i=0;i<L;++i)\n            F[i]=1ll*F[i]*F[i]%P;\n        ntt(F,-1);\n        for(int i=L-1;i>=m-1;--i)\n            mod(F[i-m+1]+=F[i]),F[i]=0;\n    }\n    printf(\"%d\\n\",f[b[X]]);\n}\n```\n","link":null,"tags":["生成函数","ntt","数论","原根"],"title":"LG 3321 [SDOI2015]序列统计"},{"categories":[["刷题记录"]],"content":"\n```cpp\n#include<bits\/stdc++.h>\nconst int N=1200000,P=167772161,G=3,Gi=55924054;\nint L,l,r[N],fac[N],inv[N];\nvoid swap(int&x,int&y){int t=x;x=y;y=t;}\nint pw(int x,int b){\n    int res=1;\n    while(b){\n        if(b&1)res=1ll*res*x%P;\n        b>>=1,x=1ll*x*x%P;\n    }\n    return res;\n}\nvoid getL(int n){\n    for(L=1;L<n;L<<=1,++l);\n    for(int i=0;i<L;++i)\n        r[i]=(r[i>>1]>>1)|((i&1)?(L>>1):0);\n}\nvoid ntt(int*A,int typ){\n    for(int i=0;i<L;++i)\n        if(i<r[i])swap(A[i],A[r[i]]);\n    for(int len=1;len<L;len<<=1){\n        int Wn=pw(~typ?G:Gi,(P-1)\/(len<<1));\n        for(int i=0;i<L;i+=len<<1){\n            int w=1;\n            for(int k=0;k<len;++k){\n                int t=1ll*w*A[i+k+len]%P;\n                A[i+k+len]=(A[i+k]-t+P)%P;\n                A[i+k]=(A[i+k]+t)%P;\n                w=1ll*w*Wn%P;\n            }\n        }\n    }\n    if(~typ)return;\n    for(int i=0,iL=pw(L,P-2);i<L;++i)\n        A[i]=1ll*A[i]*iL%P;\n}\nint s[N],a[N],b[N],g[N];\nvoid mul(int*f,int*g){\n    ntt(f,1),ntt(g,1);\n    for(int i=0;i<L;++i)f[i]=1ll*f[i]*g[i]%P;\n    ntt(f,-1);\n}\nvoid solve(int n){\n    if(n==1){s[1]=1;return;}\n    if(n&1){\n        solve(n-1);\n        for(int i=n;i;--i)\n            s[i]=(s[i-1]+1ll*s[i]*(n-1)%P)%P;\n        s[0]=1ll*s[0]*(n-1)%P;\n        return;\n    }\n    int m=n>>1,res=1;\n    solve(m);\n    for(int i=0;i<=m;++i)\n        a[i]=1ll*s[i]*fac[i]%P,\n        b[i]=1ll*res*inv[i]%P,\n        res=1ll*res*m%P;;\n    std::reverse(a,a+m+1);\n    getL((m+1)*2);\n    mul(a,b);\n    for(int i=0;i<=m;++i)\n        g[i]=1ll*inv[i]*a[m-i]%P;\n    mul(s,g);\n    for(int i=m+1;i<L;++i)a[i]=b[i]=g[i]=0;\n    for(int i=n+1;i<L;++i)s[i]=0;\n}\nvoid init(int n){\n    fac[0]=1;\n    for(int i=1;i<=n;++i)fac[i]=1ll*fac[i-1]*i%P;\n    inv[n]=pw(fac[n],P-2);\n    for(int i=n-1;i>=0;--i)inv[i]=1ll*inv[i+1]*(i+1)%P;\n}\nint main(){\n    int n;\n    scanf(\"%d\",&n);\n    init(n+n);\n    solve(n);\n    for(int i=0;i<=n;++i)\n        printf(\"%d \",s[i]);\n}\n```\n","link":null,"tags":["ntt","斯特林数","数论","模板"],"title":"LG 5408 第一类斯特林数·行"},{"categories":[["刷题记录"]],"content":"\n此题要求的是$S(n,m) \\mod 2$(第二类斯特林数)\n\n1. 当$m$为偶数,$S(n,m) \\equiv S(n-1,m-1)$\n\n2. 当$m$为奇数,$S(n,m) \\equiv S(n-1,m-1)+s(n-1,m)$\n\n这样的话,相当于:\n\n1. 当$(x,y)$中$y$为奇数时,可以走到$(x+1,y+1)$(a变换)\n\n2. 否则可以走到$(x+1,y+1)$(a变换),或$(x+1,y)$(b变换)\n\n求从$(0,0)$走到$(n,m)$的方案数$\\pmod 2$\n\n这个过程必然走了$m$次$a$变换,走了$n-m$次$b$变换\n\n而$b$变换只能在偶数位置出现,那么变换的序列必然是如下形式:\n\n$a,b\\times ?,a,a,b\\times ?,a,a,...,a$\n\n也就是在$\\frac {m+1}2$个间隔中插入$n-m$个$b$,即隔板法\n\n方案数:$C(n-m+\\frac{m+1}2-1,\\frac{m+1}2 -1) \\mod 2$\n\n还有一个结论:仅当$n\\&m=m$时,$C(n,m) \\equiv 1 \\bmod 2$(lucas定理代入即可推出)\n```cpp\n#include<cstdio>\nbool C(int n,int m){\n    return (n&m)==m;\n}\nint main(){\n    int T;scanf(\"%d\",&T);\n    while(T--){\n        int n,m;\n        scanf(\"%d%d\",&n,&m);\n        if(!n&&!m)puts(\"1\");\n        else if(!n||!m||n<0)puts(\"0\");\n        else{\n            int b=n-m,a=(m+1)>>1;\n            puts(C(b+a-1,a-1)?\"1\":\"0\");\n        }\n    }\n}\n```\n","link":null,"tags":["第二类斯特林数","组合数","数论","lucas"],"title":"POJ 1430 Binary Stirling Numbers"},{"categories":[["刷题记录"]],"content":"\n设$s$为$a$的前缀和,$S$为$s$的前缀和\n\n$$\n\\begin{aligned}\nans\n&=\\sum_{i=l}^r \\sum_{j=i}^n s_j-s_{j-i}\\\\\n&=\\sum_{i=l}^r\\left(\\sum_{j=i}^n s_j-\\sum_{j=i}^ns_{j-i}\\right)\\\\\n&=\\sum_{i=l}^r\\left(\\sum_{j=1}^n s_j - \\sum_{j=1}^{i-1} s_j -\\sum_{j=0}^{n-i}s_j\\right)\\\\\n&=\\sum_{i=l}^r ( S_n-S_{i-1}-S_{n-i})\\\\\n\\end{aligned}\n$$\n\n线段树维护$S$即可,如何维护$S$?\n\n假设$[l,r]$区间加$v$,\n\n令$g_i=1+2+3+\\dots+i=\\frac{i(i+1)}2$\n\n假设$i\\in[l,r]$,那么$S_i$加上$v\\times g_{r-i+1}$\n\n假设$i\\in[r+1,n]$,那么$S_i$加上$v\\times g_{r-l+1} + v\\times(i-r)(r-l+1)$\n```cpp\n#include<bits\/stdc++.h>\nint rd(){int x=0;char c;bool f=0;for(c=getchar();c<'0'||'9'<c;c=getchar())f^=c=='-';for(x=c-48,c=getchar();'0'<=c&&c<='9';x=x*10+c-48,c=getchar());return f?-x:x;}\nconst int N=200011,P=1000000007,i2=500000004;\nint n,m,a[N],s[N<<2],la[N<<2],lb[N<<2],lc[N<<2],G[N],S[N];\n#define ls rt<<1\n#define rs rt<<1|1\nvoid mod(int&x){if(x>=P)x-=P;}\nvoid pu(int rt){mod(s[rt]=s[ls]+s[rs]);}\nvoid add(int rt,int l,int r,int a,int b,int c){\n    mod(la[rt]+=a),mod(lb[rt]+=b),mod(lc[rt]+=c);\n    mod(s[rt]+=1ll*(S[r]-S[l-1]+P)%P*a%P);\n    mod(s[rt]+=1ll*(G[r]-G[l-1]+P)%P*b%P);\n    mod(s[rt]+=1ll*(r-l+1)*c%P);\n}\nvoid pd(int rt,int l,int r){\n    int m=l+r>>1;\n    if(la[rt]||lb[rt]||lc[rt])\n        add(ls,l,m,la[rt],lb[rt],lc[rt]),\n        add(rs,m+1,r,la[rt],lb[rt],lc[rt]),\n        la[rt]=lb[rt]=lc[rt]=0;\n}\nvoid build(int l,int r,int rt){\n    if(l==r){s[rt]=a[l];return;}\n    int m=l+r>>1;\n    build(l,m,ls),build(m+1,r,rs);\n    pu(rt);\n}\nvoid upd(int L,int R,int a,int b,int c,int l=1,int r=n,int rt=1){\n    if(L>r||R<l)return;\n    if(L<=l&&r<=R){add(rt,l,r,a,b,c);return;}\n    int m=l+r>>1;\n    pd(rt,l,r);\n    if(L<=m)upd(L,R,a,b,c,l,m,ls);\n    if(R>m)upd(L,R,a,b,c,m+1,r,rs);\n    pu(rt);\n}\nint ask(int L,int R,int l=1,int r=n,int rt=1){\n    if(L>r||R<l)return 0;\n    if(L<=l&&r<=R)return s[rt];\n    int m=l+r>>1,res=0;\n    pd(rt,l,r);\n    if(L<=m)res=ask(L,R,l,m,ls);\n    if(R>m)mod(res+=ask(L,R,m+1,r,rs));\n    return res;\n}\nvoid mdy(int l,int r,int v){\n    int a=1ll*v*i2%P;\n    upd(l,r,\n        a,\n        1ll*a*(3-l*2+P)%P,\n        (1ll*l*(l-3)+2)%P*a%P\n    );\n    if(r<n)upd(r+1,n,\n        0,\n        1ll*(r-l+1)*v%P,\n        (G[r-l+1]-1ll*r*(r-l+1)%P+P)%P*v%P\n    );\n}\nint qry(int l,int r){\n    int res=1ll*(r-l+1)*ask(n,n)%P;\n    mod(res+=P-ask(l-1,r-1));\n    mod(res+=P-ask(n-r,n-l));\n    return res;\n}\nint main(){\n    n=rd(),m=rd();\n    for(int i=1;i<=n;++i)mod(a[i]=a[i-1]+rd());\n    for(int i=2;i<=n;++i)mod(a[i]+=a[i-1]);\n    for(int i=1;i<=n;++i)\n        mod(G[i]=G[i-1]+i),\n        mod(S[i]=S[i-1]+1ll*i*i%P);\n    build(1,n,1);\n    while(m--){\n        int opt=rd(),l=rd(),r=rd();\n        if(l>r)l^=r,r^=l,l^=r;\n        if(opt==1)mdy(l,r,rd());\n        else printf(\"%d\\n\",qry(l,r));\n    }\n}\n```\n","link":null,"tags":["线段树"],"title":"LG 4458 [BJOI2018]链上二次求和"},{"categories":[["刷题记录"]],"content":"\n```cpp\n#include<bits\/stdc++.h>\nconst int N=100011;\ntypedef long long ll;\nint n,m,blk,nn,a[N],c[N],cnt[N],CNT[N];\nll ans[N],mx;\nstruct node{\n    int v,id;\n    bool operator<(node t){return v<t.v;}\n}b[N];\nstruct que{\n    int l,r,id,pl,pr;\n    bool operator<(que t){return pl!=t.pl?l<t.l:r<t.r;}\n}q[N];\nvoid cmax(ll&x,ll y){if(y>x)x=y;}\nint main(){\n    scanf(\"%d%d\",&n,&m);blk=sqrt(n);\n    for(int i=1;i<=n;++i)\n        scanf(\"%d\",c+i),\n        b[i]=(node){c[i],i};\n    std::sort(b+1,b+n+1);\n    for(int i=1;i<=n;++i)\n        a[b[i].id]=nn+=b[i].v!=b[i-1].v;\n    int l,r;\n    for(int i=1;i<=m;++i)\n        scanf(\"%d%d\",&l,&r),\n        q[i]=(que){l,r,i,(l-1)\/blk+1,(r-1)\/blk+1};\n    std::sort(q+1,q+m+1);\n    int tot=(n-1)\/blk+1;\n    for(int now=1,i=1,R=blk;now<=tot;R+=blk,++now){\n        if(R>n)R=n;\n        l=R+1,r=R,mx=0;\n        for(;q[i].pl==now;++i){\n            if(q[i].pl==q[i].pr){\n                for(int j=q[i].l;j<=q[i].r;++j)++CNT[a[j]];\n                for(int j=q[i].l;j<=q[i].r;++j)\n                    cmax(ans[q[i].id],1ll*CNT[a[j]]*c[j]);\n                for(int j=q[i].l;j<=q[i].r;++j)--CNT[a[j]];\n                continue;\n            }\n            while(r<q[i].r)\n                cmax(mx,1ll*++cnt[a[++r]]*c[r]);\n            ans[q[i].id]=mx;\n            while(l>q[i].l)\n                cmax(ans[q[i].id],1ll*++cnt[a[--l]]*c[l]);\n            for(;l<=R;++l)--cnt[a[l]];\n        }\n        for(;r>R;--r)--cnt[a[r]];\n    }\n    for(int i=1;i<=m;++i)printf(\"%lld\\n\",ans[i]);\n}\n```\n","link":null,"tags":["莫队","回滚莫队","离线"],"title":"LG AT1219 歴史の研究"},{"categories":[["刷题记录"]],"content":"\n```cpp\n#include<bits\/stdc++.h>\nconst int N=200011;\nint n,m,blk,nn,a[N],ans[N],mi[N],ma[N],clr[N],pre[N];\nstruct node{\n    int v,id;\n    bool operator<(node t){return v<t.v;}\n}b[N];\nstruct que{\n    int l,r,id,pl,pr;\n    bool operator<(que t){return pl!=t.pl?l<t.l:r<t.r;}\n}q[N];\nvoid cmax(int&x,int y){if(y>x)x=y;}\nint main(){\n    scanf(\"%d\",&n);blk=sqrt(n);\n    for(int i=1;i<=n;++i)\n        scanf(\"%d\",&b[i].v),b[i].id=i;\n    std::sort(b+1,b+n+1);\n    for(int i=1;i<=n;++i)\n        a[b[i].id]=nn+=b[i].v!=b[i-1].v;\n    scanf(\"%d\",&m);\n    int l,r;\n    for(int i=1;i<=m;++i)\n        scanf(\"%d%d\",&l,&r),\n        q[i]=(que){l,r,i,(l-1)\/blk+1,(r-1)\/blk+1};\n    std::sort(q+1,q+m+1);\n    int tot=(n-1)\/blk+1;\n    for(int now=1,i=1,R=blk;now<=tot;R+=blk,++now){\n        if(R>n)R=n;\n        int l=R+1,r=R,mx=0,tt=0;\n        for(;q[i].pl==now;++i){\n            if(q[i].pr==now){\n                for(int j=q[i].l;j<=q[i].r;++j)\n                    if(!pre[a[j]])pre[a[j]]=j;\n                    else cmax(ans[q[i].id],j-pre[a[j]]);\n                for(int j=q[i].l;j<=q[i].r;++j)pre[a[j]]=0;\n                continue;\n            }\n            while(r<q[i].r){\n                ++r;\n                ma[a[r]]=r;\n                if(!mi[a[r]])mi[a[r]]=r,clr[tt++]=a[r];\n                else cmax(mx,r-mi[a[r]]);\n            }\n            ans[q[i].id]=mx;\n            while(l>q[i].l){\n                --l;\n                if(ma[a[l]])cmax(ans[q[i].id],ma[a[l]]-l);\n                else ma[a[l]]=l;\n            }\n            for(;l<=R;++l)if(ma[a[l]]==l)ma[a[l]]=0;\n        }\n        while(tt--)mi[clr[tt]]=ma[clr[tt]]=0;\n    }\n    for(int i=1;i<=m;++i)\n        printf(\"%d\\n\",ans[i]);\n}\n```\n","link":null,"tags":["莫队","离线"],"title":"LG 5906 【模板】回滚莫队&不删除莫队"},{"categories":[["刷题记录"]],"content":"\n$$\n\\begin{aligned}\n&\\quad\\sum_{i=1}^n \\gcd(i,n)^x lcm(i,n)^y\n\\\\\n&=\\sum_{i=1}^n \\frac{in}{lcm(i,n)}^x lcm(i,n)^y\n\\\\\n&=\\sum_{i=1}^n (in)^x lcm(i,n)^{y-x}\n\\\\\n&=\\sum_{i=1}^n (in)^x \\frac{in}{\\gcd(i,n)}^{y-x}\\\\\n&=\\sum_{i=1}^n (in)^y \\gcd(i,n)^{x-y}\n\\\\\n&=n^y\\sum_{d=1}^n d^{x-y}\\sum_{i=1}^n i^y [\\gcd(i,n)=d]\n\\\\\n&=n^y\\sum_{d=1}^n d^{x-y}\\sum_{i=1}^{n\/d} (id)^y [\\gcd(i,n)=1]\n\\\\\n&=n^y\\sum_{d=1}^n d^{x-y}\\sum_{i=1}^{n\/d} (id)^y \\sum_{k|i,k|n}\\mu(k)\n\\\\\n&=n^y\\sum_{d=1}^n d^{x-y}\\sum_{k=1}^{n\/d}\\mu(k)\\sum_{i=1}^{n\/dk} (idk)^y\n\\end{aligned}\n$$\n\n设$T=dk$\n\n$$\n=n^y\\sum_{T=1}^n\\sum_{d|T}d^{x-y}\\mu(\\frac Td)\\sum_{i=1}^{n\/T} (iT)^y\n$$\n```cpp\n#include<bits\/stdc++.h>\n#define fur(i,x,y) for(int i=x;i<=y;++i)\nvoid cmin(int &x,int y){if(x>y)x=y;}\nint rd(){int x=0;char c;bool f=0;for(c=getchar();c<'0'||'9'<c;c=getchar())f^=c=='-';for(x=c-48,c=getchar();'0'<=c&&c<='9';x=x*10+c-48,c=getchar());return f?-x:x;}\nconst int N=100011,inf=2122219134;\nint main(){\n    \n}\n```\n","link":null,"tags":["莫比乌斯","数论"],"title":"LG 4464 [国家集训队]JZPKIL"},{"categories":[["刷题记录"]],"content":"\n```cpp\n#include<bits\/stdc++.h>\nconst int N=100011;\nint n,m,blk,nn,a[N],c[N],cnt[N],CNT[N];\ntypedef long long ll;\nll ans[N],mx;\nstruct node{\n    int v,id;\n    bool operator<(node t){return v<t.v;}\n}b[N];\nstruct que{\n    int l,r,id,pl,pr;\n    bool operator<(que t){return pl!=t.pl?l<t.l:r<t.r;}\n}q[N];\nvoid cmax(ll&x,ll y){if(y>x)x=y;}\nint main(){\n    scanf(\"%d%d\",&n,&m);blk=sqrt(n);\n    for(int i=1;i<=n;++i)\n        scanf(\"%d\",c+i),\n        b[i]=(node){c[i],i};\n    std::sort(b+1,b+n+1);\n    for(int i=1;i<=n;++i)\n        a[b[i].id]=nn+=b[i].v!=b[i-1].v;\n    int l,r;\n    for(int i=1;i<=m;++i)\n        scanf(\"%d%d\",&l,&r),\n        q[i]=(que){l,r,i,(l-1)\/blk+1,(r-1)\/blk+1};\n    std::sort(q+1,q+m+1);\n    int tot=(n-1)\/blk+1;\n    for(int now=1,i=1,R=blk;now<=tot;R+=blk,++now){\n        if(R>n)R=n;\n        l=R+1,r=R,mx=0;\n        for(;q[i].pl==now;++i){\n            if(q[i].pl==q[i].pr){\n                for(int j=q[i].l;j<=q[i].r;++j)++CNT[a[j]];\n                for(int j=q[i].l;j<=q[i].r;++j)\n                    cmax(ans[q[i].id],1ll*CNT[a[j]]*c[j]);\n                for(int j=q[i].l;j<=q[i].r;++j)--CNT[a[j]];\n                continue;\n            }\n            while(r<q[i].r)\n                cmax(mx,1ll*++cnt[a[++r]]*c[r]);\n            ans[q[i].id]=mx;\n            while(l>q[i].l)\n                cmax(ans[q[i].id],1ll*++cnt[a[--l]]*c[l]);\n            for(;l<=R;++l)--cnt[a[l]];\n        }\n        for(;r>=R;--r)--cnt[a[r]];\n    }\n    for(int i=1;i<=m;++i)printf(\"%lld\\n\",ans[i]);\n}\n```\n","link":null,"tags":["莫队","回滚莫队","离线"],"title":"LG 4137 Rmq Problem-mex"},{"categories":[["刷题记录"]],"content":"\n拆分为$m$项时,生成函数为$F^m (x)$\n\n那么答案的生成函数为$\\displaystyle G(x)=\\sum_{i=0}^{\\infin} F^i(x)$\n\n$F$为斐波那契数列生成函数,$\\displaystyle F(x)=\\frac x{1-x-x^2}$\n\n$\n\\begin{aligned}\nG(x)\n&=\\sum_{i=0}^{\\infty} F^i(x)\\\\\n&=\\frac 1{1-F(x)}\\\\\n&=\\frac {1-x-x^2}{1-2x-x^2}\\\\\n&=1+\\frac x{1-2x-x^2}\\\\\n&=1+\\frac x{[1-(1+\\sqrt 2)x][1-(1-\\sqrt2)x]}\\\\\n&=1+\\frac 1{2\\sqrt 2}\\left( \\frac 1{1-(1+\\sqrt 2)x} - \\frac 1{1-(1-\\sqrt 2)x} \\right)\\\\\n&=1+\\sum_{i=1}^{\\infin} \\frac{(1+\\sqrt 2)^i-(1-\\sqrt 2)^i}{2\\sqrt 2} x^i\n\\end{aligned}\n$\n\n那么:\n\n$\\displaystyle\nans_n=\\frac{(1+\\sqrt 2)^n-(1-\\sqrt 2)^n}{2\\sqrt 2}\n$\n\n其中$\\sqrt 2 \\equiv 59713600 \\pmod{10^9+7}$(二次剩余)\n\n这样的话:\n\n$\\displaystyle\n\\begin{aligned}\nans_n\n&=\\frac {\\sqrt 2}4\\left[(1+\\sqrt 2)^n-(1-\\sqrt 2)^n\\right]\\\\\n&\\equiv 59713600\\times 250000002\\times [(1+59713600)^n-(1-59713600)^n] \\pmod{10^9+7}\n\\end{aligned}\n$\n\n使用快速幂复杂度$O(\\log n)$\n\n考虑费马小定理: $ans_n \\equiv ans_{n \\mod 10^9+6}$\n\n这样就可以把$n$压到$10^9+6$以内了,再快速幂即可\n```cpp\n#include<cstdio>\nconst int P=1000000007;\nint n;\nvoid readn(){\n    char c;int p=P-1;\n    for(c=getchar();c<'0'||'9'<c;c=getchar());\n    for(n=c-48,c=getchar();'0'<=c&&c<='9';n=(10ll*n+c-48)%p,c=getchar());\n}\nint pw(int x,int b){\n    int res=1;\n    while(b){\n        if(b&1)res=1ll*res*x%P;\n        b>>=1,x=1ll*x*x%P;\n    }\n    return res;\n}\nint main(){\n    readn();\n    int t=1ll*59713600*250000002%P,\n        a=(pw(59713601,n)-pw(940286408,n)+P)%P;\n    printf(\"%d\\n\",1ll*t*a%P);\n}\n```\n","link":null,"tags":["生成函数","数论","斐波那契","二次剩余"],"title":"LG 4451 [国家集训队]整数的lqp拆分"},{"categories":[["刷题记录"]],"content":"\n首先找位置对称的回文子序列个数(多项式求)\n\n由于不能连续,所以减去对称回文子串个数(manacher求)\n\n设字符串为$S,|S|=n$\n\n假设$S_i$作为一个子序列的对称中心,$x=\\sum_{j=1\\le j\\le i-1}[S_{i-j}=S_{i+j}]$\n\n那么以$i$为中心位置的方案数为$2^{x+1}-1$\n\n设$A_i=[S_i=a],B_i=[S_i=b]$\n\n那么$\\displaystyle (A*A)_i=A_i*A_i=\\sum_{j=0}^nA_jA_{i-j}$就是对称中心为位置$\\frac i2$的两端为`a`的数量\n\n同理$(B*B)_i$就是对称中心为位置$\\frac i2$的两端为`b`的数量\n\n那么上述$(A*A)_i+(B*B)_i$就是对称中心为位置$\\frac i2$的$x+1$\n\n如果$i$为偶数,$x+1$要减去$1$(对称中心是否在同个字符上)\n\n```cpp\n#include<bits\/stdc++.h>\nconst int N=100011,P=1000000007;\ntypedef double db;\ntypedef long long ll;\nstruct cp{db r,i;cp(db R=0,db I=0){r=R,i=I;}};\ncp operator+(cp a,cp b){return cp(a.r+b.r,a.i+b.i);}\ncp operator-(cp a,cp b){return cp(a.r-b.r,a.i-b.i);}\ncp operator*(cp a,cp b){return cp(a.r*b.r-a.i*b.i,a.r*b.i+a.i*b.r);}\nchar s[N],S[N*2];\nint n,nn,ans,pw[N],l,r[N*4],p[N*2];\nconst db pi=acos(-1);\ncp a[N*4],b[N*4];\nvoid swap(cp&x,cp&y){cp t=x;x=y;y=t;}\nvoid fft(cp*A,int typ){\n    for(int i=0;i<nn;++i)\n        if(i<r[i])swap(A[i],A[r[i]]);\n    for(int len=1;len<nn;len<<=1){\n        cp Wn(cos(pi\/len),typ*sin(pi\/len));\n        for(int i=0;i<nn;i+=len<<1){\n            cp w(1,0);\n            for(int k=0;k<len;++k){\n                cp t=w*A[i+k+len];\n                A[i+k+len]=A[i+k]-t;\n                A[i+k]=A[i+k]+t;\n                w=w*Wn;\n            }\n        }\n    }\n}\nvoid mod(int&x){if(x>=P)x-=P;}\nint min(int x,int y){return x<y?x:y;}\nint main(){\n    scanf(\"%s\",s+1);\n    n=strlen(s+1);\n    pw[0]=1;\n    for(int i=1;i<=n;++i)\n        a[i].r=s[i]=='a',\n        b[i].r=s[i]=='b',\n        mod(pw[i]=pw[i-1]<<1);\n    for(nn=1;nn<=n+n;nn<<=1,++l);\n    for(int i=0;i<nn;++i)\n        r[i]=(r[i>>1]>>1)|((i&1)<<(l-1));\n    fft(a,1),fft(b,1);\n    for(int i=0;i<nn;++i)\n        a[i]=a[i]*a[i],\n        b[i]=b[i]*b[i];\n    fft(a,-1),fft(b,-1);\n\n    n=n<<1|1;\n    for(int i=1;i<=n;++i)\n        S[i]=(i&1)?'#':s[i>>1];\n    int R=0,m=0;\n    for(int i=1;i<=n;++i){\n        if(i<=R)p[i]=min(R-i,p[m*2-i]);\n        while(i+p[i]+1<=n&&i-p[i]-1>=1&&S[i+p[i]+1]==S[i-p[i]-1])++p[i];\n        if(i+p[i]>R)R=i+p[i],m=i;\n    }\n    for(int i=1;i<=n;++i)mod(ans+=P-(p[i]+1>>1));\n\n    for(int i=1;i<=n;++i){\n        int x=int(a[i].r\/nn+0.5)%P+int(b[i].r\/nn+0.5)%P+1;\n        x>>=1;\n        mod(x);\n        mod(ans+=pw[x]-1);\n    }\n    printf(\"%d\\n\",ans);\n}\n\n```\n","link":null,"tags":["多项式","fft","ntt","数论","manacher"],"title":"LG 4199 万径人踪灭"},{"categories":[["刷题记录"]],"content":"\n这题可以算是回滚莫队板子题\n\n设$S$为前缀和\n\n假设区间$[l,r]$区间和为$0$,那么$S_r-S_{1-1}=0$\n\n如果使用莫队算法的话,容易想到:\n\n用桶记录某个前缀和出现的最大\/最小位置,加点操作就很容易维护答案\n\n但这样的话删点操作就有点难实现了\n\n可以使用回滚莫队\n\n回滚莫队是一种只添加不删除的莫队,实现如下:\n\n首先对原序列进行分块,并对询问按照如下的方式排序:以左端点所在的块升序为第一关键字,以右端点升序为第二关键字\n\n枚举当前要处理的块,处理所有左端点在该块内的询问,\n\n设当前块右端为$R$,左指针移动到$R+1$,右指针移动到$R$.\n\n若询问两端在同一块内,那么暴力枚举统计即可\n\n1. 由于左端点在同一块内,右端点单调递增\n\n   不断右移右指针到当前询问右端点,并加点更新总答案\n\n   (每个块右端点总位移不超过$n$)\n\n2. 不断左移左指针到当前询问左端点,并加点更新当前询问答案\n   \n   然后将左端点回滚到$R+1$,撤销加点操作对桶的影响\n\n   (每次回滚左端点位移不超过$\\sqrt n$)\n\n继续处理下一个询问\n\n总复杂度$O(n\\sqrt n)$,实测跑的飞快\n\n请配合代码理解,**注意细节**\n```cpp\n#include<bits\/stdc++.h>\nconst int N=50011;\nint n,m,blk,s[N],p[N*2],mi[N*2],ma[N*2],ans[N],clr[N];\nstruct que{\n    int l,r,id,pl,pr;\n    bool operator<(que t){return pl!=t.pl?l<t.l:r<t.r;}\n}q[N];\nvoid cmax(int&x,int y){if(y>x)x=y;}\nint main(){\n    scanf(\"%d%d\",&n,&m);blk=sqrt(n);\n    s[0]=n;\n    for(int i=1;i<=n;++i)\n        scanf(\"%d\",s+i),s[i]+=s[i-1];\n    int l,r,mx,tt;\n    for(int i=1;i<=m;++i)\n        scanf(\"%d%d\",&l,&r),\n        q[i]=(que){l,r,i,(l-1)\/blk+1,(r-1)\/blk+1};\n    std::sort(q+1,q+m+1);\n    memset(mi,126,sizeof mi),memset(p,126,sizeof p);\n    int tot=(n-1)\/blk+1;\n    for(int now=1,i=1,R=blk;now<=tot;R+=blk,++now){\n        if(R>n)R=n;\n        l=R+1,r=R,mx=0,tt=0;\n        for(;q[i].pl==now;++i){\n            if(q[i].pr==now){\n                p[s[q[i].l-1]]=q[i].l-1;\n                for(int j=q[i].l;j<=q[i].r;++j)\n                    if(p[s[j]]<j)cmax(ans[q[i].id],j-p[s[j]]);\n                    else p[s[j]]=j;\n                p[s[q[i].l-1]]=n;\n                for(int j=q[i].l;j<=q[i].r;++j)p[s[j]]=n;\n                continue;\n            }\n            while(r<q[i].r){\n                ++r,ma[s[r]]=r;\n                if(mi[s[r]]>n)mi[s[r]]=r,clr[tt++]=s[r];\n                else cmax(mx,r-mi[s[r]]);\n            }\n            ans[q[i].id]=mx;\n            while(l>=q[i].l){\n                --l;\n                if(ma[s[l]])cmax(ans[q[i].id],ma[s[l]]-l);\n                else ma[s[l]]=l;\n            }\n            for(;l<=R;++l)if(ma[s[l]]==l)ma[s[l]]=0;\n        }\n        while(tt--)mi[clr[tt]]=n,ma[clr[tt]]=0;\n    }\n    for(int i=1;i<=m;++i)printf(\"%d\\n\",ans[i]);\n}\n```\n","link":null,"tags":["莫队","回滚莫队"],"title":"LG SP20644 ZQUERY - Zero Query"},{"categories":[["note"]],"content":"\n\n## 前置知识\n\n1. 极限\n2. 导数与高阶导数\n\n下面简单介绍下极限与导数的概念\n\n### 极限\n\n$\\displaystyle \\lim_{x\\to \\infty} \\frac 1x=0$表示当$x$无限趋近于无穷大时$\\frac 1x$无限接近于$0$\n\n$\\displaystyle \\lim_{x\\to 0} \\frac 1x=\\infty$表示当$x$无限趋近于$0$时$\\frac 1x$无限接近于无穷大\n\n[百度百科 - 极限 （数学术语）](https:\/\/baike.baidu.com\/item\/%E6%9E%81%E9%99%90\/3564509)\n\n[维基百科 - 极限](https:\/\/zh.wikipedia.org\/wiki\/%E6%9E%81%E9%99%90)\n\n### 导数\n\n导数,又名微商,是微积分中的重要基础概念.\n\n当函数$y=f(x)$的自变量$x$在一点$x_0$上产生一个增量$\\Delta x$时,函数输出值的增量$\\Delta y=f(x+\\Delta x)-f(x)$与自变量增量$\\Delta x$的比值在$\\Delta x$趋于$0$时的极限$a$如果存在,$a$即为在$x_0$处的导数,记作$f'(x_0)$或$\\frac d{dx} f(x_0)$.\n\n$\\displaystyle f'(x)=\\lim_{\\Delta x\\to 0} \\frac{\\Delta y}{\\Delta x}=\\lim_{\\Delta x\\to 0} \\frac{f(x+\\Delta x)-f(x)}{\\Delta x}$\n\n$\\displaystyle f'(x_0)=\\lim_{x\\to x_0} \\frac{f(x)-f(x_0)}{x-x_0}$\n\n![](\/posts\/泰勒展开与洛必达法则\/导数.png) ![](\/posts\/泰勒展开与洛必达法则\/导数2.gif)\n\n(图片摘自维基百科)\n\n[百度百科 - 导数](https:\/\/baike.baidu.com\/item\/%E5%AF%BC%E6%95%B0)\n\n[维基百科 - 导数](https:\/\/zh.wikipedia.org\/zh-cn\/%E5%AF%BC%E6%95%B0)\n\n## 微分中值定理\n\n### 罗尔定理\n\n如果函数$f(x)$满足:\n\n1. 在闭区间$[a,b]$上连续\n2. 在开区间$(a,b)$内可导\n3. $f(a)=f(b)$\n   \n那么存在$f'(\\xi)=0,\\xi \\in(a,b)$\n\n![](\/posts\/泰勒展开与洛必达法则\/罗尔定理.svg)\n\n几何意义: \n\n如果光滑的曲线$\\tau: y=f(x)(x\\in [a,b])$的两个端点$A,B$等高,即其连线$AB$水平,则在$\\tau$上必有一点$C(\\xi,f(\\xi))(\\xi \\in(a,b))$,$\\tau$在$C$点的切线是水平的\n\n### 拉格朗日中值定理\n\n**拉格朗日中值定理**,也简称**均值定理**\n\n罗尔定理的扩展\n\n如果函数$f(x)$满足:\n\n1. 在闭区间$[a,b]$上连续\n2. 在开区间$(a,b)$内可导\n\n那么存在$f(b)-f(a)=f'(\\xi)(b-a),\\xi \\in(a,b)$\n\n![](\/posts\/泰勒展开与洛必达法则\/拉格朗日中值定理.svg)\n\n> 证明:\n> \n> 设直线$AB:y=f(a)+\\frac{f(b)-f(a)}{b-a}(x-a)$\n> \n> 作新的函数\n> \n> $\\displaystyle \\varphi(x)=f(x)-\\left[ f(a)+\\frac{f(b)-f(a)}{b-a}(x-a) \\right]$\n> \n> $\\varphi(x)$在$[a,b]$上连续,在$(a,b)$上可导,\n> \n> $\\displaystyle \\varphi'(x)=f'(x)-\\frac{f(b)-f(a)}{b-a}$\n> \n> 且$\\varphi(a)=0,\\varphi(b)=0$. $\\varphi(x)(x\\in [a,b])$符合罗尔定理的条件,所以$\\exist \\xi \\in (a,b)$使得\n> \n> $\\displaystyle \\varphi'(\\xi)=f'(\\xi)-\\frac{f(b)-f(a)}{b-a}=0$\n\n### 柯西中值定理\n\n**柯西中值定理**,也叫**拓展中值定理**\n\n如果函数$f(x)$满足:\n\n1. 在闭区间$[a,b]$上连续\n2. 在开区间$(a,b)$内可导\n3. $g'(x)\\neq 0(\\forall x \\in (a,b))$\n\n则$\\exist \\xi \\in (a,b)$,使得:\n\n$\\displaystyle \\frac{f(b)-f(a)}{g(b)-g(a)}=\\frac{f'(\\xi)}{g'(\\xi)}$\n\n![](\/posts\/泰勒展开与洛必达法则\/柯西中值定理.png)\n\n> 证明:\n> \n> 由拉格朗日定理,在条件$g'(x)\\neq 0$下,\n> \n> $g(b)-g(a)=g'(\\eta)(b-a)\\neq 0,\\eta \\in (a,b)$\n> \n> 作函数\n> \n> $\\displaystyle F(x)=f(x)-\\frac{f(b)-f(a)}{g(b)-g(a)}(g(x)-g(a))$\n> \n> 易证$F(x)$在$[a,b]$上满足洛尔定理条件,从而存在$\\xi \\in(a,b)$使得$F'(\\xi)=0$,即\n> \n> $\\displaystyle f'(\\xi)=\\frac{f(b)-f(a)}{g(b)-g(a)}g'(\\xi)$\n> \n> 由于$g'(\\xi)\\neq 0$,得到\n> \n> $\\displaystyle \\frac{f(b)-f(a)}{g(b)-g(a)}=\\frac{f'(\\xi)}{g'(\\xi)}$\n\n## 泰勒展开\n\n### 泰勒公式\n\n若函数$f(x)$在包含$x_0$的某个闭区间$[a,b]$上具有$n$阶导数,且在开区间$(a,b)$上具有$n+1$阶导数,则对闭区间$[a,b]$上任意一点$x$,成立下式:\n\n$\\displaystyle\n\\begin{aligned}\nf(x)\n&=\\sum_{i=0}^n \\frac{f^{(i)}(x_0)}{i!}(x-x_0)^i+R_n(x)\\\\\n&=f(x_0)+f'(x_0)(x-x_0)+\\frac{f''(x_0)}{2!}(x-x_0)^2+\\cdots+\\frac{f^{(n)}(x_0)}{n!}(x-x_0)^n+R_n(x)\n\\end{aligned}\n$\n\n其中$\\displaystyle R_n(x)=\\frac{f^{(n+1)} (\\xi)}{(n+1)!}(x-x_0)^{n+1},\\xi \\in (x_0,x)$\n\n当$n\\to \\infty$时,$R_n(x)\\to 0$,可忽略不计,可以得到函数的另一种表现形式(即用无穷级数表示)\n\n> 证明:\n> \n> 设$x_0<x$($x_0>x$的情况类似),设函数\n> \n> $\\displaystyle F(t)=f(x)-\\sum_{i=0}^n \\frac{f^{(i)}(t)}{i!}(x-t)^i$\n> \n> $G(t)=(x-t)^{n+1}$\n> \n> $F(t)$在$G(t)$在$[x_0,x]$上连续,在$(x_0,x)$上可导,且\n> \n> $\\displaystyle\nF(x)=0,G(x)=0\n\\\\~\\\\\n\\begin{aligned}\nF'(t)\n&=-\\sum_{i=0}^n \\left[ \\frac{f^{(i)}(t)}{i!}(x-t)^i \\right]'\\\\\n&=-f(t)-\\sum_{i=1}^n \\left[ \\frac{f^{(i+1)}(t)}{i!}(x-t)^i - \\frac{f^{(i)}(t)} {(i-1)!}(x-t)^{i-1} \\right]\\\\\n&=-\\frac{f^{(n+1)}(t)}{n!}(x-t)^n\n\\end{aligned}\n\\\\\nG'(t)=-(n+1)(x-t)^n\n\\\\~\\\\\nF(x_0)=f(x)-\\left[ f(x_0)+f'(x_0)(x-x_0)+\\frac{f''(x_0)}{2!}(x-x_0)^2+\\cdots +\\frac{f^{(n)}(x_0)}{n!}(x-x_0)^2 \\right]\\\\\nG(x_0)=(x-x_0)^{n+1}\n$\n> \n> 并且在$(x_0,x)$上$G'(t)\\neq 0$,所以$F(t)$和$G(t)$在$[x_0,x]$上满足柯西中值定理\n> \n> 从而存在$\\xi \\in (x_0,x)$,使得\n> \n> $\\displaystyle \\frac{F(x)-F(x_0)}{G(x)-G(x_0)}=\\frac{F'(\\xi)}{G'(\\xi)}$\n> \n> 也就是:\n> \n> $\\displaystyle \\frac{f(x)-\\sum_{i=0}^n \\frac{f^{(i)}(t)}{i!}(x-t)^i}{(x-x_0)^> {n+1}}=\\frac{-\\frac{f^{(n+1)}(\\xi)}{n!}(x-\\xi)^n}{-(n+1)(x-\\xi)^n}=\\frac{f^{(n> +1)}(\\xi)}{(n+1)!}$\n> \n> 所以:\n> \n> $\\displaystyle f(x)-\\sum_{i=0}^n \\frac{f^{(i)}(t)}{i!}(x-t)^i=\\frac{f^{(n+1)}(\\xi)}{(n+1)!}(x-x_0)^{n+1}$\n> \n> 这常称为$f(x)$在点$x_0$的$n$阶泰勒公式\n\n当$n=0$时,上述公式就是拉格朗日中值公式,故泰勒定理就是拉格朗日中值定理的推广\n\n### 常用函数的泰勒展开\n\n1. $e^x$\n   \n   $(e^x)'=e^x$,当$x_0$取$0$时,\n\n   $\\displaystyle e^x=1+x+\\frac {x^2}{2!}+\\frac{x^3}{3!}+\\cdots$\n\n2. $\\sin x$\n   \n   $\\sin^{(n)}(x)=\\sin(x+n\\cdot \\frac{\\pi}2)$,当$x_0$取$0$时,\n\n   $\\displaystyle \\sin x=x-\\frac{x^3}{3!}+\\frac{x^5}{5!}-\\frac{x^7}{7!}+\\cdots$\n\n3. $\\cos x$\n   \n   $\\cos^{(n)}(x)=\\cos(x+n\\cdot \\frac{\\pi}2)$,当$x_0$取$0$时,\n\n   $\\displaystyle \\cos x=1-\\frac{x^2}{2!}+\\frac{x^4}{4!}-\\frac{x^6}{6!}+\\cdots$\n\n4. $\\ln (1+x)$\n\n   $\\ln^{(n)} (1+x)=(-1)^{n+1}\\frac{(n-1)!}{(1+x)^n}$,当$x_0$取$0$时,\n   \n   $\\displaystyle x-\\frac {x^2}2+\\frac {x^3}3-\\cdots+\\frac {(-1)^{n+1}}n x^{n}-\\cdots$\n\n5. $\\ln(1-x)$\n   \n   $\\ln^{(n)} (1-x)=-\\frac{(n-1)!}{(1-x)^n}$,当$x_0$取$0$时,\n   \n   $\\displaystyle -x-\\frac {x^2}2-\\frac {x^3}3-\\cdots-\\frac {x^{n}}n-\\cdots$\n6. $\\frac 1{1-x}$\n\n   $(\\frac 1{1-x})^{(n)}=\\frac{n!}{(1-x)^{n+1}}$,当$x_0$取$0$时,\n\n   $\\displaystyle 1+x+x^2+\\cdots+x^n+\\cdots \\quad \\forall x:\\left|x\\right|<1$\n\n## 洛必达法则\n\n假设函数$f(x)$和$g(x)$满足下列条件:\n\n1. $f(x)$,$g(x)$都在$a$点的某去心邻域$\\mathring{U}(a)$上可导,且$g'(x)\\neq 0(\\forall x \\in \\mathring{U}(a))$\n   \n2. 当$x\\to a$时$f(x)\\to 0,g(x)\\to 0$(或$f(x)\\to \\infty,g(x)\\to \\infty$)\n   \n3. $\\displaystyle lim_{x\\to a}\\frac{f'(x)}{g'(x)}$存在(也可以是$\\infty$)\n\n则$\\displaystyle \\lim_{x\\to a}\\frac{f(x)}{g(x)}=lim_{x\\to a}\\frac{f'(x)}{g'(x)}$\n\n> 证明:\n> \n> 由于$\\displaystyle \\lim_{x\\to a}\\frac{f(x)}{g(x)}$与$f(x),g(x)$在$a$点的取值无关,我们可以设$f(a)=0,g(a)=0$,则$f(x),g(x)$在$a$的某一邻域内连续\n> \n> 设$x\\in \\mathring{U}(a)$,由定理的条件1,$f(x)$和$g(x)$在$[a,x]$(或$[x,a]$)上满足柯西中值定理的条件,从而存在$\\xi \\in(a,x)$(或$(x,a)$),使得\n> \n> $\\displaystyle \\frac{f(x)}{g(x)}=\\frac{f(x)-f(a)}{g(x)-g(a)}=\\frac{f'(\\xi)}{g'(\\xi)}$\n> \n> 当$x\\to a$时$\\xi \\to a$,所以\n> \n> $\\displaystyle \\lim_{x\\to a} \\frac{f(x)}{g(x)}=\\lim_{x\\to a} \\frac{f'(\\xi)}{g'(\\xi)}=\\lim_{x\\to a} \\frac{f'(x)}{g'(x)}$\n\n在条件1,2下,只要$\\displaystyle \\lim_{x\\to a} \\frac{f'(x)}{g'(x)}=A\\text{或}\\infty$,则$\\displaystyle \\lim_{x\\to a} \\frac{f(x)}{g(x)}$必存在,且就等于$A\\text{或}\\infty$\n\n所以为了确定$\\displaystyle \\lim_{x\\to a} \\frac{f(x)}{g(x)}$的值,只要把分子、分母分别求导再取极限,在这个极限存在(或是$\\infty$)的情况下,就可以确定原来未定式的值(或是$\\infty$)\n\n这种确定未定式的值得方法称为**洛必达法则**\n\n使用洛必达法则时必须注意:\n\n1. $\\displaystyle \\lim_{x\\to a} \\frac{f(x)}{g(x)}$必须是$\\frac 00$型或$\\frac \\infty\\infty$型的\n   \n2. $\\displaystyle \\lim_{x\\to a} \\frac{f'(x)}{g'(x)}$存在(或是$\\infty$),\n   \n   $\\displaystyle \\lim_{x\\to a} \\frac{f'(x)}{g'(x)}$不存在时需要用其他方法判断这个极限是否存在\n\n> 错误示例:\n> \n> 求$\\displaystyle \\lim_{x\\to 0} \\frac x{1+\\sin x}$\n> \n> 当$x\\to 0$时,$1+\\sin x\\to 1$,\n> \n> $\\displaystyle \\lim_{x\\to 0}\\frac x{1+sin x}=\\frac 01=0$\n> \n> 套用洛必达法则,就会导致: \n> \n> $\\displaystyle \\lim_{x\\to 0} \\frac x{1+\\sin x}=\\lim_{x\\to 0} \\frac 1{\\cos x}=1$\n\n例1:\n\n求$\\displaystyle \\lim_{x\\to 0}\\frac{x-\\sin x}{x^3}$\n\n这是$\\frac 00$型未定式,使用洛必达法则,有\n\n$\\displaystyle \\lim_{x\\to 0} \\frac{x-\\sin x}{x^3}=\\lim_{x\\to 0} \\frac{1-\\cos x}{3x^2}$\n\n还是$\\frac 00$型,再次使用洛必达法则\n\n$\\displaystyle \\lim_{x\\to 0} \\frac{1-\\cos x}{3x^2}=\\lim_{x\\to 0} \\frac{\\sin x}{6x}=\\frac 16$\n\n例2:\n\n求$\\displaystyle \\lim_{x\\to +\\infty} \\frac{x^n}{e^x}$\n\n这是$\\frac \\infty\\infty$型未定式\n\n接连使用洛必达法则$n$次,得\n\n$\\displaystyle \\lim_{x\\to +\\infty} \\frac{x^n}{e^x}=\\lim_{x\\to +\\infty} \\frac{nx^{n-1}}{e^x}=\\cdots=\\lim_{x\\to +\\infty} \\frac{n!}{e^x}=0$","link":null,"tags":["数论"],"title":"泰勒展开与洛必达法则"},{"categories":[],"content":"\n\n\n## 数学常数\n\n$e$,作为数学常数,是自然对数函数的底数.\n\n$e$是一个无理数,并且是超越数\n\n$e=2.71828182845904523536\\cdots$\n\n$e$又称自然常数、欧拉数.\n\n先引入关于$e$的有趣问题\n\n### 银行问题\n\n一笔钱存在在银行,假设这笔钱为$1$,\n\n假设一年年结算一次,利率为$100\\%$,,那么一年后得到$1+1=2$,\n\n假设半年结算一次,利率为$50\\%$,那么一年后得到$(1+\\frac 12)^2=2.25$,\n\n假设每个月结算一次,利率为$\\frac 1{12}$,那么一年后得到$(1+\\frac 1{12})^{12}=2.6130\\dots$ ,\n\n$\\vdots$\n\n假设$\\frac 1n$年结算一次,一年后会得到$(1+\\frac 1n)^n$ .\n\n若$n$趋近于无限大时,那么得到的钱会不会无限多呢？\n\n答案是不会,不管$n$怎么增长,得到的钱都不会超过$e$,\n\n$\\displaystyle e=\\lim_{n\\to\\infty} (1+\\frac 1n)^n$\n\n### 细菌繁殖\n\n假设有一种细菌一天会分裂一次,\n\n如果细菌初始数量为$1$,经过$x$天后的细菌数量为$2^x$\n\n我们把分裂看成增加$100\\%$,那么上式可写为$(1+100\\%)^2$\n\n我们继续假定：每过$12$个小时,也就是分裂进行到一半的时候,新产生的那半个细胞已经可以再次分裂了.\n\n因此,一天$24$个小时可以分成两个阶段,每一个阶段都在前一个阶段的基础上增长$50\\%$.\n\n$(1+\\frac 12)^2=2.25$\n\n那么一天后得到了$2.25$个细胞\n\n假设分裂是连续不断进行的,新生细胞每分每秒都具备继续分裂的能力,那么一天最多可以得到多少个细胞呢?\n\n$(1+\\frac 1n)^n=?$\n\n当$n$趋近于无限大时,$\\displaystyle \\lim_{n\\to\\infty} (1+\\frac 1n)^n=e$\n\n经过计算$e=2.71828182845904523536\\cdots$\n\n这也就是是$e$的含义:单位时间内,持续的翻倍增长所能达到的极限值.\n\n$e$是自然增长的极限,因此以e为底的对数,就叫做自然对数.\n\n### 定义\n\n1. $\\displaystyle e=\\lim_{n\\to\\infty} (1+\\frac 1n)^n$\n\n   $\\displaystyle e=\\lim_{t\\to 0} (1+\\frac 1t)^{\\frac 1t}$($t\\to 0$时,$\\frac 1t\\to\\infty$)\n\n2. $e$为阶乘倒数之无穷级数的和\n\n   $\\displaystyle e=\\sum_{n=0}^{\\infty} \\frac 1{n!}=\\frac 1{0!}+\\frac 1{1!}+\\frac 1{2!}+\\frac 1{3!}+\\cdots$\n\n### $e$的计算\n\n$\\displaystyle\n\\begin{aligned}\ne\n&=\\lim_{n\\to\\infty} (1+\\frac 1n)^n\\\\\n&=\\lim_{n\\to\\infty} \\sum_{i=0}^n {n\\choose i} 1^{n-i}\\left(\\frac 1n\\right)^i\\\\\n&=\\lim_{n\\to\\infty} \\left[ {n\\choose 0}1^n \\left(\\frac 1n\\right)^0 + {n\\choose 1}1^{n-1} \\left(\\frac 1n\\right)^1 + {n\\choose 2}1^{n-2} \\left(\\frac 1n\\right)^2 + {n\\choose 3}1^{n-3} \\left(\\frac 1n\\right)^3 + \\cdots + {n\\choose n}1^0 \\left(\\frac 1n\\right)^n \\right]\\\\\n&=\\lim_{n\\to\\infty} \\left[ 1\\times 1 + n \\times \\frac 1n + \\frac{n!}{(n-2)!2!}\\times \\frac 1{n^2} + \\frac{n!}{(n-3)!3!}\\times \\frac 1{n^3} + \\cdots + 1\\times \\frac n{n!} \\right]\\\\\n&=\\lim_{n\\to\\infty}\\left[1+1+\\frac{n\\times \\left(n-1\\right)}{2n^2}+\\frac{n\\times \\left(n-1\\right)\\left(n-2\\right)}{3\\times 2n^3}+\\cdots+\\frac 1{n^n}\\right]\\\\\n&=1+1+\\frac 1{2!}+\\frac 1{3!}+\\cdots\\\\\n&=2.71828182845904523536\\cdots\n\\end{aligned}\n$\n\n收敛证明:\n\n$\\displaystyle\n\\begin{aligned}\ne\n&=1+1+\\frac 1{2!}+\\frac 1{3!}+\\cdots\\\\\n&<1+1+\\frac 12+\\frac 1{2^2}+\\cdots+\\frac 1{2^{n-1}}\\\\\n&=1+\\frac{1-\\left( \\frac 12 \\right)^n}{1-\\frac 12}\\\\\n&=1+2\\left[1-\\left( \\frac 12 \\right)^n \\right]\\\\\n&<3\n\\end{aligned}\n$\n\n### 性质\n\n\n1. $e$为唯一的正数$x$使:\n\n   $\\displaystyle \\int_1^x{\\frac{\\mathrm {d} t}t}=1$\n\n2. $e$为唯一的实数$x$使:\n\n   $\\displaystyle \\lim_{h\\to 0} \\frac{x^h-1}h=1$\n\n   > 证明:\n   > \n   > $x\\to 0$时$\\ln(1+x)\\sim x$ ($\\sim$代表等价于)\n   > \n   > 设$u=u(x)=\\begin{cases}\n   >    (1+x)^{\\frac 1x} , &x\\neq 0, x>-1\\\\\n   >    e,&x=0\n   > \\end{cases}$\n   > \n   > $\\displaystyle \\lim_{x\\to 0}u(x)=\\lim_{x\\to 0}(1+x)^{\\frac 1x}=e=u(0)$\n   > \n   > 所以$u$在$x=0$点也连续,$u(x)$是$(-1,+\\infty)$上的连续函数,故$\\ln u(x)$也是$(-1,+\\infty)$上的连续函数,那么\n   > \n   > $\\displaystyle\n   > \\begin{aligned}\n   > \\lim_{x\\to 0} \\frac{\\ln(1+x)}x\n   > &=\\lim_{x\\to 0} \\ln~(1+x)^{\\frac 1x}\\\\\n   > &=\\lim_{x\\to 0} \\ln u(x)\\\\\n   > &=\\ln u(0)=\\ln e\\\\\n   > &=1\n   > \\end{aligned}\n   > $\n   > \n   > 所以$x\\to 0$时$\\ln(1+x)\\sim x$\n   > \n   > 若记$t=\\ln (1+x)$,则$x=e^t-1$\n   > \n   > $x\\to 0$等价于$t\\to 0$,\n   > \n   > 所以当$t\\to 0$时,$e^t-1\\sim t$\n\n3. $e^x$的导数还是$e^x$\n   \n   > 证明:\n   > \n   > $\\displaystyle\n   > \\begin{aligned}\n   > \\frac{\\mathrm{d}}{\\mathrm{d}x}e^x\n   > &=\\lim_{\\Delta x\\to 0} \\frac{e^{x+\\Delta x-e^x}}{\\Delta x}\\\\\n   > &=e^x \\lim_{\\Delta x\\to 0} \\frac{e^{\\Delta x}-1}{\\Delta x}\n   > \\end{aligned}\n   > $\n   > \n   > 根据2,$\\frac{e^{\\Delta x}-1}{\\Delta x}=1$,所以\n   > \n   > $\\displaystyle \\frac{\\mathrm{d}}{\\mathrm{d}x}e^x=e^x$\n\n## 欧拉公式\n\n$e^{ix}=\\cos x+i\\sin x$\n\n当$x=\\pi$时,欧拉公式变为$e^{i\\pi}+1=0$,即欧拉恒等式\n\n欧拉恒等式,被誉为上帝公式,$e$、$\\pi$、$i$、乘法单位元1、加法单位元0,这五个重要的数学元素全部被包含在内,在数学爱好者眼里,仿佛一行诗道尽了数学的美好.\n\n### 证明\n\n把函数$e^x,\\sin x,\\cos x$写成泰勒级数形式：\n\n$\\displaystyle\ne^x=1+x+\\frac {x^2}{2!}+\\frac{x^3}{3!}+\\cdots\n\\\\~\\\\\n\\cos x=1-\\frac{x^2}{2!}+\\frac{x^4}{4!}-\\frac{x^6}{6!}+\\cdots\n\\\\~\\\\\n\\sin x=x-\\frac{x^3}{3!}+\\frac{x^5}{5!}-\\frac{x^7}{7!}+\\cdots\n$\n\n那么:\n\n$\n\\begin{aligned}\ne^{ix}\n&=1+ix+\\frac{i^2x^2}{2!}+\\frac{i^3x^3}{3!}+\\frac{i^4x^4}{4!}+\\frac{i^5x^5}{5!}+\\frac{i^6x^6}{6!}+\\frac{i^7x^7}{7!}+\\cdots\\\\~\\\\\n&=1+ix-\\frac{x^2}{2!}-\\frac{ix^3}{3!}+\\frac{x^4}{4!}+i\\frac{x^5}{5!}-\\frac{x^6}{6!}-i\\frac{x^7}{7!}\\\\~\\\\\n&=(1-\\frac{x^2}{2!}+\\frac{x^4}{4!}-\\frac{x^6}{6!}+\\cdots)+i(x-\\frac{x^3}{3!}+\\frac{x^5}{5!}-\\frac{x^7}{7!}+\\cdots)\\\\~\\\\\n&=\\cos x + i\\sin x\n\\end{aligned}\n$\n\n当$x=\\pi$时:\n\n$e^{i\\pi}=\\cos\\pi + i\\sin\\pi=-1$\n\n所以:\n\n$e^{i\\pi}+1=0$\n\n证毕.\n\n### 图像\n\n![](\/posts\/数学常数与欧拉公式\/Axis.svg)","link":null,"tags":[],"title":"数学常数与欧拉公式"},{"categories":[["note"],["算法","离线"]],"content":"\n\n有一类普通莫队不可解的问题就是在转移区间过程中,可能出现删点或加点操作其中之一无法实现的问题,这时可以使用回滚莫队算法\n\n\n\n","link":null,"tags":["莫队"],"title":"回滚莫队"},{"categories":[],"content":"\n\n","link":null,"tags":[],"title":"拉格朗日插值法"},{"categories":[["note"],["算法","数论"]],"content":"\n\n## 阶: \n \n定义:\n\n设$m>1$且$\\gcd(a,m)=1$,那么使得$a^r \\equiv 1 \\pmod m$成立的最小的正整数$r$称为$a$对模$m$的阶,记为$\\delta_m(a)$,或$ord_m a$\n \n定理:\n\n1. 若$m>1$且$gcd(a,m)=1$,满足$a^n\\equiv 1 \\pmod m$,那么$\\delta_m(a)|n$.~~显然~~\n   \n2. $\\delta_m(a) | \\varphi(m)$\n   > 证明:\n   > \n   > 欧拉定理: $a^{\\varphi(m)}\\equiv 1\\pmod m$\n   > \n   > $\\therefore \\delta_m(a)\\le \\varphi(m)$\n   > \n   > $\\therefore \\delta_m(a) | \\varphi(m)$\n\n3. 若$\\gcd(a,m)=1$,那么$a^i\\equiv a_j\\pmod m$,当且仅当$i\\equiv j\\pmod{\\delta_m a}$\n   \n4. 若$\\delta_m a=t$,那么$\\displaystyle \\delta_ma^u=\\frac t{\\gcd(t,u)}$\n   \n5. $a^0,a^1,a^2,\\dots,a^{\\delta_m a -1}$模$m$两两不同余。\n\n## 原根\n\n### 定义\n\n设$m$是正整数,$a$是整数,\n\n若$\\delta_m(a)=\\varphi(m)$,则称$a$为模$m$的一个原根\n\n### 判断是否有原根\n\n若$m$有原根,那么$m=2,4,p^k,2p^k$(充要条件)($p$为素数)\n\n### 求原根\n\n原根一般都很小,可以通过直接枚举然后判断是否是原根\n\n求最小原根:\n\n枚举$g$,使$\\gcd(g,m)=1$,设$p_1,p_2,\\dots,p_k$为$\\varphi(m)$的所有不同质因数,若$g$是$m$的原根,那么$\\forall 1\\le i \\le k, g^{\\frac{\\varphi(m)}{p_i}} \\not = 1$\n\n> 若一个数$m$存在原根,可以证明$m$的最小原根在$m^{0.25}$级别.\n>\n> 这个结论意味着,我们求所有的原根时,枚举最小原根花费的时间一般都是可以接受的.\n\n求所有原根:\n\n设$g$为$m$的一个原根,则集合$S={g^i|1\\le i\\le \\varphi(m),\\gcd(i,\\varphi(m))=1}$为$m$的所有原根.\n\n因此,若$m$有原根,那么$m$有$\\varphi(\\varphi(m))$个关于模$m$两两互不同余的原根\n\n### 性质\n\n1. 素数都是原根\n   \n2. 满足fft中单位根的性质,可以用于[ntt](..\/ntt)(快速数论变换)\n\n3. 设$g$为$m$的一个原根\n   \n   $g^0,g^1,g^2,\\dots,g^{\\varphi(m)-1}$构成模$m$的简化剩余系\n\n## 例题\n\n[\\[SDOI2015\\]序列统计](https:\/\/www.luogu.com.cn\/problem\/P3321)\n\n原根将乘法转加法的应用\n\n我们可以把序列中所有数变成原根的次幂,\n\n那么序列中所有数的乘积就可以转化为他们的和\n\n设这个和为$sum$\n\n设生成函数:$\\displaystyle f(x)=\\sum_{i=0}^m [i\\in S]x^i$\n\n可以发现$f(x)^n$次数为$sum$的那一项的系数就是答案\n\n使用快速幂+快速数论变换\n\n```cpp\n#include<bits\/stdc++.h>\nconst int N=3000010,P=1004535809,G=3,Gi=334845270;\nint n,m,X,S,f[N],F[N],l,r[N],b[N],L;\nvoid mod(int&x){if(x>=P)x-=P;}\nvoid swap(int&x,int&y){x^=y,y^=x,x^=y;}\nint pw(int x,int b,int p=P){\n    int res=1;\n    while(b){\n        if(b&1)res=1ll*res*x%p;\n        b>>=1;x=1ll*x*x%p;\n    }\n    return res;\n}\nvoid ntt(int*A,int typ){\n    for(int i=0;i<L;++i)\n        if(i<r[i])swap(A[i],A[r[i]]);\n    for(int len=1;len<L;len<<=1){\n        int Wn=pw(~typ?G:Gi,(P-1)\/(len<<1));\n        for(int i=0;i<L;i+=len<<1){\n            int w=1;\n            for(int k=0;k<len;++k){\n                int t=1ll*w*A[i+k+len]%P;\n                mod(A[i+k+len]=A[i+k]-t+P);\n                mod(A[i+k]+=t);\n                w=1ll*w*Wn%P;\n            }\n        }\n    }\n    if(~typ)return;\n    int inv=pw(L,P-2);\n    for(int i=0;i<L;++i)\n        A[i]=1ll*A[i]*inv%P;\n}\nint a[N],tt;\nint getg(){\n    for(int i=2;i<=m-2;++i)\n        if((m-1)%i==0)a[++tt]=i;\n    for(int i=2;;++i){\n        bool ff=1;\n        for(int j=1;j<=tt;++j)\n            if(pw(i,a[j],m)==1){ff=0;break;}\n        if(ff)return i;\n    }\n}\nint main(){\n    scanf(\"%d%d%d%d\",&n,&m,&X,&S);\n    for(int i=1,x=1,g=getg();i<=m-2;++i)\n        b[x=1ll*x*g%m]=i;\n    for(int i=1,t;i<=S;++i){\n        scanf(\"%d\",&t);\n        if(t)F[b[t]]=1;\n    }\n    \n    for(L=1;L<m;L<<=1,++l);\n    L<<=1,++l;\n\n    for(int i=0;i<L;++i)\n        r[i]=(r[i>>1]>>1)|((i&1)<<(l-1));\n    f[0]=1;\n    while(n){\n        ntt(F,1);\n        if(n&1){\n            ntt(f,1);\n            for(int i=0;i<L;++i)\n                f[i]=1ll*f[i]*F[i]%P;\n            ntt(f,-1);\n            for(int i=L-1;i>=m-1;--i)\n                mod(f[i-m+1]+=f[i]),f[i]=0;\n        }\n        n>>=1;\n        for(int i=0;i<L;++i)\n            F[i]=1ll*F[i]*F[i]%P;\n        ntt(F,-1);\n        for(int i=L-1;i>=m-1;--i)\n            mod(F[i-m+1]+=F[i]),F[i]=0;\n    }\n    printf(\"%d\\n\",f[b[X]]);\n}\n```\n\n[ZOJ 3998 Yet Another Data Structure Problem](https:\/\/zoj.pintia.cn\/problem-sets\/91827364500\/problems\/91827370149)\n\n题意:\n\n给一个序列A,要求支持以下操作:\n\n1. 区间乘\n   \n2. 区间里所有数都变成自己的$k$次幂\n   \n3. 求区间乘积(mod 10000000007)\n\n由于模数是质数,所以可以将每个数都变成原根的次幂\n\n这样区间乘转化为区间加,区间次幂转化为区间乘,求区间乘积转化为求区间和\n\n\n\n\n\n推荐:\n\nhttps:\/\/zh.wikipedia.org\/wiki\/原根\n\nhttp:\/\/tonyfang.is-programmer.com\/posts\/205326.html","link":null,"tags":["数论"],"title":"原根"},{"categories":[],"content":"\n\n刚入门数论的OIer有可能被数论符号整的一脸懵逼,一下特地整理了常用的数论符号及其含义\n\n1. 组合数: $n\\choose m$ 或 $C_n^m$\n\n2. 莫比乌斯函数: $\\mu$\n   \n3. 欧拉函数: $\\varphi$或$\\varPhi$\n   \n4. 阶: $a$关于模$m$的阶,记作$\\delta_m a$或$ord_m a$\n\n5. 第一类斯特林数: $\\begin{bmatrix}n\\\\m\\end{bmatrix}$\n   \n6. 第二类斯特林数: $\\begin{Bmatrix}n\\\\m\\end{Bmatrix}$\n   \n7. 最大公约数: $\\gcd(n,m)$或简写为$(n,m)$\n   \n8. 最小公倍数: $lcm(n,m)$或简写为$[n,m]$\n   \n9. 向下取整: $\\left\\lfloor x \\right\\rfloor$ \n    \n10. 向上取整: $\\left\\lceil x \\right\\rceil$ \n    \n11. 求和符号: $\\sum$\n    \n12. 连乘符号: $\\prod$\n    \n13. 阶乘符号: $x!$\n    \n14. 任意: $\\forall$\n    \n15. 存在: $\\exist$","link":null,"tags":["数论"],"title":"常见数论符号及含义"},{"categories":[["note"]],"content":"\n\n## 定义\n\n从$n$个元素中取出$m$个的方案数,记为$n\\choose m$或$C_n^m$\n\n$$\n{n\\choose m}=\\frac{n!}{m!(n-m)!}\n$$\n\n## 帕斯卡法则\n\n$$\n{n-1\\choose m}+{n-1\\choose m-1}={n\\choose m}\n$$\n\n证明:\n\n1. 组合数学上的意义与证明\n   \n   ${n\\choose m}$表示在有$n$个元素的集内,有$m$个元素的子集的数目。\n   \n   这些子集之中,可分为包含第一个元素的和不含第一个元素的。\n   \n   包含第一个元素的子集有${n-1 \\choose m-1}$个,不含的有${n-1 \\choose m}$个。\n\n2. 代数证明\n\n## 二项式定理\n\n$\\displaystyle\n(x+y)^n={n\\choose 0}x^ny^0 + {n\\choose 1}x^{n-1}y^1+{n\\choose 2}x^{n-2}y^2+\\dots+{n\\choose n}x^0y^n\n\\\\~\\\\\n(x+y)^n\n=\\sum_{i=0}^n{n\\choose i}x^{n-i}y^i\n=\\sum_{i=0}^n{n\\choose i}x^iy^{n-i}\n\\\\~\\\\\n(1+x)^n=\\sum_{i=0}^n{n\\choose i}x^i\n$\n\n证明(数学归纳法):\n\n","link":null,"tags":["数论","组合数"],"title":"组合数"},{"categories":[["算法","数论"],["note"]],"content":"\n\n推荐:\n- https:\/\/www.cnblogs.com\/zwfymqz\/p\/10521686.html\n- https:\/\/rqy.moe\/Algorithms\/generating-function\/\n\n## 定义\n\n生成函数又称母函数\n\n设序列$a$为$a_0,a_1,a_2,\\dots$\n\n则$g(x)=a_0+a_1x+a_2x^2+a_3x^3+\\dots$为序列$a$的生成函数\n\n## 普通生成函数\n\n普通型生成函数（ordinary generating function, 简称OGF）\n\n形如$\\displaystyle G(x)=\\sum_{i=0}^na_ix_i$的表示一个序列的多项式函数,我们称之为普通生成函数\n\n### 使用例\n\n1. > 有1克、2克、3克、4克的砝码各一枚,能称出哪几种重量？每种重量各有几种可能方案？\n\n    $1$个$1$克砝码可以看成$1+x^1$,$1$表示不取,$x^n$代表取$n$个,以下同理\n\n    $1$个$2$克砝码可以看成$1+x^2$\n\n    $1$个$3$克砝码可以看成$1+x^3$\n\n    $1$个$4$克砝码可以看成$1+x^4$\n\n    那么\n    \n    $\\begin{aligned}\n    g(x)\n    &=(1+x^1)(1+x^2)(1+x^3)(1+x^4)\\\\\n    &=1+x+x^2+2x^3+2x^4+2x^5+2x^6+2x^7+x^8+x^9+x^{10}    \n    \\end{aligned}$\n\n    可以看出重量为$3$克的方案为$2$种,$4$克的方案为$2$种,$3$克的方案为$5$种,以此类推\n\n    **可以发现得出的多项式每一项$ax^n$代表重量为$n$克的方案有$a$种**\n\n    手动模拟一下多项式计算的过程,与背包dp相似,也可配合下发例题代码理解\n\n2. > 求用$1$分、$2$分、$3$分的邮票贴出不同数值的方案数(邮票张数无限)\n   \n   那么\n   \n   $\\begin{aligned}\n   g(x)\n   &=\n   \\begin{aligned}\n   &(1+x+x^2+x^3+\\dots)\\\\\n   &(1+x^2+x^4+x^6+\\dots)\\\\\n   &(1+x^3+x^6+x^9+\\dots)\\\\\n   \\end{aligned}\\\\\n   &=1+x+2x^2+3x^3+4x^4+\\dots    \n   \\end{aligned}$\n\n   $x^4$的系数为$4$表示$4$有$4$中拆分方法:\n\n   $4=1+1+1+1=1+1+1+2=1+3=2+2$\n\n3. > 设有$n$个标志为$1,2,…,n$的网袋,第$i$个网袋里放有$n_i$个球。不同网袋里的球是不同的,而同一网袋里的球则是没有差别的,认为是相同的。询问从中取$r$个球的方案数。\n   \n   $g(x)=(1+x+x^2+\\dots+x^{n_1})(1+x+x^2+\\dots+x^{n_2})\\dots$\n\n   最后指数为$r$的项的系数就是答案\n\n### 例题\n\n[HDU 1028](http:\/\/acm.hdu.edu.cn\/showproblem.php?pid=1028)\n\n> 给出$n$,求:\n> \n> $n=a_1+a_2+\\dots+a_m(m\\le n,a_i>0)$的方案数\n> \n> eg: $n=4$时有$5$种方案\n> \n> $\\begin{aligned}\n  &4=4\\\\\n  &4=3+1\\\\\n  &4=2+2\\\\\n  &4=2+1+1\\\\\n  &4=1+1+1+1\\\\\n  \\end{aligned}$\n\n$\n\\begin{aligned}\ng(x)=\n&(1+x+x^2+x^3+\\dots+x^n)\\\\\n&(1+x^2+x^4+x^6+\\dots+x^n)\\\\\n&(1+x^3+x^6+x^9+\\dots+x^n)\\\\\n&\\cdots\\\\\n&(1+x^n)\\\\\n\\end{aligned}\\\\\n$\n\n```cpp\n#include<bits\/stdc++.h>\nint n,a[2][121];\nint main(){\n    for(int i=0;i<=120;++i)a[1][i]=1;\n    for(int i=2;i<=120;++i){\n        memset(a[i&1],0,sizeof a[i&1]);\n        int p=0;\n        for(int p=0;p<=120;p+=i)\n            for(int j=0;j+p<=120;++j)\n                a[i&1][j+p]+=a[!(i&1)][j];\n                \/\/ ax^j · x^p = ax^{j+k}\n                \/\/ a'[j+k]+=a[j]\n    }\n    while(~scanf(\"%d\",&n))\n        printf(\"%d\\n\",a[0][n]);\n}\n```\n\n### 练习:\n\n[HDU 1085](http:\/\/acm.hdu.edu.cn\/showproblem.php?pid=1085)\n\n### 推广\n\n当$a=\\{1,1,1,\\dots\\}$时,$g(x)=1+x+x^2+x^3+\\dots$\n\n当$x\\in(-1,1)$时：\n\n$\n\\displaystyle\ng(x)=1+x+x^2+x^3+\\dots+x^{n-1}\n\\\\\nxg(x)=x+x^2+x^3+x^4+\\dots+x^n\n\\\\\ng(x)=\\frac{xg(x)-g(x)}{x-1}=\\frac{x^n-1}{x-1}\n\\\\\n\\because x\\in(-1,1),n=\\infty\n\\\\\n\\therefore x^n \\rightarrow 0\n\\\\\n\\therefore g(x)=\\frac1{1-x}\n$\n\n所以:\n\n$\\displaystyle \\frac1{1-x}=1+x+x^2+x^3+\\dots$\n\n$x$替换为$kx$:\n\n$\\displaystyle \\frac 1{1-kx}=1+kx+k^2x^2+k^3x^3+\\dots$\n\n两边分别求导得:\n\n$\\displaystyle \\frac1{(1-x)^2}=0+1+2x+3x^2+4x^3+\\dots$\n\n再求导:\n\n$\\displaystyle \\frac2{(1-x)^3}=0+0+1+3x+6x^2+10x^3+\\dots$\n\n推广: $\\displaystyle \\sum_{i=0}^\\infty {i+k-1 \\choose k-1}x^i=\\frac1{(1-x)^k}$\n\n常见生成函数:\n\n|数列|OGF|\n|-|-|\n|$<1,0,0,\\dots>$|$1$|\n|$<1,1,1,\\dots>$|$\\frac 1{1-x}$|\n|$<1,k,k^2,k^3,\\dots>$|$\\frac 1{1-kx}$|\n|$<1,2,3,\\dots>$|$\\frac 1{(1-x)^2}$|\n|$<1,−1,1,−1,\\dots>$|$\\frac 1{1+x}$|\n|$<1,2,1,0,0,\\dots>$|$(1+x)^2$|\n|$<1,4,6,4,1,0,0,\\dots>$|$(1+x)^4$|\n|$<1,n,{n\\choose 2},{n\\choose 3},\\dots>$|$(1+x)^n$|\n|$<1,n,{n+1\\choose 2},{n+1\\choose 3},\\dots>$|$(1-x)^{-n}$|\n|$<0,1,\\frac 12,\\frac 13,\\dots>$|$ln(1-x)$|\n|$<0,1,-\\frac 12,\\frac 13,-\\frac 14,\\dots>$|$ln(1+x)$|\n|$<1,1,\\frac 12,\\frac 1{3!},\\frac 1{4!},\\dots>$|$e^x$|\n\n### 板子题\n\n[LG 2000 拯救世界](https:\/\/www.luogu.com.cn\/problem\/P2000)\n\n1. 金神石的块数必须是6的倍数\n   $g(x)=1+x^6+x^{12}+...=\\frac 1{1-x^6}$\n2. 木神石最多用9块\n   $g(x)=1+x+x^2+...+x^9=\\frac{1-x^{10}}{1-x}$\n3. 水神石最多用5块\n   $g(x)=1+x+x^2+...+x^5=\\frac{1-x^6}{1-x}$\n4. 火神石的块数必须是4的倍数\n   $g(x)=1+x^4+x^8+...=\\frac 1{1-x^4}$\n5. 土神石最多用7块\n   $g(x)=1+x+x^2+...+x^7=\\frac{1-x^8}{1-x}$\n\n6. 金神石的块数必须是2的倍数\n   $g(x)=1+x^2+x^4+...=\\frac 1{1-x^2}$\n7. 木神石最多用1块\n   $g(x)=1+x=\\frac{1-x^2}{1-x}$\n8. 水神石的块数必须是8的倍数\n   $g(x)=1+x^8+x^{16}+...=\\frac 1{1-x^8}$\n9. 火神石的块数必须是10的倍数\n   $g(x)=1+x^{10}+x^{20}+...=\\frac 1{1-x^{10}}$\n10. 土神石最多用3块\n    $g(x)=1+x+x^2+x^3=\\frac{1-x^4}{1-x}$\n\n$\\displaystyle \\frac 1{1-x^6}\\cdot\\frac{1-x^{10}}{1-x}\\cdot\\frac{1-x^6}{1-x}\\cdot\\frac 1{1-x^4}\\cdot\\frac{1-x^8}{1-x}\\cdot\\frac 1{1-x^2}\\cdot\\frac{1-x^2}{1-x}\\cdot\\frac 1{1-x^8}\\cdot\\frac 1{1-x^{10}}\\cdot\\frac{1-x^4}{1-x}\\\\\n=\\frac1{(1-x)^5}\\\\\n=\\sum_{i=0}^\\infty {i+4 \\choose 4}x^i$\n\n第$n$项的系数是${n+4 \\choose 4}$需要FFT或NTT\n\n### 求斐波那契数列通项公式\n\n斐波那契数列:\n\n$$f_0=1,f_1=1,f_i=f_{i-1}+f_{i-2}(i>1)$$\n\n构造生成函数:\n\n$$F(x)=x+x^2+2x^3+3x^4+5x^5+\\dots$$\n\n构造方程:\n\n$$\n\\begin{aligned}\n&\\quad F(x)-xF(x)\\\\\n&=(x+x^2+2x^3+3x^4+\\dots)-(x^2+x^3+2x^4+3x^5+\\dots)\\\\\n&=x+x^3+x^4+2x^5+3x^6+\\dots\\\\\n&=x+x^2F(x)\n\\end{aligned}\n$$\n\n解得: \n\n$$F(x)=\\frac x{1-x-x^2}$$\n\n配方: \n\n$$\nF(x)=\\frac x{(1-\\phi_1 x)(1-\\phi_2 x)}\n\\\\~\\\\\n\\displaystyle \\phi_1=\\frac{1+\\sqrt 5}2,\\phi_2=\\frac{1-\\sqrt 5}2\n$$\n\n裂项: \n\n$$F(x)=\\frac 1{\\sqrt 5}\\left( \\frac 1{1-\\phi_1x}  - \\frac 1{1-\\phi_2x} \\right)$$\n\n那么:\n\n$$f_n=\\frac 1{\\sqrt 5}\\left[ \\left( \\frac{1+\\sqrt 5}2 \\right)^n - \\left( \\frac{1-\\sqrt 5}2 \\right)^n \\right]$$\n\n## 指数型生成函数\n\n### 定义\n\n指数型生成函数（exponential generating function,简称EGF）\n\n形如$\\displaystyle G(x)=\\sum_{i=0}^n a_i \\frac{x^i}{i!}$的表示序列的多项式函数,我们称之为指数型生成函数\n\n### 使用例\n\n> 有三种物品,分别有$3,2,3$个,问拿出$4$个进行排列(不同顺序算不同方案)的方案数是多少\n\n多重集排列数:\n\n> 设$S={a_1,a_2,\\dots,a_n},N=\\sum\\limits_{i=1}^n a_i$,其中$a_i$表示第$i$个物品有$a_i$个。\n>  \n> 从中选出$N$个进行排列的方案数为$\\displaystyle \\frac{N!}{a_1! a_2! \\dots a_n!}$\n>  \n> 解释: 任意排列之后减去同种物品之间多出来的方案\n\n构造:\n\n$\\displaystyle\nG_1(x)=1+\\frac x{1!}+\\frac {x^2}{2!}+\\frac {x^3}{3!}\\\\~\\\\\nG_2(x)=1+\\frac x{1!}+\\frac {x^2}{2!}\\\\~\\\\\nG_3(x)=1+\\frac x{1!}+\\frac {x^2}{2!}+\\frac {x^3}{3!}\\\\\n$\n\n那么\n\n$$\n\\begin{aligned}\n&\\quad G_1(x)\\cdot G_2(x) \\cdot G_3(x)\\\\\n&=(1+\\frac x{1!}+\\frac {x^2}{2!}+\\frac {x^3}{3!})(1+\\frac x{1!}+\\frac {x^2}{2!})(1+\\frac x{1!}+\\frac {x^2}{2!}+\\frac {x^3}{3!})\\\\\n&=(1+3x + \\frac{9}{2}x^2 + \\frac{14}{3}x^3 + \\frac{35}{12}x^4 + \\frac{17}{12}x^5 + \\frac{35}{72} x^6 + \\frac{8}{72}x^7 + \\frac{1}{71}x^8)\n\\end{aligned}\n$$\n\n选$4$个物品的方案数就是$4!\\cdot \\frac{35}{12}=70$\n\n[hdu 1521 排列组合](http:\/\/acm.hdu.edu.cn\/showproblem.php?pid=1521)\n\n```cpp\n#include<bits\/stdc++.h>\nconst int N=11;\nint n,m,a[N],fac[100000],mx=0;\ntypedef double db;\ndb c[2][N];\nvoid solve(){\n    mx=m;\n    for(int i=1;i<=n;++i){\n        scanf(\"%d\",a+i);\n        if(a[i]>mx)mx=a[i];\n    }\n    fac[0]=1;\n    for(int i=1;i<=mx;++i)fac[i]=fac[i-1]*i;\n    memset(c,0,sizeof c);\n    for(int i=0;i<=a[1];++i)\n        c[1][i]=1.0\/(db)fac[i];\n    for(int i=2;i<=n;++i){\n        memset(c[i&1],0,sizeof c[i&1]);\n        for(int p=0;p<=m;++p)\n            for(int j=0;j<=a[i]&&j+p<=m;++j)\n                c[i&1][j+p]+=c[!(i&1)][p]\/(db)fac[j];\n    }\n    printf(\"%.0f\\n\",c[n&1][m]*fac[m]);\n}\nint main(){\n    while(~scanf(\"%d%d\",&n,&m))solve();\n}\n```\n\n### 推广\n\n$\\displaystyle e^x=\\sum_{i=0}^{\\infty}\\frac{x^i}{i!}$\n\n常见的指数型生成函数:\n\n|数列|EGF|\n|-|-|\n|$<1,1,1,\\dots>$|$e^x$|\n|$<1,-1,1,-1,\\dots>$|$e^{-x}$|\n|$<1,k,k^2,k^3,\\dots>$|$e^{kx}$|\n|$<0,1,2,\\dots>$|$xe^x$|\n|$<1,0,1,0,\\dots>$|$\\frac {e^x+e^{-x}}2$|\n|$<0,1,0,1,\\dots>$|$\\frac {e^x-e^{-x}}2$|\n\n可以发现$<f_n>$的EGF就是$<\\frac{f_n}{n!}>$的OGF\n\n例题:\n\n[poj 3734 积木](http:\/\/poj.org\/problem?id=3734)\n\n> 长度为$n$的序列,用红黄蓝绿染色,其中红、绿数量均为偶数,求方案数\n\n红、绿: $\\frac{e^x+e^{-x}}2$\n\n黄、蓝: $e^x$\n\n$\\displaystyle\n\\begin{aligned}\nF(x)\n&=e^x \\cdot \\frac{e^x+e^{-x}}2 \\cdot e^x \\cdot \\frac{e^x+e^{-x}}2\\\\\n&=\\left(e^x \\cdot \\frac{e^x+e^{-x}}2\\right)^2\\\\\n&=\\left(\\frac{e^{2x}+1}2\\right)^2\\\\\n&=\\frac{e^{4x}+2e^{2x}+1}4\\\\\n&=\\frac 14+\\sum_{i=0}^{\\infty} \\frac{4^i+2^{i+1}}4 \\cdot \\frac{x^i}{n!}\n\\end{aligned}\n\\\\\nf_n=\\frac{4^n+2^{n+1}}4 \n$\n\n```cpp\n#include<cstdio>\ntypedef long long ll;\nconst int P=10007;\nint n;\nint pw(ll x,int b){\n    ll res=1;\n    while(b){\n        if(b&1)res=res*x%P;\n        x=x*x%P;b>>=1;\n    }\n    return res;\n}\nint main(){\n    int T;scanf(\"%d\",&T);\n    while(T--)\n        scanf(\"%d\",&n),\n        printf(\"%d\\n\",(pw(4,n)+pw(2,n+1))%P*2502%P);\n}\n```","link":null,"tags":["数论","技巧"],"title":"生成函数"},{"categories":[["note"]],"content":"\n\nhttps:\/\/www.51nod.com\/Challenge\/Problem.html#problemId=1228\n\nhttps:\/\/www.51nod.com\/Challenge\/Problem.html#problemId=1258\n\nhttps:\/\/www.51nod.com\/Challenge\/Problem.html#problemId=1822\n\n## 定义\n\n$$\n\\begin{cases}\nB_0=1\\\\~\\\\\n\\displaystyle \\sum\\limits_{i=0}^n {n+1\\choose i}B_i=0,n>0\n\\end{cases}\n$$\n\n## 计算\n\n暴力计算伯努利数效率是$O(n^2)$的\n\n我们要高效计算伯努利数\n\n推式子:\n\n代入$n=n+1$:\n\n$$\n\\sum_{i=0}^n {n\\choose i}B_i=B_n,n>1\n\\\\~\\\\\n\\sum_{i=0}^n \\frac{B_i}{i!(n-i)!}=\\frac{B_n}{n!},n>1\n$$\n\n$0!=1,n=0$时,也满足上述式子\n\n$$\\sum_{i=0}^n \\frac{B_i}{i!} \\cdot \\frac 1{(n-i)!}=\\frac{B_n}{n!},n\\neq 1$$\n\n算出$n=1$的情况:\n\n$$\\sum_{i=0}^n \\frac{B_i}{i!} \\cdot \\frac 1{(n-i)!}=\\frac{B_n}{n!}+[n=1]$$\n\n构建生成函数\n\n$$\n\\sum_{n=0}^{\\infty}\\sum_{i=0}^n \\frac{B_i}{i!} x^i \\cdot \\frac 1{(n-i)!} x^{n-i}=\\sum_{n=0}^{\\infty} \\left( \\frac{B_n}{n!}+[n=1]\\right)x^n\n\\\\~\\\\\nB(x)e^x=B(x)+x\n\\\\~\\\\\nB(x)=\\frac x{e^x-1}\n\\\\~\\\\ \nB(x)=(\\frac {e^x-1}x)'\n$$\n\n## 性质\n\n$\\displaystyle \\sum_{i=1}^{n-1} i^k=\\frac 1{k+1} \\sum_{i=1}^{k+1} {k+1\\choose i}B_in^{k-i+1}$","link":null,"tags":["数论"],"title":"伯努利数与自然数幂和"},{"categories":[["note"]],"content":"\n\n","link":null,"tags":["数论","矩阵"],"title":"行列式"},{"categories":[["游记"]],"content":"\n\n时间不知不觉又过去了~~一~~两年,又到了省选的时候\n\n~~这次有点自闭,游记可能先咕咕咕了~~\n\n","link":null,"tags":["游记"],"title":"GDOI2020游记"},{"categories":[["刷题记录"]],"content":"\n首先奇偶黑白染色,源点连黑点,白点连汇点,边权为点权\n\n接着所有黑点向相邻的白点连边,边权为$\\infty$\n\n答案就是 点权和-最小割\n\n```cpp\n#include<bits\/stdc++.h>\n#define fur(i,x,y) for(int i=x;i<=y;++i)\nint rd(){int x=0;char c;bool f=0;for(c=getchar();c<'0'||'9'<c;c=getchar())f^=c=='-';for(x=c-48,c=getchar();'0'<=c&&c<='9';x=x*10+c-48,c=getchar());return f?-x:x;}\nconst int N=11111,inf=-1u>>1;\n#define id(i,j) (i-1)*m+j\nint n,m,ans,st=N-2,ed=N-1,cnt=1,head[N];\nstruct edge{int to,nxt,w;}e[N*8];\nvoid add(int x,int y,int w){\n    e[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;e[cnt].w=w;\n    e[++cnt].to=x;e[cnt].nxt=head[y];head[y]=cnt;e[cnt].w=0;\n}\nint q[N],d[N];\nbool bfs(){\n    int h=0,t=1,x;\n    memset(d,0,sizeof d);\n    d[q[0]=st]=1;\n    while(h<t){\n        x=q[h++];if(x==ed)return 1;\n        for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n            if(e[i].w&&!d[to])d[to]=d[x]+1,q[t++]=to;\n    }\n    return 0;\n}\nint min(int x,int y){return x<y?x:y;}\nint dfs(int x,int mf){\n    if(x==ed)return mf;\n    int us=0,w;\n    for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n        if(d[to]==d[x]+1&&e[i].w){\n            w=dfs(to,min(mf-us,e[i].w));\n            e[i].w-=w,e[i^1].w+=w;\n            us+=w;if(us==mf)return mf;\n        }\n    if(!us)d[x]=-1;\n    return us;\n}\nint main(){\n    n=rd(),m=rd();\n    int w;\n    fur(i,1,n)fur(j,1,m){\n        w=rd(),ans+=w;\n        if((i+j)&1){\n            add(st,id(i,j),w);\n            if(i>1)add(id(i,j),id(i-1,j),inf);\n            if(i<n)add(id(i,j),id(i+1,j),inf);\n            if(j>1)add(id(i,j),id(i,j-1),inf);\n            if(j<m)add(id(i,j),id(i,j+1),inf);\n        }\n        else add(id(i,j),ed,w);\n    }\n    while(bfs())ans-=dfs(st,inf);\n    printf(\"%d\\n\",ans);\n}\n```\n","link":null,"tags":["网络流"],"title":"LG 4474 王者之剑"},{"categories":[["公告"]],"content":"\n\n","link":null,"tags":["技术","前端"],"title":"小站日志"},{"categories":[["技术分享"]],"content":"\n\n## 背景\n\n静态博客实现搜索一直是一件很困扰人的事\n\n之前使用的方案:\n\n1. 静态文件实现搜索\n\n   将所有文章数据记录到一个json文件中,\n\n   前端加载该文件,本地进行搜索\n\n   \n\n   不是长久之计\n\n   当文字量较小时看不出什么问题\n\n   文字量变大时,json文件也随之变大,搜索前用户需要加载整个文件,消耗流量大,加载较慢,增大网站负载,而且如果网站带宽较小,用户需要加载非常久,体验极差\n\n   我的博客的数据文件已经达到`3.2MB`,若部署在github pages,国内访问体验非常差劲\n\n2. 采用百度,google等搜索引擎的全站搜索\n\n   google体验不错,可是国内需要使用魔法才可以访问\n\n   baidu收录慢,体验差\n\n   而且各大搜索引擎自定义性不高\n\n3. algolia\n\n   一个非常不错的自定义搜索api\n\n   还可以自定义数据中心位置(如:香港),挺良心的\n\n   可惜额度有点低,免费版支持上传10000条索引,每个月只有10000次请求\n\n4. site search 360\n\n   免费版每个月只有1000次请求,无法使用api\n\n   图个方便\n\n偶然看到cloudflare的workers项目,想到可以用来实现静态网站支持搜索\n\n## cloudflare workers\n\n> 通过 Workers 在边缘运行 JavaScript\n\n免费计划:\n\n> Free\n>\n> 用于个人用途和简单应用\n>\n> 计划功能\n>\n> - 包括**100,000个请求\/天**(UTC+0)1\n> - 每个请求最多占用 10 毫秒 CPU 时间\n> - 第一个请求后的延迟最低\n> - 最多 30 个 Worker\n\n\n## 思路\n\n首先还是将所有文章数据记录到一个json文件中\n\n让worker预读取文件,缓存,worker是一直运行着的,之后不用再读取数据文件\n\nworker搜索时\n\n用关键词分别匹配标题、标签、分类、内容\n\n然后返回匹配成功的所有文章\n\n只返回所需信息: 标题、链接、内容预览\n\n## 实现\n\n将json数据文件按以下格式记录\n\n```json\n[\n    {\n        \"title\":\"<title>\",             \/\/ 标题\n        \"link\":\"<link>\",               \/\/ 链接\n        \"tags\":[\"tag1\",\"tag2\",\/*...*\/],\/\/ 标签\n        \"categories\":[                 \/\/ 分类\n            [\"xx\",\"xxx\",\"xxxx\",\/*...*\/],\n            [\"yy\",\"yyy\",\"yyyy\"],\n            \/*...*\/\n        ],\n        \"content\":\"<content>\"          \/\/ 内容\n    },\n    \/*...*\/\n]\n```\n\n将下面代码粘贴到worker中运行\n\n```javascript\nconst file='https:\/\/zcmimi.github.io\/pure_data.json', \/\/ json数据文件位置\n    addr='https:\/\/blog_search.zcmimi.workers.dev', \/\/ 当前worker网址\n    preview_len=50; \/\/ 预览字数\nvar data,url;\nasync function getdata(){\n    await fetch(file).\n            then(res=>res.json()).\n            then(json=>data=json);\n}\nfunction chk(content,text,typ=0){\n    content=content.toLowerCase();\n    if(typ==0)return content.indexOf(text)!=-1;\n    else if(typ==1){\n        for(var i=0,j=0;i<content.length;++i)\n            if(content[i]==text[j])\n                if(++j==text.length)return 1;\n    }\n    return 0;\n}\nasync function search(text,typ=0){\n    text=text.toLowerCase();\n    if(!data)await getdata();\n    var res=[];\n    for(i in data){\n        var f=0;\n        if(chk(data[i].title,text,typ))f=1;\n        else for(j in data[i].tags)\n            if(chk(data[i].tags[j],text,typ)){\n                f=1;\n                break;\n            }\n        else for(j in data[i].categories)\n            for(k in data[i].categories[j])\n                if(chk(data[i].categories[j][k],text,typ)){\n                    f=1;\n                    break;\n                }\n        else if(chk(data[i].content,text,typ))f=1;\n        if(f)res.push([data[i].link,data[i].title,data[i].content.substring(0,preview_len)]);\n    }\n    return JSON.stringify(res);\n}\nfunction geturl(keyword){\n    var vars=url.split(\"&\");\n    for(var i=0;i<vars.length;++i){\n        var pair=vars[i].split(\"=\");\n        if(pair[0]==keyword)return pair[1];\n    }\n    return 0;\n}\n\/**\/\naddEventListener('fetch',event=>{\n    event.respondWith(handleRequest(event.request))\n})\nasync function handleRequest(request){\n    var res=\"usage:\\n\\\n?keyword=<keyword>&typ=<typ>\\n\\\nrequired: keyword\";\n    url=decodeURI(request.url);\n    if(chk(url,\"keyword\")){\n        url=url.substr(addr.length+2,url.length);\n        res=await search(geturl(\"keyword\"),geturl(\"typ\"));\n    }\n    return new Response(res,{\n        status:200,\n        headers:new Headers({\n            \/\/ 允许跨域访问,也可自定义域名\n            'access-control-allow-origin': '*',\n            'access-control-allow-methods': 'GET,POST,PUT,PATCH,TRACE,DELETE,HEAD,OPTIONS',\n            'access-control-max-age': '1728000',\n        }),\n    });\n}\n```\n\n使用:\n\nworkers地址+`\/?keyword=<keyword>&typ=<typ>`\n\n会返回查询结果的json,格式如下:\n\n```json\n[\n    [\n        \"<link>\",  \/\/ 链接\n        \"<title>\", \/\/ 标题\n        \"<preview>\"\/\/ 预览\n    ],\n    \/*...*\/\n]\n```\n\n其中`<keyword>`为查询关键词,必填\n\n`typ`为匹配模式,选填,默认`typ=0`\n\n`typ=0`: 子串匹配\n\n`typ=1`: 子序列匹配\n\n前端使用示范:\n\n```html\n<div class=\"mdui-progress\" id='loading-progress' style=\"position: fixed;top:0;z-index: 999999;\"><div class=\"mdui-progress-indeterminate\"><\/div><\/div>\n<div class=\"mdui-dialog\" id=\"search_dialog\">\n    <div class=\"mdui-dialog-title\">Search<\/div>\n    <div class=\"mdui-dialog-content\">\n        <div class=\"mdui-textfield\">\n            <i class=\"mdui-icon material-icons\">search<\/i>\n            <input id=\"search_input\" class=\"mdui-textfield-input\" placeholder=\"搜索\">\n        <\/div>\n        <div id=\"search_result\" class=\"mdui-list\"><\/div>\n    <\/div>\n<\/div>\n```\n\n```javascript\nfunction search(api){ \/\/api为worker地址\n    document.getElementById('loading-progress').hidden=0;\n    var text=document.getElementById(\"search_input\").value.toLowerCase(),\n        res=document.getElementById(\"search_result\"),\n        xhr=new XMLHttpRequest();\n    res.innerHTML='';\n    xhr.open('GET',api+'\/?keyword='+text,true);\n    xhr.onreadystatechange=function(){\n        if(xhr.readyState==4){\n            document.getElementById('loading-progress').hidden=1;\n            var data=JSON.parse(this.responseText);\n            for(i in data){\n                var a=document.createElement('a'),\n                    content=document.createElement('div'),\n                    Title=document.createElement('div'),\n                    Text=document.createElement('div');\n                \n                a.classList.add('mdui-list-item');\n                Title.classList.add('mdui-list-item-title');\n                Text.classList.add('mdui-list-item-text');\n                content.classList.add('mdui-list-item-content');\n                a.href=data[i][0];\n                Title.innerText=data[i][1];\n                Text.innerText=data[i][2].replace(\/[\\r\\n]\/g,\" \");\n                \n                content.appendChild(Title),content.appendChild(Text);\n                a.appendChild(content);\n                \n                res.appendChild(a);\n            }\n            search_dialog.handleUpdate();\n        }\n    }\n    xhr.send();\n}\n```\n\n## 结语\n\n有了cloudflare workers的帮助,终于解决了静态网站全站搜索的问题\n\n加载速度也得到有效提升\n\n一天10万次的搜索对于个人博客已经绰绰有余了\n\n对于这个结果我算是挺满意的了\n","link":null,"tags":["前端","技术"],"title":"cloudflare workers实现静态网站全站搜索"},{"categories":[["刷题记录"]],"content":"\n可以看出这是多颗基环树\n\n分三种情况:\n\n1. $x,y$在不同的两颗树上\n   \n2. $x,y$还没到达环就相遇了\n   \n3. $x,y$的祖先在环上不同位置\n\n\n```cpp\n#include<bits\/stdc++.h>\n#define fur(i,x,y) for(int i=x;i<=y;++i)\nint rd(){int x=0;char c;bool f=0;for(c=getchar();c<'0'||'9'<c;c=getchar())f^=c=='-';for(x=c-48,c=getchar();'0'<=c&&c<='9';x=x*10+c-48,c=getchar());return f?-x:x;}\nconst int N=500011;\nint n,q,f[20][N],cnt,head[N],d[N],fr[N],deg[N],Q[N],s[N],sz[N],bl[N];\nstd::list<int>e[N];\nbool v[N];\nvoid dfs(int x,int F){\n    fr[x]=F;\n    for(auto to:e[x])if(v[to])\n        d[to]=d[x]+1,dfs(to,F);\n}\nint lca(int x,int y){\n    if(d[x]<d[y])x^=y,y^=x,x^=y;\n    int t=d[x]-d[y];\n    for(int i=19;~i;--i)\n        if((t>>i)&1)x=f[i][x];\n    if(x==y)return y;\n    for(int i=19;~i;--i)\n        if(f[i][x]^f[i][y])\n            x=f[i][x],y=f[i][y];\n    return f[0][x];\n}\nvoid gl(int x,int id,int now){\n    if(s[x])return;\n    s[x]=now,++sz[id],bl[x]=id;\n    gl(f[0][x],id,now+1);\n}\nbool pd(int x1,int y1,int x2,int y2) {\n\tif(std::max(x1,y1)!=std::max(x2,y2))return std::max(x1,y1)<std::max(x2,y2);\n\tif(std::min(x1,y1)!=std::min(x2,y2))return std::min(x1,y1)<std::min(x2,y2);\n\treturn x1>=y1;\n}\nint main(){\n    n=rd(),q=rd();\n    fur(i,1,n)\n        ++deg[f[0][i]=rd()],\n        e[f[0][i]].push_back(i);\n    fur(k,1,19)fur(i,1,n)\n        f[k][i]=f[k-1][f[k-1][i]];\n    int tp=0,x,y,z,fx,fy;\n    for(int i=1;i<=n;++i)if(!deg[i])Q[++tp]=i;\n    while(tp){\n        v[x=Q[tp--]]=1;\n        if(!--deg[f[0][x]])Q[++tp]=f[0][x];\n    }\n    for(int i=1;i<=n;++i)\n        if(!v[i])dfs(i,i),gl(i,++cnt,1);\n    while(q--){\n        fx=fr[x=rd()],fy=fr[y=rd()];\n        if(bl[fx]^bl[fy])printf(\"-1 -1\\n\");\n        else if(fx==fy)\n            z=lca(x,y),\n            printf(\"%d %d\\n\",d[x]-d[z],d[y]-d[z]);\n        else{\n            int more1=d[x]+(s[fy]-s[fx]+sz[bl[fx]])%sz[bl[fx]],more2=d[y]+(s[fx]-s[fy]+sz[bl[fx]])%sz[bl[fx]];\n\t\t\tif(pd(d[x],more2,more1,d[y]))printf(\"%d %d\\n\",d[x],more2);\n\t\t\telse printf(\"%d %d\\n\",more1,d[y]);\n        }\n    }\n}\n```\n","link":null,"tags":["倍增","基环树","lca"],"title":"LG 3533 [POI2012]RAN-Rendezvous"},{"categories":[["刷题记录"]],"content":"\n逆推\n\n若当前区间$[l,r]$和为$x$,考虑如何得到和为$x-2$的区间:\n\n1. $a_l=2 \\rightarrow [l+1,r]$\n2. $a_r=2 \\rightarrow [l,r-1]$\n3. $a_l=a_r=1 \\rightarrow [l+1,r-1]$\n\n这样我们求出区间 最大奇数和 与 最大偶数和,就可以预处理出所有$x$的答案了\n```cpp\n#include<bits\/stdc++.h>\nconst int N=1000001;\nint n,q,a[N],s[N],L[N*2],R[N*2];\nchar c[N];\nvoid solve(int v){\n    while(v>2){\n        L[v-2]=L[v]+1,R[v-2]=R[v]-1;\n        if(a[L[v]]==2)R[v-2]=R[v];\n        else if(a[R[v]]==2)L[v-2]=L[v];\n        v-=2;\n    }\n}\nint main(){\n    int t1=0,t2=0,v;\n    scanf(\"%d%d%s\",&n,&q,c+1);\n    for(int i=1;i<=n;++i)\n        a[i]=1+(c[i]=='T'),\n        s[i]=s[i-1]+a[i];\n    v=s[n],L[v]=1,R[v]=n,solve(v);\n    for(int i=1;i<=n;++i)if(a[i]==1){t1=i+1;break;}\n    for(int i=n;i;--i)if(a[i]==1){t2=i-1;break;}\n    if((!t1&&t2)||s[t2]>s[n]-s[t1-1])\n        v=s[t2],L[v]=1,R[v]=t2;\n    else if(t1)\n        v=s[n]-s[t1-1],L[v]=t1,R[v]=n;\n    solve(v);\n    while(q--){\n        int x;scanf(\"%d\",&x);\n        if(!L[x])printf(\"NIE\\n\");\n        else printf(\"%d %d\\n\",L[x],R[x]);\n    }\n}\n```\n","link":null,"tags":["前缀和","思维"],"title":"LG 3514 [POI2011]LIZ-Lollipop"},{"categories":[["刷题记录"]],"content":"\n设$f_i$表示所有数$\\gcd$为$i$还要加入的数的期望数量\n\n$$ans=1+\\frac{\\sum_{i=1}^mf_i}m$$\n\n可以知道$f_1=0$\n\n$$f_i=1+\\frac{\\sum_{j=1}^m f_{\\gcd(i,j)}}m(i>1)$$\n\n继续推式子:\n\n$$\n\\begin{aligned}\nf_i\n&=1+\\frac{\\sum_{j=1}^m f_{\\gcd(i,j)}}m\\\\\n&=1+\\frac{\\sum_{d|i} f_d\\sum_{j=1}^m [\\gcd(i,j)=d]}m\n\\end{aligned}\n$$\n\n把分子拿出来\n\n$$\n\\begin{aligned}\n&\\quad\\sum_{d|i} f_d\\sum_{j=1}^m [\\gcd(i,j)=d]\\\\\n&=\\sum_{d|i} f_d\\sum_{j=1}^{m\/d} [\\gcd(\\frac id,j)=1]\\\\\n&=\\sum_{d|i} f_d\\sum_{j=1}^{m\/d} \\sum_{x|\\frac id,x|j}\\mu(x)\\\\\n&=\\sum_{d|i} f_d \\sum_{x|\\frac id}\\sum_{j=1}^{m\/dx}\\mu(x)\\\\\n&=\\sum_{d|i} f_d \\sum_{x|\\frac id}\\mu(x)\\left \\lfloor \\frac m{dx}\\right\\rfloor\\\\\n\\end{aligned}\\\\\n$$\n\n设$T=dx$\n\n$$\n=\\sum_{T|i}\\sum_{d|T} f_d \\mu(\\frac Td)\\left \\lfloor \\frac mT\\right\\rfloor\n$$\n\n带入原来的式子\n\n$$\nf_i=1+\\frac{\\sum_{T|i}\\left \\lfloor \\frac mT\\right\\rfloor\\sum_{d|T} f_d \\mu(\\frac Td)}m\n$$\n\n设$F_T=\\sum_{d|T} f_d \\mu(\\frac Td)$\n\n当$d\\not = i$时可以每算出一个$f_i$就更新所有$F_x(i|x)$\n\n当$d=i$时没法直接更新,这时$T=d=i,\\mu(\\frac Td)=\\mu(1)=1$\n\n$$\nf_i=1+\\frac{\\sum_{T|i}\\left \\lfloor \\frac mT\\right\\rfloor\\sum_{d|T} f_d \\mu(\\frac Td)[d\\not=i]}m+\\frac{f_i\\left\\lfloor \\frac mi \\right\\rfloor}m\n\\\\\nf_i-\\frac{f_i\\left\\lfloor \\frac mi \\right\\rfloor}m=\\frac{m+\\sum_{T|i}\\left \\lfloor \\frac mT\\right\\rfloor\\sum_{d|T} f_d \\mu(\\frac Td)[d\\not=i]}m\n\\\\\nf_i\\frac{m-\\left\\lfloor\\frac mi \\right\\rfloor}m=\\frac{m+\\sum_{T|i}\\left \\lfloor \\frac mT\\right\\rfloor\\sum_{d|T} f_d \\mu(\\frac Td)[d\\not=i]}m\n\\\\\nf_i=\\frac{m+\\sum_{T|i}\\left \\lfloor \\frac mT\\right\\rfloor\\sum_{d|T} f_d \\mu(\\frac Td)[d\\not=i]}{m-\\left\\lfloor\\frac mi \\right\\rfloor}\n$$\n\n这样就可以先算$f_i$,再算$F_i$了\n\n$[d\\not=i]$这个条件只在$T=i$的时候才有限制\n\n枚举到$T=i$,计算$f_i$时,$F_x(x<i)$都已经计算好了\n\n$F_i$还少了$f[i] \\times \\mu(1)$\n\n这正好是要剪掉的部分\n\n```cpp\n#include<bits\/stdc++.h>\nusing std::list;\nconst int N=100011,P=1000000007;\nint n,F[N],pri[N],mu[N],tt,inv[N],ans=1;\nbool v[N];\nlist<int>d[N];\nint m(int x){return x>=P?x-P:(x<0?x+P:x);}\nint main(){\n    scanf(\"%d\",&n);\n    mu[1]=1;\n    for(int i=2;i<=n;++i){\n        if(!v[i])pri[++tt]=i,mu[i]=-1;\n        for(int j=1;j<=tt&&i*pri[j]<=n;++j){\n            v[i*pri[j]]=1;\n            if(i%pri[j]==0)break;\n            mu[i*pri[j]]=-mu[i];\n        }        \n    }\n    for(int i=1;i<=n;++i)\n        for(int j=i;j<=n;j+=i)\n            d[j].push_back(i);\n    inv[1]=1;\n    for(int i=2;i<=n;++i)\n\t\tinv[i]=1ll*(P-P\/i)*inv[P%i]%P;\n    \n    for(int i=2;i<=n;++i){\n        int f=n;\n        for(auto T:d[i])\n            f=(f+1ll*n\/T*F[T])%P;\n        f=1ll*f*inv[n-n\/i]%P;\n        ans=m(ans+f+1);\n        for(int j=1,k=i;k<=n;++j,k+=i)\n            F[k]=m(F[k]+f*mu[j]);\n    }\n    printf(\"%d\\n\",1ll*ans*inv[n]%P);\n}\n```\n","link":null,"tags":["莫比乌斯","数论","期望","思维"],"title":"LG CF1139D Steps to One"},{"categories":[["刷题记录"]],"content":"\n\n## DZY Loves Math\n\n题意:\n\n对于正整数$n$,定义$f(n)$为$n$所含质因子的最大幂指数\n\n例如$f(1960)=f(2^3\\cdot 5^1\\cdot 7^2)=3,f(10007)=1,f(1)=0$\n\n给定正整数$a,b$,求$\\sum\\limits_{i=1}^a\\sum\\limits_{j=1}^b f(\\gcd(i,j))$\n\n假设$a<b$\n\n$$\n\\sum_{i=1}^a\\sum_{j=1}^b f(\\gcd(i,j))\\\\\n=\\sum_{d=1}^a f(d)\\sum_{i=1}^a\\sum_{j=1}^b[\\gcd(i,j)=d]\\\\\n=\\sum_{d=1}^a f(d)\\sum_{i=1}^{a\/d}\\sum_{j=1}^{b\/d}[\\gcd(i,j)=1]\\\\\n=\\sum_{d=1}^a f(d)\\sum_{i=1}^{a\/d}\\sum_{j=1}^{b\/d}\\sum_{x|a,x|b}\\mu(x)\\\\\n=\\sum_{d=1}^a f(d) \\sum_{x=1}^a\\mu(x)\\sum_{i=1}^{a\/dx}\\sum_{j=1}^{b\/dx}\\\\\n=\\sum_{d=1}^a f(d) \\sum_{x=1}^a\\mu(x)\\left\\lfloor\\frac a{dx}\\right\\rfloor \\left\\lfloor\\frac b{dx}\\right\\rfloor\n$$\n\n设$T=dx$\n\n$$\n=\\sum_{T=1}^a \\left\\lfloor\\frac a{T}\\right\\rfloor \\left\\lfloor\\frac b{T}\\right\\rfloor \\sum_{x|T} f(x)\\mu(\\frac Tx)\n$$\n\n前面可以数论分块,主要问题在于求$,\\sum\\limits_{x|T} f(x)\\mu(\\frac Tx)$\n\n设$g(T)=,\\sum\\limits_{x|T} f(x)\\mu(\\frac Tx)$\n\n可以发现当$\\mu(x)$为$0$时没有贡献\n\n设$T=p_1^{a_1}p_2^{a_2}\\dots p_k^{a_k}$\n\n当$a_1=a_2=\\dots=a_k$时,\n$g(T)=(-1)^{k+1}$。\n\n否则$g(T)=0$\n\n证明:\n\n1. $a_1,a_2,\\dots,a_k$不全相等时,$g(T)=0$\n   \n   如果所有质因子的次数不全相等,那么考虑次数最小的那个质因子,它无论是否选择都不会影响$f(\\frac Tx)$的值,只是差在$μ(x)$的正负。这样选它和不选它,产生的贡献正好正负抵消,因此$g(T)$一定是$0$\n\n2. $a_1=a_2=...=a_k$\n   \n   当且仅当每个质因子都选择时,$f(\\frac Tx)$等于$a−1$,否则等于$a$。那么如果把$a−1$的那次贡献看作$a$,那么答案应该是0。所以只需要考虑把$a−1$看成$a$的变化。显然当$k$为奇数时$μ(x)$为负,$a−1$的贡献为负,因此答案为$1$；否则$a−1$的贡献为正,答案为$−1$\n\n```cpp\n#include<cstdio>\nconst int N=10000001;\nint pri[N],mi[N],cnt[N],b[N];\nlong long g[N],res;\nbool v[N];\nvoid init(){\n\tfor(int i=2,tt=0;i<N;++i){\n\t\tif(!v[i])pri[++tt]=i,cnt[i]=mi[i]=1;\n\t\tfor(int j=1;j<=tt&&i*pri[j]<N;++j){\n\t\t\tv[i*pri[j]]=1;\n\t\t\tif(i%pri[j]==0){\n\t\t\t\tcnt[i*pri[j]]=cnt[i];\/\/质因子个数\n\t\t\t\tmi[i*pri[j]]=mi[i]+1;\/\/当前质因子幂次\n                b[i*pri[j]]=b[i];\/\/除当期质因子外最高幂次\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(!b[i]||b[i]==mi[i])b[i*pri[j]]=mi[i];\n                else b[i*pri[j]]=-1;\n                mi[i*pri[j]]=1,cnt[i*pri[j]]=cnt[i]+1;\n\t\t\t}\n\t\t}\n        g[i]=g[i-1];\n        if(!b[i]||b[i]==mi[i])g[i]+=(cnt[i]&1)?1:-1;\n\t}\n}\nint min(int x,int y){return x<y?x:y;}\nvoid solve(){\n\tint a,b;res=0;\n\tscanf(\"%d%d\",&a,&b);\n\tif(a>b)a^=b,b^=a,a^=b;\n\tfor(int l=1,r;l<=a;l=r+1){\n\t\tr=min(a\/(a\/l),b\/(b\/l));\n\t\tres+=1ll*(a\/l)*(b\/l)*(g[r]-g[l-1]);\n\t}\n\tprintf(\"%lld\\n\",res);\n}\nint main(){\n    init();\n\tint T;scanf(\"%d\",&T);\n\twhile(T--)solve();\n}\n```","link":null,"tags":["数论","数论分块","莫比乌斯"],"title":"DZY Loves Math 系列"},{"categories":[["刷题记录"]],"content":"\n设$a_i=\\sum\\limits_{j=1}^N[A_j=i],n=10^6$\n\n$$\n\\sum_{i=1}^n\\sum_{j=i+1}^n \\operatorname{lcm}(A_i,A_j)\\\\\n=\\sum_{i=1}^n\\sum_{j=i+1}^n a_ia_j\\frac{ij}{\\gcd(i,j)}\\\\\n=\\sum_{d=1}^n\\frac 1d\\sum_{i=1}^n\\sum_{j=i+1}^n a_ia_j ij [\\gcd(i,j)=d]\\\\\n=\\sum_{d=1}^n\\frac 1d\\sum_{i=1}^{n\/d}\\sum_{j=i+1}^{n\/d} a_{id}a_{jd} idjd [\\gcd(i,j)=1]\\\\\n=\\sum_{d=1}^n d \\sum_{i=1}^{n\/d}\\sum_{j=i+1}^{n\/d} a_{id}a_{jd} ij [\\gcd(i,j)=1]\\\\\n=\\sum_{d=1}^n d \\sum_{i=1}^{n\/d}\\sum_{j=i+1}^{n\/d} a_{id}a_{jd} ij \\sum_{x|i,x|j}\\mu(x)\\\\\n=\\sum_{d=1}^n d \\sum_{x=1}^n\\mu(x)\\sum_{i=1}^{n\/dx}\\sum_{j=i+1}^{n\/dx} a_{idx}a_{jdx} ixjx\\\\\n=\\sum_{d=1}^n d \\sum_{x=1}^n\\mu(x)x^2 \\sum_{i=1}^{n\/dx}\\sum_{j=i+1}^{n\/dx} a_{idx}a_{jdx} ij\\\\\n$$\n设$T=dx$\n$$\n=\\sum_{T=1}^n T \\sum_{x|T}\\mu(x)x \\sum_{i=1}^{n\/T}\\sum_{j=i+1}^{n\/T} a_{iT}a_{jT} ij\n$$\n```cpp\n#include<bits\/stdc++.h>\nconst int N=1000111,P=998244353;\nint n,a[N],pri[N],mu[N];\nbool v[N];\nint f(int T){\n\tint k=n\/T,sum=0,res=0;\n\tfor(int i=1;i<=k;i++)\n        (sum+=1ll*i*a[i*T]%P)%=P;\n\tfor(int i=1;i<=k;i++)\n\t\t(sum+=P-1ll*i*a[i*T]%P)%=P,\n\t\t(res+=1ll*sum*i%P*a[i*T]%P)%=P;\n\treturn res;\n}\nint main(){\n    int t,x,ans=0;scanf(\"%d\",&t);\n    while(t--){\n        scanf(\"%d\",&x),++a[x];\n        if(x>n)n=x;\n    }\n    mu[1]=1;\n    for(int i=2,tt=0;i<=n;++i){\n        if(!v[i])pri[++tt]=i,mu[i]=-1;\n        for(int j=1;j<=tt&&i*pri[j]<=n;++j){\n            v[i*pri[j]]=1;\n            if(i%pri[j]==0)break;\n            mu[i*pri[j]]=-mu[i];\n        }\n    }\n    for(int i=1;i<=n;++i)\n        mu[i]=(~mu[i])?(mu[i]*i):(mu[i]*i+P);\n    for(int x=n;x;--x)\n        for(int T=x+x;T<=n;T+=x)\n            (mu[T]+=mu[x])%=P;\n    for(int T=1;T<=n;++T)\n        (ans+=1ll*a[T]*(a[T]-1)\/2%P*T%P)%=P;\n    for(int T=1;T<=n;++T)\n        (ans+=1ll*T*mu[T]%P*f(T)%P)%=P;\n    printf(\"%d\\n\",ans);\n}\n```\n","link":null,"tags":["莫比乌斯","数论"],"title":"LG AT5200 [AGC038C] LCMs"},{"categories":[["刷题记录"]],"content":"\n先了解[\\[WC2011\\]最大XOR和路径](https:\/\/www.luogu.com.cn\/problem\/P4151)的做法\n\n线段树分治+并查集+线性基\n\n加边删边可以用按秩合并的并查集解决,遇到环就插入线性基\n\n由于并查集无法删除元素,删边可以用线段树分治处理(转化为每条边在一个时间段存在)\n```cpp\n#include<bits\/stdc++.h>\nint rd(){int x=0;char c;bool f=0;for(c=getchar();c<'0'||'9'<c;c=getchar())f^=c=='-';for(x=c-48,c=getchar();'0'<=c&&c<='9';x=x*10+c-48,c=getchar());return f?-x:x;}\nconst int N=200011;\nstruct edge{int x,y,w;}e[N*2];\nint n,m,q,bg[N*2],ed[N*2],ql[N],qr[N],f[N],d[N],dep[N];\nusing namespace std;\nmap<pair<int,int>,int>T;\nstruct XOR{\n    int p[32];\n    void ins(int x){\n        for(int i=30;x,~i;--i)if(x>>i){\n            if(!p[i]){p[i]=x;return;}\n            x^=p[i];\n        }\n    }\n    int ask(int x){\n        for(int i=30;~i;--i)\n            if((x^p[i])<x)x^=p[i];\n        return x;\n    }\n}_;\nint gf(int x){return x==f[x]?x:gf(f[x]);}\nint gd(int x){return x==f[x]?0:d[x]^gd(f[x]);}\nlist<int>s[N<<2];\n#define ls rt<<1\n#define rs rt<<1|1\nvoid upd(int L,int R,int v,int l,int r,int rt){\n    if(L<=l&&r<=R){s[rt].push_back(v);return;}\n    int m=l+r>>1;\n    if(L<=m)upd(L,R,v,l,m,ls);\n    if(R>m)upd(L,R,v,m+1,r,rs);\n}\nvoid swap(int &x,int &y){x^=y,y^=x,x^=y;}\nint X[N<<2],Y[N<<2],tp;\nbool dd[N<<2];\nvoid qry(int l,int r,int rt,XOR c){\n    int otp=tp;\n    for(auto i:s[rt]){\n        int x=e[i].x,y=e[i].y,\n            fx=gf(x),fy=gf(y),\n            w=e[i].w^gd(x)^gd(y);\n        if(fx==fy)c.ins(w);\n        else{\n            if(dep[fx]>dep[fy])swap(x,y),swap(fx,fy);\n            f[fx]=fy,d[fx]=w;\n            X[++tp]=fx,Y[tp]=fy;\n            if(dep[fx]==dep[fy])++dep[fy],dd[tp]=1;\n        }\n    }\n    if(l==r)printf(\"%d\\n\",c.ask(gd(ql[l])^gd(qr[l])));\n    else{\n        int m=l+r>>1;\n        qry(l,m,ls,c),qry(m+1,r,rs,c);\n    }\n    while(tp!=otp)\n        d[f[X[tp]]=X[tp]]=0,dep[Y[tp]]-=dd[tp],--tp;\n}\nint main(){\n    n=rd(),m=rd();\n    int opt,x,y,w,t=m,ti=1;\n    for(int i=1;i<=m;++i)\n        x=rd(),y=rd(),w=rd(),\n        e[i]={x,y,w},bg[i]=1,ed[i]=-1,\n        T[make_pair(x,y)]=i;\n    q=rd();\n    for(int i=1;i<=q;++i){\n        opt=rd(),x=rd(),y=rd();\n        if(opt==1)\n            e[++t]={x,y,rd()},bg[t]=ti,ed[t]=-1,\n            T[make_pair(x,y)]=t;\n        else if(opt==2)ed[T[make_pair(x,y)]]=ti-1;\n        else ql[ti]=x,qr[ti]=y,++ti;\n    }\n    --ti;\n    for(int i=1;i<=t;++i){\n        if(ed[i]==-1)ed[i]=ti;\n        if(bg[i]<=ed[i])upd(bg[i],ed[i],i,1,ti,1);\n    }\n    for(int i=1;i<=n;++i)f[i]=i;\n    qry(1,ti,1,_);\n}\n```\n","link":null,"tags":["离线","线性基","并查集","线段树分治"],"title":"LG CF938G Shortest Path Queries"},{"categories":[["刷题记录"]],"content":"\n同[\\[WC2011\\]最大XOR和路径](https:\/\/www.luogu.com.cn\/problem\/P4151)\n```cpp\n#include<bits\/stdc++.h>\nint rd(){int x=0;char c;bool f=0;for(c=getchar();c<'0'||'9'<c;c=getchar())f^=c=='-';for(x=c-48,c=getchar();'0'<=c&&c<='9';x=x*10+c-48,c=getchar());return f?-x:x;}\nconst int N=100011;\nint n,m,cnt,head[N],d[N],p[30];\nstruct edge{int to,nxt,w;}e[N<<1];\nvoid add(int x,int y,int w){e[++cnt].to=y,e[cnt].nxt=head[x],head[x]=cnt,e[cnt].w=w;}\nvoid ins(int x){\n    for(int i=27;x,~i;--i)if(x>>i){\n        if(!p[i]){p[i]=x;return;}\n        x^=p[i];\n    }\n}\nbool v[N];\nvoid dfs(int x){\n    v[x]=1;\n    for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n        if(!v[to])d[to]=d[x]^e[i].w,dfs(to);\n        else ins(d[x]^d[to]^e[i].w);\n}\nint main(){\n    n=rd(),m=rd();\n    int x,y,w;\n    while(m--)\n        x=rd(),y=rd(),w=rd(),\n        add(x,y,w),add(y,x,w);\n    dfs(1);x=d[n];\n    for(int i=27;~i;--i)\n        if((x^p[i])<x)x^=p[i];\n    printf(\"%d\\n\",x);\n}\n```\n","link":null,"tags":["线性基","图论","dfs"],"title":"LG CF845G Shortest Path Problem"},{"categories":[["刷题记录"]],"content":"\n做这题之前可以看看[\\[WC20$1$\\]最大XOR和路径](https:\/\/www.luogu.com.cn\/problem\/P4151)\n\n可以考虑换个思路:\n\n对于每一对点的每一位,有多少种方案能使该位的$xor$和为$1$\n\n`dfs`求出$1$到各点$x$的任意一条简单路径$xor$和$d_x$,那么求$x$到$y$的简单路径长度就是$d_x ~ xor ~ d_y$\n\n在`dfs`的过程中也可以顺便求出所有环的$xor$和,这些可以用来增广简单路径,我们将这些环的$xor$和插入到线性基中\n\n若线性基中有$cnt$个非零位,则一共会产生$2^{cnt}$个不同的$xor$值\n\n到了这一步,通过枚举两个点来统计路径的复杂度仍然是$O(n^2 \\cdot 60)$的,我们要采用更高效的方法\n\n直接讨论$d_x$对答案的贡献\n\n先统计出第$k$位为$0$的数的个数,我们将其记为$x$,再统计出第$k$位为$1$的数的个数,记为$y$,总共有$point$个点\n\n1. $d_x$的第$k$位为$1$,线性基中有第$k$位为$1$的数: \n   此时我们有两种选择：\n   - 选线性基中的,另一个点选择第$k$位为$0$的。\n   - 不选线性基中的,另一个点选择第$k$位为$1$的。总体对于答案的贡献为：$2^k\\cdot 2^{cnt-1}\\cdot (point-1)$,减$1$就是为了把自己给去掉。\n\n2. $d_i$的第$k$位为$1$,线性基中没有第$k$位为$1$的数: 这个时候另一个点只能取第$k$位为$0$的,, 所以总贡献为: $2^k\\cdot 2^{cnt}\\cdot x$。\n\n3. $d_i$的第$k$位为$0$,线性基中有第$k$位为$1$的数: 一样的,, 两种选择:\n   - 选线性基中的,另一个点选择第$k$位为$0$的。 \n   - 不选线性基中的,另一个点选择第$k$位为$1$的。总贡献为: $2^k\\cdot2^{cnt-1}\\cdot(point-1)$。\n\n3. $d_i$的第$k$位为$0$,线性基中没有第$k$位为$1$的数: 另一个点只能取第$k$位为$1$的,总贡献: $2^k\\cdot 2^{cnt}\\cdot y$。\n\n```cpp\n\n#include<bits\/stdc++.h>\ntypedef long long ll;\nconst int N=100001;\nconst ll P=1000000007,inv=500000004;\nstruct edge{int to,nxt;ll w;}e[N<<2];\nint n,m,cnt=1,head[N],tt;\nll pw[61],p[61],a[N],d[N];\nbool v[N],u[N<<2];\nvoid add(int x,int y,ll w){e[++cnt].to=y,e[cnt].nxt=head[x],head[x]=cnt,e[cnt].w=w;}\nvoid ins(ll x){\n    for(int i=60;x,~i;--i)if(x>>i){\n        if(!p[i]){p[i]=x;return;}\n        x^=p[i];\n    }\n}\nvoid dfs(int x){\n    a[++tt]=d[x],v[x]=1;\n    for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n        if(!v[to])d[to]=d[x]^e[i].w,dfs(to);\n        else if(!u[i^1])ins(d[x]^d[to]^e[i].w),u[i^1]=1;\n}\nll calc(){\n    ll ans=0;int x,y,tot=0;bool ff;\n    for(int i=0;i<=60;++i)tot+=p[i]>0;\n    for(int j=0;j<=60;++j){\n        x=y=ff=0;\n        for(int i=1;i<=tt;++i)\n            (a[i]>>j&1)?++x:++y;\n        for(int i=0;i<=60;++i)\n            if(p[i]>>j&1){ff=1;break;}\n        for(int i=1;i<=tt;++i,ans%=P)\n            if(a[i]>>j&1)\n                if(ff)ans+=pw[tot-1]*(tt-1)%P*pw[j]%P;\n                else ans+=pw[tot]*y%P*pw[j]%P;\n            else\n                if(ff)ans+=pw[tot-1]*(tt-1)%P*pw[j]%P;\n                else ans+=pw[tot]*x%P*pw[j]%P;\n    }\n    return ans;\n}\nint main(){\n    scanf(\"%d%d\",&n,&m);\n    int x,y;ll w,ans=0;\n    while(m--)\n        scanf(\"%d%d%lld\",&x,&y,&w),\n        add(x,y,w),add(y,x,w);\n    pw[0]=1;\n    for(int i=1;i<=60;++i)pw[i]=(pw[i-1]<<1)%P;\n    for(int i=1;i<=n;++i)if(!v[i]){\n        memset(p,0,sizeof p);\n        tt=0,dfs(i);\n        (ans+=calc())%=P;\n    }\n    ans=ans*inv%P;\n    printf(\"%lld\\n\",ans);\n}\n```","link":null,"tags":["线性基","思维","图论"],"title":"LG CF724G Xor-matic Number of the Graph"},{"categories":[["刷题记录"]],"content":"\n线性基中每个元素的异或方案唯一,也就是说,线性基中不同的异或组合异或出的数都是不一样的。\n\n那么我们把字符串转成二进制,然后插入线性基\n\n线性基内的元素都是由外界元素异或出来的,那么对于线性基内每个元素,我们都有选\/不选两种情况,\n\n假设线性基内有$cnt$个元素,答案就是$2^{cnt}$\n```cpp\n#include<cstdio>\ntypedef long long ll;\nint n,m,ans;\nll p[51];\nchar s[50];\nvoid ins(ll x){\n    for(int i=n;x,~i;--i)if(x>>i){\n        if(!p[i]){\n            p[i]=x,++ans;\n            return;\n        }\n        x^=p[i];\n    }\n}\nint main(){\n    scanf(\"%d%d\",&n,&m);\n    for(int i=1;i<=m;++i){\n        scanf(\"%s\",s);\n        ll x=0;\n        for(int j=0;j<n;++j)\n            if(s[j]=='O')x+=1<<n-j;\n        ins(x);\n    }\n    printf(\"%d\\n\",(1ll<<ans)%2008);\n}\n```\n","link":null,"tags":["线性基"],"title":"LG 3857 [TJOI2008]彩灯"},{"categories":[["刷题记录"]],"content":"\n线性基搬到了树上\n\n线性基是支持合并的\n\n这题就是倍增暴力合并线性基\n\n虽然$O(\\log^3_2n)$的复杂度已经可以通过了,但是还有更优的方法\n\n在倍增找出询问两点的lca,然后以rmq的方式合并+查询线性基,可以将复杂度降到$O(\\log^2_2n)$\n\n\n```cpp\n#include<bits\/stdc++.h>\n#define fur(i,x,y) for(int i=x;i<=y;++i)\nconst int N=20011;\ntypedef long long ll;\nint head[N],cnt,n,q,f[21][N],dep[N],l2[N];\nll a[N],d[21][N][61],ans[61];\nstruct edge{int to,nxt;}e[N<<1];\nvoid add(int x,int y){e[++cnt].to=y,e[cnt].nxt=head[x],head[x]=cnt;}\nbool v[N];\nvoid ins(ll *p,ll x){\n    for(int i=60;x,~i;--i)if((x>>i)&1){\n        if(!p[i]){p[i]=x;return;}\n        x^=p[i];\n    }\n}\nvoid mg(ll *a,ll *b){\n    for(int i=60;~i;--i)\n        if(a[i])ins(b,a[i]);\n}\nvoid dfs(int x){\n    dep[x]=dep[f[0][x]]+1,ins(d[0][x],a[x]);\n    fur(i,1,l2[dep[x]])\n        f[i][x]=f[i-1][f[i-1][x]],\n        mg(d[i-1][x],d[i][x]),\n        mg(d[i-1][f[i-1][x]],d[i][x]);\n    for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n        if(to!=f[0][x])f[0][to]=x,dfs(to);\n}\nint lca(int x,int y){\n    if(dep[x]<dep[y])x^=y,y^=x,x^=y;\n    while(dep[x]>dep[y])\n        x=f[l2[dep[x]-dep[y]]][x];\n    if(x==y)return y;\n    for(int i=l2[dep[x]];~i;--i)\n        if(f[i][x]^f[i][y])\n            x=f[i][x],y=f[i][y];\n    return f[0][x];\n}\nint kth(int x,int k){\n    for(int i=15;~i;--i)\n        if((k>>i)&1)x=f[i][x];\n    return x;\n}\nll ask(int x,int y){\n    memset(ans,0,sizeof ans);\n    int z=lca(x,y),k=l2[dep[x]-dep[z]];\n    mg(d[0][z],ans),\n    mg(d[k][x],ans),\n    mg(d[k][kth(x,dep[x]-dep[z]-(1<<k))],ans);\n    k=l2[dep[y]-dep[z]];\n    mg(d[k][y],ans),\n    mg(d[k][kth(y,dep[y]-dep[z]-(1<<k))],ans);\n    ll res=0;\n    for(int i=60;~i;--i)\n        if((res^ans[i])>res)res^=ans[i];\n    return res;\n}\nint main(){\n    scanf(\"%d%d\",&n,&q);\n    fur(i,1,n)scanf(\"%lld\",a+i);\n    int x,y;\n    fur(i,2,n)\n        l2[i]=l2[i>>1]+1,\n        scanf(\"%d%d\",&x,&y),\n        add(x,y),add(y,x);\n    dfs(1);\n    while(q--)\n        scanf(\"%d%d\",&x,&y),\n        printf(\"%lld\\n\",ask(x,y));\n}\n```\n","link":null,"tags":["线性基","倍增","lca"],"title":"LG 3292 [SCOI2016]幸运数字"},{"categories":[["刷题记录"]],"content":"\n(以下长度定义为边权异或和)\n\n首先钦定一条1到n的路径\n\n容易发现可以通过环来增广路径\n\n路径到环中间的路程要走两次,相当于没有\n\n那么把所有环的长度插入线性基,\n\n直接随意找一条1到n的路径,然后求这条路径长度在线性基上最大能异或成多少即可\n\n假设1到n有一条更好的路径,那么会和刚才钦定的路径形成一个环,相当于异或时已经考虑过了\n\n```cpp\n#include<bits\/stdc++.h>\nconst int N=100001,inf=2122219134;\ntypedef long long ll;\nint n,m,cnt,head[N];\nstruct edge{int to,nxt;ll w;}e[N<<1];\nvoid add(int x,int y,ll w){e[++cnt].to=y,e[cnt].nxt=head[x],head[x]=cnt;e[cnt].w=w;}\nll p[61],d[N],ans;\nvoid ins(ll x){\n    for(int i=60;~i;--i)if(x>>i){\n        if(!p[i]){p[i]=x;return;}\n        x^=p[i];\n    }\n}\nll ask(ll ans){\n    for(int i=60;~i;--i)\n        if((ans^p[i])>ans)ans^=p[i];\n    return ans;\n}\nbool v[N];\nvoid dfs(int x,ll res){\n    d[x]=res,v[x]=1;\n    for(int i=head[x];i;i=e[i].nxt)\n        if(v[e[i].to])ins(res^e[i].w^d[e[i].to]);\n        else dfs(e[i].to,res^e[i].w);\n}\nint main(){\n    scanf(\"%d%d\",&n,&m);\n    int x,y;ll w;\n    while(m--)\n        scanf(\"%d%d%lld\",&x,&y,&w),\n        add(x,y,w),add(y,x,w);\n    dfs(1,0);\n    ans=d[n];\n    for(int i=60;~i;--i)\n        if((ans^p[i])>ans)ans^=p[i];\n    printf(\"%lld\\n\",ans);\n}\n```\n","link":null,"tags":["线性基","图论","dfs","贪心"],"title":"LG 4151 [WC2011]最大XOR和路径"},{"categories":[["刷题记录"]],"content":"\n先按魔法值排序,然后按顺序插入,如果不能被当前集合异或出来,那么插入并加上其贡献\n```cpp\n#include<bits\/stdc++.h>\ntypedef long long ll;\nconst int N=1001;\nint n,ans=0;\nll p[61];\nstruct node{\n    int v;ll x;\n    bool operator<(node t){return v>t.v;}\n}a[N];\nvoid ins(ll x,int v){\n    for(int i=60;~i;--i)if(x>>i){\n        if(!p[i]){\n            p[i]=x,ans+=v;\n            return;\n        }\n        x^=p[i];\n    }\n}\nint main(){\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;++i)\n        scanf(\"%lld%d\",&a[i].x,&a[i].v);\n    std::sort(a+1,a+n+1);\n    for(int i=1;i<=n;++i)ins(a[i].x,a[i].v);\n    printf(\"%d\\n\",ans);\n}\n```\n","link":null,"tags":["线性基","二进制","贪心"],"title":"LG 4570 [BJWC2011]元素"},{"categories":[["算法"],["note"]],"content":"\n\n","link":null,"tags":["位运算","二进制"],"title":"线性基"},{"categories":[["刷题记录"]],"content":"\n矩阵乘法\n\n这题倍增加速比快速幂快,可以节省很多多余的计算\n\n二进制拆位后才能矩阵运算\n```cpp\n#include<bits\/stdc++.h>\n#define fur(i,x,y) for(int i=x;i<=y;++i)\ntypedef unsigned int ll;\nll rd(){ll x=0;char c;for(c=getchar();c<'0'||'9'<c;c=getchar());for(x=c-48,c=getchar();'0'<=c&&c<='9';x=x*10+c-48,c=getchar());return x;}\nchar cr[50];int tt;\nvoid print(ll x){\n    if(!x)putchar('0');\n    while(x)cr[++tt]=x%10+'0',x\/=10;\n    while(tt)putchar(cr[tt--]);\n    putchar('\\n');\n}\nint n,m,q;ll f[101],g[101],t[101];\nstruct mat{bool a[101][101];}bs[32];\nmat operator*(mat a,mat b){\n    mat c;\n    fur(i,1,n)fur(j,1,n){\n        c.a[i][j]=0;\n        fur(k,1,n)c.a[i][j]^=a.a[i][k]&b.a[k][j];\n    }\n    return c;\n}\nvoid mul(mat x){\n    memset(t,0,n*4+4);\n    fur(i,1,n)fur(j,1,n)\n        if(x.a[i][j])t[i]^=g[j];\n    fur(i,1,n)g[i]=t[i];\n}\nll solve(ll v){\n    fur(i,1,n)g[i]=f[i];\n    fur(i,0,31)if((v>>i)&1)mul(bs[i]);\n    return g[1];\n}\nint main(){\n    n=rd(),m=rd(),q=rd();\n    int x,y;;\n    fur(i,1,n)f[i]=rd();\n    fur(i,1,m)\n        x=rd(),y=rd(),\n        bs[0].a[x][y]=bs[0].a[y][x]=1;\n    fur(i,1,31)bs[i]=bs[i-1]*bs[i-1];\n    while(q--)print(solve(rd()));\n}\n```\n","link":null,"tags":["矩阵","倍增","二进制"],"title":"LG 6569 [NOI Online 3 提高组]魔法值"},{"categories":[["刷题记录"]],"content":"\n40%的$log n$做法挺容易的,就是一直往右儿子走,走到叶子就往左走,一直重复即可\n\n100%的做法：\n\n首先可以把$f(l)\\bigoplus\\dots\\bigoplus f(r)$变成\n\n$[f(1)\\bigoplus f(2)\\bigoplus\\dots\\bigoplus f(r)]\\bigoplus[f(1)\\bigoplus f(2)\\bigoplus\\dots\\bigoplus f(l-1)]$\n\n显然$f(2^k)=f(2^k+1)=2^{k+1}-1$\n\n接着可以发现$\\forall k,1\\le t\\le 2^k-1,f(2^k+2t)=f(2^k+2t+1)$\n\n因为最下一层没有填满整一层,只填满了根节点的左子树,根节点的右子树并没有发生变化\n\n剩下的$f(n)$就需要考虑一下了\n\n首先算出树的深度(根节点深度为0)\n\n左边: 即使没占满也全算\n\n右边: $f(n\/2)$\n```cpp\n#include<bits\/stdc++.h>\ntypedef long long ll;\nbool chk(ll n){return !(n&(n-1));}\nll f(ll n,int d){\n    if(chk(n)||chk(n-1))return (n<<1)-1;\n    return f(n>>1,d-1)+(1ll<<d);\n}\nll f(ll n){return f(n,log2(n-1)+1);}\n#include<bits\/extc++.h>\nll g(ll n){\n    if(!n)return 0;\n    ll res=0;\n    __gnu_pbds::gp_hash_table<ll,bool>b;\n    for(ll i=1;i<=n;i<<=1){\n        if(!b[i])b[i]=1,res^=f(i);\n        if(i<n&&!b[i+1])b[i+1]=1,res^=f(i+1);\n    }\n    if(n&1^1&&!b[n])res^=f(n);\n    return res;\n}\nint main(){\n    ll l,r;\n    scanf(\"%lld%lld\",&l,&r);\n    printf(\"%lld\\n\",g(r)^g(l-1));\n}\n```\n","link":null,"tags":[],"title":"LG 6025 线段树"},{"categories":[["刷题记录"]],"content":"\n可以考虑把字符串倒序\n\n这样添加一个字母相当于增加了一个后缀,相对原来更好处理\n\n可以发现在插入新的字符串时,height改变的只有`height[pre],height[p],height[nxt]`\n\n通过平衡树动态维护这三个位置就可以了\n\n```cpp\n#include<bits\/stdc++.h>\n#define gc getchar()\n#define fur(i,x,y) for(int i=x;i<=y;++i)\nvoid cmax(int &x,int y){if(x<y)x=y;}\nint rd(){int x=0;char c;bool f=0;for(c=gc;c<'0'||'9'<c;c=gc)f^=c=='-';for(x=c-48,c=gc;'0'<=c&&c<='9';x=x*10+c-48,c=gc);return f?-x:x;}\nconst int N=100011;\nusing std::set;\nint n,m,s[N],sa[N],rnk[N],tax[N],tp[N],height[N],f[20][N];\nvoid qsort(){\n    fur(i,0,m)tax[i]=0;\n    fur(i,1,n)++tax[rnk[i]];\n    fur(i,1,m)tax[i]+=tax[i-1];\n    for(int i=n;i;--i)sa[tax[rnk[tp[i]]]--]=tp[i];\n}\nvoid suffix(){\n    m=100000;\n    fur(i,1,n)tp[i]=i,rnk[i]=s[i];\n    qsort();\n    for(int w=1,p=0;p<n;m=p,w<<=1){\n        p=0;\n        fur(i,1,w)tp[++p]=n-w+i;\n        fur(i,1,n)if(sa[i]>w)tp[++p]=sa[i]-w;\n        qsort();\n        std::swap(tp,rnk);\n        rnk[sa[1]]=p=1;\n        fur(i,2,n)rnk[sa[i]]=p+=tp[sa[i]]^tp[sa[i-1]]||tp[sa[i]+w]^tp[sa[i-1]+w];\n    }\n}\nvoid gh(){\n    for(int i=1,k=0;i<=n;++i){\n        if(k)--k;\n        int j=sa[rnk[i]-1];\n        while(s[i+k]==s[j+k]&&i+k<=n&&j+k<=n)++k;\n        height[rnk[i]]=k;\n    }\n}\nint min(int x,int y){return x<y?x:y;}\nvoid st(){\n    fur(i,1,n)f[0][i]=height[i];\n    fur(k,1,20)\n        fur(i,1,n-(1<<k)+1)\n            f[k][i]=min(f[k-1][i],f[k-1][i+(1<<k-1)]);\n}\nint ask(int l,int r){\n    if(l==r)return -1u>>1;\n    ++l;\n    int k=log2(r-l+1);\n    return min(f[k][l],f[k][r-(1<<k)+1]);\n}\nstruct qwq{int v,p;bool operator<(qwq t){return v<t.v;}}b[N];\nset<int>T;\nint main(){\n    n=rd();\n    fur(i,1,n)b[i]={rd(),i};\n    std::sort(b+1,b+n+1);\n    int p=0;long long ans=0;\n    fur(i,1,n)s[n-b[i].p+1]=p+=b[i].v!=b[i-1].v;\n    suffix(),gh(),st();\n    for(int i=n;i;--i){\n        T.insert(rnk[i]);\n        set<int>::iterator it=T.find(rnk[i]);\n        int k=0;\n        if(it!=T.begin()){\n            p=*(--it);\n            k=ask(p,rnk[i]);\n            ++it;\n        }\n        ++it;\n        if(it!=T.end()){\n            p=*it;\n            cmax(k,ask(rnk[i],p));\n        }\n        ans+=n-i+1-k;\n        printf(\"%lld\\n\",ans);\n    }\n}\n```\n","link":null,"tags":["后缀数组","平衡树"],"title":"LG 4070 [SDOI2016]生成魔咒"},{"categories":[["刷题记录"]],"content":"\n\nSPOJ的GSS系列是关于区间统计技巧的集合\n\n~~非常适合锻炼码力~~\n\n[LG GSS1](https:\/\/www.luogu.com.cn\/problem\/SP1043) | [SPOJ GSS1](https:\/\/www.SPOJ.com\/problems\/GSS1)\n\n[LG GSS2](https:\/\/www.luogu.com.cn\/problem\/SP1557) | [SPOJ GSS2](https:\/\/www.SPOJ.com\/problems\/GSS2)\n\n[LG GSS3](https:\/\/www.luogu.com.cn\/problem\/SP1716) | [SPOJ GSS3](https:\/\/www.SPOJ.com\/problems\/GSS3)\n\n[LG GSS4](https:\/\/www.luogu.com.cn\/problem\/SP2713) | [SPOJ GSS4](https:\/\/www.SPOJ.com\/problems\/GSS4)\n\n[LG GSS5](https:\/\/www.luogu.com.cn\/problem\/SP2916) | [SPOJ GSS5](https:\/\/www.SPOJ.com\/problems\/GSS5)\n\n[LG GSS6](https:\/\/www.luogu.com.cn\/problem\/SP4487) | [SPOJ GSS6](https:\/\/www.SPOJ.com\/problems\/GSS6)\n\n[LG GSS7](https:\/\/www.luogu.com.cn\/problem\/SP6779) | [SPOJ GSS7](https:\/\/www.SPOJ.com\/problems\/GSS7)\n\n[LG GSS8](https:\/\/www.luogu.com.cn\/problem\/SP19543) | [SPOJ GSS8](https:\/\/www.SPOJ.com\/problems\/GSS8)\n\nGSS1,GSS3: 最大子段和:\n\n每个节点记录区间和,最大后缀和,最大前缀和,答案\n\n```cpp\nnode operator+(node x,node y){\n    node c;\n    c.s=x.s+y.s;\/\/ 和\n    c.mx=max(max(x.mx,y.mx),x.r+y.l); \/\/答案\n    c.l=max(x.l,x.s+y.l);\/\/最大前缀\n    c.r=max(y.r,y.s+x.r);\/\/最大后缀\n    return c;\n}\n```\n\n## GSS3 & GSS 1\n\n> 静态区间最大子段和,单点修改\n\n线段树\n\n```cpp\n#include<bits\/stdc++.h>\nint max(int x,int y){return x>y?x:y;}\nint rd(){int x=0;char c;bool f=0;for(c=getchar();c<'0'||'9'<c;c=getchar())f^=c=='-';for(x=c-48,c=getchar();'0'<=c&&c<='9';x=x*10+c-48,c=getchar());return f?-x:x;}\nconst int N=50011;\n#define ls rt<<1\n#define rs rt<<1|1\nint n,q;\nstruct node{int s,l,r,mx;}s[N<<2];\nnode operator+(node x,node y){\n    node c;\n    c.s=x.s+y.s;\n    c.mx=max(max(x.mx,y.mx),x.r+y.l);\n    c.l=max(x.l,x.s+y.l);\n    c.r=max(y.r,y.s+x.r);\n    return c;\n}\nvoid build(int l,int r,int rt){\n    if(l==r){s[rt].s=s[rt].mx=s[rt].l=s[rt].r=rd();return;}\n    int m=l+r>>1;\n    build(l,m,ls),build(m+1,r,rs);\n    s[rt]=s[ls]+s[rs];\n}\nvoid upd(int p,int v,int l,int r,int rt){\n    if(l==r){s[rt]={v,v,v,v};return;}\n    int m=l+r>>1;\n    if(p<=m)upd(p,v,l,m,ls);\n    else upd(p,v,m+1,r,rs);\n    s[rt]=s[ls]+s[rs];\n}\nnode ask(int L,int R,int l,int r,int rt){\n    if(L==l&&r==R)return s[rt];\n    int m=l+r>>1;\n    if(L>m)return ask(L,R,m+1,r,rs);\n    else if(R<=m)return ask(L,R,l,m,ls);\n    else return ask(L,m,l,m,ls)+ask(m+1,R,m+1,r,rs);\n}\nint main(){\n    n=rd();\n    build(1,n,1);\n    q=rd();\n    while(q--){\n        int opt=rd(),x=rd(),y=rd();\n        if(opt)printf(\"%d\\n\",ask(x,y,1,n,1).mx);\n        else upd(x,y,1,n,1);\n    }\n}\n```\n\n## GSS5\n\n> 给定一个序列。查询左端点在$[x_1, y_1]$之间,且右端点在$[x_2, y_2]$之间的最大子段和,数据保证$x_1\\leq x_2,y_1\\leq y_2$​ ,但是不保证端点所在的区间不重合\n\n分类讨论\n\n1. 不重合:\n   \n   $[y_1,x_2]$的和+$[x_1,y_1-1]$的最大后缀和+$[x_2+1,y_2]$的最大前缀和\n\n2. 重合:\n   \n   - $[x_2,y_1]$的最大子段和\n   - $[x_2,y_1]$的和+$[x_1,x_2-1]$的最大后缀和+$[y_1+1,x_2]$的最大前缀和\n   - $[x_1,x_2-1]$最大后缀和+$[x_2,y_1]$最大前缀和\n   - $[x_2,y_1]$最大后缀和+$[y_1+1,y_2]$最大前缀和\n\n```cpp\n#include<bits\/stdc++.h>\nint max(int x,int y){return x>y?x:y;}\nint rd(){int x=0;char c;bool f=0;for(c=getchar();c<'0'||'9'<c;c=getchar())f^=c=='-';for(x=c-48,c=getchar();'0'<=c&&c<='9';x=x*10+c-48,c=getchar());return f?-x:x;}\nconst int N=10011;\nint n,q;\n#define ls rt<<1\n#define rs rt<<1|1\nstruct node{int s,l,r,mx;}s[N<<2];\nnode operator+(node x,node y){\n    node c;\n    c.s=x.s+y.s;\n    c.mx=max(max(x.mx,y.mx),x.r+y.l);\n    c.l=max(x.l,x.s+y.l);\n    c.r=max(y.r,y.s+x.r);\n    return c;\n}\nvoid build(int l,int r,int rt){\n    if(l==r){s[rt].s=s[rt].mx=s[rt].l=s[rt].r=rd();return;}\n    int m=l+r>>1;\n    build(l,m,ls),build(m+1,r,rs);\n    s[rt]=s[ls]+s[rs];\n}\nnode ask(int L,int R,int l=1,int r=n,int rt=1){\n    if(L>R)return s[0];\n    if(L==l&&r==R)return s[rt];\n    int m=l+r>>1;\n    if(L>m)return ask(L,R,m+1,r,rs);\n    else if(R<=m)return ask(L,R,l,m,ls);\n    else return ask(L,m,l,m,ls)+ask(m+1,R,m+1,r,rs);\n}\nvoid solve(){\n    n=rd();\n    build(1,n,1);\n    q=rd();\n    while(q--){\n        int x=rd(),y=rd(),X=rd(),Y=rd();\n        if(y<X)printf(\"%d\\n\",max(ask(x,y-1).r,0)+ask(y,X).s+max(ask(X+1,Y).l,0));\n        else{\n            node a=ask(x,X-1),b=ask(X,y),c=ask(y+1,Y);\n            printf(\"%d\\n\",max(max(b.mx,max(a.r,0)+b.s+max(c.l,0)),max(a.r+b.l,b.r+c.l)));\n        }\n    }\n}\nint main(){\n    int T=rd();\n    while(T--)solve();\n}\n```\n\n## GSS6\n\n> 给出一个由$N$个整数组成的序列$A$,你需要应用$M$> 个操作：\n> \n> - `I p x` 在$~p~$处插入插入一个元素$~x~$\n> - `D p` 删除$~p~$处的一个元素\n> - `R p x` 修改$~p~$处元素的值为$~x~$\n> - `Q l r` 查询一个区间$[l,r]$的最大子段和\n\n最大子段和搬到了平衡树上\n\n```cpp\n#include<bits\/stdc++.h>\nint max(int x,int y){return x>y?x:y;}\nint rd(){int x=0;char c;bool f=0;for(c=getchar();c<'0'||'9'<c;c=getchar())f^=c=='-';for(x=c-48,c=getchar();'0'<=c&&c<='9';x=x*10+c-48,c=getchar());return f?-x:x;}\nconst int N=200001;\nstruct node{\n    int s,l,r,mx;\n    node(){s=l=r=mx=0;}\n    node(int v){s=l=r=mx=v;}\n}s[N<<1];\nnode operator+(node x,node y){\n    node c;\n    c.s=x.s+y.s;\n    c.mx=max(max(x.mx,y.mx),x.r+y.l);\n    c.l=max(x.l,x.s+y.l);\n    c.r=max(y.r,y.s+x.r);\n    return c;\n}\nint RT,cnt,sz[N],v[N],rnd[N],c[2][N];\n#define ls c[0][x]\n#define rs c[1][x]\nint ne(int val){\n    s[++cnt]=node(val),rnd[cnt]=rand(),v[cnt]=val,sz[cnt]=1;\n    return cnt;\n}\nvoid pu(int x){\n    sz[x]=sz[ls]+1+sz[rs];\n    s[x]=node(v[x]);\n    if(ls)s[x]=s[ls]+s[x];\n    if(rs)s[x]=s[x]+s[rs];\n}\nvoid sl(int x,int k,int &a,int &b){\n    if(!x){a=b=0;return;}\n    if(sz[ls]>=k)b=x,sl(ls,k,a,ls);\n    else a=x,sl(rs,k-sz[ls]-1,rs,b);\n    pu(x);\n}\nint mg(int x,int y){\n    if(!x||!y)return x|y;\n    if(rnd[x]<rnd[y]){\n        c[1][x]=mg(c[1][x],y);\n        pu(x);return x;\n    }\n    else{\n        c[0][y]=mg(x,c[0][y]);\n        pu(y);return y;\n    }\n}\nint main(){\n    srand(time(0));\n    for(int n=rd();n--;)RT=mg(RT,ne(rd()));\n    char opt;\n    for(int q=rd(),x,y,z,l,r;q--;){\n        while(isspace(opt=getchar()));\n        if(opt=='I')\n            sl(RT,rd()-1,x,z),\n            RT=mg(x,mg(ne(rd()),z));\n        else if(opt=='D')\n            sl(RT,rd()-1,x,z),sl(z,1,y,z),\n            RT=mg(x,z);\n        else if(opt=='R')\n            sl(RT,rd()-1,x,z),sl(z,1,y,z),\n            s[y]=node(v[y]=rd()),\n            RT=mg(x,mg(y,z));\n        else if(opt=='Q')\n            l=rd(),r=rd(),\n            sl(RT,r,x,z),sl(x,l-1,x,y),\n            printf(\"%d\\n\",s[y].mx),\n            RT=mg(x,mg(y,z));\n    }\n}\n```\n\n## GSS7\n\n> 给定一棵树,有$N(N \\le 100000)$个节点,每一个节点都有一个权值$x_i (|x_i| \\le 10000)$\n> \n> 你需要执行$Q (Q \\le 100000)$次操作：\n> \n> 1. `1 a b` 查询`(a,b)`这条链上的最大子段和,**可以为空**（即输出$0$）\n> 2. `2 a b c` 将`(a,b)`这条链上的所有点权变为`c` $(|c| \\le 10000)$\n\n最大子段和搬到了树上,树链剖分\n\n树剖查询时注意合并顺序和反转左边\n\n```cpp\n#include<bits\/stdc++.h>\nvoid swap(int&x,int&y){x^=y,y^=x,x^=y;}\nint max(int x,int y){return x>y?x:y;}\nvoid rd(int&x){x=0;char c;bool f=0;for(c=getchar();c<'0'||'9'<c;c=getchar())f^=c=='-';for(x=c-48,c=getchar();'0'<=c&&c<='9';x=x*10+c-48,c=getchar());if(f)x=-x;}\nconst int N=100001;\nint n,cnt,head[N],a[N],c[N];\nstruct edge{int to,nxt;}e[N<<1];\nvoid add(int x,int y){e[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;}\nint d[N],f[N],siz[N],top[N],id[N],sz;\nvoid dfs(int x){\n    siz[x]=1;\n    for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n        if(to!=f[x])\n            f[to]=x,d[to]=d[x]+1,\n            dfs(to),siz[x]+=siz[to];\n}\nvoid bt(int x,int tp){\n    top[x]=tp;c[id[x]=++sz]=a[x];\n    int k=0;\n    for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n        if(to!=f[x]&&siz[to]>siz[k])k=to;\n    if(k)bt(k,tp);\n    for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n        if(!top[to])bt(to,to);\n}\nstruct node{\n    int s,l,r,mx;\n    node(){s=l=r=mx=0;}\n    node(int v){s=v,l=r=mx=max(v,0);}\n    void rev(){swap(l,r);}\n}s[N<<2];\nnode operator+(node x,node y){\n    node c;\n    c.s=x.s+y.s;\n    c.mx=max(max(x.mx,y.mx),x.r+y.l);\n    c.l=max(x.l,x.s+y.l);\n    c.r=max(y.r,y.s+x.r);\n    return c;\n}\nint laz[N<<2];bool tag[N<<2];\n#define ls rt<<1\n#define rs rt<<1|1\nvoid build(int l,int r,int rt){\n    if(l==r){s[rt]=node(c[l]);return;}\n    int m=l+r>>1;\n    build(l,m,ls),build(m+1,r,rs);\n    s[rt]=s[ls]+s[rs];\n}\nvoid pd(int rt,int ln,int rn){\n    if(tag[rt]){\n        laz[ls]=laz[rs]=laz[rt];\n        tag[ls]=tag[rs]=1;\n        s[ls]=node(laz[rt]*ln);\n        s[rs]=node(laz[rt]*rn);\n        tag[rt]=0;\n    }\n}\nvoid mdy(int L,int R,int v,int l,int r,int rt){\n    if(L<=l&&r<=R){\n        s[rt]=node(v*(r-l+1));\n        laz[rt]=v;tag[rt]=1;\n        return;\n    }\n    int m=l+r>>1;\n    pd(rt,m-l+1,r-m);\n    if(L<=m)mdy(L,R,v,l,m,ls);\n    if(R>m)mdy(L,R,v,m+1,r,rs);\n    s[rt]=s[ls]+s[rs];\n}\nnode qry(int L,int R,int l,int r,int rt){\n    if(L==l&&r==R)return s[rt];\n    int m=l+r>>1;\n    pd(rt,m-l+1,r-m);\n    if(L>m)return qry(L,R,m+1,r,rs);\n    else if(R<=m)return qry(L,R,l,m,ls);\n    else return qry(L,m,l,m,ls)+qry(m+1,R,m+1,r,rs);\n}\nint ask(int x,int y){\n    node l,r;\n    while(top[x]^top[y])\n        if(d[top[x]]>d[top[y]])\n            l=qry(id[top[x]],id[x],1,n,1)+l,x=f[top[x]];\n        else \n            r=qry(id[top[y]],id[y],1,n,1)+r,y=f[top[y]];\n    if(d[x]>d[y])\n        l=qry(id[y],id[x],1,n,1)+l;\n    else \n        r=qry(id[x],id[y],1,n,1)+r;\n    l.rev();\n    return (l+r).mx;\n}\nvoid upd(int x,int y,int v){\n    while(top[x]^top[y]){\n        if(d[top[x]]<d[top[y]])swap(x,y);\n        mdy(id[top[x]],id[x],v,1,n,1),x=f[top[x]];\n    }\n    if(d[x]>d[y])swap(x,y);\n    mdy(id[x],id[y],v,1,n,1);\n}\nint main(){\n    rd(n);\n    for(int i=1;i<=n;++i)rd(a[i]);\n    int q,opt,x,y,v;\n    for(int i=1;i<n;++i)\n        rd(x),rd(y),\n        add(x,y),add(y,x);\n    dfs(1),bt(1,1),build(1,n,1);\n    for(rd(q);q--;){\n        rd(opt),rd(x),rd(y);\n        if(opt==1)printf(\"%d\\n\",ask(x,y));\n        else rd(v),upd(x,y,v);\n    }\n}\n```\n\n## GSS2\n\n> 静态区间最大子段和,**相同的数只算一次**\n\n难度激增\n\n参考[\\[SDOI2009\\]HH的项链](https:\/\/www.luogu.com.cn\/problem\/P1972)的做法\n\nGSS1的合并最大前缀和,最大子段和,最大后缀和的方法以不再适用\n\n对每个位置$i$求出上一次出现相同数的位置$pre_i$\n\n还是按照右端点排序,按顺序添加元素,添加$a_i$时,更新$[pre_i-1,i]$\n\n线段树每个节点维护4个值,$sum,hismax,sumtag,hismaxtag$。\n\n对于叶子节点:\n\n$sum$表示从这个叶结点所对应的原序列的所有元素和\n\n$hismax$表示$sum$的历史最大值（最小为0）\n\n对于非叶子节点:\n\n$sum$表示左右儿子的$sum$的最大值,\n\n$hismax$表示左右儿子的$hismax$的最大值。\n\n查询区间的$hismax$即可\n\n特别注意`pushdown()`函数的更新顺序\n\n```cpp\n#include<bits\/stdc++.h>\ntypedef long long ll;\ntemplate<class T>\nvoid rd(T&x){char c;bool f=0;for(c=getchar();c<'0'||'9'<c;c=getchar())f^=c=='-';for(x=c-48,c=getchar();'0'<=c&&c<='9';x=x*10+c-48,c=getchar());if(f)x=-x;}\nll max(ll x,ll y){return x>y?x:y;}\nvoid cmax(ll&x,ll y){if(x<y)x=y;}\nconst int N=100001;\nint n,m,b[N<<1],pre[N];\nll a[N],ans[N];\nstruct node{ll s,hs,laz,hlaz;}s[N<<2];\nnode operator+(node a,node b){return {max(a.s,b.s),max(a.hs,b.hs),0,0};}\n#define ls rt<<1\n#define rs rt<<1|1\nvoid pd(int rt){\n    cmax(s[ls].hs,s[ls].s+s[rt].hlaz);\n    cmax(s[rs].hs,s[rs].s+s[rt].hlaz);\n    s[ls].s+=s[rt].laz;\n    s[rs].s+=s[rt].laz;\n    cmax(s[ls].hlaz,s[ls].laz+s[rt].hlaz);\n    cmax(s[rs].hlaz,s[rs].laz+s[rt].hlaz);\n    s[ls].laz+=s[rt].laz;\n    s[rs].laz+=s[rt].laz;\n    s[rt].laz=s[rt].hlaz=0;\n}\nvoid upd(int L,int R,ll v,int l,int r,int rt){\n    if(L<=l&&r<=R){\n        cmax(s[rt].hs,s[rt].s+=v);\n        cmax(s[rt].hlaz,s[rt].laz+=v);\n        return;\n    }\n    int m=l+r>>1;pd(rt);\n    if(L<=m)upd(L,R,v,l,m,ls);\n    if(R>m)upd(L,R,v,m+1,r,rs);\n    s[rt]=s[ls]+s[rs];\n}\nnode ask(int L,int R,int l,int r,int rt){\n    if(L<=l&&r<=R)return s[rt];\n    int m=l+r>>1;pd(rt);\n    if(L>m)return ask(L,R,m+1,r,rs);\n    else if(R<=m)return ask(L,R,l,m,ls);\n    else return ask(L,R,l,m,ls)+ask(L,R,m+1,r,rs);\n}\nstruct que{\n    int l,r,id;\n    bool operator<(que t){return r<t.r;}\n}q[N];\nint main(){\n    rd(n);\n    for(int i=1;i<=n;++i)\n        rd(a[i]),\n        pre[i]=b[a[i]+100000],\n        b[a[i]+100000]=i;\n    rd(m);\n    for(int i=1;i<=m;++i)\n        rd(q[i].l),rd(q[i].r),q[i].id=i;\n    std::sort(q+1,q+m+1);\n    for(int i=1,j=1;i<=n;++i){\n        upd(pre[i]+1,i,a[i],1,n,1);\n        for(;j<=m&&q[j].r<=i;++j)\n            ans[q[j].id]+=ask(q[j].l,q[j].r,1,n,1).hs;\n    }\n    for(int i=1;i<=m;++i)\n        printf(\"%lld\\n\",ans[i]);\n}\n```\n\n## GSS4\n\n> 区间开方(向下取整),区间求和\n\n可以发现$10^{18}$次方最多开方$6$次就会变成$1$\n\n那么每个数都在$6$次以内就会变成$1$,然后不变,所以最多修改$6\\times10^5$次\n\n打标记记录区间是否都是$1$,如果区间被标记,就不用向下继续\n\n```cpp\n#include<bits\/stdc++.h>\nconst int N=100011;\ntypedef long long ll;\nll s[N<<2];\nbool b[N<<2];\n#define ls rt<<1\n#define rs rt<<1|1\nvoid pu(int rt){s[rt]=s[ls]+s[rs],b[rt]=b[ls]&b[rs];}\nvoid build(int l,int r,int rt){\n    if(l==r){\n        scanf(\"%lld\",s+rt);\n        b[rt]=s[rt]<=1;\n        return;\n    }\n    int m=l+r>>1;\n    build(l,m,ls),build(m+1,r,rs);\n    pu(rt);\n}\nvoid upd(int L,int R,int l,int r,int rt){\n    if(b[rt])return;\n    if(l==r){\n        s[rt]=sqrt(s[rt]),\n        b[rt]=s[rt]<=1;\n        return;\n    }\n    int m=l+r>>1;\n    if(L<=m)upd(L,R,l,m,ls);\n    if(R>m)upd(L,R,m+1,r,rs);\n    pu(rt);\n}\nll ask(int L,int R,int l,int r,int rt){\n    if(L<=l&&r<=R)return s[rt];\n    int m=l+r>>1;\n    return ((L<=m)?ask(L,R,l,m,ls):0)+((R>m)?ask(L,R,m+1,r,rs):0);\n}\nint main(){\n    int n,q,opt,x,y,id=0;\n    while(~scanf(\"%d\",&n)){\n        printf(\"Case #%d:\\n\",++id);\n        build(1,n,1);\n        scanf(\"%d\",&q);\n        while(q--){\n            scanf(\"%d%d%d\",&opt,&x,&y);\n            if(x>y)x^=y,y^=x,x^=y;\n            if(opt)printf(\"%lld\\n\",ask(x,y,1,n,1));\n            else upd(x,y,1,n,1);\n        }\n    }\n}\n```\n\n## GSS8\n\n> 给你一个序列,$A[0], A[1]...A[N - 1]. (0 \\le A[i] \\lt 2^{32})$\n> \n> 你需要支持$Q$次操作\n> \n> 1. `I pos val` 插入一个数字在第$pos$个位置之前,$0 \\le val \\lt 2^{32}$, 如果$pos=current_length$,那么你需要将这个数字放到序列末尾\n> 2. `D pos` 删除第$pos$个元素\n> 3. `R pos val` 将第$pos$个元素变为$val(0 \\le val \\lt 2^{32})$\n> 4. `Q l r k` 询问$(\\sum\\limits_{i=l}^{r} A[i] \\cdot (i - l + 1) ^ k) \\mod 2^{32}$,保证$0 \\le k \\le 10$\n> \n> 第一行一个正整数 $n$,接下来一行 $n$ 个整数,表示 $a_0,a_1...a_{n-1}$。  \n> \n> 第三行一个整数 $q$,表示操作个数。\n> \n> 接下来 $q$ 行,每行表示一个操作。\n> \n> 数据点保证：\n> $1\\le n \\le 10^5,0 \\le q \\le 10^5$\n\n平衡树\n\n由于$0\\le k \\le 10$,可以用$ans_k$储存当前$k$的区间答案\n\n考虑如何合并左右儿子区间($m=\\left\\lfloor\\frac{l+r}2\\right\\rfloor$):\n\n$$\n\\sum^r_{i=1}a_i(i-l+1)^k=\\sum^m_{i=1}a_i(i-l+1)^k+\\sum^r_{i=m+1}a_i(i-l+1)^k\n\\\\ \n\\begin{aligned}\n\\sum^r_{i=m+1}a_i(i-l+1)^k\n&=\\sum^r_{i=m+1}a_i[(m-l+1)-(i-m)]^k\\\\\n&=\\sum^r_{i=m+1}a_i \\sum_{j=0}^k{k\\choose j}(m-l+1)^{k-j}(i-m)^k\\\\\n&=\\sum_{j=0}^k{k\\choose j}(m-l+1)^{k-j}\\sum^r_{i=m+1}a_i(i-m)^k\\\\\n&=\\sum_{j=0}^k{k\\choose j}(m-l+1)^{k-j} rans_j\\\\\n\\end{aligned}\n\\\\\n\\sum^r_{i=1}a_i(i-l+1)^k=lans_k+\\sum_{j=0}^k{k\\choose j}(m-l+1)^{k-j} rans_j\n$$\n\n这样就可以方便地合并左右儿子区间了\n\n```cpp\n#include<bits\/stdc++.h>\n#define int unsigned int\nint rd(){int x=0;char c;for(c=getchar();c<'0'||'9'<c;c=getchar());for(x=c-48,c=getchar();'0'<=c&&c<='9';x=x*10+c-48,c=getchar());return x;}\nconst int N=200001;\nint RT,cnt,sz[N],v[N],rnd[N],c[2][N],s[N][11],C[11][11],pw[11];\n#define ls c[0][x]\n#define rs c[1][x]\nvoid init(int x,int val){\n    v[x]=val;\n    for(int i=0;i<=10;++i)s[x][i]=val;\n}\nint ne(int val){\n    init(++cnt,val),rnd[cnt]=rand(),sz[cnt]=1;\n    return cnt;\n}\nvoid pu(int x){\n    sz[x]=sz[ls]+1+sz[rs];\n    for(int i=pw[0]=1;i<=10;++i)pw[i]=pw[i-1]*(sz[ls]+1);\n    for(int k=0;k<=10;++k){\n        s[x][k]=s[ls][k]+v[x]*pw[k];\n        for(int j=0;j<=k;++j)\n            s[x][k]+=C[k][j]*pw[k-j]*s[rs][j];\n    }\n}\nvoid sl(int x,int k,int &a,int &b){\n    if(!x){a=b=0;return;}\n    if(sz[ls]>=k)b=x,sl(ls,k,a,ls);\n    else a=x,sl(rs,k-sz[ls]-1,rs,b);\n    pu(x);\n}\nint mg(int x,int y){\n    if(!x||!y)return x|y;\n    if(rnd[x]<rnd[y]){\n        c[1][x]=mg(c[1][x],y);\n        pu(x);return x;\n    }\n    else{\n        c[0][y]=mg(x,c[0][y]);\n        pu(y);return y;\n    }\n}\nsigned main(){\n    srand(time(0));\n    for(int i=C[0][0]=1;i<=10;++i)\n        for(int j=C[i][0]=1;j<=i;++j)\n            C[i][j]=C[i-1][j]+C[i-1][j-1];\n    for(int n=rd();n--;)RT=mg(RT,ne(rd()));\n    char opt;\n    for(int q=rd(),x,y,z,l,r;q--;){\n        while(isspace(opt=getchar()));\n        if(opt=='I')\n            sl(RT,rd(),x,z),\n            RT=mg(x,mg(ne(rd()),z));\n        else if(opt=='D')\n            sl(RT,rd(),x,z),sl(z,1,y,z),\n            RT=mg(x,z);\n        else if(opt=='R')\n            sl(RT,rd(),x,z),sl(z,1,y,z),\n            init(y,rd()),\n            RT=mg(x,mg(y,z));\n        else if(opt=='Q')\n            l=rd()+1,r=rd()+1,\n            sl(RT,r,x,z),sl(x,l-1,x,y),\n            printf(\"%u\\n\",s[y][rd()]),\n            RT=mg(x,mg(y,z));\n    }\n}\n```","link":null,"tags":["数据结构","线段树","平衡树"],"title":"SPOJ GSS 系列"},{"categories":[["note"]],"content":"\n\n## 数据结构\n\n- 栈\n  - 单调栈\n\n- 队列\n  - 单调队列\n  - 优先队列\n  - 双端队列\n  \n- 堆\n  - 二叉堆\n  - 可并堆\n    - 左偏树\n    - 配对堆\n    - 斐波那契堆\n\n- 并查集\n  - 路径压缩\n  - 按秩合并\n  - 可持久化并查集\n\n- 线段树\n  - 区间加\n  - 区间乘\n  - 主席树\n  - 标记永久化\n\n- 树状数组\n    - 区间加单点查\n    - 区间加区间查\n  \n- st表(rmq)\n- 平衡树\n  - treap\n  - fhqtreap\n  - splay\n  - SBT\n  - 替罪羊树\n- kd-tree\n- link-cut tree\n- 树套树\n  - 线段树套平衡树\n  - 线段树套线段树\n- 笛卡尔树\n\n## 字符串\n\n- kmp\n  - exkmp\n- hash\n- trie\n- AC自动机\n  - fail树\n- 后缀数组SA\n- 后缀树SAM\n- manacher\n- 回文自动机\n\n## 数论\n\n- 快速幂 & 慢速乘\n- 质数\n  - 暴力判断\n  - miller-rabbin\n  - 筛质数\n    - 埃筛\n    - 欧拉筛\n  - 分解质因数\n- gcd \n  - exgcd \n- 费马小定理\n- 逆元\n  - 线性求逆元\n  - 费马小定理求逆元\n  - exgcd求逆元\n- crt \n  - excrt\n- 矩阵\n  - 矩阵乘法\n  - 矩阵快速幂\n  - 矩阵求逆\n- 行列式\n- 组合数\n  - 杨辉三角\n  - lucas \n    - exlucas\n- bsgs\n  - exbsgs\n- 欧拉函数\n  - 线性筛欧拉函数\n  - 欧拉定理\n- 狄利克雷卷积\n- 莫比乌斯函数 \n  - 莫比乌斯反演\n- 概率和期望\n- 高斯消元\n- 线性基\n- 数列\n  - 斐波那契数列\n  - 卡特林数\n  - 斯特林数\n    - 第一类斯特林数\n    - 第二类斯特林数\n- Polya定理\n- 置换群\n- 原根\n- 快速傅里叶变换(FFT)\n  - 离散傅里叶变换(DFT)\n  - 离散傅里叶逆变换(IDFT)\n  - 快速数论变换(NTT)\n  - 快速傅里叶变换的优化版(FNTT)\n  - 快速沃尔什变换(FWT)\n  - 任意模数FFT(MTT)\n  - 快速莫比乌斯变化(FMT)\n\n- 拉格朗日\n  - 拉格朗日插值\n  - 拉格朗日乘子法\n  - 拉格朗日四平方和定理\n\n- 线性规划\n<\/details>\n\n## 动态规划\n\n- 线性dp\n- 背包dp\n  - 01背包\n  - 完全背包\n  - 多重背包\n    - 二进制优化多重背包\n- 区间dp\n- 状压dp\n- 树形dp\n  - 基环树dp\n- DAG上dp\n- 多维dp\n- 期望dp\n- 数位dp\n- 动态dp\n- dp的优化\n  - 数据结构优化dp\n    - 线段树优化dp\n    - 单调队列优化dp\n  - 斜率优化\n  - 决策单调性\n\n## 树论\n\n- 生成树\n- LCA\n  - 树链剖分\n    - 树链剖分换根\n  - 倍增\n  - tarjan离线\n- 虚树\n- 基环树\n- 树链剖分\n  - 重链剖分\n  - 实链剖分\n  - 长链剖分\n- dfs序\n  - 欧拉序\n- 树分治\n  - 点分治\n    - 树的直径\n    - 树的重心\n  - 动态点分治\n  - 静态链分治\n- 树上倍增\n- 树分块\n- link-cut tree\n- top tree\n- zip tree\n\n## 图论\n\n- 最短路\n  - spfa\n    - 判断负环\n    - 堆优化\n  - dijkstra\n    - 堆优化\n    - 线段树优化\n  - floyed\n    - 倍增floyed\n  - k短路\n  - 差分约束\n- tarjan\n  - 强连通分量(缩点)\n  - 双连通分量\n  - 割点,割边,桥\n  - 2-sat\n- 拓扑排序\n- 二分图\n  - 匈牙利\n  - 网络流\n  - KM\n- 网络流\n  - 最大流(最小割)\n    - dinic\n    - isap\n  - 最小费用最大流\n    - spfa费用流\n    - zkw费用流\n  - 有上下界的网络流\n  - 数据结构优化网络流\n  - 分数规划\n\n- 欧拉图\n- 区间图与弦图\n- 平面图与对偶图\n- 最小树形图\n- 仙人掌\n  - 动态仙人掌\n\n\n## STL\n\n- map\n  - unordered_map\n- set\n  - multiset\n- stack\n- queue\n- deque\n- priority_queue\n- vector\n- list\n- bitset\n\n## 搜索\n\n- dfs\n- bfs\n  - 双向bfs\n- A*\n- IDA*\n- DLX\n- 记忆化搜索\n- 剪枝\n- 模拟退火\n- 爬山算法\n- 随机化\n\n## 计算几何\n\n- 向量\n  - 点积\n  - 叉积\n- 凸包\n- 旋转卡壳\n- 扫描线\n<\/details>\n\n## 其他算法与思想\n\n- 二分\n  - 三分\n  - 整体二分\n  - 01分数规划\n\n- 倍增\n- 贪心\n- 枚举\n- 暴力\n- 模拟\n- 分治\n  - cdq分治\n  - 线段树分治\n- 离散化\n- meet in the middle\n- 排序\n  - 快速排序\n  - 归并排序\n    - 求逆序对\n  - 桶排\n  - 基数排序\n  - 计数排序\n  - 堆排序\n- 分块\n- 随机化\n- 前缀和\n  - 二维前缀和\n- 高精度\n  - 压位\n- 递推\n  - 矩阵加速递推\n- 位运算\n- 莫队\n  - 树上莫队\n  - 带修莫队\n- 打表\n- 老司机树\n","link":null,"tags":[],"title":"OI知识点思维导图"},{"categories":[["刷题记录"]],"content":"\n有多种做法\n\nAC自动机暴力\n\nAC自动机+树状数组+lca+dfs序\n\n后缀数组+ST表+树状数组\n\n\n\n## AC自动机暴力\n\n原数据可以过,后来添加了加强数据就tle了\n\n对点名串建立AC自动机,枚举名字在上面匹配,跳fail树统计\n\n记得用于标记是否访问的数组不能用memset清零,要按原来的修改回去\n\n玄学复杂度\n\n```cpp\n#include<bits\/stdc++.h>\n#include<bits\/extc++.h>\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}void out(const char* s){while(*s)pt(*s++);}void out(char* s){while(*s)pt(*s++);}void out(char c){pt(c);}template<typename T>void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\n#define fur(i,x,y) for(int i=x;i<=y;++i)\nconst int N=100001;\nusing std::list,__gnu_pbds::gp_hash_table;\nint fail[N],sz,q[N],ans[N],ANS[N],vi[N],VI[N],vp,VP;\nlist<int>s1[50001],s2[50001],ed[N];\ngp_hash_table<int,int>c[N];\nbool vis[N],VIS[N];\nint main(){\n    int n,m,tot,now,v;\n    in(n,m);\n    fur(i,1,n){\n        in(tot);while(tot--)in(v),s1[i].push_back(v);\n        in(tot);while(tot--)in(v),s2[i].push_back(v);\n    }\n    fur(i,1,m){\n        now=0,in(tot);\n        while(tot--){\n            in(v);\n            if(!c[now][v])c[now][v]=++sz;\n            now=c[now][v];\n        }\n        ed[now].push_back(i);\n    }\n    int h=0,t=0;\n    for(auto to:c[0])\n        fail[to.second]=0,q[t++]=to.second;\n    while(h<t){\n        int now=q[h++];\n        for(auto to:c[now]){\n            int k=fail[now];\n            while(k&&!c[k][to.first])k=fail[k];\n            fail[to.second]=c[k][to.first],q[t++]=to.second;\n        }\n    }\n    fur(i,1,n){\n        now=0;\n        for(auto x:s1[i]){\n            while(now&&!c[now][x])now=fail[now];\n            now=c[now][x];\n            for(t=now;t;t=fail[t])if(!vis[t]){\n                vis[t]=1,vi[++vp]=t;\n                for(int to:ed[t])if(!VIS[to])\n                    VIS[to]=1,VI[++VP]=to,\n                    ++ans[to],++ANS[i];\n            }\n        }\n        now=0;\n        for(auto x:s2[i]){\n            while(now&&!c[now][x])now=fail[now];\n            now=c[now][x];\n            for(t=now;t;t=fail[t])if(!vis[t]){\n                vis[t]=1,vi[++vp]=t;\n                for(int to:ed[t])if(!VIS[to])\n                    VIS[to]=1,VI[++VP]=to,\n                    ++ans[to],++ANS[i];\n            }\n        }\n        while(vp)vis[vi[vp--]]=0;\n        while(VP)VIS[VI[VP--]]=0;\n    }\n    fur(i,1,m)out(ans[i]),pt('\\n');\n    fur(i,1,n)out(ANS[i]),pt(' ');\n    flush();\n}\n```\n\n## 后缀数组正解\n\n后缀数组+rmq+二分+后缀数组\n\n我们将所有姓名串和点名串拼在一起,中间用原串中不会出现的数隔开,对每个点记录它是哪个串的。\n\n求出sa,rnk,height数组,建立height数组的rmq\n\n接着转化问题\n\n第一问: \n\n设当前询问的字符串在串起来的字符串中起始位置为$i$,排名为$rnk_i$,长度为$len_i$\n\n求在所有后缀中,与当前询问的字符串后缀$\\operatorname{LCP}$等于当前字符串长度的,属于多少个名字\n\n可以通过二分求出范围,然后判断\n\n问题也就转化成: 求给定范围内颜色数目, (HH的项链)\n\n第二问也就转化成: 求每个颜色被多少个询问区间覆盖\n\n访问到L处给树状数组`bit[L]++`,到R时`bit[L]--`,到i时查询`sum(i)-sum(pre[i])`\n```cpp\n#include<bits\/stdc++.h>\n#define gc getchar()\n#define fur(i,x,y) for(int i=x;i<=y;++i)\nint rd(){int x=0;char c;bool f=0;for(c=gc;c<'0'||'9'<c;c=gc)f^=c=='-';for(x=c-48,c=gc;'0'<=c&&c<='9';x=x*10+c-48,c=gc);return f?-x:x;}\nconst int N=300011;\nint nn,q,n,m,col[N],s[N],sa[N],rnk[N],height[N],len[N],tax[N],tp[N];\nvoid qsort(){\n    fur(i,0,m)tax[i]=0;\n    fur(i,1,n)++tax[rnk[i]];\n    fur(i,1,m)tax[i]+=tax[i-1];\n    for(int i=n;i;--i)sa[tax[rnk[tp[i]]]--]=tp[i];\n}\nvoid suffix(){\n    m=11111;\n    fur(i,1,n)tp[i]=i,rnk[i]=s[i];\n    qsort();\n    for(int w=1,p=0;p<n;m=p,w<<=1){\n        p=0;\n        fur(i,1,w)tp[++p]=n-w+i;\n        fur(i,1,n)if(sa[i]>w)tp[++p]=sa[i]-w;\n        qsort();\n        std::swap(tp,rnk);\n        rnk[sa[1]]=p=1;\n        fur(i,2,n)rnk[sa[i]]=p+=tp[sa[i]]^tp[sa[i-1]]||tp[sa[i]+w]^tp[sa[i-1]+w];\n    }\n}\nvoid gh(){\n    int k=0,j;fur(i,1,n){\n        if(k)--k;\n        j=sa[rnk[i]-1];\n        while(s[i+k]==s[j+k]&&i+k<=n&&j+k<=n)++k;\n        height[rnk[i]]=k;\n    }\n}\nint f[19][N];\nint min(int x,int y){return x<y?x:y;}\nvoid st(){\n    fur(i,1,n)f[0][i]=height[i];\n    fur(i,1,18)\n        fur(j,1,n-(1<<i)+1)\n            f[i][j]=min(f[i-1][j],f[i-1][j+(1<<i-1)]);\n}\nint ask(int l,int r){\n    if(l==r)return -1u>>1;\n    if(l>r)l^=r,r^=l,l^=r;\n    ++l;\n    int k=log2(r-l+1);\n    return min(f[k][l],f[k][r-(1<<k)+1]);\n}\nint t1[N],t2[N];\nvoid upd(int*tr,int x,int v){if(x)for(;x<=n;x+=x&-x)tr[x]+=v;}\nint qry(int*tr,int x){int res=0;for(;x;x-=x&-x)res+=tr[x];return res;}\nint qry(int*tr,int x,int y){return qry(tr,y)-qry(tr,x-1);}\nint pre[N],b[N],que[N],lp[N];\nstruct node{\n    int id,l,r;\n    bool operator<(node t){return r<t.r;}\n}p[N];\nint a1[N],a2[N];\nint main(){\n    nn=rd(),q=rd();\n    fur(i,1,nn){\n        for(int x=rd();x--;)col[++n]=i,s[n]=rd();s[++n]=10001;\n        for(int x=rd();x--;)col[++n]=i,s[n]=rd();s[++n]=10001;\n    }\n    fur(i,1,q){\n        len[n+1]=rd(),que[n+1]=i;\n        for(int j=len[n+1];j--;)col[++n]=-i,s[n]=rd();s[++n]=10001;\n    }\n    suffix(),gh(),st();\n    fur(i,1,n){\n        if(col[sa[i]]>0){\/\/ 求出pre数组\n            pre[i]=b[col[sa[i]]];\n            b[col[sa[i]]]=i;\n        }\n        if(que[i]){\/\/ 二分出询问范围\n            p[que[i]].id=que[i];\n            int l=1,r=rnk[i];\n            while(l<r){\n                int mid=l+r>>1;\n                if(ask(mid,rnk[i])>=len[i])r=mid;\n                else l=mid+1;\n            }\n            lp[que[i]]=p[que[i]].l=l;\n            l=rnk[i],r=n;\n            while(l<r){\n                int mid=l+r+1>>1;\n                if(ask(mid,rnk[i])>=len[i])l=mid;\n                else r=mid-1;\n            }\n            p[que[i]].r=r;\n        }\n    }\n    std::sort(p+1,p+q+1);\n    std::sort(lp+1,lp+q+1);\n    for(int i=1,j=1,k=1;i<=n;++i){\n        int t=0;for(;j<=q&&lp[j]==i;++j)++t;\n        upd(t2,i,t);\n        if(col[sa[i]]>0)\n            a2[col[sa[i]]]+=qry(t2,pre[i]+1,i),\n            upd(t1,i,1),upd(t1,pre[i],-1);\n        for(;k<=q&&p[k].r==i;++k){\n            a1[p[k].id]=qry(t1,p[k].l,p[k].r);\n            upd(t2,p[k].l,-1);\n        }\n    }\n    fur(i,1,q)printf(\"%d\\n\",a1[i]);\n    fur(i,1,nn)printf(\"%d \",a2[i]);\n}\n```\n","link":null,"tags":["AC自动机","后缀数组","rmq","二分","树状数组"],"title":"LG 2336 [SCOI2012]喵星球上的点名"},{"categories":[["刷题记录"]],"content":"\n> 相同的定义为：两个子串长度相同且一个串的全部元素加上一个数就会变成另一个串\n\n那么我们差分之后再判断即可\n```cpp\n#include<bits\/stdc++.h>\n#define gc getchar()\n#define fur(i,x,y) for(int i=x;i<=y;++i)\nvoid cmin(int &x,int y){if(x>y)x=y;}\nint rd(){int x=0;char c;bool f=0;for(c=gc;c<'0'||'9'<c;c=gc)f^=c=='-';for(x=c-48,c=gc;'0'<=c&&c<='9';x=x*10+c-48,c=gc);return f?-x:x;}\nconst int N=1000011;\nint cnt,n,m,sa[N],rnk[N],height[N],tax[N],tp[N],col[N],s[N];\nvoid qsort(){\n    fur(i,0,m)tax[i]=0;\n    fur(i,1,n)++tax[rnk[i]];\n    fur(i,1,m)tax[i]+=tax[i-1];\n    for(int i=n;i;--i)sa[tax[rnk[tp[i]]]--]=tp[i];\n}\nvoid suffix(){\n    m=3000;\n    fur(i,1,n)rnk[i]=s[i],tp[i]=i;\n    qsort();\n    for(int w=1,p=0;p<n;m=p,w<<=1){\n        p=0;\n        fur(i,1,w)tp[++p]=n-w+i;\n        fur(i,1,n)if(sa[i]>w)tp[++p]=sa[i]-w;\n        qsort();\n        std::swap(tp,rnk);\n        rnk[sa[1]]=p=1;\n        fur(i,2,n)\n            rnk[sa[i]]=p+=tp[sa[i]]^tp[sa[i-1]]||tp[sa[i]+w]^tp[sa[i-1]+w];\n    }\n}\nvoid gh(){\n    for(int i=1,k=0;i<=n;++i){\n        if(k)--k;\n        int j=sa[rnk[i]-1];\n        while(s[i+k]==s[j+k]&&i+k<=n&&j+k<=n)++k;\n        height[rnk[i]]=k;\n    }\n}\n\/* 二分判断\nbool v[N];\nint sta[N],top;\nbool chk(int x){\n\twhile(top)v[sta[top--]]=0;\n\tfor (int i=1;i<=n;i++) {\n\t\tif (height[i]<x)while(top)v[sta[top--]]=0;\n\t\tif(!v[col[sa[i]]]){\n\t\t\tv[col[sa[i]]]=1;\n\t\t\tsta[++top]=col[sa[i]];\n\t\t\tif(top==cnt)return 1; \n\t\t}\n\t}\n\treturn 0;\n}\n*\/\nint tot,v[N],q[N],L[N],R[N];\nvoid add(int x){if(col[x]&&++v[col[x]]==1)++tot;}\nvoid del(int x){if(col[x]&&!--v[col[x]])--tot;}\nint main(){\n    int mi=-1u>>1;\n    cnt=rd();\n    fur(i,1,cnt){\n        int t=rd(),la=rd();\n        L[i]=n+1;\n        while(--t)s[++n]=rd()-la,la+=s[n],cmin(mi,s[i]);\n        R[i]=n;\n        s[++n]=1865+i;\n    }\n    fur(i,1,n)s[i]=s[i]-mi+1;\n    suffix(),gh();\n    \/* 二分\n    int l=0,r=110,ans=0;\n    while (l<=r){\n\t\tint mid=l+r>>1;\n\t\tif (chk(mid))l=mid+1,ans=mid;\n\t\telse r=mid-1;\n\t}\n    *\/\n    fur(i,1,cnt)fur(j,L[i],R[i])col[rnk[j]]=i;\n    int h=1,t=0,l=1,ans=0;\n    add(1);\n    fur(i,2,n){\n        while(h<=t&&height[i]<=height[q[t]])--t;\n        q[++t]=i;\n        add(i);\n        if(tot==cnt){\n            while(tot==cnt&&l<i)del(l++);\n            add(--l);\n        }\n        while(h<=t&&q[h]<=l)++h;\n        if(tot==cnt&&height[q[h]]>ans)ans=height[q[h]];\n    }\n    printf(\"%d\\n\",ans+1);\n}\n```\n","link":null,"tags":["后缀数组","二分","差分","单调队列"],"title":"LG 2463 [SDOI2008]Sandy的卡片"},{"categories":[["刷题记录"]],"content":"\n```cpp\n#include<bits\/stdc++.h>\nconst int N=100011;\nchar s[N];\nint n,m,tax[N],tp[N],rnk[N],sa[N],height[N];\nvoid qsort(){\n    for(int i=0;i<=m;++i)tax[i]=0;\n    for(int i=1;i<=n;++i)++tax[rnk[i]];\n    for(int i=1;i<=m;++i)tax[i]+=tax[i-1];\n    for(int i=n;i;--i)sa[tax[rnk[tp[i]]]--]=tp[i];\n}\nvoid suffix(){\n    m=200;\n    for(int i=1;i<=n;++i)sa[i]=0,rnk[i]=s[i]-'A'+1,tp[i]=i;\n    qsort();\n    for(int w=1,p=0;p<n;m=p,w<<=1){\n        p=0;\n        for(int i=1;i<=w;++i)tp[++p]=n-w+i;\n        for(int i=1;i<=n;++i)\n            if(sa[i]>w)tp[++p]=sa[i]-w;\n        qsort();\n        std::swap(tp,rnk);\n        rnk[sa[1]]=p=1;\n        for(int i=2;i<=n;++i)\n            rnk[sa[i]]=p+=tp[sa[i]]^tp[sa[i-1]]||tp[sa[i]+w]^tp[sa[i-1]+w];\n    }\n}\nvoid solve(){\n    scanf(\"%s\",s+1),n=strlen(s+1);\n    suffix();\n    long long ans=n*(n+1)>>1;\n    for(int i=1,k=0;i<=n;++i){\n        if(k)--k;\n        int j=sa[rnk[i]-1];\n        while(s[i+k]==s[j+k]&&i+k<=n&&j+k<=n)++k;\n        ans-=k;\n    }\n    printf(\"%lld\\n\",ans);\n}\nint main(){\n    int T;scanf(\"%d\",&T);\n    while(T--)solve();\n}\n```\n","link":null,"tags":["后缀数组"],"title":"LG SP694 DISUBSTR - Distinct Substrings"},{"categories":[["刷题记录"]],"content":"\n连接所有字符串($cnt$个),中间用特殊字符隔开\n\n给每个位置标记所属字符串\n\n然后求出`sa`,`rnk`,`height`数组\n\n我们要找出$cnt$个所属字符串不同的后缀,让他们$\\operatorname{LCP}$最长\n\n可以用双指针+单调队列的方式实现\n\n单调队列记录当前区间最小的`height`,单调递增,双指针移动右指针的同时维护单调队列,移动右指针后判断是否可以移动左指针,并重复到无法移动,同时对应弹出单调队列的队头\n```cpp\n#include<bits\/stdc++.h>\nconst int N=10111;\nint cnt,n,m,sa[N],rnk[N],height[N],tax[N],tp[N];\nchar s[N];\nvoid qsort(){\n    for(int i=0;i<=m;++i)tax[i]=0;\n    for(int i=1;i<=n;++i)++tax[rnk[i]];\n    for(int i=1;i<=m;++i)tax[i]+=tax[i-1];\n    for(int i=n;i;--i)\n        sa[tax[rnk[tp[i]]]--]=tp[i];\n}\nvoid suffix(){\n    m=100;\n    for(int i=1;i<=n;++i)tp[i]=i,rnk[i]=s[i]-'a'+1;\n    qsort();\n    for(int w=1,p=0;p<n;m=p,w<<=1){\n        p=0;\n        for(int i=1;i<=w;++i)tp[++p]=n-w+i;\n        for(int i=1;i<=n;++i)if(sa[i]>w)\n            tp[++p]=sa[i]-w;\n        qsort();\n        std::swap(tp,rnk);\n        rnk[sa[1]]=p=1;\n        for(int i=2;i<=n;++i)\n            rnk[sa[i]]=p+=tp[sa[i]]^tp[sa[i-1]]||tp[sa[i]+w]^tp[sa[i-1]+w];\n    }\n}\nvoid get_height(){\n    for(int i=1,k=0;i<=n;++i){\n        if(k)--k;\n        int j=sa[rnk[i]-1];\n        while(s[i+k]==s[j+k]&&i+k<=n&&j+k<=n)++k;\n        height[rnk[i]]=k;\n    }\n}\nint col[N],L[N],R[N],v[N],tot,q[N],h=1,t;\nvoid add(int x){if(col[x])if(++v[col[x]]==1)++tot;}\nvoid del(int x){if(col[x])if(!--v[col[x]])--tot;}\nvoid cmax(int &x,int y){if(x<y)x=y;}\nint main(){\n    scanf(\"%d\",&cnt);\n    for(int i=1;i<=cnt;++i)\n        L[i]=n+1,\n        scanf(\"%s\",s+n+1),\n        s[n=strlen(s+1)+1]=i+'a'-1,\n        R[i]=n-1;\n    suffix();\n    get_height();\n    for(int i=1;i<=cnt;++i)\n        for(int j=L[i];j<=R[i];++j)\n            col[rnk[j]]=i;\n\tint l=1,ans=0;\n\tadd(1);\n\tfor(int r=2;r<=n;++r){\n\t\twhile(h<=t&&height[q[t]]>=height[r])--t;\n\t\tq[++t]=r;\n\t\tadd(r);\n\t\tif(tot==cnt){\n\t\t\twhile(tot==cnt&&l<r)del(l++);\n\t\t\tadd(--l);\n\t\t}\n\t\twhile(h<=t&&q[h]<=l)++h;\n\t\tif(tot==cnt)cmax(ans,height[q[h]]);\n\t}\n    printf(\"%d\\n\",ans);\n}\n```\n","link":null,"tags":["后缀数组"],"title":"LG 5546 [POI2000]公共串"},{"categories":[["刷题记录"]],"content":"\n枚举长度$L$,然后判断长度为$L$的子串能连续出现几次(1次肯定可以,这里判断出现2次以上的)\n\n复杂度$\\Theta(\\frac n1+\\frac n2+\\cdots +\\frac nn)$\n\n假设现在枚举到位置$j$\n\n找到$k=\\operatorname{LCP}(suf(j),suf(j+L))$,$\\left \\lfloor \\frac ki \\right \\rfloor +1$就是从$j$开始到$j$之后循环的次数\n\n再判断一下$j$之前是否有再出现过,就可以得出当前答案\n\n\n```cpp\n#include<bits\/stdc++.h>\nconst int N=50011;\nint n,m,sa[N],rnk[N],tax[N],tp[N],height[N];\nchar s[N];\nvoid qsort(){\n    for(int i=0;i<=m;++i)++tax[i]=0;\n    for(int i=1;i<=n;++i)++tax[rnk[i]];\n    for(int i=1;i<=m;++i)tax[i]+=tax[i-1];\n    for(int i=n;i;--i)sa[tax[rnk[tp[i]]]--]=tp[i];\n}\nint f[17][N];\nint min(int x,int y){return x<y?x:y;}\nvoid st(){\n    for(int i=1;i<=n;++i)f[0][i]=height[i];\n    for(int k=1;k<=16;++k)\n        for(int i=1;i+(1<<k)-1<=n;++i)\n            f[k][i]=min(f[k-1][i],f[k-1][i+(1<<(k-1))]);\n}\nint ask(int l,int r){\n    if(l==r)return -1u>>1;\n    if(l>r)l^=r,r^=l,l^=r;++l;\n    int k=log2(r-l+1);\n    return min(f[k][l],f[k][r-(1<<k)+1]);\n}\nint get(){char c;while((c=getchar())<'a');return c-'a'+1;}\nvoid solve(){\n    scanf(\"%d\",&n);\n    m=3;\n    for(int i=1;i<=n;++i)sa[i]=0,rnk[i]=s[i]=get(),tp[i]=i;\n    qsort();\n    for(int w=1,p=0;p<n;m=p,w<<=1){\n        p=0;\n        for(int i=1;i<=w;++i)tp[++p]=n-w+i;\n        for(int i=1;i<=n;++i)if(sa[i]>w)tp[++p]=sa[i]-w;\n        qsort();\n        std::swap(tp,rnk);\n        rnk[sa[1]]=p=1;\n        for(int i=2;i<=n;++i)\n            rnk[sa[i]]=p+=tp[sa[i]]^tp[sa[i-1]]||tp[sa[i]+w]^tp[sa[i-1]+w];\n    }\n    for(int i=1,k=0;i<=n;++i){\n        if(k)--k;\n        int j=sa[rnk[i]-1];\n        while(s[i+k]==s[j+k]&&i+k<=n&&j+k<=n)++k;\n        height[rnk[i]]=k;\n    }\n    st();\n    int ans=1;\n    for(int i=1;i<=n;++i)\n        for(int j=1;j+i<=n;j+=i){\n            int k=ask(rnk[j],rnk[j+i]),now=k\/i+1,t=j-i+k%i;\n            if(ask(rnk[t],rnk[t+i])>k)++now;\n            if(now>ans)ans=now;            \n        }\n    printf(\"%d\\n\",ans);\n}\nint main(){\n    int T;scanf(\"%d\",&T);\n    while(T--)solve();\n}\n```\n","link":null,"tags":["后缀数组"],"title":"LG SP687 REPEATS - Repeats"},{"categories":[["刷题记录"]],"content":"\n首先用后缀数组求出height数组\n\n可以发现,重复出现的子串在sa数组中一定是连续的\n\n那么在height中也是连续的\n\n那么我们只需要求出 height数组中 连续$k-1$个数中 最小的数 最大可以是多少 即可\n\n单调队列就可以解决\n```cpp\n#include<bits\/stdc++.h>\n#define gc getchar()\nint rd(){int x=0;char c;bool f=0;for(c=gc;c<'0'||'9'<c;c=gc)f^=c=='-';for(x=c-48,c=gc;'0'<=c&&c<='9';x=x*10+c-48,c=gc);return f?-x:x;}\nconst int N=1000011;\nint n,m,k,s[N],rnk[N],sa[N],tp[N],tax[N],height[N],q[N];\nvoid qsort(){\n    for(int i=0;i<=m;++i)tax[i]=0;\n    for(int i=1;i<=n;++i)++tax[rnk[i]];\n    for(int i=1;i<=m;++i)tax[i]+=tax[i-1];\n    for(int i=n;i;--i)sa[tax[rnk[tp[i]]]--]=tp[i];\n}\nint main(){\n    n=rd(),k=rd();\n    for(int i=1;i<=n;++i)rnk[i]=s[i]=rd(),tp[i]=i;\n    m=1000000;\n    qsort();\n    for(int w=1,p=0;p<n;m=p,w<<=1){\n        p=0;\n        for(int i=1;i<=w;++i)tp[++p]=n-w+i;\n        for(int i=1;i<=n;++i)if(sa[i]>w)tp[++p]=sa[i]-w;\n        qsort();\n        std::swap(tp,rnk);\n        rnk[sa[1]]=p=1;\n        for(int i=2;i<=n;++i)\n            rnk[sa[i]]=p+=tp[sa[i]]^tp[sa[i-1]]||tp[sa[i]+w]^tp[sa[i-1]+w];\n    }\n    for(int i=1,k=0;i<=n;++i){\n        if(k)--k;\n        int j=sa[rnk[i]-1];\n        while(s[i+k]==s[j+k]&&i+k<=n&&j+k<=n)++k;\n        height[rnk[i]]=k;\n    }\n    int h=1,t=0,ans=0;\n    for(int i=2;i<=n;++i){\n        while(h<=t&&height[q[t]]>=height[i])--t;\n        q[++t]=i;\n        if(i<k)continue;\n        while(i-q[h]+1>=k)++h;\n        if(ans<height[q[h]])ans=height[q[h]];\n    }\n    printf(\"%d\\n\",ans);\n}\n```\n","link":null,"tags":["后缀数组","单调队列"],"title":"LG 2852 [USACO06DEC]Milk Patterns G"},{"categories":[["刷题记录"]],"content":"\n$\\frac {n(n+1)}2 - \\sum height[i]$\n```cpp\n#include<bits\/stdc++.h>\nconst int N=100011;\nchar s[N];\nint n,m,sa[N],rnk[N],tax[N],tp[N];\nvoid qsort(){\n    for(int i=0;i<=m;++i)tax[i]=0;\n    for(int i=1;i<=n;++i)++tax[rnk[i]];\n    for(int i=1;i<=m;++i)tax[i]+=tax[i-1];\n    for(int i=n;i;--i)sa[tax[rnk[tp[i]]]--]=tp[i];\n}\nvoid suffix(){\n    m=100;\n    for(int i=1;i<=n;++i)sa[i]=0,rnk[i]=s[i]-'a'+1,tp[i]=i;\n    qsort();\n    for(int w=1,p=0;p<n;m=p,w<<=1){\n        p=0;\n        for(int i=1;i<=w;++i)tp[++p]=n-w+i;\n        for(int i=1;i<=n;++i)\n            if(sa[i]>w)tp[++p]=sa[i]-w;\n        qsort();\n        std::swap(tp,rnk);\n        rnk[sa[1]]=p=1;\n        for(int i=2;i<=n;++i)\n            rnk[sa[i]]=p+=tp[sa[i]]^tp[sa[i-1]]||tp[sa[i]+w]^tp[sa[i-1]+w];\n    }\n}\nint main(){\n    scanf(\"%d%s\",&n,s+1);\n    suffix();\n    long long ans=1ll*n*(n+1)>>1;\n    for(int i=1,k=0;i<=n;++i){\n        if(k)--k;\n        int j=sa[rnk[i]-1];\n        while(s[i+k]==s[j+k]&&i+k<=n&&j+k<=n)++k;\n        ans-=k;\n    }\n    printf(\"%lld\\n\",ans);\n}\n```\n","link":null,"tags":["后缀数组"],"title":"LG 2408 不同子串个数"},{"categories":[["刷题记录"]],"content":"\n看到环就想到把原串变成两倍,而这对被延长了的原串中的子串在sa中的排名没有影响\n\n比如`baba`变成`babadfasdfa`,这并不会影响到`baba`的排名\n\n那么直接求出`sa`后输出即可\n```cpp\n#include<bits\/stdc++.h>\nconst int N=200011;\nchar s[N];\nint n,m,sa[N],rnk[N],tax[N],tp[N];\nvoid qsort(){\n    for(int i=0;i<=m;++i)tax[i]=0;\n    for(int i=1;i<=n;++i)++tax[rnk[i]];\n    for(int i=1;i<=m;++i)tax[i]+=tax[i-1];\n    for(int i=n;i;--i)sa[tax[rnk[tp[i]]]--]=tp[i];\n}\nvoid suffix(){\n    m=300;\n    for(int i=1;i<=n;++i)sa[i]=0,rnk[i]=s[i],tp[i]=i;\n    qsort();\n    for(int w=1,p=0;p<n;m=p,w<<=1){\n        p=0;\n        for(int i=1;i<=w;++i)tp[++p]=n-w+i;\n        for(int i=1;i<=n;++i)\n            if(sa[i]>w)tp[++p]=sa[i]-w;\n        qsort();\n        std::swap(tp,rnk);\n        rnk[sa[1]]=p=1;\n        for(int i=2;i<=n;++i)\n            rnk[sa[i]]=p+=tp[sa[i]]^tp[sa[i-1]]||tp[sa[i]+w]^tp[sa[i-1]+w];\n    }\n}\nint main(){\n    scanf(\"%s\",s+1),n=strlen(s+1);\n    for(int i=1;i<=n;++i)s[i+n]=s[i];\n    n<<=1;\n    suffix();\n    for(int i=1;i<=n;++i)if(sa[i]<=(n>>1))\n        putchar(s[sa[i]+(n>>1)-1]);\n}\n```\n","link":null,"tags":["后缀数组"],"title":"LG 4051 [JSOI2007]字符加密"},{"categories":[["刷题记录"]],"content":"\n```cpp\n#include<bits\/stdc++.h>\n#define fur(i,x,y) for(int i=x;i<=y;++i)\nconst int N=1000001;\nchar s[N];\nint n,m,sa[N],rnk[N],tp[N],tax[N];\nvoid qsort(){\n    fur(i,0,m)tax[i]=0;\n    fur(i,1,n)++tax[rnk[i]];\n    fur(i,1,m)tax[i]+=tax[i-1];\n    for(int i=n;i;--i)\n        sa[tax[rnk[tp[i]]]--]=tp[i];\n}\nvoid suffix(){\n    m=75;\n    fur(i,1,n)rnk[i]=s[i]-'0'+1,tp[i]=i;\n    qsort();\n    for(int w=1,p=0;p<n;m=p,w<<=1){\n        p=0;\n        fur(i,1,w)tp[++p]=n-w+i;\n        fur(i,1,n)if(sa[i]>w)\n            tp[++p]=sa[i]-w;\n        qsort();\n        std::swap(tp,rnk);\n        rnk[sa[1]]=p=1;\n        fur(i,2,n)\n            rnk[sa[i]]=p+=tp[sa[i-1]]^tp[sa[i]]||tp[sa[i-1]+w]^tp[sa[i]+w];\n    }\n}\n\/* -height *\/\nint height[N];\nvoid get_height(){\n    for(int i=1,k=0;i<=n;++i){\n\t\tif(k)--k;\n\t\tint j=sa[rnk[i]-1];\n\t\twhile(s[i+k]==s[j+k]&&i+k<=n&&j+k<=n)++k;\n\t\theight[rnk[i]]=k; \n\t}\n}\n\/* - *\/\nint main(){\n    scanf(\"%s\",s+1),n=strlen(s+1);\n    suffix();\n    fur(i,1,n)printf(\"%d \",sa[i]);\n}\n```\n","link":null,"tags":["后缀数组","模板"],"title":"LG 3809 【模板】后缀排序"},{"categories":[["刷题记录"]],"content":"\n```cpp\n#include<bits\/stdc++.h>\nconst int N=1000111;\nint cnt,n,m,sa[N],rnk[N],height[N],tax[N],tp[N];\nchar s[N];\nvoid qsort(){\n    for(int i=0;i<=m;++i)tax[i]=0;\n    for(int i=1;i<=n;++i)++tax[rnk[i]];\n    for(int i=1;i<=m;++i)tax[i]+=tax[i-1];\n    for(int i=n;i;--i)\n        sa[tax[rnk[tp[i]]]--]=tp[i];\n}\nvoid suffix(){\n    m=200;\n    for(int i=1;i<=n;++i)sa[i]=0,rnk[i]=(s[i]<='a')?s[i]:(s[i]-'a'+1),tp[i]=i;\n    qsort();\n    for(int w=1,p=0;p<n;m=p,w<<=1){\n        p=0;\n        for(int i=1;i<=w;++i)tp[++p]=n-w+i;\n        for(int i=1;i<=n;++i)\n            if(sa[i]>w)tp[++p]=sa[i]-w;\n        qsort();\n        std::swap(tp,rnk);\n        rnk[sa[1]]=p=1;\n        for(int i=2;i<=n;++i)\n            rnk[sa[i]]=p+=tp[sa[i]]^tp[sa[i-1]]||tp[sa[i]+w]^tp[sa[i-1]+w];\n    }\n}\nvoid get_height(){\n    for(int i=1,k=0;i<=n;++i){\n        if(k)--k;\n        int j=sa[rnk[i]-1];\n        while(s[i+k]==s[j+k]&&i+k<=n&&j+k<=n)++k;\n        height[rnk[i]]=k;\n    }\n}\nint col[N],L[N],R[N],v[N],tot,q[N];\nvoid add(int x){if(col[x])if(++v[col[x]]==1)++tot;}\nvoid del(int x){if(col[x])if(!--v[col[x]])--tot;}\nvoid cmax(int &x,int y){if(x<y)x=y;}\nint main(){\n    int T;scanf(\"%d\",&T);\nwhile(T--){\n    n=tot=0;memset(height,0,sizeof height);\n    memset(col,0,sizeof col);\n    memset(v,0,sizeof v);\n    memset(q,0,sizeof q);\n    scanf(\"%d\",&cnt);\n    for(int i=1;i<=cnt;++i)\n        L[i]=n+1,\n        scanf(\"%s\",s+n+1),\n        s[n=strlen(s+1)+1]=i,\n        R[i]=n-1;\n    suffix();\n    get_height();\n    for(int i=1;i<=cnt;++i)\n        for(int j=L[i];j<=R[i];++j)\n            col[rnk[j]]=i;\n\tint l=1,ans=0,h=1,t;\n    tot=0;\n\tadd(1);\n\tfor(int r=2;r<=n;++r){\n\t\twhile(h<=t&&height[q[t]]>=height[r])--t;\n\t\tq[++t]=r;\n\t\tadd(r);\n\t\tif(tot==cnt){\n\t\t\twhile(tot==cnt&&l<r)del(l++);\n\t\t\tadd(--l);\n\t\t}\n\t\twhile(h<=t&&q[h]<=l)++h;\n\t\tif(tot==cnt)cmax(ans,height[q[h]]);\n\t}\n    printf(\"%d\\n\",ans);\n}\n}\n```\n","link":null,"tags":["后缀数组"],"title":"LG SP10570 LONGCS - Longest Common Substring"},{"categories":[["算法","字符串"],["note"]],"content":"\n\n## 简介\n\n后缀数组,又称`SA`\n\n是OI中处理字符串的有力工具\n\n## 实现\n\n有两种实现的方法\n\n1. 倍增法\n2. DC3\n\n这里主要讲倍增法\n\n`sa[i]`表示所有后缀中的字典序排名为$i$的后缀的起始位置\n\n`rnk[i]`表示起始位置为$i$的后缀(后缀$i$)在所有后缀中的排名\n\n图解:\n\n![](1.png)\n\n从长度$1$的块开始排序,接着是长度为$2$,然后每次长度都倍增\n\n第一次直接对所有字符进行排序\n\n每次将当前块分为相等的两段,这两段的排名上一轮已经求出了,变成一个二元组$(a,b)$\n\n比较两个块相当于比较两个二元组\n\n一直倍增知道块长大于字符串长度,终止即可\n\n这里的排序使用基数排序加快速度\n\n[LG P3809 【模板】后缀排序](https:\/\/www.luogu.com.cn\/problem\/P3809)\n\n```cpp\n#include<bits\/stdc++.h>\n#define fur(i,x,y) for(int i=x;i<=y;++i)\nconst int N=1000001;\nchar s[N];\nint n,m,sa[N],rnk[N],tp[N],tax[N];\nvoid qsort(){\/\/对(rnk[i],tp[i])进行排序\n    \/\/ tax[i]: i号元素出现了多少次\n    fur(i,0,m)tax[i]=0;\n    fur(i,1,n)++tax[rnk[i]];\n    fur(i,1,m)tax[i]+=tax[i-1];\n    for(int i=n;i;--i)\n        sa[tax[rnk[tp[i]]]--]=tp[i];\n}\nvoid suffix(){\n    m=75;\n    fur(i,1,n)rnk[i]=s[i]-'a'+1,tp[i]=i;\n    qsort();\n    for(int w=1,p=0;p<n;m=p,w<<=1){\n        p=0;\n        fur(i,1,w)tp[++p]=n-w+i;\n        fur(i,1,n)if(sa[i]>w)\n            tp[++p]=sa[i]-w;\n        qsort();\n        std::swap(tp,rnk);\n        rnk[sa[1]]=p=1;\n        fur(i,2,n)\n            rnk[sa[i]]=p+=tp[sa[i-1]]^tp[sa[i]]||tp[sa[i-1]+w]^tp[sa[i]+w];\n    }\n}\nint main(){\n    scanf(\"%s\",s+1),n=strlen(s+1);\n    suffix();\n    fur(i,1,n)printf(\"%d \",sa[i]);\n}\n```\n\n## height数组\n\n单纯看`sa`数组,可能没什么用\n\n我们定义`height[i]`表示后缀`sa[i]`与后缀`sa[i-1]`的最长公共前缀(`LCP`)\n\n仔细思考可以发现,后缀$j$和后缀$k$($rnk_j<rnk_k$)的最长公共前缀为:\n\n$$\\min_{i=rnk_j}^{rnk_k}\\left\\{height_i\\right\\}$$\n\n这样一来建立一个`ST`表就可以快速求出任意两个后缀的`LCP`了\n\n如果直接通过枚举计算`height`数组,时间复杂度为$\\Theta(n^2)$\n\n如何快速求`height`数组？\n\n再定义`H[i]=height[rnk[i]]`\n\n结论: $H_i\\ge H_{i-1}-1$\n\n![](height.png)\n\n浅蓝的是`H[i-1]`的结果,蓝色部分最多比浅蓝部分少了开头一小段\n\n红线截取的部分也一定是相同的\n\n所以$H_i\\ge H_{i-1}-1$\n\n按照`H[1],H[2],...,H[n]`的顺序计算,并利用`H`数组的性质,时间复杂度可以降为$\\Theta(n)$\n\n```cpp\nint height[N];\nvoid get_height(){\n    for(int i=1,k=0;i<=n;++i){\n\t\tif(k)--k;\n\t\tint j=sa[rnk[i]-1];\n\t\twhile(s[i+k]==s[j+k]&&i+k<=n&&j+k<=n)++k;\n\t\theight[rnk[i]]=k; \n\t}\n}\n```\n\n## 最长公共子串\n\n1. 连接两个字符串\n2. 求$sa,rnk,height$\n3. 求排名相邻但原来不在同一个字符串中的两个后缀的`height`值的最大值。\n   \n时间复杂度$\\Theta(A+B)$已经取到下限,由此看出,这是一个非常优秀的算法。\n\n![](lcs.png)\n\n## 习题\n\n[LG P5546 \\[POI2000\\]公共串](https:\/\/www.luogu.com.cn\/problem\/P5546)\n\n多个字符串的共同子串\n\n```cpp\n#include<bits\/stdc++.h>\nconst int N=10111;\nint cnt,n,m,sa[N],rnk[N],height[N],tax[N],tp[N];\nchar s[N];\nvoid qsort(){\n    for(int i=0;i<=m;++i)tax[i]=0;\n    for(int i=1;i<=n;++i)++tax[rnk[i]];\n    for(int i=1;i<=m;++i)tax[i]+=tax[i-1];\n    for(int i=n;i;--i)\n        sa[tax[rnk[tp[i]]]--]=tp[i];\n}\nvoid suffix(){\n    m=100;\n    for(int i=1;i<=n;++i)tp[i]=i,rnk[i]=s[i]-'a'+1;\n    qsort();\n    for(int w=1,p=0;p<n;m=p,w<<=1){\n        p=0;\n        for(int i=1;i<=w;++i)tp[++p]=n-w+i;\n        for(int i=1;i<=n;++i)if(sa[i]>w)\n            tp[++p]=sa[i]-w;\n        qsort();\n        std::swap(tp,rnk);\n        rnk[sa[1]]=p=1;\n        for(int i=2;i<=n;++i)\n            rnk[sa[i]]=p+=tp[sa[i]]^tp[sa[i-1]]||tp[sa[i]+w]^tp[sa[i-1]+w];\n    }\n}\nvoid get_height(){\n    for(int i=1,k=0;i<=n;++i){\n        if(k)--k;\n        int j=sa[rnk[i]-1];\n        while(s[i+k]==s[j+k]&&i+k<=n&&j+k<=n)++k;\n        height[rnk[i]]=k;\n    }\n}\nint col[N],L[N],R[N],v[N],tot;\nvoid add(int x){if(col[x])if(++v[col[x]]==1)++tot;}\nvoid del(int x){if(col[x])if(!--v[col[x]])--tot;}\nvoid cmax(int &x,int y){if(x<y)x=y;}\nint main(){\n    scanf(\"%d\",&cnt);\n    for(int i=1;i<=cnt;++i)\n        L[i]=n+1,\n        scanf(\"%s\",s+n+1),\n        s[n=strlen(s+1)+1]=i+'a'-1,\n        R[i]=n-1;\n    suffix();\n    get_height();\n    for(int i=1;i<=cnt;++i)\n        for(int j=L[i];j<=R[i];++j)\n            col[rnk[j]]=i;\n    using std::deque;\n    deque<int>q;\n\tint l=1,ans=0;\n\tadd(1);\n\tfor(int r=2;r<=n;++r){\n\t\twhile(!q.empty()&&height[q.back()]>=height[r])q.pop_back();\n\t\tq.emplace_back(r);\n\t\tadd(r);\n\t\tif(tot==cnt){\n\t\t\twhile(tot==cnt&&l<r)del(l++);\n\t\t\tadd(--l);\n\t\t}\n\t\twhile(!q.empty()&&q.front()<=l) q.pop_front();\n\t\tif(tot==cnt)cmax(ans,height[q.front()]);\n\t}\n    printf(\"%d\\n\",ans);\n}\n```\n\n[\\[SCOI2012\\]喵星球上的点名](https:\/\/www.luogu.com.cn\/problem\/P2336)\n","link":null,"tags":["字符串","后缀数组"],"title":"后缀数组"},{"categories":[["刷题记录"]],"content":"\n首先根据输入的字符串构造trie\n\n然后构建AC自动机\n\n利用了fail树的一个性质:\n\n若$y$节点的fail指针指向$x$节点,那么 根到$x$形成的字符串 一定在 根到$y$形成的字符串 中出现过\n\n那么我们对于每个询问`x y`,只需要找出根到$y$上的节点有多少个fail指针直接或间接指向$x$的,就是答案\n\n构建fail树之后使用dfs序+树状数组统计\n```cpp\n#include<bits\/stdc++.h>\n#define gc getchar()\n#define fur(i,x,y) for(int i=x;i<=y;++i)\nvoid cmin(int &x,int y){if(x>y)x=y;}void cmax(int &x,int y){if(x<y)x=y;}\nvoid in(int &x){x=0;char c;bool f=0;for(c=gc;c<'0'||'9'<c;c=gc)f^=c=='-';for(x=c-48,c=gc;'0'<=c&&c<='9';x=x*10+c-48,c=gc);if(f)x=-x;}\nconst int N=100011;\nusing std::list,std::pair;\nchar ch[N];\nint n,m,sz,tot,cnt,c[N][26],fa[N],fail[N],p[N],q[N],head[N],ans[N];\nlist<int>e[N];\nlist<pair<int,int>>que[N];\nint L[N],R[N],dfn,s[N];\nvoid dfs(int x){\n    L[x]=++dfn;\n    for(int to:e[x])dfs(to);\n    R[x]=dfn;\n}\nvoid add(int x,int v){for(;x<=sz;x+=x&-x)s[x]+=v;}\nint ask(int x){int res=0;for(;x;x-=x&-x)res+=s[x];return res;}\nint main(){\n    scanf(\"%s\",ch),n=strlen(ch);\n    int x=1,y,h=0,t=1;\n    sz=1;fur(i,0,25)c[0][i]=1;\n    fur(i,0,n-1)\n        if(ch[i]=='P')p[++tot]=x;\n        else if(ch[i]=='B')x=fa[x];\n        else{\n            if(!c[x][ch[i]-'a'])fa[c[x][ch[i]-'a']=++sz]=x;\n            x=c[x][ch[i]-'a'];\n        }\n    q[0]=1,fail[1]=0;\n    while(h<t){\n        x=q[h++];\n        fur(i,0,25)\n            if(c[x][i])fail[c[x][i]]=c[fail[x]][i],q[t++]=c[x][i];\n            else c[x][i]=c[fail[x]][i];\n    }\n    fur(i,1,sz)e[fail[i]].push_back(i);\n    in(m);\n    fur(i,1,m)in(x),in(y),que[y].push_back(std::make_pair(i,x));\n    dfs(1);\n    x=1,tot=0;\n    fur(i,0,n-1)\n        if(ch[i]=='P'){\n            ++tot;for(auto x:que[tot])\n                ans[x.first]=ask(R[p[x.second]])-ask(L[p[x.second]]-1);\n        }\n        else if(ch[i]=='B')add(L[x],-1),x=fa[x];\n        else x=c[x][ch[i]-'a'],add(L[x],1);\n    fur(i,1,m)printf(\"%d\\n\",ans[i]);\n}\n```\n","link":null,"tags":["AC自动机"],"title":"LG 2414 [NOI2011]阿狸的打字机"},{"categories":[["刷题记录"]],"content":"\n设$f(i,j,0\/1,0\/1)$表示第$i$轮的第$j$场,你是否是胜利者的粉丝,是否是失败者的粉丝\n\n可以发现轮数有点像堆,如果轮数从$0$开始编号,第$i$轮的第$j$场由第$i-1$轮的第$2j$场、第$i-1$轮的第$2j+1$场转移而来\n\n\n```cpp\n#include<bits\/stdc++.h>\n#define gc getchar()\n#define fur(i,x,y) for(int i=x;i<=y;++i)\nvoid in(int &x){x=0;char c;bool f=0;for(c=gc;c<'0'||'9'<c;c=gc)f^=c=='-';for(x=c-48,c=gc;'0'<=c&&c<='9';x=x*10+c-48,c=gc);if(f)x=-x;}\nint n,k,f[18][2][2][1<<18];\nbool w[1<<17|1];\nvoid cmax(int &x,int y){if(y>x)x=y;}\nint main(){\n    in(n),in(k);\n    int x;\n    fur(i,1,k)in(x),w[x-1]=1;\n    memset(f,-0x3f,sizeof f);\n    fur(i,0,(1<<n-1)-1)\n        f[1][w[i<<1]][w[i<<1|1]][i]=f[1][w[i<<1|1]][w[i<<1]][i]=w[i<<1]|w[i<<1|1];\n    fur(i,2,n)\n        fur(j,0,(1<<n-i)-1)\n            fur(wl,0,1)fur(ll,0,1)fur(wr,0,1)fur(lr,0,1){\n                int t=f[i-1][wl][ll][j<<1]+f[i-1][wr][lr][j<<1|1];\n                cmax(f[i][wl|wr][ll|lr][j],t+((ll|lr)<<1)+(wl|wr));\n                if(wl|wr)cmax(f[i][wl+wr-1][1][j],t+(ll|lr)+(wl|wr)+1);\n            }\n    x=0;\n    fur(wl,0,1)fur(ll,0,1)cmax(x,f[n][wl][ll][0]+(wl|ll));\n    printf(\"%d\\n\",x);\n}\n```\n","link":null,"tags":["状压dp","动态规划"],"title":"LG CF1310B Double Elimination"},{"categories":[["刷题记录"]],"content":"\n枚举变换情况($6!$),然后`kmp`$\\Theta(n)$判断即可\n```cpp\n#include<bits\/stdc++.h>\nconst int N=125011,inf=2122219134;\nchar s1[N],s2[N];\nint n,m,a[N],b[N],nxt[N],p[6],now,ans[N];\nvoid kmp(){\n    for(int i=1,k=0;i<m;++i){\n        while(k&&b[i]^b[k])k=nxt[k-1];\n        if(b[i]==b[k])++k;\n        nxt[i]=k;\n    }\n    for(int i=0,k=0;i<n;++i){\n        while(k&&a[i]^b[k])k=nxt[k-1];\n        if(a[i]==b[k])++k;\n        if(k==m){\n            if(now<ans[i])ans[i]=now;\n            k=nxt[k-1];\n        }\n    }\n}\nint main(){\n    scanf(\"%s%s\",s1,s2);\n    n=strlen(s1),m=strlen(s2);\n    for(int i=m-1;i<n;++i)ans[i]=-1u>>1;\n    p[5]=5;\n    for(p[0]=0;p[0]<6;++p[0])\n    for(p[1]=1;p[1]<6;++p[1])\n    for(p[2]=2;p[2]<6;++p[2])\n    for(p[3]=3;p[3]<6;++p[3])\n    for(p[4]=4;p[4]<6;++p[4]){\n        for(int i=0;i<n;++i)a[i]=p[s1[i]-'a'];\n        for(int i=0;i<m;++i)b[i]=p[s2[i]-'a'];\n        now=(p[0]>0)+(p[1]>1)+(p[2]>2)+(p[3]>3)+(p[4]>4);\n        kmp();\n    }\n    for(int i=m-1;i<n;++i)printf(\"%d \",ans[i]);\n}\n```\n","link":null,"tags":["kmp","字符串"],"title":"LG CF954I Yet Another String Matching Problem"},{"categories":[["刷题记录"]],"content":"\n容易发现,只要这个点与$1$之间存在某条路径长度($\\le$阶段数)+阶段数为偶数的,那$1$就得提供原材料\n\n我们分别求出长度为奇数、偶数的最短路长度即可判断\n```cpp\n#include<bits\/stdc++.h>\n#define gc getchar()\nvoid in(int &x){x=0;char c;bool f=0;for(c=gc;c<'0'||'9'<c;c=gc)f^=c=='-';for(x=c-48,c=gc;'0'<=c&&c<='9';x=x*10+c-48,c=gc);if(f)x=-x;}\nconst int N=100011;\nint n,cnt,head[N],q[N<<1],d[2][N];\nbool p[N<<1];\nstruct edge{int to,nxt;}e[N<<1];\nvoid add(int x,int y){e[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;}\nvoid bfs(){\n    int h=0,t=1,x;bool v;\n    q[0]=1,p[0]=0,d[0][1]=2;\n    while(h<t){\n        x=q[h],v=p[h++];\n        for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n            if(!d[!v][to])\n                d[!v][to]=d[v][x]+1,\n                q[t]=to,p[t++]=!v;\n    }\n}\nint main(){\n    int m,q,x,y;\n    in(n),in(m),in(q);\n    while(m--)in(x),in(y),add(x,y),add(y,x);\n    bfs();\n    while(q--)\n        in(x),in(y),\n        puts((!d[y&1][x]||d[y&1][x]>y+2)?\"No\":\"Yes\");\n}\n```\n","link":null,"tags":["bfs","最短路"],"title":"LG 5663 加工零件"},{"categories":[["刷题记录"]],"content":"\n可以发现如果要字典序最小,那么就需要让靠前的数字变小\n\n那么最终形成的平均数是递增的\n\n可以用单调栈维护平均数递增\n```cpp\n#include<bits\/stdc++.h>\n#define gc getchar()\n#define fur(i,x,y) for(int i=x;i<=y;++i)\n#define fdr(i,x,y) for(int i=x;i>=y;--i)\nvoid in(int &x){x=0;char c;bool f=0;for(c=gc;c<'0'||'9'<c;c=gc)f^=c=='-';for(x=c-48,c=gc;'0'<=c&&c<='9';x=x*10+c-48,c=gc);if(f)x=-x;}\nconst int N=1000011;\nint n,a[N],t[N],tp,tot;\nlong long s[N],sum;\nint main(){\n    in(n);\n    fur(i,1,n)in(a[i]);\n    s[tp=1]=a[n],t[1]=1;\n    fdr(i,n-1,1){\n        tot=1,sum=a[i];\n        while(tp&&sum*t[tp]>=tot*s[tp])\n            sum+=s[tp],tot+=t[tp],--tp;\n        s[++tp]=sum,t[tp]=tot;\n    }\n    fdr(i,tp,1){\n        double k=1.0*s[i]\/(double)t[i];\n        fur(j,1,t[i])printf(\"%.9f\\n\",k);\n    }\n}\n```\n","link":null,"tags":["后缀和","字典序","单调栈"],"title":"LG CF1299C Water Balance"},{"categories":[["刷题记录"]],"content":"\n交互题\n\n我们从叶子节点开始搜索,把所有叶子节点添加到队列中\n\n每次从队列中弹出两个叶子节点,\n\n如果`lca`为其中一个,那么这个`lca`就是树根\n\n否则删除这两个节点,可能会形成新的叶子节点,加入队列\n\n因为最坏情况下每次都会删掉两个节点,那么重复$\\frac n2$次后,也就只剩下根节点了\n```cpp\n#include<bits\/stdc++.h>\n#define gc getchar()\n#define fur(i,x,y) for(int i=x;i<=y;++i)\nvoid cmin(int &x,int y){if(x>y)x=y;}void cmax(int &x,int y){if(x<y)x=y;}\nvoid in(int &x){x=0;char c;bool f=0;for(c=gc;c<'0'||'9'<c;c=gc)f^=c=='-';for(x=c-48,c=gc;'0'<=c&&c<='9';x=x*10+c-48,c=gc);if(f)x=-x;}\nconst int N=100011,inf=2122219134;\nusing std::list;\nint n,d[N],q[N],h,t;\nlist<int>e[N];\nbool v[N];\nint main(){\n    in(n);\n    int x,y,z;\n    fur(i,2,n)\n        in(x),in(y),\n        e[x].push_back(y),\n        e[y].push_back(x),\n        ++d[x],++d[y];\n    fur(i,1,n)if(d[i]==1)q[t++]=i;\n    fur(i,1,n>>1){\n        x=q[h++],y=q[h++];\n        printf(\"? %d %d\\n\",x,y),fflush(stdout);\n        in(z);\n        if(z==x||z==y)return printf(\"! %d\\n\",z),0;\n        for(int z:e[x])\n            if(!v[z]&&--d[z]==1)q[t++]=z;\n        for(int z:e[y])\n            if(!v[z]&&--d[z]==1)q[t++]=z;\n        v[x]=v[y]=1;\n    }\n    fur(i,1,n)if(!v[i])printf(\"! %d\\n\",i);\n}\n```\n","link":null,"tags":["交互","lca","树"],"title":"LG CF1305D Kuroni and the Celebration"},{"categories":[["刷题记录"]],"content":"\n可以发现有三种路径:\n\n1. $a \\leftrightarrow b$\n   \n2. $a \\leftrightarrow x \\leftrightarrow y \\leftrightarrow b$\n\n3. $a \\leftrightarrow y \\leftrightarrow x \\leftrightarrow b$\n\n只需要判断这三条路径是否满足就可以了\n\n可以发现只要$dis\\le k$而且和$k$同奇偶就是符合的\n\n(比如$x\\leftrightarrow y$可以一直循环,变成$x\\leftrightarrow y \\leftrightarrow x \\leftrightarrow y \\dots$,每次长度$+2$)\n\n\n```cpp\n#include<bits\/stdc++.h>\n#define gc getchar()\n#define fur(i,x,y) for(int i=x;i<=y;++i)\nvoid in(int &x){x=0;char c;bool f=0;for(c=gc;c<'0'||'9'<c;c=gc)f^=c=='-';for(x=c-48,c=gc;'0'<=c&&c<='9';x=x*10+c-48,c=gc);if(f)x=-x;}\nconst int N=100011;\nint n,k,cnt,head[N],d[N],f[N],siz[N],top[N];\nstruct edge{int to,nxt;}e[N<<1];\nvoid add(int x,int y){e[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;}\n#define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\nvoid dfs(int x){\n    siz[x]=1;\n    fl(i,x)if(to!=f[x]){\n        f[to]=x;d[to]=d[x]+1;\n        dfs(to);siz[x]+=siz[to];\n    }\n}\nvoid bt(int x,int tp){\n    top[x]=tp;int k=0;\n    fl(i,x)if(to!=f[x]&&siz[to]>siz[k])k=to;\n    if(!k)return;bt(k,tp);\n    fl(i,x)if(!top[to])bt(to,to);\n}\nint lca(int x,int y){\n    while(top[x]!=top[y])(d[top[x]]>d[top[y]])?(x=f[top[x]]):(y=f[top[y]]);\n    return d[x]<d[y]?x:y;\n}\nint dis(int x,int y){return d[x]+d[y]-2*d[lca(x,y)];}\nbool chk(int x){return x<=k&&(x&1)==(k&1);}\nint main(){\n    in(n);\n    int x,y,a,b,q;\n    fur(i,2,n)in(x),in(y),add(x,y),add(y,x);\n    dfs(1),bt(1,1);\n    in(q);\n    while(q--){\n        in(x),in(y),in(a),in(b),in(k);\n        if(chk(dis(a,b))||chk(dis(a,x)+1+dis(y,b))||chk(dis(a,y)+1+dis(x,b)))puts(\"YES\");\n        else puts(\"NO\");\n    }\n}\n```\n","link":null,"tags":["树","lca"],"title":"LG CF1304E 1-Trees and Queries"},{"categories":[["刷题记录"]],"content":"\n暴力枚举即可\n```cpp\n#include<bits\/stdc++.h>\nint abs(int x){return x<0?-x:x;}\nvoid solve(){\n    int a,b,c,ans=1<<30,lim,res,A,B,C;\n    scanf(\"%d%d%d\",&a,&b,&c);lim=c<<1;\n    for(int i=1;i<=lim;++i)\n        for(int j=i;j<=lim;j+=i)\n            for(int k=j;k<=lim;k+=j){\n                res=abs(a-i)+abs(b-j)+abs(c-k);\n                if(res<ans)ans=res,A=i,B=j,C=k;\n            }\n    printf(\"%d\\n%d %d %d\\n\",ans,A,B,C);\n}\nint main(){\n    int t;scanf(\"%d\",&t);\n    while(t--)solve();\n}\n```\n","link":null,"tags":["暴力","枚举"],"title":"LG CF1311D Three Integers"},{"categories":[["刷题记录"]],"content":"\n可以发现$110\\leftrightarrow 011$相当于$0$前\/后移动了2格,那么每个$0$位置的奇偶性是不变的\n\n而且每个$0$无法移动到下一个$0$的后面\n\n把这些$0$记录到一个序列里,然后通过哈希判断两个子串在序列中对应的部分是否相同\n\n因为子序列的起点奇偶性不同,分别表示以起点为奇数和偶数为标准时哈希得的前缀$0$序列数组。\n```cpp\n#include<cstdio>\nconst int N=200011,P=998244353;\nint n,q,s[N],b[N],h[N],H[N];\nchar a[N];\nint get(int l,int r){\n    int*g=(l&1)?h:H;\n    return (g[r]-1ll*g[l-1]*b[s[r]-s[l-1]]%P+P)%P;\n}\nint main(){\n    scanf(\"%d%s%d\",&n,a+1,&q);\n    b[0]=1;\n    for(int i=1;i<=n;++i){\n        b[i]=23ll*b[i-1]%P;\n        s[i]=s[i-1]+(a[i]==48);\n        if(a[i]==48)\n            h[i]=(23ll*h[i-1]+1+(i&1))%P,\n            H[i]=(23ll*H[i-1]+1+(i&1^1))%P;\n        else h[i]=h[i-1],H[i]=H[i-1];\n    }\n    while(q--){\n        int x,y,w;\n        scanf(\"%d%d%d\",&x,&y,&w);\n        printf(get(x,x+w-1)==get(y,y+w-1)?\"Yes\\n\":\"No\\n\");\n    }\n}\n```\n","link":null,"tags":["哈希"],"title":"LG CF1320D Reachable Strings"},{"categories":[["刷题记录"]],"content":"\n$$\nans={n\\choose w_1}\\cdot {n-w_1\\choose w_2}\\cdot {n-w_1-w_2\\choose w_3}\\cdots {n-w_1-w_2-\\dots -w_{m-1}\\choose w_m}\n$$\n\n套扩展卢卡斯即可\n```cpp\n#include<bits\/stdc++.h>\n#define gc getchar()\n#define fur(i,x,y) for(int i=x;i<=y;++i)\nvoid in(int &x){x=0;char c;bool f=0;for(c=gc;c<'0'||'9'<c;c=gc)f^=c=='-';for(x=c-48,c=gc;'0'<=c&&c<='9';x=x*10+c-48,c=gc);if(f)x=-x;}\nconst int N=100011;\nint P,lim,w[N],pi[N],pk[N],cnt;\nint pw(int x,int b,int p){\n    int res=1;\n    while(b){\n        if(b&1)res=1ll*res*x%p;\n        b>>=1,x=1ll*x*x%p;\n    }\n    return res;\n}\nvoid exgcd(int a,int b,int&x,int&y){\n    if(!b){x=1,y=0;return;}\n    exgcd(b,a%b,y,x);\n    y-=a\/b*x;\n}\nint inv(int v,int p){\n    int x,y;\n    exgcd(v,p,x,y);\n    return (x+=p)>p?x-p:x;\n}\nint crt(int v,int p){return 1ll*v*inv(P\/p,p)%P*(P\/p)%P;}\nint fac(int n,int pi,int pk){\n    if(!n)return 1;\n    int res=1;\n    fur(i,2,pk)\n        if(i%pi)res=1ll*res*i%pk;\n    res=pw(res,n\/pk,pk);\n    fur(i,2,n%pk)\n        if(i%pi)res=1ll*res*i%pk;\n    return 1ll*res*fac(n\/pi,pi,pk)%pk;\n}\nint C(int n,int m,int pi,int pk){\n    if(m>n)return 0;\n    int cnt=0;\n    for(int i=n;i;i\/=pi)cnt+=i\/pi;\n    for(int i=m;i;i\/=pi)cnt-=i\/pi;\n    for(int i=n-m;i;i\/=pi)cnt-=i\/pi;\n    return 1ll*pw(pi,cnt,pk)*fac(n,pi,pk)%P\n              *inv(fac(m,pi,pk),pk)%P*inv(fac(n-m,pi,pk),pk)%P;\n}\nint main(){\n    int n,m,sum=0,t,ans=1,res;\n    in(P),in(n),in(m),lim=sqrt(P);\n    fur(i,1,m)in(w[i]),sum+=w[i];\n    if(sum>n)return printf(\"Impossible\"),0;\n    t=P;\n    fur(i,2,lim)if(t%i==0){\n        pi[++cnt]=i;pk[cnt]=1;\n        while(t%i==0)pk[cnt]*=i,t\/=i;\n    }\n    if(t>1)pi[++cnt]=t,pk[cnt]=t;\n    fur(i,1,m){\n        res=0;\n        fur(j,1,cnt)res=(res+crt(C(n,w[i],pi[j],pk[j]),pk[j]))%P;\n        ans=1ll*ans*res%P;\n        n-=w[i];\n    }\n    printf(\"%d\\n\",ans);\n}\n```\n","link":null,"tags":["exlucas","数论"],"title":"LG 2183 [国家集训队]礼物"},{"categories":[["刷题记录"]],"content":"\n设$p=p_1^{k_1}p_2^{k_2}\\dots p_n^{k_n}$\n\n求出每个${n\\choose m} \\equiv a_i \\pmod {p_i^{k_i}}$\n\n\n得到同余方程组\n\n$$\n\\begin{cases}\n{n\\choose m} \\equiv a_1 \\pmod {p_1^{k_1}}\n\\\\\n{n\\choose m} \\equiv a_2 \\pmod {p_2^{k_2}}\n\\\\\n\\vdots\n\\\\\n{n\\choose m} \\equiv a_n \\pmod {p_n^{k_n}}\n\\end{cases}\n$$\n\n使用`crt`即可求出$n\\choose m$的值\n\n$p^t$不是质数,那么如何求${n\\choose m} \\mod p^t$呢?\n\n可以计算${n\\choose m}=\\frac{n!}{m!(n-m)!}$,分别计算出$n!,m!,(n-m)!$在模$p^t$意义下的值\n\n假设$p=3,t=2,n=19$,\n\n$$\nn!=1\\cdot 2\\cdot 3\\cdots 19\n\\\\\n=(1\\cdot 2\\cdot 4\\cdot 5\\cdot 7\\cdot 8\\cdot 10\\cdot 11\\cdot 13\\cdot 14\\cdot 16\\cdot 17\\cdot 19)\\cdot (3\\cdot 6\\cdot 9\\cdot 12\\cdot 15\\cdot 18)\n\\\\ \n=(1\\cdot 2\\cdot 4\\cdot 5\\cdot 7\\cdot 8\\cdot 10\\cdot 11\\cdot 13\\cdot 14\\cdot 16\\cdot 17\\cdot 19)\\cdot 3^6\\cdot(1\\cdot2\\cdot3\\cdot4\\cdot5\\cdot6)\n$$\n\n可以发现后面的部分相当于$\\left\\lfloor \\frac np \\right\\rfloor!$,递归计算即可\n\n前半部分以$p^t$为周期,即\n\n$1\\cdot 2\\cdot 4\\cdot 5\\cdot 7\\cdot 8 \\equiv 10\\cdot 11\\cdot 13\\cdot 14\\cdot 16\\cdot 17 \\pmod {3^2}$\n\n只需要计算不满足周期的数$19$就可以了\n\n\n\n```cpp\n#include<bits\/stdc++.h>\ntypedef long long ll;\nint lim;\nll P;\nll pw(ll x,ll b,ll p){\n    ll res=1;\n    while(b){\n        if(b&1)res=res*x%p;\n        b>>=1,x=x*x%p;\n    }\n    return res;\n}\nvoid exgcd(ll a,ll b,ll &x,ll &y){\n    if(!b){x=1,y=0;return;}\n    exgcd(b,a%b,x,y);\n    ll t=x;x=y,y=t-a\/b*y;\n}\nll inv(ll v,ll p){\n    ll x,y;\n    exgcd(v,p,x,y);\n    return (x+=p)>p?x-p:x;\n}\nll crt(ll v,ll p){return v*inv(P\/p,p)%P*(P\/p)%P;}\nll fac(ll n,ll p,ll pk){\n    if(!n)return 1;\n    ll res=1;\n    for(int i=2;i<=pk;++i)\n        if(i%p)res=res*i%pk;\n    res=pw(res,n\/pk,pk);\n    for(int i=2;i<=n%pk;++i)\n        if(i%p)res=res*i%pk;\n    return res*fac(n\/p,p,pk)%pk;\n}\nll C(ll n,ll m,ll p,ll pk){\n    ll cnt=0;\n    for(ll i=n;i;i\/=p)cnt+=i\/p;\n    for(ll i=m;i;i\/=p)cnt-=i\/p;\n    for(ll i=n-m;i;i\/=p)cnt-=i\/p;\n    return pw(p,cnt,pk)*fac(n,p,pk)%pk*inv(fac(m,p,pk),pk)%pk*inv(fac(n-m,p,pk),pk)%pk;\n}\nll exlucas(ll n,ll m){\n    ll res=0,t=P,pk;\n    for(int i=2;i<=lim;++i)\n    if(t%i==0){\n        pk=1;while(t%i==0)pk*=i,t\/=i;\n        res=(res+crt(C(n,m,i,pk),pk))%P;\n    }\n    if(t>1)res=(res+crt(C(n,m,t,t),t))%P;\n    return res;\n}\nint main(){\n    ll n,m;\n    scanf(\"%lld%lld%lld\",&n,&m,&P);lim=sqrt(P)+1;\n    printf(\"%lld\\n\",exlucas(n,m));\n}\n```\n","link":null,"tags":["数论","模板"],"title":"LG 4720 【模板】扩展卢卡斯"},{"categories":[["刷题记录"]],"content":"\n可以发现答案是递减的\n\n每个$q_i$相当于破坏掉$[1,q_i]$的最大值\n\n那么我们把$[1,q_i]$区间$-1$\n\n将最大值变为$p_k$的时候,相当于$[1,k]$的最大值都变成了$p_k$\n\n那么把$[1,k]$区间$+1$\n\n每次询问的时候,一直将当前最大值$-1$,应用变化,直到区间最大值大于$0$,输出答案\n\n具体看代码\n```cpp\n#include<bits\/stdc++.h>\n#define fur(i,x,y) for(int i(x);i<=y;++i)\nint max(int x,int y){return x>y?x:y;}\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}void out(const char* s){while(*s)pt(*s++);}void out(char* s){while(*s)pt(*s++);}void out(char c){pt(c);}template<typename T>void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\nconst int N=300011;\n#define ls rt<<1\n#define rs rt<<1|1\nint n,a[N],p[N],s[N<<2],laz[N<<2];\nvoid pd(int rt){\n    if(laz[rt]){\n        laz[ls]+=laz[rt];\n        laz[rs]+=laz[rt];\n        s[ls]+=laz[rt];\n        s[rs]+=laz[rt];\n        laz[rt]=0;\n    }\n}\nvoid upd(int L,int R,int v,int l=1,int r=n,int rt=1){\n    if(L<=l&&r<=R){s[rt]+=v,laz[rt]+=v;return;}\n    int m=l+r>>1;pd(rt);\n    if(L<=m)upd(L,R,v,l,m,ls);\n    if(R>m)upd(L,R,v,m+1,r,rs);\n    s[rt]=max(s[ls],s[rs]);\n}\nint main(){\n    in(n);\n    fur(i,1,n)in(a[i]),p[a[i]]=i;\n    upd(1,p[n],1);\n    int x,res=n;out(n,\" \");\n    fur(i,1,n-1){\n        in(x);\n        upd(1,x,-1);\n        while(s[1]<=0)upd(1,p[--res],1);\n        out(res,\" \");\n    }in(x);\n    flush();\n}\n```\n","link":null,"tags":["线段树"],"title":"LG CF1326E Bombs"},{"categories":[["刷题记录"]],"content":"\n首先把连接所有$i\\rightarrow p_i$,可以得到若干个环\n\n每$k$次$p_i=p_{p_i}$后会让$i$指向环上从$i$数起的$k+1$个点\n\n只需要让一个环满足条件既可以,我们可以对每个环分别处理,然后答案取$\\min$\n\n可以发现假设一个环长度为$l$,若$k$可行,那么$\\gcd(k,l)$也是可行的\n\n我们判断是否存在$0\\le t < \\gcd(k,l)$,使环上所有模$\\gcd(k,l)$等于$t$的点的颜色都相同就可以了\n```cpp\n#include<bits\/stdc++.h>\n#define gc getchar()\n#define fur(i,x,y) for(int i=x;i<=y;++i)\nvoid cmin(int &x,int y){if(x>y)x=y;}\nvoid in(int &x){x=0;char c;bool f=0;for(c=gc;c<'0'||'9'<c;c=gc)f^=c=='-';for(x=c-48,c=gc;'0'<=c&&c<='9';x=x*10+c-48,c=gc);if(f)x=-x;}\nconst int N=200011;\nbool v[N];\nint n,c[N],p[N],a[N],cnt,ans,d[N],tot;\nint solve(){\n    tot=0;\n    for(int i=1;1ll*i*i<=cnt;++i)\n        if(cnt%i==0){\n            d[++tot]=i;\n            if(i*i!=cnt)d[++tot]=cnt\/i;\n        }\n    std::sort(d+1,d+tot+1);\n    fur(t,1,tot)\n        fur(i,0,d[t]-1){\n            for(int j=i;j<cnt;j+=d[t])\n                if(a[i]!=a[j])goto ski;\n            return d[t];\n            ski:;\n        }\n    return cnt;\n}\nint main(){\n    int T;in(T);\n    while(T--){\n        in(n),ans=n;\n        fur(i,1,n)in(p[i]),v[i]=0;\n        fur(i,1,n)in(c[i]);\n        fur(i,1,n)if(!v[i]){\n            a[0]=c[i];v[i]=1;cnt=1;\n            for(int j=p[i];j!=i;j=p[j])a[cnt++]=c[j],v[j]=1;\n            cmin(ans,solve());\n        }\n        printf(\"%d\\n\",ans);\n    }\n}\n```\n","link":null,"tags":["图论"],"title":"LG CF1327D inftyite Path"},{"categories":[["刷题记录"]],"content":"\n可以发现,这条链必然经过每个给定点的父亲\n\n把每个给定点都变成它的父亲\n\n按深度排序\n\n依次判断接下来的节点是否在上一个的子树中即可\n```cpp\n#include<bits\/stdc++.h>\n#define gc getchar()\n#define fur(i,x,y) for(int i=x;i<=y;++i)\nvoid in(int &x){x=0;char c;bool f=0;for(c=gc;c<'0'||'9'<c;c=gc)f^=c=='-';for(x=c-48,c=gc;'0'<=c&&c<='9';x=x*10+c-48,c=gc);if(f)x=-x;}\nconst int N=200011;\nint n,q,cnt,head[N],a[N],f[N],d[N],L[N],R[N],dfn;\nbool cmp(int x,int y){return d[x]<d[y];}\nstruct edge{int to,nxt;}e[N<<1];\nvoid add(int x,int y){e[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;}\nvoid dfs(int x){\n    L[x]=++dfn,d[x]=d[f[x]]+1;\n    for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n        if(to^f[x])f[to]=x,dfs(to);\n    R[x]=dfn;\n}\nbool chk(int x,int y){return L[x]<=L[y]&&L[y]<=R[x];}\nint main(){\n    in(n),in(q);\n    int x,y,ff;\n    fur(i,2,n)in(x),in(y),add(x,y),add(y,x);\n    f[1]=1,dfs(1);\n    while(q--){\n        in(y);\n        fur(i,1,y)in(x),a[i]=f[x];\n        std::sort(a+1,a+y+1,cmp);\n        ff=1;\n        fur(i,1,y-1)if(!chk(a[i],a[i+1])){ff=0;break;}\n        puts(ff?\"YES\":\"NO\");\n    }\n}\n```\n","link":null,"tags":["树"],"title":"LG CF1328E Tree Queries"},{"categories":[["刷题记录"]],"content":"\n很妙的构造题\n\n首先,可以发现异或和明显不大于总和\n\n第二,如果异或和与总和的奇偶不同,那么无解(二进制下最低位不同,没法用进位来填充)\n\n剩下的就都可以构造了\n\n当$u=v$的时候,输出$u$就可以了,当$u=0$的时候记得特判\n\n设$x=\\frac{u+v}2$\n\n那么$\\left\\{x,x,u\\right\\}$就一定可以满足\n\n如果$x \\And u=0$的时候$\\left\\{x,u\\right\\}$等价于$\\left\\{x+u\\right\\}$\n\n那么$\\left\\{x,x+u\\right\\}$可以满足\n```cpp\n#include<bits\/stdc++.h>\nint main(){\n    long long a,b,x;scanf(\"%lld%lld\",&a,&b);\n    if(a>b||(a&1)!=(b&1))return printf(\"-1\\n\"),0;\n    if(a==b){\n        if(!a)printf(\"0\\n\");\n        else printf(\"1\\n%lld\\n\",a);\n    }\n    else{\n        x=b-a>>1;\n        if(x&a)printf(\"3\\n%lld %lld %lld\\n\",x,x,a);\n        else printf(\"2\\n%lld %lld\\n\",x,a|x);\n    }\n}\n```\n","link":null,"tags":["异或","位运算","构造"],"title":"LG CF1325D Ehab the Xorcist"},{"categories":[["刷题记录"]],"content":"\n首先我们可以只保留每个数奇数次幂的因子\n\n第二,根据约数个数定理,因为每个数的约数不超过7,所以最多只有两个质因子\n\n可以把选择一个数看成在这两个质因子之间的连边\n\n如果只有一个,那么把$1$作为另一个质因子\n\n于是我们得到一张图\n\n乘积为完全平方,也就是每个质因子都是偶数次幂,那么再最终的图中它的入度为偶数\n\n那就是说我们要找这个无向图中的最小环\n\n\n\n\n```cpp\n#include<bits\/stdc++.h>\n#define gc getchar()\n#define fur(i,x,y) for(int i=x;i<=y;++i)\nvoid cmin(int &x,int y){if(x>y)x=y;}\nvoid in(int &x){x=0;char c;bool f=0;for(c=gc;c<'0'||'9'<c;c=gc)f^=c=='-';for(x=c-48,c=gc;'0'<=c&&c<='9';x=x*10+c-48,c=gc);if(f)x=-x;}\nconst int N=1000011,inf=2122219134;\nbool f[N];\nint cnt,pri[N],id[N],head[N],tt=1,S;\nvoid ol(int n){\n    pri[cnt=1]=id[1]=S=1;\n    fur(i,2,n){\n        if(!f[i])pri[++cnt]=i,id[i]=cnt,S+=(i<=999);\n        for(int j=2;j<=cnt&&i*pri[j]<=n;++j){\n            f[i*pri[j]]=1;\n            \/\/ if(i%pri[j]==0)break;\n        }\n    }\n}\nstruct edge{int to,nxt;}e[N];\nvoid add(int x,int y){\n    e[++tt].to=y,e[tt].nxt=head[x],head[x]=tt;\n    e[++tt].to=x,e[tt].nxt=head[y],head[y]=tt;\n}\nint q[N],p[N],d[N];\nint bfs(int x){\n    fur(i,1,78500)d[i]=inf;\n    int h=0,t=1,pre,sz=inf;\n    q[0]=x;d[x]=0;\n    while(h<t){\n        x=q[h],pre=p[h++];\n        for(int i=head[x],to;to=e[i].to,i&&i!=pre;i=e[i].nxt)\n        if(d[to]==inf){\n            d[to]=d[x]+1;\n            q[t]=to,p[t++]=i^1;\n        }\n        else cmin(sz,d[x]+d[to]+1);\n    }\n    return sz;\n}\nint main(){\n    int n;in(n);\n    ol(1000000);\n    int x,a[2];\n    fur(i,1,n){\n        in(x);\n        int tot=0;\n        for(int j=2,t;j<=cnt&&(t=pri[j]*pri[j])<=x;++j)\n        if(x%pri[j]==0){\n            while(x%t==0)x\/=t;\n            if(x%pri[j]==0)a[tot++]=j,x\/=pri[j];\n        }\n        if(x>1)a[tot++]=id[x],x=1;\n        if(!tot)return printf(\"1\\n\"),0;\n        else if(tot==1)add(1,a[0]);\n        else add(a[0],a[1]);\n    }\n    int ans=inf;\n    fur(i,1,S)cmin(ans,bfs(i));\n    if(ans==inf)ans=-1;\n    printf(\"%d\\n\",ans);\n}\n```\n","link":null,"tags":["数论","图论","最小环"],"title":"LG CF1325E Ehab's REAL Number Theory Problem"},{"categories":[["刷题记录"]],"content":"\n两次dfs即可\n\n第一次dfs: \n\n计算出每个点的子树,包含这个点,答案最大是多少\n\n显然$S_x=v_x+\\sum\\limits_{y\\in son_x} [S_y>0]S_y$\n\n(若$x$为黑点$v_x=-1$,否则$v_x=1$)\n\n第二次dfs:\n\n通过$x$的父亲的答案来计算出$x$的答案\n\n如果$x$目前的答案$>0$,则从$x$的答案减去$x$目前的答案\n\n如果这个结果$>0$,那么$x$的答案加上这个结果\n\n感觉直接看代码可能更直观\n```cpp\n#include<bits\/stdc++.h>\n#define gc getchar()\n#define fur(i,x,y) for(int i=x;i<=y;++i)\nvoid in(int &x){x=0;char c;bool f=0;for(c=gc;c<'0'||'9'<c;c=gc)f^=c=='-';for(x=c-48,c=gc;'0'<=c&&c<='9';x=x*10+c-48,c=gc);if(f)x=-x;}\nconst int N=200011;\nint n,cnt,head[N],s[N];\nstruct edge{int to,nxt;}e[N<<1];\nvoid add(int x,int y){e[++cnt].to=y,e[cnt].nxt=head[x];head[x]=cnt;}\nvoid dfs(int x,int f){\n    for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n        if(to^f){dfs(to,x);if(s[to]>0)s[x]+=s[to];}\n}\nvoid up(int x,int f){\n    int t=s[f];if(s[x]>0)t-=s[x];\n    if(t>0)s[x]+=t;\n    for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n        if(to^f)up(to,x);\n}\nint main(){\n    in(n);\n    int x,y;\n    fur(i,1,n)in(x),s[i]=x?1:-1;\n    fur(i,1,n-1)in(x),in(y),add(x,y),add(y,x);\n    dfs(1,0);up(1,0);\n    fur(i,1,n)printf(\"%d \",s[i]);\n}\n```\n","link":null,"tags":["树型dp","dfs"],"title":"LG CF1324F Maximum White Subtree"},{"categories":[["刷题记录"]],"content":"\n设$f_{i,j}$表示前$i$个点,第$i$个点的覆盖状态为$j$($j$为$8$位二进制数)\n\n\n```cpp\n#include<bits\/stdc++.h>\n#define gc getchar()\n#define fur(i,x,y) for(int i=x;i<=y;++i)\nvoid in(int &x){x=0;char c;bool f=0;for(c=gc;c<'0'||'9'<c;c=gc)f^=c=='-';for(x=c-48,c=gc;'0'<=c&&c<='9';x=x*10+c-48,c=gc);if(f)x=-x;}\nconst int N=200011;\nint n,cnt,head[N],s[N];\nstruct edge{int to,nxt;}e[N<<1];\nvoid add(int x,int y){e[++cnt].to=y,e[cnt].nxt=head[x];head[x]=cnt;}\nvoid dfs(int x,int f){\n    for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n        if(to^f){dfs(to,x);if(s[to]>0)s[x]+=s[to];}\n}\nvoid up(int x,int f){\n    int t=s[f];if(s[x]>0)t-=s[x];\n    if(t>0)s[x]+=t;\n    for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n        if(to^f)up(to,x);\n}\nint main(){\n    in(n);\n    int x,y;\n    fur(i,1,n)in(x),s[i]=x?1:-1;\n    fur(i,1,n-1)in(x),in(y),add(x,y),add(y,x);\n    dfs(1,0);up(1,0);\n    fur(i,1,n)printf(\"%d \",s[i]);\n}\n```\n","link":null,"tags":["状压dp","动态规划"],"title":"LG CF1313D Happy New Year"},{"categories":[["刷题记录"]],"content":"\n建立新数$c$,使$c_i=a_i-b_i$\n\n那么就是要找多少对$i<j$且$c_i>c_j$\n\n将$c$排序,然后双指针统计一下就可以了\n```cpp\n#include<bits\/stdc++.h>\nint n,a[200001];\nint main(){\n    scanf(\"%d\",&n);\n    int x;long long ans=0;\n    for(int i=1;i<=n;++i)scanf(\"%d\",a+i);\n    for(int i=1;i<=n;++i)scanf(\"%d\",&x),a[i]-=x;\n    std::sort(a+1,a+n+1,std::greater<int>());\n    x=n;\n    for(int i=1;i<=n;++i){\n        while(a[x]+a[i]<=0&&x>i)--x;\n        if(a[x]+a[i]>0)ans+=x-i;\n        else break;\n    }\n    printf(\"%lld\\n\",ans);\n}\n```\n","link":null,"tags":["排序","双指针"],"title":"LG CF1324D Pair of Topics"},{"categories":[["刷题记录"]],"content":"\n首先,确定最大值和唯一一对的相同的元素\n\n这对元素分别放在最大值的左边和右边\n\n剩下的$n-3$个元素,有两种选择:\n\n1. 放在最大值左边\n2. 放在最大值右边\n\n那么就有$2^{n-3}$种方案\n\n从$[1,m]$中选取$n-1$个不相同的元素,有$m \\choose {n-1}$种方案\n\n接着在这$n-1$个元素中选取一个非最大值的元素作为唯一相同那一对,有$n-2$种方案\n\n那么最终答案就是$2^{n-3} \\times {m \\choose{n-1}} \\times (n-2)$\n\n```cpp\n#include<bits\/stdc++.h>\nconst int P=998244353;\nint pw(int x,int b){\n    int res=1;\n    while(b){\n        if(b&1)res=1ll*res*x%P;\n        b>>=1,x=1ll*x*x%P;\n    }\n    return res;\n}\nint fac(int x){\n    int ans=1;\n    for(int i=2;i<=x;++i)ans=1ll*ans*i%P;\n    return ans;\n}\nint C(int n,int m){\n    if(n<m)return 0;\n    return 1ll*fac(n)*pw(fac(m),P-2)%P*pw(fac(n-m),P-2)%P;\n}\nint main(){\n    int n,m;\n    scanf(\"%d%d\",&n,&m);\n    if(n<=2){printf(\"0\\n\");return 0;}\n    printf(\"%d\\n\",1ll*pw(2,n-3)*C(m,n-1)%P*(n-2)%P);\n}\n```\n","link":null,"tags":["数论","组合数"],"title":"LG CF1312D Count the Arrays"},{"categories":[["刷题记录"]],"content":"\n看到$n\\le 500$容易想到是区间dp\n\n设$f(i,j)$为$[i,j]$合并后的最小长度,$w(i,j)$为合并后的和\n\n$f(i,j)=\\min\\left\\{ f(i,k)+f(k+1,j)\\right\\}$\n\n当$f(i,k)=f(k+1,j)=1$且$w(i,k)=w(k+1,j)$时,合并即可\n\n```cpp\n#include<bits\/stdc++.h>\ntypedef long long ll;typedef unsigned long long ull;typedef double db;typedef short sht;\n#define fur(i,x,y) for(int i(x);i<=y;++i)\nvoid cmin(int &x,int y){if(x>y)x=y;}\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}void out(const char* s){while(*s)pt(*s++);}void out(char* s){while(*s)pt(*s++);}void out(char c){pt(c);}template<typename T>void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\nconst int N=511;\nint n,a[N],f[N][N],w[N][N];\nint main(){\n    in(n);\n    fur(i,1,n)in(a[i]),f[i][i]=1,w[i][i]=a[i];\n    fur(i,2,n)\n        fur(l,1,n-i+1){\n            int r=l+i-1;f[l][r]=r-l+1;\n            fur(k,l,r-1)\n                if(f[l][k]==1&&f[k+1][r]==1&&w[l][k]==w[k+1][r]){\n                    f[l][r]=1,w[l][r]=w[l][k]+1;\n                    break;\n                }\n                else cmin(f[l][r],f[l][k]+f[k+1][r]);\n        }\n    printf(\"%d\\n\",f[1][n]);\n}\n```\n","link":null,"tags":["动态规划","区间dp"],"title":"LG CF1312E Array Shrinking"},{"categories":[["刷题记录"]],"content":"\n枚举右端点$r$,当前颜色$x$\n\n设$lst_x$为颜色$x$上一次出现的位置\n\n假设我们已经得知了$f(l,r-1),l\\in [1,r-1]$\n\n那么$f(l,r),l\\in [lst_x+1,r]=f(l,r-1)+1$\n\n也就是说我们把$[lst_x+1,r]$区间$+1$就可以了\n\n于是这题就变成了线段树(或树状数组)维护区间平方和\n```cpp\n#include<bits\/stdc++.h>\n#pragma GCC optimize(3)\n#define il __inline__ __attribute__ ((always_inline))\ntypedef long long ll;typedef unsigned long long ull;typedef double db;typedef short sht;\n#define fur(i,x,y) for(int i(x);i<=y;++i)\n#define fdr(i,x,y) for(int i(x);i>=y;--i)\n#define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n#define l2(n) ((int)(log2(n)))\ntemplate <class T>T ABS(T x){return x>0?x:-x;}\ntemplate <class T>T MAX(T x,T y){return x>y?x:y;}\ntemplate <class T>T MIN(T x,T y){return x<y?x:y;}\ntemplate <class T>T GCD(T x,T y){return y?GCD(y,x%y):x;}\ntemplate <class T>void SWAP(T &x,T &y){T t=x;x=y;y=t;}\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}void out(const char* s){while(*s)pt(*s++);}void out(char* s){while(*s)pt(*s++);}void out(char c){pt(c);}template<typename T>void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\nconst int N=1000011,inf=2122219134;\nint n;\n__int128 s[N<<2],sq[N<<2],laz[N<<2],ans;\n#define ls rt<<1\n#define rs rt<<1|1\n#include<bits\/extc++.h>\nusing namespace __gnu_pbds;\ngp_hash_table<int,int>lst;\nvoid add(int rt,ull v,int len){\n    sq[rt]+=2*s[rt]*v+v*v*len;\n    s[rt]+=v*len;\n}\nvoid pd(int rt,int ln,int rn){\n    if(laz[rt]){\n        laz[ls]+=laz[rt];\n        laz[rs]+=laz[rt];\n        add(ls,laz[rt],ln);\n        add(rs,laz[rt],rn);\n        laz[rt]=0;\n    }\n}\nvoid upd(int L,int R,int l,int r,int rt){\n    if(L<=l&&r<=R){\n        add(rt,1,r-l+1);++laz[rt];\n        return;\n    }\n    int m=(l+r)>>1;\n    pd(rt,m-l+1,r-m);\n    if(L<=m)upd(L,R,l,m,ls);\n    if(R>m)upd(L,R,m+1,r,rs);\n    s[rt]=s[ls]+s[rs];\n    sq[rt]=sq[ls]+sq[rs];\n}\nint main(){\n    in(n);\n    int x;\n    fur(i,1,n){\n        in(x);\n        upd(lst[x]+1,i,1,n,1);\n        lst[x]=i;\n        ans+=sq[1];\n    }\n    printf(\"%d\\n\",ans%1000000007);\n}\n```\n","link":null,"tags":["线段树","计数","树状数组"],"title":"LG 6477 [NOI Online]子序列问题"},{"categories":[["刷题记录"]],"content":"\n```cpp\n#include<bits\/stdc++.h>\n#define fur(i,x,y) for(int i(x);i<=y;++i)\n#define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n#define Fl(i,x) for(int i(Head[x]),to;to=e[i].to,i;i=e[i].nxt)\nvoid cmin(int &x,int y){if(x>y)x=y;}\nvoid cmax(int &x,int y){if(x<y)x=y;}\nconst int N=80011;\nint n,m,cnt,ans,head[N],Head[N],bl[N],c[N],f[N];\nstruct edge{\n    int x,to,nxt,w;\n    double k;\n}e[200011];\nvoid add(int x,int y,int w,double k){\n    e[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;e[cnt].w=w,e[cnt].k=k;e[cnt].x=x;\n}\nvoid addd(int x,int y,int w){\n    e[++cnt].to=y;e[cnt].nxt=Head[x];Head[x]=cnt;e[cnt].w=w;\n}\nint dfn[N],low[N],sz,q[N*2],tp,id=1;\nbool v[N];\nvoid tarjan(int x){\n    dfn[x]=low[x]=++sz;\n    v[x]=1;q[++tp]=x;\n    fl(i,x)\n    if(!dfn[to])tarjan(to),cmin(low[x],low[to]);\n    else if(v[to])cmin(low[x],dfn[to]);\n    if(low[x]==dfn[x]){\n        ++id;\n        while(int k=q[tp--]){\n            bl[k]=id,v[k]=0;\n            if(k==x){++id;break;}\n        }\n    }\n}\nint main(){\n    scanf(\"%d%d\",&n,&m);\n    int x,y,w,h=0,t=1;double k;\n    fur(i,1,m)scanf(\"%d%d%d%lf\",&x,&y,&w,&k),add(x,y,w,k);\n    fur(i,1,n)if(!dfn[i])tarjan(i);\n    cnt=0;\n    fur(i,1,m){\n        x=bl[e[i].x],y=bl[e[i].to];\n        if(x==y){\n            w=e[i].w;\n            while(w){\n                c[x]+=w;\n                w=int(w*e[i].k);\n            }\n        }\n        else addd(x,y,e[i].w);\n    }\n    scanf(\"%d\",&x);q[0]=x=bl[x];\n    f[x]=c[x];\n    while(h<t){\n        v[x=q[h++]]=0;\n        Fl(i,x)if(f[x]+e[i].w+c[to]>f[to]){\n            f[to]=f[x]+e[i].w+c[to];\n            if(!v[to])q[t++]=to,v[to]=1;\n        }\n    }\n    fur(i,1,id)cmax(ans,f[i]);\n    printf(\"%d\\n\",ans);\n}\n```\n","link":null,"tags":["tarjan","动态规划"],"title":"LG 2656 采蘑菇"},{"categories":[["刷题记录"]],"content":"\n## 线段树分治+`LCT`\n\n一个非常暴力的思路\n\nFBI WARNING: 极有可能因为常数巨大而超时\n\n把询问(修改)时间看成序列,每条边在这个序列上的一段区间出现\n\n```cpp\n#include<bits\/stdc++.h>\n#define il __inline__ __attribute__ ((always_inline))\n#define fur(i,x,y) for(int i(x);i<=y;++i)\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}void out(const char* s){while(*s)pt(*s++);}void out(char* s){while(*s)pt(*s++);}void out(char c){pt(c);}template<typename T>void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\nconst int M=50011;\nint n,m,q,tot,cnt,lst[M],pos[M],head[M<<2];\nstruct node{int x,y,w;}a[M<<2];\nstruct edge{int to,nxt;}e[M<<4];\nil void add(int x,int y){e[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;}\n\/* LCT START*\/\nint f[M<<2],c[2][M<<2],v[M<<2],mx[M<<2];\nbool rev[M<<2];\n#define ls c[0][x]\n#define rs c[1][x]\nil void pu(int x){\n    mx[x]=x;\n    if(ls&&v[mx[ls]]>v[mx[x]])mx[x]=mx[ls];\n    if(rs&&v[mx[rs]]>v[mx[x]])mx[x]=mx[rs];\n}\nil void pd(int x){\n    if(rev[x])\n        rev[ls]^=1,rev[rs]^=1,\n        ls^=rs,rs^=ls,ls^=rs,\n        rev[x]=0;\n}\nil int g(int x){return c[1][f[x]]==x;}\nil int nrt(int x){return c[0][f[x]]==x||c[1][f[x]]==x;}\nil void rotate(int x){\n    int y=f[x],z=f[y],l=g(x),r=!l,w=c[r][x];\n    if(nrt(y))c[g(y)][z]=x;\n    c[r][x]=y,c[l][y]=w;\n    if(w)f[w]=y;\n    f[x]=z,f[y]=x;\n    pu(y);\n}\nvoid pda(int x){if(nrt(x))pda(f[x]);pd(x);}\nil void splay(int x){\n    \/\/ for(pda(x);nrt(x);rotate(x))if(nrt(f[x]))\n        \/\/ rotate(g(x)^g(f[x])?x:f[x]);\n    for(pda(x);nrt(x);rotate(x));\/\/这题单旋更快\n    pu(x);\n}\nil void access(int x){\n    for(int y=0;x;x=f[y=x])\n        splay(x),rs=y,pu(x);\n}\nil void mrt(int x){access(x),splay(x),rev[x]^=1;}\nil int frt(int x){\n    for(access(x),splay(x);ls;pd(x),x=ls);\n    splay(x);return x;\n}\n\/* LCT END *\/\nvoid upd(int L,int R,int v,int l,int r,int rt){\n    if(L<=l&&r<=R){add(rt,v);return;}\n    int m=l+r>>1;\n    if(L<=m)upd(L,R,v,l,m,rt<<1);\n    if(R>m)upd(L,R,v,m+1,r,rt<<1|1);\n}\nil void link(int x,int y){mrt(x),f[x]=y;}\nil void spl(int x,int y){mrt(x),access(y),splay(y);}\nil void cut(int x,int y){spl(x,y),f[x]=c[0][y]=0,pu(y);}\nint st[M<<2],tp=0;\nlong long ans;\nbool typ[M<<2];\nvoid div(int l,int r,int rt){\n    int x,y,w,bg=tp,to,m=l+r>>1;\n    for(int i=head[rt];i;i=e[i].nxt){\n        to=e[i].to,x=a[to].x,y=a[to].y,w=a[to].w;\n        if(frt(x)==frt(y)){\n            spl(x,y);\n            int p=mx[y];\n            if(v[p]>w){\n                cut(a[p-n].x,p),cut(a[p-n].y,p),ans-=a[p-n].w;\n                st[++tp]=p-n,typ[tp]=0;\n            }\n            else continue;\n        }\n        link(x,to+n),link(y,to+n),ans+=w;\n        st[++tp]=to,typ[tp]=1;\n    }\n    if(l==r)out(ans,ln);\n    else div(l,m,rt<<1),div(m+1,r,rt<<1|1);\n    for(;tp^bg;--tp){\n        x=st[tp];\n        if(typ[tp])\n            ans-=a[x].w,\n            cut(a[x].x,x+n),cut(a[x].y,x+n);\n        else\n            ans+=a[x].w,\n            link(a[x].x,x+n),link(a[x].y,x+n);\n    }\n}\nint main(){\n    in(n,m,q);tot=m;\n    fur(i,1,m)in(a[i].x,a[i].y,a[i].w),lst[i]=1,pos[i]=i;\n    fur(i,1,q){\n        int k,d;in(k,d);\n        if(lst[k]<i)upd(lst[k],i-1,pos[k],1,q,1);\n        lst[k]=i;a[++tot]=a[pos[k]];a[tot].w=d;pos[k]=tot;\n    }\n    fur(i,1,m)upd(lst[i],q,pos[i],1,q,1);\n    fur(i,1,tot)v[n+i]=a[i].w;\n    div(1,q,1);\n    flush();\n}\n```\n\n## cdq分治\n\n一个非常巧妙的思路\n\n和线段树分治一样,我们对修改时间进行分治\n\n暴力: 当$l=r$的时候,就直接让修改生效,然后求一边`MST`(最小生成树)\n\n图的规模是$m$,$\\mathcal{O}(nm)$显然不行\n\n要靠分治来缩小图的规模\n\n1. 必选边\n\n   假设当前处理的区间为$[l,r]$,把区间中要求改的边全部改为$-\\infty$,跑一遍`MST`\n\n   那么跑完后不是$-\\infty$且还在`MST`中的边,之后也一定会留在`MST`中\n\n   那么可以把这些边形成的连通块缩点,把剩下的边存下来继续分治\n\n2. 无用边\n   \n   假设当前处理的区间为$[l,r]$,把区间中要求改的边全部改为$\\infty$,跑一遍`MST`\n\n   那么跑完后不是$\\infty$且不在`MST`中的边,之后也一定不在`MST`中\n\n\n```cpp\n#include<bits\/stdc++.h>\n#define il __inline__ __attribute__ ((always_inline))\n#define fur(i,x,y) for(int i(x);i<=y;++i)\ntypedef long long ll;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}void out(const char* s){while(*s)pt(*s++);}void out(char* s){while(*s)pt(*s++);}void out(char c){pt(c);}template<typename T>void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\nusing std::sort;\nconst int N=50011,inf=1<<30;\nint n,m,q,f[N],sz[N],a[N],c[N],tot[20];\nstruct node{\n    int x,y,w,id;\n    bool operator<(node t){return w<t.w;}\n}e[20][N],b[N],t[N];\nstruct mdy{int x,y;}p[N];\nint gf(int x){return x==f[x]?x:(f[x]=gf(f[x]));}\nvoid link(int x,int y){\n    x=gf(x),y=gf(y);\n    if(sz[x]>sz[y])x^=y,y^=x,x^=y;\n    f[x]=y,sz[y]+=sz[x];\n}\nvoid set(int T,node*a){\n    fur(i,1,T)\n        f[a[i].x]=a[i].x,f[a[i].y]=a[i].y,\n        sz[a[i].x]=sz[a[i].y]=1;\n}\nvoid useful(int&T,ll&val){\n    int tt=0;\n    set(T,b);sort(b+1,b+T+1);\n    fur(i,1,T)if(gf(b[i].x)^gf(b[i].y))\n        link(b[i].x,b[i].y),t[++tt]=b[i];\n    set(tt,t);\n    fur(i,1,tt)if(t[i].w!=-inf&&gf(t[i].x)^gf(t[i].y))\n        val+=t[i].w,link(t[i].x,t[i].y);\n    tt=0;\n    fur(i,1,T)if(gf(b[i].x)^gf(b[i].y))\n        t[++tt]={f[b[i].x],f[b[i].y],b[i].w,b[i].id};\n    fur(i,1,tt)c[b[i].id]=i,b[i]=t[i];\n    T=tt;\n}\nvoid useless(int&T){\n    int tt=0;\n    set(T,b);sort(b+1,b+T+1);\n    fur(i,1,T)\n        if(gf(b[i].x)^gf(b[i].y))\n            link(b[i].x,b[i].y),t[++tt]=b[i];\n        else if(b[i].w==inf)t[++tt]=b[i];\n    fur(i,1,tt)c[b[i].id]=i,b[i]=t[i];\n    T=tt;\n}\nvoid div(int l,int r,int d,ll val){\n    int T=tot[d],m=l+r>>1;\n    if(l==r)a[p[l].x]=p[l].y;\n    fur(i,1,T){\n        e[d][i].w=a[e[d][i].id];\n        b[i]=e[d][i],c[b[i].id]=i;\n    }\n    if(l==r){\n        set(T,b);\n        sort(b+1,b+T+1);\n        fur(i,1,T)if(gf(b[i].x)^gf(b[i].y))\n            link(b[i].x,b[i].y),val+=b[i].w;\n        out(val,ln);return;\n    }\n    fur(i,l,r)b[c[p[i].x]].w=-inf;\n    useful(T,val);\n    fur(i,l,r)b[c[p[i].x]].w=inf;\n    useless(T);\n    fur(i,1,T)e[d+1][i]=b[i];\n    tot[d+1]=T;\n    div(l,m,d+1,val);\n    div(m+1,r,d+1,val);\n}\nint main(){\n    in(n,m,q);\n    int x,y;\n    fur(i,1,m)in(x,y,a[i]),e[0][i]={x,y,a[i],i};\n    fur(i,1,q)in(p[i].x,p[i].y);\n    tot[0]=m;div(1,q,0,0);\n    flush();\n}\n```\n","link":null,"tags":["lct","线段树分治"],"title":"LG 3206 [HNOI2010]城市建设"},{"categories":[["刷题记录"]],"content":"\n要转化为加边,之后用并查集维护是否连通就可以了(带权维护连通块大小,为n的时候说明全部连通)\n\n每条边都在特定的时间段中出现\n\n由于加边完还要删掉这里使用按秩合并\n```cpp\n#include<bits\/stdc++.h>\n#pragma GCC optimize(3)\n#define il __inline__ __attribute__ ((always_inline))\ntypedef long long ll;typedef unsigned long long ull;typedef double db;typedef short sht;\n#define fur(i,x,y) for(int i(x);i<=y;++i)\n#define fdr(i,x,y) for(int i(x);i>=y;--i)\ntemplate <class T>T MAX(T x,T y){return x>y?x:y;}\ntemplate <class T>T MIN(T x,T y){return x<y?x:y;}\ntemplate <class T>void SWAP(T &x,T &y){T t=x;x=y;y=t;}\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}void out(const char* s){while(*s)pt(*s++);}void out(char* s){while(*s)pt(*s++);}void out(char c){pt(c);}template<typename T>void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\nusing namespace std;\nconst int N=100011,M=200011;\nint n,q,k,tp,cnt,f[N],siz[N],X[M],Y[M],head[N*4],st[N*80];\nlist<int>T[M];\nint gf(int x){while(f[x])x=f[x];return x;}\nstruct edge{int to,nxt;}e[N*80];\nvoid add(int x,int y){e[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;}\nvoid upd(int L,int R,int v,int l,int r,int rt){\n    if(L<=l&&r<=R){add(rt,v);return;}\n    int m=(l+r)>>1;\n    if(L<=m)upd(L,R,v,l,m,rt<<1);\n    if(R>m)upd(L,R,v,m+1,r,rt<<1|1);\n}\nvoid qry(int l,int r,int rt){\n    int m=(l+r)>>1,x,y,bg=tp;\n    for(int i=head[rt];i;i=e[i].nxt){\n        x=gf(X[e[i].to]),y=gf(Y[e[i].to]);\n        if(x^y){\n            if(siz[x]+siz[y]==n){fur(j,l,r)out(\"Connected\\n\");goto ski;}\n            if(siz[x]>siz[y])SWAP(x,y);\n            siz[f[st[++tp]=x]=y]+=siz[x];\n        }\n    }\n    if(l==r)out(\"Disconnected\\n\");\n    else qry(l,m,rt<<1),qry(m+1,r,rt<<1|1);\n    ski:;\n    for(;tp^bg;--tp)\n        siz[f[x=st[tp]]]-=siz[x],f[x]=0;\n}\nint main(){\n    in(n,k);\n    fur(i,1,k)in(X[i],Y[i]);\n    int c,x,la;\n    list<int>::iterator it;\n    in(q);\n    fur(i,1,q)\n        for(in(c);c;--c)\n            in(x),T[x].push_back(i);\n    fur(i,1,k){\n        T[i].sort(),T[i].push_back(q+1);\n        for(it=T[i].begin(),la=1;it!=T[i].end();la=*it+1,++it)\n            if(la!=*it)upd(la,*it-1,i,1,q,1);\n    }\n    fur(i,1,n)siz[i]=1;\n    qry(1,q,1);\n    flush();\n}\n```\n","link":null,"tags":["lct","并查集","线段树分治"],"title":"LG 5227 [AHOI2013]连通图"},{"categories":[["刷题记录"]],"content":"\n## 定义\n\n> 二分图又称作二部图,是图论中的一种特殊模型。 \n> \n> 设$G=(V,E)$是一个无向图,\n> \n> 如果顶点$V$可分割为两个互不相交的子集$(A,B)$,\n> \n> 并且图中的每条边$i\\leftrightarrow j$所关联的两个顶点$i$和$j$分别属于这两个不同的顶点集($i \\in A,j \\in B$),\n> \n> 则称图$G$为一个二分图。\n> \n> 简而言之,就是顶点集V可分割为两个互不相交的子集,并且图中每条边依附的两个顶点都分属于这两个互不相交的子集,两个子集内的顶点不相邻。\n\n## 判断\n\n区别二分图,关键是看点集是否能分成两个独立的点集。\n\n无向图$G$为二分图的充分必要条件是: $G$至少有两个顶点,且其所有回路的长度均为偶数。\n\n证明:\n\n> 必要性:\n> \n> 设$G=<V,E>$为一个简单无向图,$G$为二分图,那么可以将$V$分为$V_1,V_2$\n> \n> 设$C$为$G$中长度为$l$的圈,$C=(v_1,v_2,...v_{l-1},v_l,v_1)$\n> \n> 那么$v_1\\in V_1,v_2\\in V_2,v_3\\in V_1 ,\\cdots,v_l \\in V_2$\n> \n> 也就是: \n> \n> $$\n> v_1,v_3,v_5,\\cdots v_l-1 \\in V_1\n> \\\\\n> v_2,v_4,v_6,\\cdots v_l \\in V_2\n> $$\n> \n> 所以$l$必定为偶数\n\n> 充分性:\n> \n> 设无向图$G$中每个圈的长度都是偶数,并且假定$G$为连通图\n> \n> 定义$V$的两个子集$V_1,V_2$:\n> \n> 任取$v\\in V$,\n> \n> $V_1=\\left\\{v|dist(v_i,v) \\mod 2 = 0\\right\\}$\n> \n> $V_2=\\left\\{v|dist(v_i,v) \\mod 2 = 1\\right\\}$\n> \n> $V_1$的节点间无边连接,\n> \n> 假若不然,设有边$v_i\\leftrightarrow v_j\\in E$且$v_i,v_j\\in V_1$,那么$v$到$v_i$以及$v$到$v_j$的长> 度都是偶数,\n> \n> 那么$v$到$v_i$到$v_j$到$v$这个圈的长度为奇数,与给定条件矛盾,所以边$v_i\\leftrightarrow v_j$不存在\n> \n> 同理可证$V_2$的节点间无边连接\n\n\n\n回归正题,我们要判断是否是二分图,只需要判断图里是否存在奇环就可以了\n\n## 解法一\n\nlink-cut tree\n\n考虑到每条边最后都是要删掉的,那么当构成环时,我们就可以将该环中最早要被删掉的边给删去,因为这样一来不会影响连通性,二来又可以化环为链。\n\n添加一条边的时候,若两端未连通,直接连边即可\n\n若两端已经连通,这时一定会形成一个环,为了维护`LCT`,连接两端时,我们需要把环上消失时刻最早的边给删去,如果是奇环则把这条边加入集合\n\n删边时如果是`LCT`上的边则断开,在集合中则将其从集合中删除\n\n查询时若集合中没有边,则为二分图\n\n```cpp\n#include<bits\/stdc++.h>\n#define fur(i,x,y) for(int i(x);i<=y;++i)\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}void out(const char* s){while(*s)pt(*s++);}void out(char* s){while(*s)pt(*s++);}void out(char c){pt(c);}template<typename T>void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\nconst int N=100011,M=200011,inf=2122219134,P=300011;\nint n,m,T,cnt,tot,s[P],fr[P],siz[P],v[P],c[2][P],f[P],ad[N],de[N];\nbool rev[P],is[M],on[M];\nstruct node{int x,y,v;}a[M];\nstruct edge{int to,nxt;}e[M<<1];\nvoid add(int *head,int x,int y){e[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;}\n#define ls c[0][x]\n#define rs c[1][x]\nvoid pu(int x){\n    s[x]=v[x],fr[x]=x;\n    siz[x]=(x>n)+siz[ls]+siz[rs];\n    if(s[ls]<s[x])s[x]=s[ls],fr[x]=fr[ls];\n    if(s[rs]<s[x])s[x]=s[rs],fr[x]=fr[rs];\n}\nvoid pr(int x){rev[x]^=1,ls^=rs,rs^=ls,ls^=rs;}\nvoid pd(int x){\n    if(rev[x]){\n        if(ls)pr(ls);\n        if(rs)pr(rs);\n        rev[x]=0;\n    }\n}\nint g(int x){return c[1][f[x]]==x;}\nint nrt(int x){return c[0][f[x]]==x||c[1][f[x]]==x;}\nvoid rotate(int x){\n    int y=f[x],z=f[y],l=g(x),r=!l,w=c[r][x];\n    if(nrt(y))c[g(y)][z]=x;\n    c[r][x]=y,c[l][y]=w;\n    if(w)f[w]=y;\n    f[x]=z,f[y]=x;\n    pu(y);\n}\nvoid pda(int x){if(nrt(x))pda(f[x]);pd(x);}\nvoid splay(int x){\n    for(pda(x);nrt(x);rotate(x))if(nrt(f[x]))\n        rotate(g(x)^g(f[x])?x:f[x]);\n    pu(x);\n}\nvoid access(int x){\n    for(int y=0;x;x=f[y=x])\n        splay(x),rs=y,pu(x);\n}\nvoid mrt(int x){access(x),splay(x),pr(x);}\nint frt(int x){\n    for(access(x),splay(x);ls;pd(x),x=ls);\n    splay(x);return x;\n}\nvoid cut(int x,int y){\n    mrt(x);\n    if(frt(y)==x&&f[y]==x&&!c[0][y])rs=f[y]=0,pu(x);\n}\nvoid inc(int i){\n    int x=a[i].x,y=a[i].y;\n    if(x==y){is[i]=1,++tot;return;};\n    mrt(x);\n    if(frt(y)!=x)on[i]=1,mrt(y),f[x]=f[y]=i+n;\/\/直接连接\n    else{\n        splay(y);\n        int k=fr[y]-n;\n        if(a[k].v<a[i].v){\n            if(siz[y]&1^1)is[k]=1,++tot;\/\/是奇环,将边加入集合\n            cut(a[k].x,k+n),cut(a[k].y,k+n);\n            mrt(x),mrt(y),f[x]=f[y]=i+n;\n            on[k]=0,on[i]=1;\n        }\n        else if(siz[y]&1^1)is[i]=1,++tot;\n    }\n}\nvoid dec(int i){\n    if(on[i])cut(a[i].x,i+n),cut(a[i].y,i+n);\/\/是LCT上的边\n    else if(is[i])--tot;\/\/从集合中删去\n}\nint main(){\n    s[0]=v[0]=inf;\n    in(n,m,T);\n    fur(i,1,n)v[i]=s[i]=inf,fr[i]=i;\n    int x,y,st,ed;\n    fur(i,1,m){\n        in(x,y,st,ed);\n        a[i]={x,y,ed};\n        s[i+n]=v[i+n]=ed,fr[i+n]=i+n,siz[i+n]=1;\n        add(ad,st,i),add(de,ed,i);\n    }\n    fur(i,0,T-1){\n        for(int j=ad[i];j;j=e[j].nxt)inc(e[j].to);\n        for(int j=de[i];j;j=e[j].nxt)dec(e[j].to);\n        out(tot?\"No\\n\":\"Yes\\n\");\n    }\n    flush();\n}\n```\n\n## 解法二\n\n线段树分治+并查集\n\n可以发现每条边存在的时间都是一个区间\n\n如何判断是否出现奇环呢?\n\n并查集维护每个点到根的距离(只需要维护奇偶就可以了)\n\n由于要支持删除,这里使用并查集按秩合并(启发式合并)\n\n连接一条边时,若两端以连通,则判断添加后是否形成奇环\n\n\n```cpp\n#include<bits\/stdc++.h>\n#define fur(i,x,y) for(int i(x);i<=y;++i)\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}void out(const char* s){while(*s)pt(*s++);}void out(char* s){while(*s)pt(*s++);}void out(char c){pt(c);}template<typename T>void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\nconst int N=1000011,M=200011;\nint n,m,T,cnt,tp,head[N<<2],f[N],siz[N];\nbool ans[N],s[N];\nint gf(int x){while(x!=f[x])x=f[x];return x;}\nint dis(int x){int d=0;while(x!=f[x])d^=s[x],x=f[x];return d;}\nstruct node{int x,y;}a[M],sta[N<<2];\nstruct edge{int to,nxt;}e[N<<2];\nvoid add(int x,int y){e[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;}\nvoid upd(int L,int R,int v,int l,int r,int rt){\n    if(L<=l&&r<=R){add(rt,v);return;}\n    int m=l+r>>1;\n    if(L<=m)upd(L,R,v,l,m,rt<<1);\n    if(R>m)upd(L,R,v,m+1,r,rt<<1|1);\n}\nvoid qry(int l,int r,int rt){\n    int m=l+r>>1,ff=1,x,y,fx,fy,bg=tp;\n    for(int i=head[rt];i;i=e[i].nxt){\n        x=a[e[i].to].x,y=a[e[i].to].y,fx=gf(x),fy=gf(y);\n        if(fx==fy){if(dis(x)^dis(y)^1){ff=0;break;}}\n        else{\n            if(siz[fx]>siz[fy])fx^=fy,fy^=fx,fx^=fy;\n            siz[fy]+=siz[fx],s[fx]=s[x]^s[y]^1;\n            f[fx]=fy;\n            sta[++tp]={fx,fy};\n        }\n    }\n    if(ff){\n        if(l==r)ans[l]=1;\n        else qry(l,m,rt<<1),qry(m+1,r,rt<<1|1);\n    }\n    while(tp!=bg){\n        x=sta[tp].x,y=sta[tp].y;\n        siz[y]-=siz[x];\n        s[x]=0,f[x]=x;\n        --tp;\n    }\n}\nint main(){\n    in(n,m,T);\n    int st,ed;\n    fur(i,1,m){\n        in(a[i].x,a[i].y,st,ed);\n        if(st<ed)upd(st+1,ed,i,1,T,1);\n    }\n    fur(i,1,n)f[i]=i,siz[i]=1;\n    qry(1,T,1);\n    fur(i,1,T)out(ans[i]?\"Yes\\n\":\"No\\n\");\n    flush();\n}\n```\n","link":null,"tags":["线段树分治","lct","二分图"],"title":"BZ 4025 二分图"},{"categories":[["算法","离线"],["note"]],"content":"\n\n核心思想: 把一个修改看成一个区间,每个询问是一个叶子,修改在线段树上打标记\n\n","link":null,"tags":["算法","离线"],"title":"线段树分治"},{"categories":[["刷题记录"]],"content":"\n可以看成思维偏序问题\n\n先按第一维优先,相同则继续比较其他维排序(保证之后插入的点不会被之前插入的点的范围覆盖,防止统计的时候漏掉),\n\n$f_i=\\max{f_j + 1}$\n\n剩下三维可以用`KDT`求出最大的$f_j$\n\n有两种写法:\n\n1. 带重构`KDT`\n   \n2. 先构建完整的`KDT`,然后把插入当作激活节点\n```cpp\n#include<bits\/stdc++.h>\n#pragma GCC optimize(3)\ntypedef double db;\n#define fur(i,x,y) for(int i(x);i<=y;++i)\nint max(int x,int y){return x>y?x:y;}\nvoid cmin(int &x,int y){x=x<y?x:y;}\nvoid cmax(int &x,int y){x=x>y?x:y;}\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}void out(const char* s){while(*s)pt(*s++);}void out(char* s){while(*s)pt(*s++);}void out(char c){pt(c);}template<typename T>void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\nconst int N=50011,inf=2122219134;\nint _cmp,n,rt,ans,ls[N],rs[N],mi[N][3],mx[N][3],s[N],g[N];\nstruct node{\n    int v[4];\n    int& operator[](int x){return v[x];}\n    bool operator<(node p){fur(i,0,3)if(v[i]!=p[i])return v[i]<p[i];}\n}t[N];\nvoid pu(int x){\n    fur(i,0,2){\n        mi[x][i]=mx[x][i]=t[x][i+1];\n        if(ls[x])cmin(mi[x][i],mi[ls[x]][i]),cmax(mx[x][i],mx[ls[x]][i]);\n        if(rs[x])cmin(mi[x][i],mi[rs[x]][i]),cmax(mx[x][i],mx[rs[x]][i]);\n    }\n}\nbool cmp(int a,int b){return t[a][_cmp]<t[b][_cmp];}\nint build(int l,int r,int b){\n    if(l>r)return 0;\n    int m=l+r>>1;\n    _cmp=b+1,std::nth_element(g+l,g+m,g+r+1,cmp);\n    ls[g[m]]=build(l,m-1,(b+1)%3),\n    rs[g[m]]=build(m+1,r,(b+1)%3),\n    pu(g[m]);return g[m];\n}\nint id,as;\nbool chk(int *p,int *q=t[id].v+1){\n    fur(i,0,2)if(p[i]>q[i])return 0;\n    return 1;\n}\nvoid ask(int x){\n    if(!x||s[x]<=as)return;\n    if(!chk(mi[x]))return;\n    if(chk(mx[x])){as=s[x];return;}\n    if(chk(t[x].v+1))cmax(as,t[x][0]);\n    ask(ls[x]),ask(rs[x]);\n}\nvoid on(int x){\n    if(x==id){cmax(s[x],t[x][0]=as);return;}\n    if(!chk(t[id].v+1,mx[x])||!chk(mi[x]))return;\n    if(ls[x])on(ls[x]);if(rs[x])on(rs[x]);\n    cmax(s[x],s[ls[x]]),cmax(s[x],s[rs[x]]);\n}\nint main(){\n    in(n);\n    fur(i,1,n)in(t[i][0],t[i][1],t[i][2],t[i][3]),g[i]=i;\n    std::sort(t+1,t+n+1);\n    fur(i,1,n)t[i][0]=0;\n    rt=build(1,n,0);\n    fur(i,1,n)\n        id=i,as=0,ask(rt),\n        cmax(ans,++as),\n        on(rt);\n    printf(\"%d\\n\",ans);\n}\n```\n","link":null,"tags":["kdt"],"title":"LG 3769 [CH弱省胡策R2]TATT"},{"categories":[["刷题记录"]],"content":"\n首先: 构建`KDT`\n\n对每个点分别进行查询,也就是搜索\n\n直接对`KDT`进行遍历每次搜索的复杂度是`O(n)`的,显然`TLE`\n\n这时我们需要估价函数,在这里也就是: \n\n估算出查询点到子树对应的长方形中的点的\"最近距离\"\n\n若\"最近距离\"已经超过了当前答案,就跳过当前子树.\n\n搜索时比较左右子树的\"最近距离\",先搜索\"最近距离\"小的\n\n```cpp\n#include<bits\/stdc++.h>\ntypedef double db;\n#define fur(i,x,y) for(int i(x);i<=y;++i)\nconst int N=200011,inf=2122219134;\nint n,id,ls[N],rs[N];\ndb ans=2e18,L[N],R[N],D[N],U[N];\nstruct node{db x,y;}t[N];\nbool cmpx(node p,node q){return p.x<q.x;}\nbool cmpy(node p,node q){return p.y<q.y;}\ndb min(db x,db y){return x<y?x:y;}\ndb max(db x,db y){return x>y?x:y;}\nvoid upd(int x,int y){\n    L[x]=min(L[x],L[y]),R[x]=max(R[x],R[y]),\n    D[x]=min(D[x],D[y]),U[x]=max(U[x],U[y]);\n}\nvoid pu(int x){\n    L[x]=R[x]=t[x].x;\n    D[x]=U[x]=t[x].y;\n    if(ls[x])upd(x,ls[x]);\n    if(rs[x])upd(x,rs[x]);\n}\nint build(int l,int r){\n    if(l>r)return 0;\n    int m=l+r>>1;\n    db ax=0,ay=0,vx=0,vy=0;\n    fur(i,l,r)ax+=t[i].x,ay+=t[i].y;\n    ax\/=(db)(r-l+1),ay\/=(db)(r-l+1);\n    fur(i,l,r)\n        vx+=(ax-t[i].x)*(ax-t[i].x),\n        vy+=(ay-t[i].y)*(ay-t[i].y);\n    std::nth_element(t+l,t+m,t+r+1,vx>vy?cmpx:cmpy);\n    ls[m]=build(l,m-1),rs[m]=build(m+1,r),pu(m);\n    return m;\n}\ndb dis(int p){return (t[p].x-t[id].x)*(t[p].x-t[id].x)+(t[p].y-t[id].y)*(t[p].y-t[id].y);}\ndb f(int p){\n    db res=0;\n    if(L[p]>t[id].x)res+=(L[p]-t[id].x)*(L[p]-t[id].x);\n    if(R[p]<t[id].x)res+=(t[id].x-R[p])*(t[id].x-R[p]);\n    if(D[p]>t[id].y)res+=(D[p]-t[id].y)*(D[p]-t[id].y);\n    if(U[p]<t[id].y)res+=(t[id].y-U[p])*(t[id].y-U[p]);\n    return res;\n}\nvoid qry(int l,int r){\n    if(l>r)return;\n    int m=l+r>>1;\n    if(m!=id)ans=min(ans,dis(m));\n    if(l==r)return;\n    db ld=f(ls[m]),rd=f(rs[m]);\n    if(ld<rd){\n        if(ld<ans)qry(l,m-1);\n        if(rd<ans)qry(m+1,r);\n    }\n    else{\n        if(rd<ans)qry(m+1,r);\n        if(ld<ans)qry(l,m-1);\n    }\n}\nint main(){\n    scanf(\"%d\",&n);\n    fur(i,1,n)scanf(\"%lf%lf\",&t[i].x,&t[i].y);\n    build(1,n);\n    fur(i,1,n)id=i,qry(1,n);\n    printf(\"%.4f\\n\",sqrt(ans));\n}\n```\n","link":null,"tags":["kdt"],"title":"LG 1429 平面最近点对（加强版）"},{"categories":[["刷题记录"]],"content":"\n```cpp\n#include<bits\/stdc++.h>\n#pragma GCC optimize(3)\n#define il __inline__ __attribute__ ((always_inline))\n#define fur(i,x,y) for(int i(x);i<=y;++i)\ntemplate <class T>il T ABS(T x){return x>0?x:-x;}\ntemplate <class T>il T MAX(T x,T y){return x>y?x:y;}\ntemplate <class T>il T MIN(T x,T y){return x<y?x:y;}\nusing namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\nconst int N=100011,inf=2122219134;\nint n,rt,ls[N],rs[N],L[N],R[N],D[N],U[N],ans=inf;\nstruct node{int x,y;}t[N];\nbool cmpx(node a,node b){return a.x<b.x;}\nbool cmpy(node a,node b){return a.y<b.y;}\nvoid upd(int x,int y){\n    L[x]=MIN(L[x],L[y]),R[x]=MAX(R[x],R[y]),\n    D[x]=MIN(D[x],D[y]),U[x]=MAX(U[x],U[y]);\n}\nvoid pu(int x){\n    L[x]=R[x]=t[x].x,\n    D[x]=U[x]=t[x].y;\n    if(ls[x])upd(x,ls[x]);\n    if(rs[x])upd(x,rs[x]);\n}\nint build(int l,int r){\n    if(l>r)return 0;\n    int m=l+r>>1;\n    double ax=0,ay=0,vx=0,vy=0;\n    fur(i,l,r)ax+=t[i].x,ay+=t[i].y;\n    ax\/=r-l+1,ay\/=r-l+1;\n    fur(i,l,r)\n        vx+=ABS(ax-t[i].x),\n        vy+=ABS(ay-t[i].y);\n    nth_element(t+l,t+m,t+r+1,vx>vy?cmpx:cmpy);\n    ls[m]=build(l,m-1),rs[m]=build(m+1,r),pu(m);\n    return m;\n}\nint id,mi,mx;\nint dis(int p){return ABS(t[p].x-t[id].x)+ABS(t[p].y-t[id].y);}\nint fmi(int p){\n    return MAX(L[p]-t[id].x,0)+MAX(t[id].x-R[p],0)+\n           MAX(D[p]-t[id].y,0)+MAX(t[id].y-U[p],0);\n}\nint fmx(int p){\n    return MAX(ABS(L[p]-t[id].x),ABS(R[p]-t[id].x))+\n           MAX(ABS(D[p]-t[id].y),ABS(U[p]-t[id].y));\n}\nvoid qmi(int x){\n    if(!x)return;\n    if(x!=id)mi=MIN(mi,dis(x));\n    int ld=fmi(ls[x]),rd=fmi(rs[x]);\n    if(ld<rd){\n        if(ld<mi)qmi(ls[x]);\n        if(rd<mi)qmi(rs[x]);\n    }\n    else{\n        if(rd<mi)qmi(rs[x]);\n        if(ld<mi)qmi(ls[x]);\n    }\n}\nvoid qmx(int x){\n    if(!x)return;\n    if(x!=id)mx=MAX(mx,dis(x));\n    int ld=fmx(ls[x]),rd=fmx(rs[x]);\n    if(ld>rd){\n        if(ld>mx)qmx(ls[x]);\n        if(rd>mx)qmx(rs[x]);\n    }\n    else{\n        if(rd>mx)qmx(rs[x]);\n        if(ld>mx)qmx(ls[x]);\n    }\n}\nint main(){\n    in(n);\n    fur(i,1,n)in(t[i].x,t[i].y);\n    rt=build(1,n);\n    fur(i,1,n)\n        id=i,mi=inf,mx=-inf,\n        qmi(rt),qmx(rt),\n        ans=MIN(ans,mx-mi);\n    printf(\"%d\\n\",ans);\n}\n```\n","link":null,"tags":["kdt"],"title":"LG 2479 [SDOI2010]捉迷藏"},{"categories":[["刷题记录"]],"content":"\n```cpp\n#include<bits\/stdc++.h>\n#pragma GCC optimize(3)\n#define il __inline__ __attribute__ ((always_inline))\ntypedef long long ll;typedef unsigned long long ull;typedef double db;typedef short sht;\n#define fur(i,x,y) for(int i(x);i<=y;++i)\n#define fdr(i,x,y) for(int i(x);i>=y;--i)\n#define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n#define clr(x,y) memset(x,y,sizeof(x))\n#define cpy(x,y) memcpy(x,y,sizeof(x))\n#define fin(s) freopen(s\".in\",\"r\",stdin)\n#define fout(s) freopen(s\".out\",\"w\",stdout)\n#define fcin ios::sync_with_stdio(false)\n#define l2(n) ((int)(log2(n)))\ntemplate <class T>il T ABS(T x){return x>0?x:-x;}\ntemplate <class T>il T MAX(T x,T y){return x>y?x:y;}\ntemplate <class T>il T MIN(T x,T y){return x<y?x:y;}\ntemplate <class T>il T GCD(T x,T y){return y?GCD(y,x%y):x;}\ntemplate <class T>il void SWAP(T &x,T &y){T t=x;x=y;y=t;}\nusing namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\nconst int N=50011,inf=2122219134;\nint n,q,rt,ls[N],rs[N],L[N],R[N],D[N],U[N];\nll s[N];\nstruct node{int x,y;ll v;}t[N];\nbool cmpx(node a,node b){return a.x<b.x;}\nbool cmpy(node a,node b){return a.y<b.y;}\nvoid upd(int x,int y){\n    L[x]=MIN(L[x],L[y]),R[x]=MAX(R[x],R[y]),\n    D[x]=MIN(D[x],D[y]),U[x]=MAX(U[x],U[y]);\n}\nvoid pu(int x){\n    L[x]=R[x]=t[x].x;\n    D[x]=U[x]=t[x].y;\n    if(ls[x])upd(x,ls[x]);\n    if(rs[x])upd(x,rs[x]);\n    s[x]=t[x].v+s[ls[x]]+s[rs[x]];\n}\nint build(int l,int r){\n    if(l>r)return 0;\n    int m=l+r>>1;\n    db ax=0,ay=0,vx=0,vy=0;\n    fur(i,l,r)ax+=t[i].x,ay+=t[i].y;\n    ax\/=r-l+1,ay\/=r-l+1;\n    fur(i,l,r)\n        vx+=(ax-t[i].x)*(ax-t[i].x),\n        vy+=(ay-t[i].y)*(ay-t[i].y);\n    nth_element(t+l,t+m,t+r+1,vx>vy?cmpx:cmpy);\n    ls[m]=build(l,m-1);\n    rs[m]=build(m+1,r);\n    pu(m);return m;\n}\nint A,B;ll C;\nint chk(int x,int y){return 1ll*A*x+1ll*B*y<C;}\nll ask(int x){\n    if(!x)return 0;\n    int f=chk(L[x],D[x])+chk(L[x],U[x])+chk(R[x],D[x])+chk(R[x],U[x]);\n    if(!f)return 0;\n    if(f==4)return s[x];\n    return (chk(t[x].x,t[x].y)?t[x].v:0)+ask(ls[x])+ask(rs[x]);\n}\nint main(){\n    in(n,q);\n    fur(i,1,n)in(t[i].x,t[i].y,t[i].v);\n    rt=build(1,n);\n    while(q--)in(A,B,C),out(ask(rt),ln);\n    flush();\n}\n```\n","link":null,"tags":["kdt"],"title":"LG 4475 巧克力王国"},{"categories":[["刷题记录"]],"content":"\n```cpp\n#include<bits\/stdc++.h>\ntypedef long long ll;\n#define fur(i,x,y) for(int i(x);i<=y;++i)\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}void out(const char* s){while(*s)pt(*s++);}void out(char* s){while(*s)pt(*s++);}void out(char c){pt(c);}template<typename T>void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\nconst int N=100011;const ll inf=1ll<<63;\nint rt,id,ls[N],rs[N];\nint L[N],R[N],D[N],U[N];\nstruct node{int x,y;}t[N];\nbool cmpx(node p,node q){return p.x<q.x;}\nbool cmpy(node p,node q){return p.y<q.y;}\ntemplate<class T>T min(T x,T y){return x<y?x:y;}\ntemplate<class T>T max(T x,T y){return x>y?x:y;}\nll sq(int x){return 1ll*x*x;}\nvoid upd(int x,int y){\n    L[x]=min(L[x],L[y]),R[x]=max(R[x],R[y]),\n    D[x]=min(D[x],D[y]),U[x]=max(U[x],U[y]);\n}\nvoid pu(int x){\n    L[x]=R[x]=t[x].x;\n    D[x]=U[x]=t[x].y;\n    if(ls[x])upd(x,ls[x]);\n    if(rs[x])upd(x,rs[x]);\n}\nint build(int l,int r){\n    if(l>r)return 0;\n    int m=l+r>>1;\n    double ax=0,ay=0,vx=0,vy=0;\n    fur(i,l,r)ax+=t[i].x,ay+=t[i].y;\n    ax\/=r-l+1,ay\/=r-l+1;\n    fur(i,l,r)\n        vx+=sq(ax-t[i].x),\n        vy+=sq(ay-t[i].y);\n    std::nth_element(t+l,t+m,t+r+1,vx>vy?cmpx:cmpy);\n    ls[m]=build(l,m-1);rs[m]=build(m+1,r);pu(m);\n    return m;\n}\nstd::priority_queue<ll,std::vector<ll>,std::greater<ll>>q;\nll dis(int x){return sq(t[x].x-t[id].x)+sq(t[x].y-t[id].y);}\nll f(int x){\n    return max(sq(L[x]-t[id].x),sq(R[x]-t[id].x))+\n           max(sq(D[x]-t[id].y),sq(U[x]-t[id].y));\n}\nvoid qry(int x){\n    if(!x)return;\n    ll res=dis(x),ld=inf,rd=inf;\n    if(x!=id&&res>q.top())q.pop(),q.push(res);\n    if(ls[x])ld=f(ls[x]);\n    if(rs[x])rd=f(rs[x]);\n    if(ld<rd){\n        if(ld>q.top())qry(ls[x]);\n        if(rd>q.top())qry(rs[x]);\n    }\n    else{\n        if(rd>q.top())qry(rs[x]);\n        if(ld>q.top())qry(ls[x]);\n    }\n}\nint main(){\n    int n,k;\n    in(n,k);\n    fur(i,1,n)in(t[i].x,t[i].y);\n    rt=build(1,n);\n    k<<=1;while(k--)q.push(-1);\n    fur(i,1,n)id=i,qry(rt);\n    printf(\"%lld\\n\",q.top());\n}\n```\n","link":null,"tags":["kdt"],"title":"LG 4357 [CQOI2016]K远点对"},{"categories":[["算法","数据结构"],["note"]],"content":"\n\n## 简介\n\n`k-D Tree(KDT,k-Dimension Tree)`是一种可以高效处理$k$维空间信息的数据结构。\n\n[维基百科](https:\/\/wiki.zcmimi.workers.dev\/wiki\/K-d%E6%A0%91)\n\n在算法竞赛的题目中,一般$k=2$\n\n## 构建\n\n`KDT`本质上是二叉搜索树,每个节点对应坐标系中的某个点\n\n已知$k$维空间中有$n$个点,要怎么构建成`KDT`呢\n\n1. 若只剩一个点,返回这个点\n\n2. 选择一个维度,将空间划分为两个\n   \n3. 在选择的维度上选择一个切割点,作为当前子树的根节点,根据 这个维度 把 切割点 两边的点分别划分到 左子树 和 右子树\n   \n4. 继续递归处理左子树和右子树\n\n\n> ![](3dtree.png)\n> \n> 一个三维k-d树。\n> \n> 第一次划分（红色）把根节点（白色）划分成两个节点,\n> \n> 然后它们分别再次被划分（绿色）为两个子节点。\n> \n> 最后这四个子节点的每一个都被划分（蓝色）为两个子节点。\n> \n> 因为没有更进一步的划分,最后得到的八个节点称为叶子节点。\n\n> ![](2dtree.jpg)\n> \n> 其构建出 k-D Tree 的形态可能是这样的：\n> \n> ![](2dtree_.jpg)\n\n如果只是这样建树,复杂度无法保证\n\n优化：\n\n1. 每次选择的切割维度是**方差最大**的维度\n   \n2. 切割点选择该维度上的**中位数**,保证划分后左右子树大小大致相等\n\n可以发现使用优化二后,构建出的`KDT`树高最多为$\\log n$\n\n优化一也可以换成每次切割后都换另一个维度切割\n\n## 插入\n\n在插入一个$k$维点时,先根据记录的分割维度和分割点判断应该继续插入到左子树还是右子树,如果到达了空结点,新建一个结点代替这个空结点。\n\n## 平衡\n\n如果数据经过了构造,可能会造成`KDT`变成链\n\n要怎么维护`KDT`的平衡性呢？\n\n由于`KDT`的构造,不能支持旋转,类似与`fhqtreap`的随机优先级也不能保证其复杂度,可以保证平衡性的手段只有类似于**替罪羊树**的重构思想。\n\n我们引入一个重构常数$\\alpha$,对于`KDT`上的一个结点$x$,若其有一个子树的结点数在以$x$为根的子树的结点数中的占比大于$\\alpha$,则认为以$x$为根的子树是不平衡的,需要重构。\n\n重构时,中序遍历子树得到原序列,然后重新构建出一棵`KDT`,代替原来不平衡的子树。\n\n所以：成功插入结点后回溯插入的过程,维护结点的信息,如果发现当前的子树不平衡,则重构当前子树。\n\n## 邻域查询\n\n[LG 1429 平面最近点对（加强版)](https:\/\/www.luogu.org\/problem\/P1429)\n\n首先: 构建`KDT`\n\n对每个点分别进行查询,也就是搜索\n\n直接对`KDT`进行遍历每次搜索的复杂度是`O(n)`的,显然`TLE`\n\n这时我们需要估价函数,在这里也就是: \n\n估算出查询点到子树对应的长方形中的点的\"最近距离\"\n\n若\"最近距离\"已经超过了当前答案,就跳过当前子树.\n\n搜索时比较左右子树的\"最近距离\",先搜索\"最近距离\"小的\n\n```cpp\n#include<bits\/stdc++.h>\ntypedef double db;\n#define fur(i,x,y) for(int i(x);i<=y;++i)\nconst int N=200011,inf=2122219134;\nint n,id,ls[N],rs[N];\ndb ans=2e18,L[N],R[N],D[N],U[N];\nstruct node{db x,y;}t[N];\nbool cmpx(node p,node q){return p.x<q.x;}\nbool cmpy(node p,node q){return p.y<q.y;}\ndb min(db x,db y){return x<y?x:y;}\ndb max(db x,db y){return x>y?x:y;}\nvoid upd(int x,int y){\n    L[x]=min(L[x],L[y]),R[x]=max(R[x],R[y]),\n    D[x]=min(D[x],D[y]),U[x]=max(U[x],U[y]);\n}\nvoid pu(int x){\n    L[x]=R[x]=t[x].x;\n    D[x]=U[x]=t[x].y;\n    if(ls[x])upd(x,ls[x]);\n    if(rs[x])upd(x,rs[x]);\n}\nint build(int l,int r){\n    if(l>r)return 0;\n    int m=l+r>>1;\n    db ax=0,ay=0,vx=0,vy=0;\n    fur(i,l,r)ax+=t[i].x,ay+=t[i].y;\n    ax\/=(db)(r-l+1),ay\/=(db)(r-l+1);\n    fur(i,l,r)\n        vx+=(ax-t[i].x)*(ax-t[i].x),\n        vy+=(ay-t[i].y)*(ay-t[i].y);\n    std::nth_element(t+l,t+m,t+r+1,vx>vy?cmpx:cmpy);\n    ls[m]=build(l,m-1),rs[m]=build(m+1,r),pu(m);\n    return m;\n}\ndb dis(int p){return (t[p].x-t[id].x)*(t[p].x-t[id].x)+(t[p].y-t[id].y)*(t[p].y-t[id].y);}\ndb f(int p){\n    db res=0;\n    if(L[p]>t[id].x)res+=(L[p]-t[id].x)*(L[p]-t[id].x);\n    if(R[p]<t[id].x)res+=(t[id].x-R[p])*(t[id].x-R[p]);\n    if(D[p]>t[id].y)res+=(D[p]-t[id].y)*(D[p]-t[id].y);\n    if(U[p]<t[id].y)res+=(t[id].y-U[p])*(t[id].y-U[p]);\n    return res;\n}\nvoid qry(int l,int r){\n    if(l>r)return;\n    int m=l+r>>1;\n    if(m!=id)ans=min(ans,dis(m));\n    if(l==r)return;\n    db ld=f(ls[m]),rd=f(rs[m]);\n    if(ld<rd){\n        if(ld<ans)qry(l,m-1);\n        if(rd<ans)qry(m+1,r);\n    }\n    else{\n        if(rd<ans)qry(m+1,r);\n        if(ld<ans)qry(l,m-1);\n    }\n}\nint main(){\n    scanf(\"%d\",&n);\n    fur(i,1,n)scanf(\"%lf%lf\",&t[i].x,&t[i].y);\n    build(1,n);\n    fur(i,1,n)id=i,qry(1,n);\n    printf(\"%.4f\\n\",sqrt(ans));\n}\n```\n\n[LG 2093 \\[国家集训队\\]JZPFAR](https:\/\/www.luogu.com.cn\/problem\/P2093)\n\n思路与上一题差不多\n\n可以用堆动态维护第$k$大\n\n只需要开一个小根堆,先插入$k$个点(占位)\n\n每次找到一个点,若距离大于对顶则弹出对顶,向堆中插入改点\n\n```cpp\n#include<bits\/stdc++.h>\n#pragma GCC optimize(3)\n#define il __inline__ __attribute__ ((always_inline))\ntypedef long long ll;typedef unsigned long long ull;typedef double db;typedef short sht;\n#define fur(i,x,y) for(int i(x);i<=y;++i)\n#define fdr(i,x,y) for(int i(x);i>=y;--i)\n#define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n#define clr(x,y) memset(x,y,sizeof(x))\n#define cpy(x,y) memcpy(x,y,sizeof(x))\n#define fin(s) freopen(s\".in\",\"r\",stdin)\n#define fout(s) freopen(s\".out\",\"w\",stdout)\n#define fcin ios::sync_with_stdio(false)\n#define l2(n) ((int)(log2(n)))\ntemplate <class T>il T ABS(T x){return x>0?x:-x;}\ntemplate <class T>il T MAX(T x,T y){return x>y?x:y;}\ntemplate <class T>il T MIN(T x,T y){return x<y?x:y;}\ntemplate <class T>il T GCD(T x,T y){return y?GCD(y,x%y):x;}\ntemplate <class T>il void SWAP(T &x,T &y){T t=x;x=y;y=t;}\nusing namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\nconst int N=100011,inf=2122219134;\nint n,rt,cnt,siz[N],c[2][N],L[N],R[N],D[N],U[N];\n#define ls c[0][x]\n#define rs c[1][x]\nbool d[N];\ndb a=0.75;\nstruct node{int x,y,v;}t[N];\nbool cmpx(node p,node q){return p.x<q.x;}\nbool cmpy(node p,node q){return p.y<q.y;}\nvoid upd(int x,int y){\n    L[x]=MIN(L[x],L[y]),R[x]=MAX(R[x],R[y]),\n    D[x]=MIN(D[x],D[y]),U[x]=MAX(U[x],U[y]);\n}\nvoid pu(int x){\n    siz[x]=siz[ls]+siz[rs]+1;\n    L[x]=R[x]=t[x].x;\n    D[x]=U[x]=t[x].y;\n    if(ls)upd(x,ls);\n    if(rs)upd(x,rs);\n}\nint build(int l,int r){\n    if(l>r)return 0;\n    int m=l+r>>1,x=m;\n    db av1=0,av2=0,v1=0,v2=0;\n    fur(i,l,r)av1+=t[i].x,av2+=t[i].y;\n    av1\/=r-l+1,av2\/=r-l+1;\n    fur(i,l,r)\n        v1+=(av1-t[i].x)*(av1-t[i].x),\n        v2+=(av2-t[i].y)*(av2-t[i].y);\n    nth_element(t+l,t+m,t+r+1,(v1>v2)?cmpx:cmpy);\n    d[x]=v1>v2;\n    ls=build(l,m-1),rs=build(m+1,r);\n    pu(x);return x;\n}\nint qx,qy;\nstruct dat{\n    ll d;int id;\n    bool operator<(dat p)const{return d>p.d||(d==p.d&&id<p.id);}\n};\npriority_queue<dat>q;\nll dis(node p){return 1ll*(p.x-qx)*(p.x-qx)+1ll*(p.y-qy)*(p.y-qy);}\nll mxd(int x){\n    return MAX(1ll*(L[x]-qx)*(L[x]-qx),1ll*(R[x]-qx)*(R[x]-qx))+\n           MAX(1ll*(D[x]-qy)*(D[x]-qy),1ll*(U[x]-qy)*(U[x]-qy));\n}\nvoid ask(int x){\n    if(!x)return;\n    ll res=dis(t[x]),ld=0,rd=0;\n    if(res>q.top().d||(res==q.top().d&&t[x].v<q.top().id))\n        q.pop(),q.push(dat{res,t[x].v});\n    if(ls)ld=mxd(ls);\n    if(rs)rd=mxd(rs);\n    if(ld>rd){\n        if(ld>=q.top().d)ask(ls);\n        if(rd>=q.top().d)ask(rs);\n    }\n    else{\n        if(rd>=q.top().d)ask(rs);\n        if(ld>=q.top().d)ask(ls);\n    }\n}\nint main(){\n    in(n);\n    int m,x,y,k;\n    fur(i,1,n)in(x,y),t[i]=node{x,y,i};\n    rt=build(1,n);\n    in(m);\n    while(m--){\n        in(qx,qy,k);\n        while(!q.empty())q.pop();\n        while(k--)q.push(dat{-1,0});\n        ask(rt);\n        out(q.top().id,ln);\n    }\n    flush();\n}\n```\n\n## 高维空间操作\n\n[LG 4148 简单题](https:\/\/www.luogu.org\/problem\/P4148)\n\n20M的空间限制卡掉了树套树,强制在线卡掉了CDQ分治\n\n所以这题是`KDT`模板题\n\n查询时判断如果当前子树对应的矩形在查询范围内,直接加上该子树的贡献,返回\n\n否则判断当前点是否在范围内,加上答案,接着继续递归左右子树\n\n```cpp\n#include<bits\/stdc++.h>\n#pragma GCC optimize(3)\n#define il __inline__ __attribute__ ((always_inline))\n#define fur(i,x,y) for(int i(x);i<=y;++i)\n#define fdr(i,x,y) for(int i(x);i>=y;--i)\n#define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n#define clr(x,y) memset(x,y,sizeof(x))\n#define cpy(x,y) memcpy(x,y,sizeof(x))\n#define fin(s) freopen(s\".in\",\"r\",stdin)\n#define fout(s) freopen(s\".out\",\"w\",stdout)\n#define fcin ios::sync_with_stdio(false)\n#define l2(n) ((int)(log2(n)))\ntemplate <class T>il T ABS(T x){return x>0?x:-x;}\ntemplate <class T>il T MAX(T x,T y){return x>y?x:y;}\ntemplate <class T>il T MIN(T x,T y){return x<y?x:y;}\ntemplate <class T>il T GCD(T x,T y){return y?GCD(y,x%y):x;}\ntemplate <class T>il void SWAP(T &x,T &y){T t=x;x=y;y=t;}\nusing namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\nconst int N=200001;\nint n,cnt,rt,siz[N],s[N],ls[N],rs[N],L[N],R[N],D[N],U[N],g[N],tot,d[N];\ndouble a=0.75;\nstruct node{int x,y,v;}t[N];\nbool cmpx(int p,int q){return t[p].x<t[q].x;}\nbool cmpy(int p,int q){return t[p].y<t[q].y;}\nvoid pu(int x){\n    siz[x]=siz[ls[x]]+siz[rs[x]]+1;\n    s[x]=s[ls[x]]+s[rs[x]]+t[x].v;\n    L[x]=R[x]=t[x].x;\n    D[x]=U[x]=t[x].y;\n    if(ls[x])\n        L[x]=MIN(L[x],L[ls[x]]),R[x]=MAX(R[x],R[ls[x]]),\n        D[x]=MIN(D[x],D[ls[x]]),U[x]=MAX(U[x],U[ls[x]]);\n    if(rs[x])\n        L[x]=MIN(L[x],L[rs[x]]),R[x]=MAX(R[x],R[rs[x]]),\n        D[x]=MIN(D[x],D[rs[x]]),U[x]=MAX(U[x],U[rs[x]]);\n}\nint build(int l,int r){\n    if(l>r)return 0;\n    int m=l+r>>1;\n    double av1=0,av2=0,v1=0,v2=0;\n    fur(i,l,r)av1+=t[g[i]].x,av2+=t[g[i]].y;\n    av1\/=r-l+1,av2\/=r-l+1;\n    fur(i,l,r)\n        v1+=(av1-t[g[i]].x)*(av1-t[g[i]].x),\n        v2+=(av2-t[g[i]].y)*(av2-t[g[i]].y);\n    if(v1>v2)nth_element(g+l,g+m,g+r+1,cmpx),d[g[m]]=1;\n    else nth_element(g+l,g+m,g+r+1,cmpy),d[g[m]]=2;\n    ls[g[m]]=build(l,m-1);\n    rs[g[m]]=build(m+1,r);\n    pu(g[m]);\n    return g[m];\n}\nvoid get(int x){if(x)get(ls[x]),g[++tot]=x,get(rs[x]);}\nvoid rb(int&x){tot=0;get(x);x=build(1,tot);}\nbool bad(int x){return a*siz[x]<=(double)MAX(siz[ls[x]],siz[rs[x]]);}\nvoid ins(int&x,int v){\n    if(!x){pu(x=v);return;}\n    if(d[x]==1){\n        if(t[v].x<=t[x].x)ins(ls[x],v);\n        else ins(rs[x],v);\n    }\n    else{\n        if(t[v].y<=t[x].y)ins(ls[x],v);\n        else ins(rs[x],v);\n    }\n    pu(x);\n    if(bad(x))rb(x);\n}\nint ql,qr,qd,qu;\nint ask(int x){\n    if(!x||qr<L[x]||ql>R[x]||qu<D[x]||qd>U[x])return 0;\n    if(ql<=L[x]&&R[x]<=qr&&qd<=D[x]&&U[x]<=qu)return s[x];\n    return ask(ls[x])+ask(rs[x])+\n    ((ql<=t[x].x&&t[x].x<=qr&&qd<=t[x].y&&t[x].y<=qu)?t[x].v:0);\n}\nint main(){\n    in(n);\n    int opt,x,y,v,la=0;\n    while(1){\n        in(opt);\n        if(opt==3)break;\n        if(opt==1){\n            in(x,y,v);\n            x^=la,y^=la,v^=la;\n            t[++cnt]={x,y,v};\n            ins(rt,cnt);\n        }\n        else in(ql,qd,qr,qu),\n        ql^=la,qr^=la,qu^=la,qd^=la,\n        out(la=ask(rt),ln);\n    }\n    flush();\n}\n```\n\n\n可以看成思维偏序问题\n\n先按第一维优先,相同则继续比较其他维排序(保证之后插入的点不会被之前插入的点的范围覆盖,防止统计的时候漏掉),\n\n$f_i=\\max{f_j + 1}$\n\n剩下三维可以用`KDT`求出最大的$f_j$\n\n有两种写法:\n\n1. 带重构`KDT`\n   \n2. 先构建完整的`KDT`,然后把插入当作激活节点\n\n带重构`KDT`:\n\n```cpp\n#include<bits\/stdc++.h>\n#pragma GCC optimize(3)\ntypedef double db;\n#define fur(i,x,y) for(int i(x);i<=y;++i)\nint max(int x,int y){return x>y?x:y;}\nvoid cmin(int &x,int y){x=x<y?x:y;}\nvoid cmax(int &x,int y){x=x>y?x:y;}\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}void out(const char* s){while(*s)pt(*s++);}void out(char* s){while(*s)pt(*s++);}void out(char c){pt(c);}template<typename T>void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\nconst int N=50011,inf=2122219134;\nint _cmp,n,rt,ans,siz[N],ls[N],rs[N],mi[N][3],mx[N][3],s[N],d[N];\nstruct node{\n    int v[4];\n    int& operator[](int x){return v[x];}\n    bool operator<(node p){fur(i,0,3)if(v[i]!=p[i])return v[i]<p[i];}\n}t[N];\nvoid upd(int x,int y){\n    fur(i,0,2)\n        cmin(mi[x][i],mi[y][i]),\n        cmax(mx[x][i],mx[y][i]);\n}\nvoid pu(int x){\n    fur(i,0,2)mi[x][i]=mx[x][i]=t[x][i+1];\n    if(ls[x])upd(x,ls[x]);\n    if(rs[x])upd(x,rs[x]);\n    s[x]=max(t[x][0],max(s[ls[x]],s[rs[x]]));\n    siz[x]=1+siz[ls[x]]+siz[rs[x]];\n}\ndb av[4],v[4];\nint tot,g[N];\nbool cmp(int a,int b){return t[a][_cmp]<t[b][_cmp];}\nint build(int l,int r,int b){\n    if(l>r)return 0;\n    int m=l+r>>1;\n    _cmp=b+1,std::nth_element(g+l,g+m,g+r+1,cmp);\n    ls[g[m]]=build(l,m-1,(b+1)%3),rs[g[m]]=build(m+1,r,(b+1)%3),pu(g[m]);\n    return g[m];\n}\nvoid get(int x){if(x)get(ls[x]),g[++tot]=x,get(rs[x]);}\nvoid rb(int &x){tot=0,get(x),x=build(1,tot,0);}\nbool bad(int x){return 0.75*(db)siz[x]<=(db)max(siz[ls[x]],siz[rs[x]]);}\nvoid ins(int &x,int cur){\n    if(!x){pu(x=cur);return;}\n    ins((t[cur][d[x]]<=t[x][d[x]])?ls[x]:rs[x],cur);\n    pu(x);\n    if(bad(x))rb(x);\n}\nint id,as;\nbool chk(int *p){\n    fur(i,0,2)if(p[i]>t[id][i+1])return 0;\n    return 1;\n}\nvoid ask(int x){\n    if(!x||s[x]<=as)return;\n    if(chk(mx[x])){as=s[x];return;}\n    if(!chk(mi[x]))return;\n    if(chk(t[x].v+1))cmax(as,t[x][0]);\n    ask(ls[x]),ask(rs[x]);\n}\nint main(){\n    freopen(\"in.in\",\"r\",stdin);\n    in(n);\n    fur(i,1,n)fur(j,0,3)in(t[i][j]);\n    std::sort(t+1,t+n+1);\n    t[1][0]=1,ins(rt,1);\n    fur(i,2,n)\n        id=i,as=0,ask(rt),\n        cmax(ans,t[i][0]=as+1),\n        ins(rt,i);\n    printf(\"%d\\n\",ans);\n}\n```\n\n激活节点写法:\n\n```cpp\n#include<bits\/stdc++.h>\n#pragma GCC optimize(3)\ntypedef double db;\n#define fur(i,x,y) for(int i(x);i<=y;++i)\nint max(int x,int y){return x>y?x:y;}\nvoid cmin(int &x,int y){x=x<y?x:y;}\nvoid cmax(int &x,int y){x=x>y?x:y;}\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}void out(const char* s){while(*s)pt(*s++);}void out(char* s){while(*s)pt(*s++);}void out(char c){pt(c);}template<typename T>void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\nconst int N=50011,inf=2122219134;\nint _cmp,n,rt,ans,ls[N],rs[N],mi[N][3],mx[N][3],s[N],g[N];\nstruct node{\n    int v[4];\n    int& operator[](int x){return v[x];}\n    bool operator<(node p){fur(i,0,3)if(v[i]!=p[i])return v[i]<p[i];}\n}t[N];\nvoid pu(int x){\n    fur(i,0,2){\n        mi[x][i]=mx[x][i]=t[x][i+1];\n        if(ls[x])cmin(mi[x][i],mi[ls[x]][i]),cmax(mx[x][i],mx[ls[x]][i]);\n        if(rs[x])cmin(mi[x][i],mi[rs[x]][i]),cmax(mx[x][i],mx[rs[x]][i]);\n    }\n}\nbool cmp(int a,int b){return t[a][_cmp]<t[b][_cmp];}\nint build(int l,int r,int b){\n    if(l>r)return 0;\n    int m=l+r>>1;\n    _cmp=b+1,std::nth_element(g+l,g+m,g+r+1,cmp);\n    ls[g[m]]=build(l,m-1,(b+1)%3),\n    rs[g[m]]=build(m+1,r,(b+1)%3),\n    pu(g[m]);return g[m];\n}\nint id,as;\nbool chk(int *p,int *q=t[id].v+1){\n    fur(i,0,2)if(p[i]>q[i])return 0;\n    return 1;\n}\nvoid ask(int x){\n    if(!x||s[x]<=as)return;\n    if(!chk(mi[x]))return;\n    if(chk(mx[x])){as=s[x];return;}\n    if(chk(t[x].v+1))cmax(as,t[x][0]);\n    ask(ls[x]),ask(rs[x]);\n}\nvoid on(int x){\n    if(x==id){cmax(s[x],t[x][0]=as);return;}\n    if(!chk(t[id].v+1,mx[x])||!chk(mi[x]))return;\n    if(ls[x])on(ls[x]);if(rs[x])on(rs[x]);\n    cmax(s[x],s[ls[x]]),cmax(s[x],s[rs[x]]);\n}\nint main(){\n    in(n);\n    fur(i,1,n)in(t[i][0],t[i][1],t[i][2],t[i][3]),g[i]=i;\n    std::sort(t+1,t+n+1);\n    fur(i,1,n)t[i][0]=0;\n    rt=build(1,n,0);\n    fur(i,1,n)\n        id=i,as=0,ask(rt),\n        cmax(ans,++as),\n        on(rt);\n    printf(\"%d\\n\",ans);\n}\n```","link":null,"tags":["数据结构"],"title":"k-d tree"},{"categories":[["刷题记录"]],"content":"\n```cpp\n#include<bits\/stdc++.h>\n#pragma GCC optimize(3)\n#define il __inline__ __attribute__ ((always_inline))\ntypedef long long ll;typedef unsigned long long ull;typedef double db;typedef short sht;\n#define fur(i,x,y) for(int i(x);i<=y;++i)\n#define fdr(i,x,y) for(int i(x);i>=y;--i)\n#define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n#define clr(x,y) memset(x,y,sizeof(x))\n#define cpy(x,y) memcpy(x,y,sizeof(x))\n#define fin(s) freopen(s\".in\",\"r\",stdin)\n#define fout(s) freopen(s\".out\",\"w\",stdout)\n#define fcin ios::sync_with_stdio(false)\n#define l2(n) ((int)(log2(n)))\ntemplate <class T>il T ABS(T x){return x>0?x:-x;}\ntemplate <class T>il T MAX(T x,T y){return x>y?x:y;}\ntemplate <class T>il T MIN(T x,T y){return x<y?x:y;}\ntemplate <class T>il T GCD(T x,T y){return y?GCD(y,x%y):x;}\ntemplate <class T>il void SWAP(T &x,T &y){T t=x;x=y;y=t;}\nusing namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\nconst int N=100011,inf=2122219134;\nint n,rt,cnt,siz[N],c[2][N],L[N],R[N],D[N],U[N];\n#define ls c[0][x]\n#define rs c[1][x]\nbool d[N];\ndb a=0.75;\nstruct node{int x,y,v;}t[N];\nbool cmpx(node p,node q){return p.x<q.x;}\nbool cmpy(node p,node q){return p.y<q.y;}\nvoid upd(int x,int y){\n    L[x]=MIN(L[x],L[y]),R[x]=MAX(R[x],R[y]),\n    D[x]=MIN(D[x],D[y]),U[x]=MAX(U[x],U[y]);\n}\nvoid pu(int x){\n    siz[x]=siz[ls]+siz[rs]+1;\n    L[x]=R[x]=t[x].x;\n    D[x]=U[x]=t[x].y;\n    if(ls)upd(x,ls);\n    if(rs)upd(x,rs);\n}\nint build(int l,int r){\n    if(l>r)return 0;\n    int m=l+r>>1,x=m;\n    db av1=0,av2=0,v1=0,v2=0;\n    fur(i,l,r)av1+=t[i].x,av2+=t[i].y;\n    av1\/=r-l+1,av2\/=r-l+1;\n    fur(i,l,r)\n        v1+=(av1-t[i].x)*(av1-t[i].x),\n        v2+=(av2-t[i].y)*(av2-t[i].y);\n    nth_element(t+l,t+m,t+r+1,(v1>v2)?cmpx:cmpy);\n    d[x]=v1>v2;\n    ls=build(l,m-1),rs=build(m+1,r);\n    pu(x);return x;\n}\nint qx,qy;\nstruct dat{\n    ll d;int id;\n    bool operator<(dat p)const{return d>p.d||(d==p.d&&id<p.id);}\n};\npriority_queue<dat>q;\nll dis(node p){return 1ll*(p.x-qx)*(p.x-qx)+1ll*(p.y-qy)*(p.y-qy);}\nll mxd(int x){\n    return MAX(1ll*(L[x]-qx)*(L[x]-qx),1ll*(R[x]-qx)*(R[x]-qx))+\n           MAX(1ll*(D[x]-qy)*(D[x]-qy),1ll*(U[x]-qy)*(U[x]-qy));\n}\nvoid ask(int x){\n    if(!x)return;\n    ll res=dis(t[x]),ld=0,rd=0;\n    if(res>q.top().d||(res==q.top().d&&t[x].v<q.top().id))\n        q.pop(),q.push(dat{res,t[x].v});\n    if(ls)ld=mxd(ls);\n    if(rs)rd=mxd(rs);\n    if(ld>rd){\n        if(ld>=q.top().d)ask(ls);\n        if(rd>=q.top().d)ask(rs);\n    }\n    else{\n        if(rd>=q.top().d)ask(rs);\n        if(ld>=q.top().d)ask(ls);\n    }\n}\nint main(){\n    in(n);\n    int m,x,y,k;\n    fur(i,1,n)in(x,y),t[i]=node{x,y,i};\n    rt=build(1,n);\n    in(m);\n    while(m--){\n        in(qx,qy,k);\n        while(!q.empty())q.pop();\n        while(k--)q.push(dat{-1,0});\n        ask(rt);\n        out(q.top().id,ln);\n    }\n    flush();\n}\n```\n","link":null,"tags":["kdt"],"title":"LG 2093 [国家集训队]JZPFAR"},{"categories":[["刷题记录"]],"content":"\n`k-d tree`模板\n\n```cpp\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define I inline\n#define ll long long\nusing namespace std;\n\ntemplate <typename T>\nvoid read(T &x) {\n    x = 0; bool f = 0;\n    char c = getchar();\n    for (;!isdigit(c);c=getchar()) if (c=='-') f=1;\n    for (;isdigit(c);c=getchar()) x=x*10+(c^48);\n    if (f) x=-x;\n}\n\nconst int N = 200500;\nstruct node {\n\tint d[4];\n\tbool operator < (const node &k) const {\n\t\tfor (int i = 0;i < 4; i++) \n\t\t\tif (d[i] != k.d[i]) return d[i] < k.d[i];\n\t\treturn 0;\n\t}\n}p[N];\n\nint g[N], k;\n\nI bool cmp(int a, int b) {\n\treturn p[a].d[k] < p[b].d[k];\n}\n\n#define ls son[x][0]\n#define rs son[x][1]\n\nint son[N][2];\nint mx[N][3], mn[N][3], mxa[N], res[N], ans;\nI void Mn(int &x, int y) { if (x > y) x = y; }\nI void Mx(int &x, int y) { if (x < y) x = y; }\n\nI void maintain(int x) {\n\tfor (int i = 0;i <= 2; i++) {\n\t\tmx[x][i] = mn[x][i] = p[x].d[i+1];\n\t\tif (ls) Mx(mx[x][i], mx[ls][i]), Mn(mn[x][i], mn[ls][i]);\n\t\tif (rs) Mx(mx[x][i], mx[rs][i]), Mn(mn[x][i], mn[rs][i]);\n\t}\n}\nint build(int l, int r, int d) {\n\tif (l > r) return 0;\n\tint mid = (l + r) >> 1;\n\tk = d + 1, nth_element(g + l, g + mid, g + r + 1, cmp);\n\tson[g[mid]][0] = build(l, mid - 1, (d + 1) % 3);\n\tson[g[mid]][1] = build(mid + 1, r, (d + 1) % 3);\n\tmaintain(g[mid]); return g[mid];\n}\n\nint tmp;\n\n\/\/ 判断x点是否在y点范围以内 \ninline bool in(int *x, int *y) {\n\tint cnt = 0;\n\tfor (int i = 0;i < 3; i++) cnt += (x[i] <= y[i]);\n\treturn cnt == 3;\n}\n\nvoid query(int x, int y) {\n\tif (mxa[x] <= tmp) return;\n\tif (!in(mn[x], p[y].d + 1)) return;\n\tif (in(mx[x], p[y].d + 1)) return tmp = mxa[x], void();\n\tif (in(p[x].d + 1, p[y].d + 1)) Mx(tmp, res[x]);\n\tif (ls) query(ls, y); if (rs) query(rs, y);\n}\n\n\/\/ 激活操作 \nvoid upit(int x, int y) {\n\tif (x == y) {\n\t\tres[x] = tmp, Mx(mxa[x], res[x]); return;\n\t}\n\tif (!in(p[y].d + 1, mx[x]) || !in(mn[x], p[y].d + 1)) return;\n\t\/\/ 如果y点不在里面就返回 \n\tif (ls) upit(ls, y); if (rs) upit(rs, y);\n\tMx(mxa[x], mxa[ls]), Mx(mxa[x], mxa[rs]);\n}\n\nint rt, n;\nint main() {\n\tfreopen (\"..\/in.in\",\"r\",stdin);\n\tread(n);\n\tfor (int i = 1;i <= n; i++) {\n\t\tread(p[i].d[0]), read(p[i].d[1]);\n\t\tread(p[i].d[2]), read(p[i].d[3]);\n\t\tg[i] = i;\n\t}\n\tsort(p + 1, p + n + 1); rt = build(1, n, 0);\n\tfor (int i = 1;i <= n; i++) \n\t\ttmp = 0, query(rt, i), tmp++, upit(rt, i), Mx(ans, tmp);\n\tcout << ans << endl;\n\treturn 0;\n}\n\n\n```\n","link":null,"tags":["kdt"],"title":"LG 4148 简单题"},{"categories":[["刷题记录"]],"content":"\n`1 x`表示把点$x$到根节点的路径上所有的点染上一种没有用过的新颜色\n\n从这里可以看出每种颜色在树上都是一条链的形式存在\n\n可以发现这和`LCT`很像\n\n那么`1`操作可以看成`access`操作,(如何操作先放着\n\n$x$到根的颜色种数也就是要经过的虚边的条数,设为$S_x$\n\n求$x$到$y$的路径的权值,可以使用树上差分的形式\n\n也就是转化为$S_x + S_y - 2\\times S_{lca(x,y)} + 1$\n\n`3`操作也就是求子树最值\n\n我们回过头来看`access`操作:\n\n1. 原来的实边变虚,意味着要多走一条虚边,将此链所管辖的区域全部+1\n   \n2. 虚边变实边,意味着要多少一条虚边,将此链所管辖的区域全部-1\n\n注意: `LCT`中`splay`的父子关系并不是原树中的父子关系,要找到该`splay`中深度最小的节点(也就是这条链的顶端再操作)\n\n综上可以用 lct+lca+dfs序+线段树 解决\n\n当然也可以通过树剖模拟`access`的形式来解决\n\n```cpp\n#include<bits\/stdc++.h>\n#pragma GCC optimize(3)\n#define il __inline__ __attribute__ ((always_inline))\n#define fur(i,x,y) for(int i(x);i<=y;++i)\n#define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\ntemplate <class T>il T MAX(T x,T y){return x>y?x:y;}\nusing namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\nconst int N=100011;\nint n,q,cnt,head[N],a[N];\nstruct seg{\n    #define ls rt<<1\n    #define rs rt<<1|1\n    #define pu s[rt]=MAX(s[ls],s[rs])\n    int s[N<<2],laz[N<<2];\n    void build(int l=1,int r=n,int rt=1){\n        if(l==r)return void(s[rt]=a[l]);\n        int m=l+r>>1;\n        build(l,m,ls);build(m+1,r,rs);\n        pu;\n    }\n    il void pd(int rt){\n        if(laz[rt]){\n            laz[ls]+=laz[rt];\n            laz[rs]+=laz[rt];\n            s[ls]+=laz[rt];\n            s[rs]+=laz[rt];\n            laz[rt]=0;\n        }\n    }\n    void upd(int L,int R,int v,int l=1,int r=n,int rt=1){\n        if(L<=l&&r<=R){\n            s[rt]+=v,laz[rt]+=v;\n            return;\n        }\n        int m=l+r>>1;\n        pd(rt);\n        if(L<=m)upd(L,R,v,l,m,ls);\n        if(R>m)upd(L,R,v,m+1,r,rs);\n        pu;\n    }\n    int ask(int L,int R,int l=1,int r=n,int rt=1){\n        if(L<=l&&r<=R)return s[rt];\n        int m=l+r>>1,ans=0;\n        pd(rt);\n        if(L<=m)ans=ask(L,R,l,m,ls);\n        if(R>m)ans=MAX(ans,ask(L,R,m+1,r,rs));\n        return ans;\n    }\n    il int operator[](int x){\n        int l=1,r=n,rt=1;\n        while(1){\n            if(l==r)return s[rt];\n            int m=l+r>>1;\n            pd(rt);\n            if(x<=m)r=m,rt=ls;\n            else l=m+1,rt=rs;\n        }\n    }\n    #undef ls\n    #undef rs\n}S;\nstruct edge{int to,nxt;}e[N<<1];\nil void add(int x,int y){e[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;}\nint siz[N],top[N],id[N],sz;\nstruct lct{\n    #define ls c[0][x]\n    #define rs c[1][x]\n    int f[N],c[2][N];\n    il int g(int x){return c[1][f[x]]==x;}\n    il int nrt(int x){return c[0][f[x]]==x||c[1][f[x]]==x;}\n    il void rotate(int x){\n        int y=f[x],z=f[y],l=g(x),r=!l,w=c[r][x];\n        if(nrt(y))c[g(y)][z]=x;\n        c[r][x]=y,c[l][y]=w;\n        if(w)f[w]=y;\n        f[x]=z,f[y]=x;\n    }\n    il void splay(int x){\n        for(;nrt(x);rotate(x))if(nrt(f[x]))\n            rotate(g(x)^g(f[x])?x:f[x]);\n    }\n    il int frt(int x){while(ls)x=ls;return x;}\n    il void access(int x){\n        for(int y=0,t;x;x=f[y=x]){\n            splay(x);\n            if(rs)t=frt(rs),S.upd(id[t],id[t]+siz[t]-1,1);\n            if(rs=y)t=frt(y),S.upd(id[t],id[t]+siz[t]-1,-1);\n        }\n    }\n    #undef ls\n    #undef rs\n}T;\nint f[N],d[N];\nvoid dfs(int x){\n    siz[x]=1;d[x]=d[f[x]]+1;\n    fl(i,x)if(to!=f[x])\n        f[to]=T.f[to]=x,dfs(to),siz[x]+=siz[to];\n}\nvoid bt(int x,int tp){\n    top[x]=tp;a[id[x]=++sz]=d[x];int k=0;\n    fl(i,x)if(to!=f[x]&&siz[to]>siz[k])k=to;\n    if(!k)return;bt(k,tp);\n    fl(i,x)if(!top[to])bt(to,to);\n}\nil int lca(int x,int y){\n    while(top[x]^top[y])\n        d[top[x]]>d[top[y]]?x=f[top[x]]:y=f[top[y]];\n    return d[x]<d[y]?x:y;\n}\nint main(){\n    in(n,q);\n    int opt,x,y;\n    fur(i,2,n)in(x,y),add(x,y),add(y,x);\n    dfs(1);bt(1,1);S.build();\n    while(q--){\n        in(opt,x);\n        if(opt==1)T.access(x);\n        else if(opt==2)\n            in(y),out(S[id[x]]+S[id[y]]-(S[id[lca(x,y)]]<<1)+1,ln);\n        else out(S.ask(id[x],id[x]+siz[x]-1),ln);\n    }\n    flush();\n}\n```\n","link":null,"tags":["lct","线段树","树状数组","dfs序","树链剖分","lca"],"title":"LG 3703 [SDOI2017]树点涂色"},{"categories":[["刷题记录"]],"content":"\nLCT维护重心\n\n这里利用了两个重心性质:\n\n1. 树中所有点到某个点的距离和中,到重心的距离和是最小的,如果有两个距离和,他们的距离和一样。\n   \n2. 把两棵树通过某一点相连得到一颗新的树,新的树的重心必然在连接原来两棵树重心的路径上。\n\n我们需要维护子树的大小\n\n合并的时候连接两棵树,分离出连接原来两棵树重心的路径,在链上搜索出答案\n\n方法类似平衡树的查找\n```cpp\n#include<bits\/stdc++.h>\nconst int N=100011;\nint n,q,s[N],s2[N],c[2][N],f[N],bl[N],ans;\nbool rev[N];\nint BL(int x){return x==bl[x]?x:(bl[x]=BL(bl[x]));}\n#define ls c[0][x]\n#define rs c[1][x]\nvoid pu(int x){s[x]=s[ls]+s[rs]+1+s2[x];}\nvoid pr(int x){rev[x]^=1;ls^=rs,rs^=ls,ls^=rs;}\nvoid pd(int x){\n    if(rev[x]){\n        if(ls)pr(ls);\n        if(rs)pr(rs);\n        rev[x]=0;\n    }\n}\nint g(int x){return c[1][f[x]]==x;}\nint nrt(int x){return c[0][f[x]]==x||c[1][f[x]]==x;}\nvoid rotate(int x){\n    int y=f[x],z=f[y],l=g(x),r=!l,w=c[r][x];\n    if(nrt(y))c[g(y)][z]=x;\n    c[r][x]=y,c[l][y]=w;\n    if(w)f[w]=y;\n    f[x]=z,f[y]=x;\n    pu(y),pu(x);\n}\nvoid pda(int x){if(nrt(x))pda(f[x]);pd(x);}\nvoid splay(int x){\n    for(pda(x);nrt(x);rotate(x))if(nrt(f[x]))\n        rotate(g(x)^g(f[x])?x:f[x]);\n    pu(x);\n}\nvoid access(int x){\n    for(int y=0;x;x=f[y=x])\n        splay(x),s2[x]+=s[rs]-s[rs=y],pu(x);\n}\nvoid mrt(int x){access(x),splay(x),pr(x);}\nvoid link(int x,int y){\n    mrt(x),access(y),splay(y);\n    f[x]=y;\n    s2[y]+=s[x];\n    pu(y);\n}\nint find(int x){\n    bool ff=s[x]&1;\n    int sum=s[x]>>1,cl,cr,as=n+1,lsum=0,rsum=0;\n    while(x){\n        pd(x);\n        cl=s[ls]+lsum,cr=s[rs]+rsum;\n        if(cl<=sum&&cr<=sum){\n            if(ff)return x;\n            else if(as>x)as=x;\n        }\n        if(cl<cr)lsum+=s[ls]+s2[x]+1,x=rs;\n        else rsum+=s[rs]+s2[x]+1,x=ls;\n    }\n    return as;\n}\nint main(){\n    scanf(\"%d%d\",&n,&q);\n    for(int i=1;i<=n;++i)s[i]=1,bl[i]=i,ans^=i;\n    char opt[5];\n    int x,y;\n    while(q--){\n        scanf(\"%s\",opt);\n        if(opt[0]=='X')printf(\"%d\\n\",ans);\n        else if(opt[0]=='Q')\n            scanf(\"%d\",&x),\n            printf(\"%d\\n\",BL(x));\n        else{\n            scanf(\"%d%d\",&x,&y);\n            link(x,y);\n            x=BL(x),y=BL(y);\n            mrt(x),access(y),splay(y);\n            int z=find(y);\n            bl[x]=bl[y]=bl[z]=z;\n            ans^=x^y^z;\n            splay(z);\n        }\n    }\n}\n```\n","link":null,"tags":["lct","并查集"],"title":"LG 4299 首都"},{"categories":[["刷题记录"]],"content":"\n## 解法一\n\n化边为点\n\n每个点的父边赋予该点的颜色。我们需要两个LCT,每种对应一个颜色。一条边只有在对应颜色的LCT中才会被连上。\n\n接着可以发现,修改一个点的颜色,只需要在原来颜色对应`LCT`中断开父边,在新颜色`LCT`中连接父边,就可以维护同色连通块了\n\n查询的时候只要找到$x$所在`splay`的根,右子树大小就是答案(相当于边的数目,根的深度最浅,只有右子树)\n\n注意: 1节点是没有父亲的,不过为了模型的建立,要有父边,于是需要加一个虚点,让1的父亲指向它连边\n\n手动模拟一下应该可以懂\n\n```cpp\n#include<bits\/stdc++.h>\n#pragma GCC optimize(3)\n#define il __inline__ __attribute__ ((always_inline))\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\nconst int N=100011;\nint n,q,cnt,head[N],fa[N],v[N];\nbool col[N];\nstruct edge{int to,nxt;}e[N<<1];\nil void add(int x,int y){e[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;}\nstruct LCT{\n    int s[N],c[2][N],s2[N],f[N];\n    il void build(){for(int i=1;i<=n+1;++i)s[i]=1;}\n    #define ls c[0][x]\n    #define rs c[1][x]\n    il void pu(int x){s[x]=s[ls]+s[rs]+1+s2[x];}\n    il int g(int x){return c[1][f[x]]==x;}\n    il int nrt(int x){return c[0][f[x]]==x||c[1][f[x]]==x;}\n    il void rotate(int x){\n        int y=f[x],z=f[y],l=g(x),r=!l,w=c[r][x];\n        if(nrt(y))c[g(y)][z]=x;\n        c[r][x]=y,c[l][y]=w;\n        if(w)f[w]=y;\n        f[x]=z,f[y]=x;\n        pu(y),pu(x);\n    }\n    il void splay(int x){\n        for(int y;nrt(x);rotate(x))if(nrt(y=f[x]))\n            rotate(g(x)^g(y)?x:y);\n        pu(x);\n    }\n    il void access(int x){for(int y=0;x;x=f[y=x])splay(x),s2[x]+=s[rs]-s[rs=y],pu(x);}\n    il void brt(int x){access(x),splay(x);}\n    il int frt(int x){\n        for(brt(x);ls;x=ls);\n        splay(x);return x;\n    }\n    il void link(int x){\n        splay(x);\n        int y=f[x]=fa[x];\n        brt(y);\n        c[1][y]=x,pu(y);\n    }\n    il void cut(int x){\n        brt(x);\n        ls=f[ls]=0;\n        pu(x);\n    }\n    il int ask(int x){return s[c[1][frt(x)]];}\n}T[2];\nvoid dfs(int x){\n    for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n        if(to!=fa[x])fa[to]=x,dfs(to);\n    T[0].link(x);\n}\nint main(){\n    in(n);\n    T[0].build(),T[1].build();\n    int x,y;\n    for(int i=1;i<n;++i)in(x,y),add(x,y),add(y,x);\n    fa[1]=n+1;dfs(1);\n    in(q);\n    while(q--){\n        in(y,x);\n        if(y)T[col[x]].cut(x),T[col[x]^=1].link(x);\n        else out(T[col[x]].ask(x),ln);\n    }\n    flush();\n}\n```\n\n## 解法2\n\n类似QTREE5的做法\n\n记录实链顶端和底端的答案\n\n要仔细考虑`push up`\n\n```cpp\n#include<bits\/stdc++.h>\nconst int N=100011;\nint n,q,s[2][N],c[2][N],f[N],sl[N],sr[N],col[N],tc[N],lc[N],rc[N];\n#define ls c[0][x]\n#define rs c[1][x]\nvoid pu(int x){\n    sl[x]=sl[ls]+(((tc[ls]!=2&&col[x]==tc[ls])||!ls)?s[col[x]][x]+1+(lc[rs]==col[x]?sl[rs]:0):0);\n    sr[x]=sr[rs]+(((tc[rs]!=2&&col[x]==tc[rs])||!rs)?s[col[x]][x]+1+(rc[ls]==col[x]?sr[ls]:0):0);\n    lc[x]=ls?lc[ls]:col[x];\n    rc[x]=rs?rc[rs]:col[x];\n    if(tc[ls]==2||tc[rs]==2||(ls&&tc[ls]!=col[x])||(rs&&tc[rs]!=col[x]))tc[x]=2;\n    else tc[x]=col[x];\n}\nint g(int x){return c[1][f[x]]==x;}\nint nrt(int x){return c[0][f[x]]==x||c[1][f[x]]==x;}\nvoid rotate(int x){\n    int y=f[x],z=f[y],l=g(x),r=!l,w=c[r][x];\n    if(nrt(y))c[g(y)][z]=x;\n    c[r][x]=y,c[l][y]=w;\n    if(w)f[w]=y;\n    f[x]=z,f[y]=x;\n    pu(y),pu(x);\n}\nvoid splay(int x){\n    for(;nrt(x);rotate(x))if(nrt(f[x]))\n        rotate(g(x)^g(f[x])?x:f[x]);\n}\nvoid access(int x){\n    for(int y=0;x;x=f[y=x]){\n        splay(x);\n        s[lc[rs]][x]+=sl[rs];\n        rs=y;\n        s[lc[y]][x]-=sl[y];\n        pu(x);\n    }\n}\nint cnt=0,head[N];\nstruct edge{int to,nxt;}e[N<<1];\nvoid add(int x,int y){e[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;}\nvoid dfs(int x,int fa){\n    for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n    if(to!=fa){\n        dfs(to,x);\n        f[to]=x;s[lc[to]][x]+=sl[to];\n    }\n    pu(x);\n}\nint main(){\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;++i)sl[i]=sr[i]=1;\n    int x,y;\n    for(int i=1;i<n;++i){\n        scanf(\"%d%d\",&x,&y);\n        add(x,y),add(y,x);\n    }\n    dfs(1,0);\n    scanf(\"%d\",&q);\n    while(q--){\n        scanf(\"%d%d\",&y,&x);\n        access(x),splay(x);\n        if(y)col[x]^=1,pu(x);\n        else printf(\"%d\\n\",sr[x]);\n    }\n}\n```\n","link":null,"tags":["lct"],"title":"LG SP16549 QTREE6 - Query on a tree VI"},{"categories":[["刷题记录"]],"content":"\n还是QTREE6的方法\n\n从维护子树大小变成了维护子树最值\n```cpp\n#include<bits\/stdc++.h>\n#pragma GCC optimize(3)\n#define il __inline__ __attribute__ ((always_inline))\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\nconst int N=100011,inf=1000000000;\nusing std::multiset;\nint n,q,cnt,head[N],fa[N],v[N];\nbool col[N];\nstruct edge{int to,nxt;}e[N<<1];\nil void add(int x,int y){e[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;}\nstruct LCT{\n    LCT(){s[0]=-inf;}\n    int s[N],c[2][N],f[N];\n    multiset<int>s2[N];\n    #define ls c[0][x]\n    #define rs c[1][x]\n    il int max(int x,int y){return x>y?x:y;}\n    il void pu(int x){\n        s[x]=max(max(s[ls],s[rs]),v[x]);\n        if(!s2[x].empty())s[x]=max(s[x],*s2[x].rbegin());\n    }\n    il int g(int x){return c[1][f[x]]==x;}\n    il int nrt(int x){return c[0][f[x]]==x||c[1][f[x]]==x;}\n    il void rotate(int x){\n        int y=f[x],z=f[y],l=g(x),r=!l,w=c[r][x];\n        if(nrt(y))c[g(y)][z]=x;\n        c[r][x]=y,c[l][y]=w;\n        if(w)f[w]=y;\n        f[x]=z,f[y]=x;\n        pu(y),pu(x);\n    }\n    il void splay(int x){\n        for(int y;nrt(x);rotate(x))if(nrt(y=f[x]))\n            rotate(g(x)^g(y)?x:y);\n        pu(x);\n    }\n    il void access(int x){\n        for(int y=0;x;x=f[y=x]){\n            splay(x);\n            if(rs)s2[x].insert(s[rs]);\n            if(rs=y)s2[x].erase(s2[x].find(s[y]));\n            pu(x);\n        }\n    }\n    il void brt(int x){access(x),splay(x);}\n    il int frt(int x){\n        for(brt(x);ls;x=ls);\n        splay(x);return x;\n    }\n    il void link(int x){\n        splay(x);\n        int y=f[x]=fa[x];\n        brt(y);\n        c[1][y]=x,pu(y);\n    }\n    il void cut(int x){\n        brt(x);\n        ls=f[ls]=0;\n        pu(x);\n    }\n    il int ask(int x){return s[c[1][frt(x)]];}\n}T[2];\nvoid dfs(int x){\n    for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n        if(to!=fa[x])fa[to]=x,dfs(to);\n    T[col[x]].link(x);\n}\nint main(){\n    in(n);\n    int x,y;\n    for(int i=1;i<n;++i)\n        in(x,y),\n        add(x,y),add(y,x);\n    for(int i=1;i<=n;++i)in(col[i]);\n    for(int i=1;i<=n;++i)in(v[i]);\n    fa[1]=n+1;dfs(1);\n    in(q);\n    while(q--){\n        in(y,x);\n        if(y==0)out(T[col[x]].ask(x),ln);\n        else if(y==1)T[col[x]].cut(x),T[col[x]^=1].link(x);\n        else{\n            T[0].brt(x),T[1].brt(x),\n            in(v[x]),\n            T[0].pu(x),T[1].pu(x);\n        }\n    }\n    flush();\n}\n```\n","link":null,"tags":["lct"],"title":"LG SP16580 QTREE7 - Query on a tree VII"},{"categories":[["刷题记录"]],"content":"\n## fhqtreap做法\n\n在普通`fhqtreap`的基础上记录节点的父亲\n\n`M x y`: 一直向上走就可以找到根,然后合并即可\n\n`D x`: 求出$x$的排名,然后按排名分裂即可\n\n`Q x y`: 求出$x,y$排名,分裂,得出答案,再合并回去\n\n```cpp\n#include<bits\/stdc++.h>\n#pragma GCC optimize(3)\n#define il __inline__ __attribute__ ((always_inline))\ntypedef long long ll;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\nconst int N=200001;\nint n,q,ls[N],rs[N],f[N],rnd[N],v[N],sz[N];\nll s[N];\nil int rand(){static int seed=233;return seed=(int)seed*482711LL%n; }\nil void pu(int x){\n    s[x]=s[ls[x]]+s[rs[x]]+v[x];\n    sz[x]=sz[ls[x]]+sz[rs[x]]+1;\n    f[ls[x]]=f[rs[x]]=x;\n}\nvoid sl(int &x,int &y,int rt,int k){\n    if(!rt)return void(x=y=0);\n    if(sz[ls[rt]]>=k)y=rt,sl(x,ls[y],ls[y],k);\n    else x=rt,sl(rs[x],y,rs[x],k-sz[ls[x]]-1);\n    pu(rt);\n}\nint mg(int x,int y){\n    if(!x||!y)return x|y;\n    if(rnd[x]<rnd[y]){\n        rs[x]=mg(rs[x],y);\n        pu(x);return x;\n    }\n    else{\n        ls[y]=mg(x,ls[y]);\n        pu(y);return y;\n    }\n}\nil int get(int x){\n    while(f[x])x=f[x];\n    return x;\n}\nil int rnk(int x){\n    int cnt=sz[ls[x]]+1;\n    while(x){\n        if(rs[f[x]]==x)cnt+=sz[ls[f[x]]]+1;\n        x=f[x];\n    }\n    return cnt;\n}\nint main(){\n    in(n,q);\n    for(int i=1;i<=n;++i)in(v[i]),s[i]=v[i],rnd[i]=rand(),sz[i]=1;\n    char opt;int x,y,z;\n    while(q--){\n        in(opt,x);\n        if(opt=='M'){\n            in(y),x=get(x),y=get(y);\n            if(x!=y)mg(y,x);\n        }\n        else if(opt=='D'){\n            int rt=get(x),rk=rnk(x);\n            sl(x,y,rt,rk-1);\n            f[x]=f[y]=0;\n        }\n        else if(opt=='Q'){\n            in(y);\n            int rt=get(x);\n            if(get(y)!=rt){out(\"-1\\n\");continue;}\n            else{\n                int rkx=rnk(x),rky=rnk(y);\n                if(rkx>rky)rkx^=rky,rky^=rkx,rkx^=rky;\n                sl(x,z,rt,rky);\n                sl(x,y,x,rkx-1);\n                out(s[y],ln);\n                mg(mg(x,y),z);\n            }\n        }\n    }\n    flush();\n}\n```\n\n## splay做法\n\n做法详见注释\n\n```cpp\n#include<bits\/stdc++.h>\n#pragma GCC optimize(3)\n#define il __inline__ __attribute__ ((always_inline))\ntypedef long long ll;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\nconst int N=200001;\nint n,q,c[2][N],f[N],v[N];\nll s[N];\n#define ls(x) c[0][x]\n#define rs(x) c[1][x]\nil void pu(int x){s[x]=s[ls(x)]+s[rs(x)]+v[x];}\nil int g(int x){return rs(f[x])==x;}\nil void rotate(int x){\n    int y=f[x],z=f[y],l=g(x),r=!l,w=c[r][x];\n    if(z)c[g(y)][z]=x;\n    c[r][x]=y,c[l][y]=w;\n    if(w)f[w]=y;\n    f[x]=z,f[y]=x;\n    pu(y),pu(x);\n}\nil void splay(int x){\n    \/\/for(int y;y=f[x];rotate(x))if(f[y])\n    \/\/    rotate(g(x)^g(y)?x:y);\n    while(f[x])rotate(x);\/\/这题单旋更快\n}\nil void mg(int x,int y){\n    if(x==y)return;\n    splay(x),splay(y);\n    if(f[x])return;\n    \/\/将x接到y子树中最右端\n    while(rs(y))y=rs(y);\n    f[rs(y)=x]=y;\n    pu(y);\n}\nil void cut(int x){splay(x),f[ls(x)]=0,ls(x)=0,pu(x);}\/\/断开x与x前面的\nil ll ask(int x,int y){\n    if(x==y)return v[x];\n    ll l,r;\n    splay(x),l=s[ls(x)];\n    splay(y),r=s[ls(y)];\n    if(!f[x])return -1;\n    \/\/有可能出现端点前后颠倒的情况\n    if(l>r)return l-r+v[x];\n    else return r-l+v[y];\n}\nint main(){\n    in(n,q);\n    for(int i=1;i<=n;++i)in(v[i]);\n    char opt;int x,y,z;\n    while(q--){\n        in(opt,x);\n        if(opt=='M')in(y),mg(x,y);\n        else if(opt=='D')cut(x);\n        else if(opt=='Q')in(y),out(ask(x,y),ln);\n    }\n    flush();\n}\n```\n```cpp\n#include<bits\/stdc++.h>\n#pragma GCC optimize(3)\n#define il __inline__ __attribute__ ((always_inline))\ntypedef long long ll;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\nconst int N=200001;\nint n,q,c[2][N],f[N],v[N];\nll s[N];\n#define ls(x) c[0][x]\n#define rs(x) c[1][x]\nil void pu(int x){s[x]=s[ls(x)]+s[rs(x)]+v[x];}\nil int g(int x){return rs(f[x])==x;}\nil void rotate(int x){\n    int y=f[x],z=f[y],l=g(x),r=!l,w=c[r][x];\n    if(z)c[g(y)][z]=x;\n    c[r][x]=y,c[l][y]=w;\n    if(w)f[w]=y;\n    f[x]=z,f[y]=x;\n    pu(y),pu(x);\n}\nil void splay(int x){\n    \/\/ for(int y;y=f[x];rotate(x))if(f[y])\n        \/\/ rotate(g(x)^g(y)?x:y);\n    while(f[x])rotate(x);\n}\nil void mg(int x,int y){\n    if(x==y)return;\n    splay(x),splay(y);\n    if(f[x])return;\n    while(rs(y))y=rs(y);\n    f[rs(y)=x]=y;\n    pu(y);\n}\nil void cut(int x){splay(x),f[ls(x)]=0,ls(x)=0,pu(x);}\nil ll ask(int x,int y){\n    if(x==y)return v[x];\n    ll l,r;\n    splay(x),l=s[ls(x)];\n    splay(y),r=s[ls(y)];\n    if(!f[x])return -1;\n    if(l>r)return l-r+v[x];\n    else return r-l+v[y];\n}\nint main(){\n    in(n,q);\n    for(int i=1;i<=n;++i)in(v[i]);\n    char opt;int x,y,z;\n    while(q--){\n        in(opt,x);\n        if(opt=='M')in(y),mg(x,y);\n        else if(opt=='D')cut(x);\n        else if(opt=='Q')in(y),out(ask(x,y),ln);\n    }\n    flush();\n}\n```\n","link":null,"tags":["lct","并查集","splay","fhqtreap"],"title":"LG 4847 银河英雄传说V2"},{"categories":[["刷题记录"]],"content":"\n`LCT`动态维护最小生成树\n\n维护链上的最大值和次大值\n\n先找出最小生成树,然后枚举剩下的边,找出相差最小的,得出答案\n\n这题还可以用kruskal生成树+倍增(或树剖)做,常数会小很多\n```cpp\n#include<bits\/stdc++.h>\n#define il __inline__ __attribute__ ((always_inline))\nil int min(int x,int y){return x<y?x:y;}\nil int max(int x,int y){return x>y?x:y;}\nnamespace IN{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;inline char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}template<typename T>inline void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>inline void in(T &x,arr & ... y){in(x),in(y...);}}using namespace IN;\nconst int N=100001;\nint n,m,s[N<<1],S[N<<1],c[2][N<<1],f[N<<1],v[N<<1];\nbool rev[N<<1];\n#define ls c[0][x]\n#define rs c[1][x]\nil void pu(int x){\n    if(s[ls]>s[rs])s[x]=s[ls],S[x]=max(S[ls],s[rs]);\n    else if(s[rs]>s[ls])s[x]=s[rs],S[x]=max(s[ls],S[rs]);\n    else s[x]=s[ls],S[x]=max(S[ls],S[rs]);\n\n    if(v[x]>s[x])S[x]=s[x],s[x]=v[x];\n    else if(v[x]!=s[x]&&v[x]>S[x])S[x]=v[x];\n}\nil void pr(int x){rev[x]^=1,ls^=rs,rs^=ls,ls^=rs;}\nil void pd(int x){\n    if(rev[x]){\n        if(ls)pr(ls);\n        if(rs)pr(rs);\n        rev[x]=0;\n    }\n}\nil int g(int x){return c[1][f[x]]==x;}\nil int nrt(int x){return c[0][f[x]]==x||c[1][f[x]]==x;}\nvoid pda(int x){if(nrt(x))pda(f[x]);pd(x);}\nil void rotate(int x){\n    int y=f[x],z=f[y],l=g(x),r=!l,w=c[r][x];\n    if(nrt(y))c[g(y)][z]=x;\n    c[r][x]=y,c[l][y]=w;\n    if(w)f[w]=y;\n    f[x]=z,f[y]=x;\n    pu(y),pu(x);\n}\nil void splay(int x){\n    for(pda(x);nrt(x);rotate(x))if(nrt(f[x]))\n        rotate(g(x)^g(f[x])?x:f[x]);\n}\nil void access(int x){\n    for(int y=0;x;x=f[y=x])\n        splay(x),rs=y,pu(x);\n}\nil void mrt(int x){access(x),splay(x),pr(x);}\nstruct edge{\n    int x,y,w;\n    bool operator<(edge t){return w<t.w;}\n}e[300001];\nint fa[N];\nint gf(int x){return x==fa[x]?x:(fa[x]=gf(fa[x]));}\nint main(){\n    in(n,m);\n    for(int i=1;i<=m;++i)in(e[i].x,e[i].y,e[i].w);\n    std::sort(e+1,e+m+1);\n    long long tot=0;int x,y,id=n,ans=-1u>>1;\n    for(int i=1;i<=n;++i)fa[i]=i;\n    for(int i=1;i<=m;++i){\n        x=e[i].x,y=e[i].y;\n        if(gf(x)!=gf(y)){\n            fa[fa[x]]=fa[y];\n            tot+=e[i].w;\n            v[++id]=e[i].w;\n            mrt(x),mrt(y),f[x]=f[y]=id;\n        }\n        else{\n            mrt(x),access(y),splay(y);\n            ans=min(ans,e[i].w-(e[i].w>s[y]?s[y]:S[y]));\n        }\n    }\n    printf(\"%lld\\n\",tot+ans);\n}\n```\n","link":null,"tags":["lct","kruskal","树链剖分","倍增"],"title":"LG 4180 [BJWC2010]严格次小生成树"},{"categories":[["刷题记录"]],"content":"\n求$\\sum_{i=l}^r deep[LCA(i,z)]$\n\n首先,可以把询问拆成两个部分相减$\\sum_{i=1}^r deep[LCA(i,z)]-\\sum_{i=1}^{l-1} deep[LCA(i,z)]$\n\n考虑一种暴力解法: 把$1-r$到根的路径全部+1,再查询$z$到根的路径和就是答案\n\n可以发现问题的答案是可以叠加求出的\n\n容易想到排序后离线处理\n\n用树剖或`LCT`求解都可以\n\n这里采用树剖+树状数组\n```cpp\n#include<bits\/stdc++.h>\n#define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n#define il __inline__ __attribute__ ((always_inline))\nnamespace IN{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;inline char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}template<typename T>inline void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>inline void in(T &x,arr & ... y){in(x),in(y...);}}using namespace IN;\nnamespace OUT{const char ln='\\n';const int str=1<<20;static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;inline void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}inline void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}inline void out(char c){pt(c);}template<typename T>inline void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>inline void out(T x,arr & ... y){out(x),out(y...);}}using namespace OUT;\nconst int N=50011,P=201314;\nint n,q,cnt=0,head[N];\nstruct edge{int to,nxt;}e[N<<1];\nil void add(int x,int y){e[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;}\nint f[N],top[N],siz[N],id[N],sz;\nvoid dfs(int x){\n    siz[x]=1;\n    fl(i,x)dfs(to),siz[x]+=siz[to];\n}\nvoid bt(int x,int tp){\n    top[x]=tp;id[x]=++sz;int k=n;\n    fl(i,x)if(siz[to]>siz[k])k=to;\n    if(k==n)return;bt(k,tp);\n    fl(i,x)if(to!=k)bt(to,to);\n}\nint s[N],S[N];\nil void mod(int &x){while(x>=P)x-=P;}\nil int mo(int x){return x>=P?x%P:x;}\nil void upd(int x,int v){\n    for(int i=x--;i<=n;i+=i&-i)\n        s[i]+=v,mod(S[i]+=x*v);\n}\nil int ask(int x){\n    int res=0,RES=0;\n    for(int i=x;i;i-=i&-i)\n        mod(res+=s[i]),mod(RES+=S[i]);\n    return mo(1ll*x*res%P-RES+P);\n}\nil void upd(int l,int r,int v){upd(l,v),upd(r+1,-v);}\nil int ask(int l,int r){return mo(ask(r)-ask(l-1)+P);}\nil int ASK(int x){\n    int res=0;\n    while(top[x])mod(res+=ask(id[top[x]],id[x])),x=f[top[x]];\n    return mo(res+ask(id[x]));\n}\nint ans[N];\nstruct que{int x,z,v,id;bool operator<(que t)const{return x<t.x;}}Q[N<<1];\nil void u(int x){\n    while(top[x])upd(id[top[x]],id[x],1),x=f[top[x]];\n    upd(id[0],id[x],1);\n}\nint main(){\n    in(n,q);\n    for(int i=1;i<n;++i)in(f[i]),add(f[i],i);\n    dfs(0);bt(0,0);\n    int l,r,z;\n    for(int i=0;i<q;++i){\n        in(l,r,z);\n        Q[i<<1]={l-1,z,-1,i};\n        Q[i<<1|1]={r,z,1,i};\n    }\n    std::sort(Q,Q+(q<<1));\n    for(int i=0,j=-1;i<(q<<1);++i){\n        while(j<Q[i].x)u(++j);\n        mod(ans[Q[i].id]+=Q[i].v*ASK(Q[i].z));\n    }\n    for(int i=0;i<q;++i)out(mo(ans[i]+P),ln);\n    flush();\n}\n```\n","link":null,"tags":["lct","树链剖分","离线","树状数组"],"title":"BZ 3626 LNOI2014 LCA"},{"categories":[["刷题记录"]],"content":"\n```cpp\n#include<bits\/stdc++.h>\n#define il __inline__ __attribute__ ((always_inline))\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\nconst int N=200001;\nint n,m,q,s[N],c[2][N],f[N],bl[N];\nbool rev[N];\nint BL(int x){return bl[x]==x?x:(bl[x]=BL(bl[x]));}\n#define ls c[0][x]\n#define rs c[1][x]\nil void pr(int x){rev[x]^=1,ls^=rs,rs^=ls,ls^=rs;}\nil void pd(int x){\n    if(rev[x]){\n        if(ls)pr(ls);\n        if(rs)pr(rs);\n        rev[x]=0;\n    }\n}\nil int g(int x){return c[1][f[x]]==x;}\nil int nrt(int x){return c[0][f[x]]==x||c[1][f[x]]==x;}\nil void rotate(int x){\n    int y=f[x],z=f[y],l=g(x),r=!l,w=c[r][x];\n    if(nrt(y))c[g(y)][z]=x;\n    c[r][x]=y,c[l][y]=w;\n    if(w)f[w]=y;\n    f[x]=z,f[y]=x;\n}\nvoid pda(int x){if(nrt(x))pda(f[x]);pd(x);}\nil void splay(int x){\n    for(pda(x);nrt(x);rotate(x))if(nrt(f[x]))\n        rotate(g(x)^g(f[x])?x:f[x]);\n}\nil void access(int x){for(int y=0;x;x=f[y=x]=BL(f[x]))splay(x),rs=y;}\nil void mrt(int x){access(x),splay(x),pr(x);}\nil int frt(int x){\n    for(access(x),splay(x);ls;pd(x),x=ls);\n    splay(x);return x;\n}\nint tmp;\nvoid set(int x,int y){if(x)tmp+=s[x],bl[x]=y,set(ls,x),set(rs,x);}\nil int mg(int x,int y){\n    if(x==y)return 1;\n    mrt(x);\n    if(frt(y)!=x){f[x]=y;return 0;}\n    else{\n        tmp=0,\n        set(rs,x),rs=0,\n        s[x]+=tmp;\n        return 1;\n    }\n}\nint main(){\n    in(n,m,q);\n    int x,y;\n    for(int i=1;i<=n;++i)s[i]=1,bl[i]=i;\n    for(int i=1;i<=m;++i)in(x,y),mg(BL(x),BL(y));\n    while(q--){\n        in(x,y);\n        x=BL(x),y=BL(y);\n        if(mg(x,y))out(s[x],ln);\n        else out(\"No\\n\");\n    }\n    flush();\n}\n```\n","link":null,"tags":["lct"],"title":"BZ 4998 星球联盟"},{"categories":[["刷题记录"]],"content":"\nlct缩点\n\n和[LG 2542 \\[AHOI2005\\]航线规划](https:\/\/www.luogu.com.cn\/problem\/P2542)有点像\n\n缩点的时候顺便和并所有点的信息\n```cpp\n#include<bits\/stdc++.h>\n#define il __inline__ __attribute__ ((always_inline))\nil int min(int x,int y){return x<y?x:y;}\nil int max(int x,int y){return x>y?x:y;}\nnamespace IN{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;inline char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}template<typename T>inline void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>inline void in(T &x,arr & ... y){in(x),in(y...);}}using namespace IN;\nnamespace OUT{const char ln='\\n';const int str=1<<20;static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;inline void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}inline void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}inline void out(char c){pt(c);}template<typename T>inline void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>inline void out(T x,arr & ... y){out(x),out(y...);}}using namespace OUT;\nconst int N=150011,inf=2122219134;\nint n,q,s[N],f[N],c[2][N],v[N],bl[N],a[N];\nbool rev[N];\nint BL(int x){return bl[x]==x?x:(bl[x]=BL(bl[x]));}\n#define ls c[0][x]\n#define rs c[1][x]\nil void pu(int x){s[x]=s[ls]+s[rs]+v[x];}\nil void pr(int x){rev[x]^=1,ls^=rs,rs^=ls,ls^=rs;}\nil void pd(int x){\n    if(rev[x]){\n        if(ls)pr(ls);\n        if(rs)pr(rs);\n        rev[x]=0;\n    }\n}\nil int g(int x){return c[1][f[x]]==x;}\nil int nrt(int x){return c[0][f[x]]==x||c[1][f[x]]==x;}\nil void rotate(int x){\n    int y=f[x],z=f[y],l=g(x),r=!l,w=c[r][x];\n    if(nrt(y))c[g(y)][z]=x;\n    c[r][x]=y,c[l][y]=w;\n    if(w)f[w]=y;\n    f[x]=z,f[y]=x;\n    pu(y),pu(x);\n}\nvoid pda(int x){if(nrt(x))pda(f[x]);pd(x);}\nil void splay(int x){\n    for(pda(x);nrt(x);rotate(x))if(nrt(f[x]))\n        rotate(g(x)^g(f[x])?x:f[x]);\n}\nil void access(int x){\n    for(int y=0;x;x=f[y=x]=BL(f[x]))\n        splay(x),rs=y,pu(x);\n}\nil void mrt(int x){access(x),splay(x),pr(x);}\nil int frt(int x){\n    for(access(x),splay(x);ls;pd(x),x=ls);\n    splay(x);return x;\n}\nint tmp;\nvoid get(int x,int y){\n    if(x)tmp+=v[x],bl[x]=y,get(ls,x),get(rs,x);\n}\nint main(){\n    in(n,q);\n    for(int i=1;i<=n;++i)in(a[i]),s[i]=v[i]=a[i],bl[i]=i;\n    int opt,x,y;\n    while(q--){\n        in(opt,x,y);\n        if(opt==1){\n            x=BL(x),y=BL(y);\n            if(x==y)continue;\n            mrt(x);\n            if(frt(y)!=x)f[x]=y;\n            else tmp=0,get(rs,x),rs=0,v[x]+=tmp,pu(x);\n        }\n        if(opt==2){\n            mrt(BL(x));\n            v[BL(x)]+=y-a[x];\n            s[BL(x)]+=y-a[x];\n            a[x]=y;\n        }\n        if(opt==3){\n            x=BL(x),y=BL(y);\n            mrt(x);\n            if(frt(y)!=x)out(-1,ln);\n            else out(s[x],ln);\n        }\n    }\n    flush();\n}\n```\n","link":null,"tags":["lct"],"title":"BZ 2959 长跑"},{"categories":[["刷题记录"]],"content":"\n根据套路,用`LCT`维护子树,信息为最值,每个节点都开一个`multiset`来记录虚子树信息\n\n思考`LCT`的定义,每个`splay`维护的是一条深度单调递增的链(也可以说是实链)\n\n我们定义`lm[x],rm[x]`分别为每条实链的上端和下端能够到达最近的白点的距离\n\n这样就可以方便地更新信息了\n\n每次求解可以`access(x),splay(x)`,然后$x$就是树根所在实链的下端,输出`rm[x]`就可以了\n\n这样不需要换根什么的,也就不需要翻转操作,省去了复杂的pushdown过程\n```cpp\n#include<bits\/stdc++.h>\n#pragma GCC optimize(3)\n#define il __inline__ __attribute__ ((always_inline))\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\nconst int N=100011,inf=1000000000;\nint n,q,siz[N],c[2][N],f[N],lm[N],rm[N];\nbool rev[N],col[N];\nusing std::multiset;\nmultiset<int>s2[N];\n#define ls(x) c[0][x]\n#define rs(x) c[1][x]\nil int min(int x,int y){return x<y?x:y;}\nil void pu(int x){\n    siz[x]=siz[ls(x)]+siz[rs(x)]+1;\n    int t=s2[x].empty()?inf:*s2[x].begin();\n    lm[x]=min(lm[ls(x)],siz[ls(x)]+min(col[x]?0:inf,min(t,lm[rs(x)]+1)));\n    rm[x]=min(rm[rs(x)],siz[rs(x)]+min(col[x]?0:inf,min(t,rm[ls(x)]+1)));\n}\nil int g(int x){return rs(f[x])==x;}\nil int nrt(int x){return ls(f[x])==x||rs(f[x])==x;}\nil void rotate(int x){\n    int y=f[x],z=f[y],l=g(x),r=!l,w=c[r][x];\n    if(nrt(y))c[g(y)][z]=x;\n    c[r][x]=y,c[l][y]=w;\n    if(w)f[w]=y;\n    f[y]=x,f[x]=z;\n    pu(y),pu(x);\n}\nil void splay(int x){\n    for(;nrt(x);rotate(x))if(nrt(f[x]))\n        rotate(g(x)^g(f[x])?x:f[x]);\n}\nil void access(int x){\n    for(int y=0;x;x=f[y=x]){\n        splay(x);\n        s2[x].insert(lm[rs(x)]+1);\n        rs(x)=y;\n        multiset<int>::iterator it=s2[x].lower_bound(lm[rs(x)]+1);\n        if(it!=s2[x].end()&&(*it)==lm[rs(x)]+1)s2[x].erase(it);\n        pu(x);\n    }\n}\nstruct edge{int to,nxt;}e[N<<1];\nint cnt=0,head[N];\nil void add(int x,int y){e[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;}\nvoid dfs(int x,int fa){\n    for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n    if(to!=fa){\n        f[to]=x;s2[x].insert(inf+1);pu(x);\n        dfs(to,x);\n    }\n}\nint main(){\n    in(n);\n    lm[0]=rm[0]=inf;\n    int opt,x,y;\n    for(int i=1;i<n;++i)in(x,y),add(x,y),add(y,x);\n    dfs(1,0);\n    in(q);\n    while(q--){\n        in(opt,x);\n        access(x),splay(x);\n        if(!opt)col[x]^=1,pu(x);\n        else out(rm[x]>n?-1:rm[x],ln);\n    }\n    flush();\n}\n```\n","link":null,"tags":["lct"],"title":"LG SP2939 QTREE5 - Query on a tree V"},{"categories":[["刷题记录"]],"content":"\n容易看出$x,y$切断后,$x$的子树大小乘上$y$的子树大小就是答案\n\n用`LCT`维护子树大小即可\n\n```cpp\n#include<bits\/stdc++.h>\n#pragma GCC optimize(3)\n#define il __inline__ __attribute__ ((always_inline))\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\nconst int N=100011;\nint n,q,siz[N],siz2[N],c[2][N],f[N];\nbool rev[N];\n#define ls(x) c[0][x]\n#define rs(x) c[1][x]\nil void pu(int x){siz[x]=siz[ls(x)]+siz[rs(x)]+1+siz2[x];}\nil void pr(int x){rev[x]^=1;int t=ls(x);ls(x)=rs(x),rs(x)=t;}\nil void pd(int x){\n    if(rev[x]){\n        if(ls(x))pr(ls(x));\n        if(rs(x))pr(rs(x));\n        rev[x]=0;\n    }\n}\nil int g(int x){return rs(f[x])==x;}\nil int nrt(int x){return ls(f[x])==x||rs(f[x])==x;}\nil void rotate(int x){\n    int y=f[x],z=f[y],l=g(x),r=!l,w=c[r][x];\n    if(nrt(y))c[g(y)][z]=x;\n    c[r][x]=y,c[l][y]=w;\n    if(w)f[w]=y;\n    f[x]=z,f[y]=x;\n    pu(y),pu(x);\n}\nvoid pda(int x){\n    if(nrt(x))pda(f[x]);\n    pd(x);\n}\nil void splay(int x){\n    for(pda(x);nrt(x);rotate(x))if(nrt(f[x]))\n        rotate(g(x)^g(f[x])?x:f[x]);\n}\nil void access(int x){\n    for(int y=0;x;x=f[y=x])\n        splay(x),siz2[x]+=siz[rs(x)]-siz[rs(x)=y],pu(x);\n}\nil void mrt(int x){access(x),splay(x),pr(x);}\nint main(){\n    in(n,q);\n    for(int i=1;i<=n;++i)siz[i]=1;\n    char opt;int x,y;\n    while(q--){\n        in(opt,x,y);\n        if(opt=='A')\n            mrt(x),mrt(y),\n            siz2[f[x]=y]+=siz[x];\n        else{\n            mrt(x),access(y),splay(y);  \n            f[x]=ls(y)=0,pu(x);\n            mrt(x),mrt(y);\n            out((long long)siz[x]*siz[y],ln);\n            siz2[f[x]=y]+=siz[x];\n        }\n    }\n    flush();\n}\n```\n","link":null,"tags":["lct","统计","子树"],"title":"LG 4219 [BJOI2014]大融合"},{"categories":[["刷题记录"]],"content":"\n按边权从小到大排序后,依次添加边\n\n问题转化为了: \n\n每次加边的时候,\n\n如果两点为连通,则加边\n\n否则在目前的生成树上找到边权最小的边, 并替换为新边\n\n可以用`LCT`维护\n\n```cpp\n#include<bits\/stdc++.h>\n#pragma GCC optimize(3)\n#define il __inline__ __attribute__ ((always_inline))\nil int min(int x,int y){return x<y?x:y;}\nnamespace IN{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;inline char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}template<typename T>inline void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>inline void in(T &x,arr & ... y){in(x),in(y...);}}using namespace IN;\nconst int N=250001,inf=-1u>>1;\nint n,m,rev[N],c[2][N],f[N],s[N];\nstruct edge{int x,y,w;bool operator<(edge t){return w<t.w;}}e[N];\n#define ls(x) c[0][x]\n#define rs(x) c[1][x]\nil void pu(int x){s[x]=min(x>n?x:inf,min(s[ls(x)],s[rs(x)]));}\nil void pr(int x){rev[x]^=1;int t=ls(x);ls(x)=rs(x),rs(x)=t;}\nil void pd(int x){\n    if(rev[x]){\n        if(ls(x))pr(ls(x));\n        if(rs(x))pr(rs(x));\n        rev[x]=0;\n    }\n}\nil int g(int x){return rs(f[x])==x;}\nil int nrt(int x){return ls(f[x])==x||rs(f[x])==x;}\nil void rotate(int x){\n    int y=f[x],z=f[y],l=g(x),r=!l,w=c[r][x];\n    if(nrt(y))c[g(y)][z]=x;\n    c[r][x]=y,c[l][y]=w;\n    if(w)f[w]=y;\n    f[x]=z,f[y]=x;\n    pu(y),pu(x);\n}\nint st[N];\nil void splay(int x){\n    int z=0,y=st[++z]=x;\n    while(nrt(y))st[++z]=y=f[y];\n    while(z)pd(st[z--]);\n    for(;nrt(x);rotate(x))if(nrt(f[x]))\n        rotate(g(x)^g(f[x])?x:f[x]);\n}\nil void access(int x){for(int y=0;x;x=f[y=x])splay(x),rs(x)=y,pu(x);}\nil void mrt(int x){access(x),splay(x),pr(x);}\nil int frt(int x){\n    for(access(x),splay(x);ls(x);pd(x),x=ls(x));\n    splay(x);return x;\n}\nil void link(int x,int y){mrt(x),f[x]=y;}\nbool b[N];\nint main(){\n    s[0]=inf;\n    in(n,m);\n    for(int i=1;i<=m;++i)in(e[i].x,e[i].y,e[i].w);\n    std::sort(e+1,e+m+1);\n    int x,y,t=n,tt=0,p=1,ans=inf;\n    for(int i=1;i<=m;++i){\n        x=e[i].x,y=e[i].y;++t;\n        if(x==y){b[i]=1;continue;}\n        mrt(x);\n        if(frt(y)!=x)f[f[x]=t]=y,++tt;\n        else{\n            mrt(x),access(y),splay(y);\n            int now=s[y];\n            b[now-n]=1;splay(now);\n            f[ls(now)]=f[rs(now)]=0;\n            link(x,t),link(t,y);\n        }\n        while(b[p]&&p<=i)++p;\n        if(tt>=n-1)ans=min(ans,e[i].w-e[p].w);\n    }\n    printf(\"%d\\n\",ans);\n}\n```\n","link":null,"tags":["lct"],"title":"LG 4234 最小差值生成树"},{"categories":[["刷题记录"]],"content":"\n经典的`link-cut tree`维护连通分量\n\n首先看到这种题我们可以考虑倒序添加\n\n假设每个点代表一个双连通分量,那么两个点之间的关键路径数就是链长-1\n\n可以用`LCT`+并查集来维护\n\n连接一条边:\n\n1. 两端在同一个双连通分量中: 什么都不用干\n   \n2. 两端还未连通: 直接`link`\n\n3. 两端已经联通: 缩点\n   \n   将连接两端的路径提取出来,合并这些点\n\n```cpp\nint BL(int x){return bl[x]==x?x:(bl[x]=BL(bl[x]));}\/\/并查集\nvoid set(int x,int y){if(x)bl[x]=y,set(ls(x),x),set(rs(x),x);}\nvoid mg(int x,int y){\n    if(x==y)return;\/\/在同一个双连通分量\n    mrt(x);\n    if(frt(y)!=x){f[x]=y;return;}\/\/未连通\n\n    \/*\n    在find root的过程中已经access(y)提出了x到y的路径\n    我们现在只需要把x的子树的并查集祖先都改成x,然后断开x与子树的连接即可\n    *\/\n    set(rs(x),x),rs(x)=0,pu(x);\n}\nvoid access(int x){\n    \/*\n    缩点的时候x的子树指空了,我们需要在access的时候接回去\n\n    这样原本连接链上其他节点的access后都会指向x了\n    *\/\n    for(int y=0;x;x=f[y=x]=BL(f[x]))\n        splay(x),rs(x)=y,pu(x);\n}\n```\n\n```cpp\n#include<bits\/stdc++.h>\n#pragma GCC optimize(3)\n#define il __inline__ __attribute__ ((always_inline))\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\nil void swap(int &x,int &y){x^=y,y^=x,x^=y;}\nconst int N=30011,M=100011;\nint n,m,s[N],c[2][N],f[N],st[N],bl[N];\nbool rev[N];\n#define ls(x) c[0][x]\n#define rs(x) c[1][x]\nil void pu(int x){s[x]=s[ls(x)]+s[rs(x)]+1;}\nil void pr(int x){swap(ls(x),rs(x));rev[x]^=1;}\nil void pd(int x){\n    if(rev[x]){\n        if(ls(x))pr(ls(x));\n        if(rs(x))pr(rs(x));\n        rev[x]=0;\n    }\n}\nil int g(int x){return rs(f[x])==x;}\nil int nrt(int x){return ls(f[x])==x||rs(f[x])==x;}\nil void rotate(int x){\n    int y=f[x],z=f[y],l=g(x),r=!l,w=c[r][x];\n    if(nrt(y))c[g(y)][z]=x;\n    c[r][x]=y,c[l][y]=w;\n    if(w)f[w]=y;\n    f[y]=x,f[x]=z;\n    pu(y),pu(x);\n}\nil void splay(int x){\n    int z=0,y=st[++z]=x;\n    while(nrt(y))st[++z]=y=f[y];\n    while(z)pd(st[z--]);\n    for(;nrt(x);rotate(x))if(nrt(f[x]))\n        rotate(g(x)^g(f[x])?x:f[x]);\n}\nint BL(int x){return bl[x]==x?x:(bl[x]=BL(bl[x]));}\nil void access(int x){for(int y=0;x;x=f[y=x]=BL(f[x]))splay(x),rs(x)=y,pu(x);}\nil void mrt(int x){access(x),splay(x),pr(x);}\nil int frt(int x){\n    for(access(x),splay(x);ls(x);pd(x),x=ls(x));\n    splay(x);return x;\n}\nil void sl(int x,int y){mrt(x),access(y),splay(y);}\nvoid set(int x,int y){if(x)bl[x]=y,set(ls(x),x),set(rs(x),x);}\nil void mg(int x,int y){\n    if(x==y)return;\n    mrt(x);\n    if(frt(y)!=x){f[x]=y;return;}\n    set(rs(x),x),rs(x)=0,pu(x);\n}\n#include<bits\/extc++.h>\nusing namespace __gnu_pbds;\ngp_hash_table<int,bool>vis[N];\nint X[M],Y[M],A[M],B[M],O[M],ans[M];\nint main(){\n    in(n,m);\n    int c,x,y,q;\n    for(int i=1;i<=n;++i)s[i]=1,bl[i]=i;\n    for(int i=1;i<=m;++i){\n        in(X[i],Y[i]);\n        if(X[i]>Y[i])swap(X[i],Y[i]);\n    }\n    for(q=1;in(O[q]),~O[q];++q){\n        in(x,y);\n        if(x>y)swap(x,y);\n        if(!O[q])vis[x][y]=1;\n        A[q]=x,B[q]=y;\n    }\n    for(int i=1;i<=m;++i)if(!vis[X[i]][Y[i]])mg(BL(X[i]),BL(Y[i]));\n    for(c=0,--q;q;--q){\n        x=BL(A[q]),y=BL(B[q]);\n        if(O[q])sl(x,y),ans[++c]=s[y]-1;\n        else mg(x,y);\n    }\n    while(c)out(ans[c--],ln);\n    flush();\n}\n```\n","link":null,"tags":["lct","强连通分量"],"title":"LG 2542 [AHOI2005]航线规划"},{"categories":[["刷题记录"]],"content":"\n```cpp\n#include<bits\/stdc++.h>\n#define il __inline__ __attribute__ ((always_inline))\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\nconst int N=100011,P=51061;\n#define int long long\nint n,q,s[N],siz[N],v[N],c[2][N],f[N],st[N],add[N],mul[N];\nbool rev[N];\n#define ls(x) c[0][x]\n#define rs(x) c[1][x]\nil void pu(int x){\n    s[x]=(s[ls(x)]+s[rs(x)]+v[x])%P;\n    siz[x]=siz[ls(x)]+siz[rs(x)]+1;\n}\nil void pr(int x){int t=ls(x);ls(x)=rs(x);rs(x)=t;rev[x]^=1;}\nil void pd(int x){\n    if(rev[x]){\n        if(ls(x))pr(ls(x));\n        if(rs(x))pr(rs(x));\n        rev[x]=0;\n    }\n    if(mul[x]^1){\n        if(ls(x)){\n            mul[ls(x)]=mul[ls(x)]*mul[x]%P;\n            add[ls(x)]=add[ls(x)]*mul[x]%P;\n            s[ls(x)]=s[ls(x)]*mul[x]%P;\n            v[ls(x)]=v[ls(x)]*mul[x]%P;\n        }\n        if(rs(x)){\n            mul[rs(x)]=mul[rs(x)]*mul[x]%P;\n            add[rs(x)]=add[rs(x)]*mul[x]%P;\n            s[rs(x)]=s[rs(x)]*mul[x]%P;\n            v[rs(x)]=v[rs(x)]*mul[x]%P;\n        }\n        mul[x]=1;\n    }\n    if(add[x]){\n        if(ls(x)){\n            add[ls(x)]=(add[ls(x)]+add[x])%P;\n            s[ls(x)]=(s[ls(x)]+add[x]*siz[ls(x)]%P)%P;\n            v[ls(x)]=(v[ls(x)]+add[x])%P;\n        }\n        if(rs(x)){\n            add[rs(x)]=(add[rs(x)]+add[x])%P;\n            s[rs(x)]=(s[rs(x)]+add[x]*siz[rs(x)]%P)%P;\n            v[rs(x)]=(v[rs(x)]+add[x])%P;\n        }\n        add[x]=0;\n    }\n}\nil int g(int x){return rs(f[x])==x;}\nil int nrt(int x){return ls(f[x])==x||rs(f[x])==x;}\nil void rotate(int x){\n    int y=f[x],z=f[y],l=g(x),r=!l,w=c[r][x];\n    if(nrt(y))c[g(y)][z]=x;\n    c[r][x]=y,c[l][y]=w;\n    if(w)f[w]=y;\n    f[x]=z,f[y]=x;\n    pu(y),pu(x);\n}\nil void splay(int x){\n    int z=0,y=st[++z]=x;\n    while(nrt(y))st[++z]=y=f[y];\n    while(z)pd(st[z--]);\n    for(;nrt(x);rotate(x))if(nrt(f[x]))\n        rotate(g(f[x])^g(x)?x:f[x]);\n}\nil void access(int x){\n    for(int y=0;x;x=f[y=x])\n        splay(x),rs(x)=y,pu(x);\n}\nil void mrt(int x){access(x),splay(x),pr(x);}\nil int frt(int x){\n    for(access(x),splay(x);ls(x);pd(x),x=ls(x));\n    splay(x);return x;\n}\nil void link(int x,int y){\n    mrt(x);\n    if(frt(y)^x)f[x]=y;\n}\nil void sl(int x,int y){mrt(x),access(y),splay(y);}\nil void cut(int x,int y){\n    mrt(x);\n    if(frt(y)==x&f[y]==x&&!ls(y))\n        f[y]=rs(x)=0,pu(x);\n}\nsigned main(){\n    in(n,q);\n    int x,y,c;char opt;\n    for(int i=1;i<=n;++i)mul[i]=1,siz[i]=1,v[i]=1;\n    for(int i=2;i<=n;++i)in(x,y),link(x,y);\n    while(q--){\n        in(opt,x,y);\n        if(opt=='+')\n            in(c),sl(x,y),\n            s[y]=(s[y]+c*siz[y]%P)%P,v[y]=(v[y]+c)%P,\n            add[y]=(add[y]+c)%P;\n        if(opt=='-')cut(x,y),in(x,y),link(x,y);\n        if(opt=='*'){\n            in(c),sl(x,y),\n            s[y]=s[y]*c%P,v[y]=v[y]*c%P;\n            add[y]=add[y]*c%P,\n            mul[y]=mul[y]*c%P;\n        }\n        if(opt=='\/')sl(x,y),out(s[y],ln);\n    }\n    flush();\n}\n```\n","link":null,"tags":["lct"],"title":"LG 1501 [国家集训队]Tree II"},{"categories":[["算法","数据结构"],["note"]],"content":"\n\n`link-cut tree`是一个挺复杂的东西,本文主要用于复习巩固`link-cut tree`\n\n> 推荐: \n> \n> - https:\/\/www.cnblogs.com\/flashhu\/p\/8324551.html\n> \n> - https:\/\/oi-wiki.org\/ds\/lct\/\n\n## 简介\n\n`link-cut tree`是一种数据结构,我们用它来解决动态树问题。\n\n> **动态树问题**\n> \n> 维护一个森林, 支持删除某条边,加⼊某条边,并保证加边,删边之后仍是森林。我们要维护这个森林的一些信息。\n> \n> 一般的操作有两点连通性,两点路径权值和(或最值等),连接两点和切断某条边、修改信息等。\n\n`link-cut tree`简称`LCT`,但它不叫动态树,动态树是指一类问题。\n\n`Splay Tree`是`LCT`的基础(使用`Splay`维护森林),但是`LCT`⽤的`Splay Tree`和普通的`Splay`在细节处不太一样(进行了一些扩展)。\n\n## 概念\n\n`LCT`基于实链剖分\n\n> 将向某一个儿子的连边划分为实边,连向其他子树的边划分为虚边。\n> \n> 虚边、实边可动态变化\n> \n> 虚边：儿子认父,父不认子\n>\n> 实边：儿子认父,父也认子\n\n`LCT`支持: \n\n1. 查询、修改链上的信息(最值,总和等)\n   \n2. 换根\n   \n3. 动态连边、删边\n\n`LCT`的基本操作复杂度均摊为$\\log n$\n\n但是常数较大,在可以使用树链剖分的情况下还是使用树链剖分比较好\n\n## 性质\n\n1. 每一个`Splay`(森林)维护的是**一条从上到下按在原树中深度严格递增的路径,且中序遍历Splay得到的每个点的深度序列严格递增**。\n   \n2. 每个节点包含且仅包含于一个`Splay`(森林)中 ~~(这不是废话吗？)~~\n\n## 操作\n\n以下的`ls(x)`等同于`c[0][x]`,表示左儿子,`rs(x)`等同于`c[1][x]`,表示左儿子\n\n### Push up\n\n```cpp\nvoid pu(int x){\n    siz[x]=siz[ls(x)]+siz[rs(x)]+1;\n}\n```\n\n### Push rev\n\n```cpp\nvoid pr(int x){\n    swap(ls(x),rs(x));\n    rev[x]^=1;\n}\n```\n\n### Push down\n\n```cpp\nvoid pd(int x){\n    if(rev[x]){\n        if(ls(x))pr(ls(x));\n        if(rs(x))pr(rs(x));\n        rev[x]=0;\n    }\n}\n```\n\n### rotate & splay\n\n`LCT`中的`splay`和普通的`splay`有一定区别\n\n不会`splay`的请先自行了解\n\n```cpp\nvoid g(int x){return rs(f[x])==x;}\nvoid rotate(int x){\n    int y=f[x],z=f[y],l=g(x),r=!l,w=c[r][x];\n    if(nrt(y))c[g(y)][z]=x;\n    c[r][x]=y;c[l][y]=w;\n    if(w)f[w]=y;\n    f[x]=z,f[y]=x;\n    pu(y),pu(x);\n}\nint st[N];\nvoid splay(int x){\n    int z=0,y=st[++z]=x;\n    while(nrt(y))st[++z]=y=f[y];\n    while(z)pd(st[z--]);\n    for(;nrt(x);rotate(x))\n        if(nrt(f[x]))turn(g(x)^g(f[x])?x:f[x]);\n}\n```\n\n### Access\n\n`LCT`的核心操作\n\n`access`的四步操作：\n\n1. 把当前节点转到根\n2. 把儿子换成上一次操作的节点(如果没有上一次就是没有)\n3. 更新当前点的信息。\n4. 把当前点换成当前点的父亲,继续操作\n\n```cpp\nvoid access(int x){\n    for(int y=0;x;x=f[y=x])\n        splay(x),rs(x)=y,pu(x);\n}\n```\n\n### Make root\n\n仅次于`Access`的核心操作\n\n```cpp\nvoid mrt(int x){\n    access(x),splay(x),pr(x);\n}\n```\n\n当连接$x$到根,并把$x$旋转到根后\n\n$x$成为树根,$x$变为树上深度最小的点,$x$到原树根的路径上的边全部反向\n\n那么翻转`access(x)`后形成的$x$到原树根的链所在的`splay`即可\n\n### Find root\n\n`access(x),splay(x)`后,原来的根变成$x$所在`splay`里深度最小的那个,那么一直往左儿子走就可以找到原来的根了(记得`push down`)\n\n注意最后要把原来的根`splay`上去,保证复杂度\n\n```cpp\nvoid frt(int x){\n    for(access(x),splay(x);ls(x);pd(x),x=ls(x));\n    splay(x);return x;\n}\n```\n\n### Link\n\n直接看代码就可以懂了\n\n```cpp\nvoid link(int x,int y){\n    mrt(x);\n    if(frt(y)!=x)f[x]=y;\n}\n```\n\n### Split\n\n直接将$x$到$y$的路径提出来,为了方便我们将$y$作为该`splay`的根\n\n```cpp\nvoid sl(int x,int y){\n    mrt(x),access(y),splay(y);\n}\n```\n\n### Cut\n\n若存在边连接$x,y$\n\n将根换为$x$后,$x$的深度最小,其次是$y$\n\n`find root`之后$x$被旋转到了根节点\n\n$y$为$x$的右儿子且$y$没有左儿子\n\n判断完毕就是可以断开$x,y$之间的关系并更新$x$了\n\n```cpp\nvoid cut(int x,int y){\n    mrt(x);\n    if(frt(y)==x&&f[y]==x&&!ls(y))f[y]=rs(x)=0,pu(x);\n}\n```\n\n[LG 3690 【模板】link-cut tree （动态树）](https:\/\/www.luogu.com.cn\/problem\/P3690)\n\n这题就是标准的模板了\n\n```cpp\n#include<bits\/stdc++.h>\n#define il __inline__ __attribute__ ((always_inline))\nnamespace IN{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;inline char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}template<typename T>inline void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>inline void in(T &x,arr & ... y){in(x),in(y...);}}using namespace IN;\nnamespace OUT{const char ln='\\n';const int str=1<<20;static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;inline void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}inline void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}inline void out(char c){pt(c);}template<typename T>inline void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>inline void out(T x,arr & ... y){out(x),out(y...);}}using namespace OUT;\nconst int N=100011;\nint n,m,s[N],v[N],c[2][N],f[N],st[N];\nbool rev[N];\n#define ls(x) c[0][x]\n#define rs(x) c[1][x]\nil void pu(int x){s[x]=s[ls(x)]^s[rs(x)]^v[x];}\nil void pr(int x){int t=ls(x);ls(x)=rs(x);rs(x)=t;rev[x]^=1;}\nil void pd(int x){\n    if(rev[x]){\n        if(ls(x))pr(ls(x));\n        if(rs(x))pr(rs(x));\n        rev[x]=0;\n    }\n}\nil int g(int x){return rs(f[x])==x;}\nil int nrt(int x){return ls(f[x])==x||rs(f[x])==x;}\nil void rotate(int x){\n    int y=f[x],z=f[y],l=g(x),r=!l,w=c[r][x];\n    if(nrt(y))c[g(y)][z]=x;\n    c[r][x]=y,c[l][y]=w;\n    if(w)f[w]=y;\n    f[x]=z,f[y]=x;\n    pu(y),pu(x);\n}\nil void splay(int x){\n    int z=0,y=st[++z]=x;\n    while(nrt(y))st[++z]=y=f[y];\n    while(z)pd(st[z--]);\n    for(;nrt(x);rotate(x))if(nrt(f[x]))\n        rotate(g(x)^g(f[x])?x:f[x]);\n}\nil void access(int x){\n    for(int y=0;x;x=f[y=x])\n        splay(x),rs(x)=y,pu(x);\n}\nil void mrt(int x){access(x),splay(x),pr(x);}\nil int frt(int x){\n    for(access(x),splay(x);ls(x);pd(x),x=ls(x));\n    splay(x);return x;\n}\nil void link(int x,int y){\n    mrt(x);\n    if(frt(y)^x)f[x]=y;\n}\nil void sl(int x,int y){mrt(x),access(y),splay(y);}\nil void cut(int x,int y){\n    mrt(x);\n    if(frt(y)==x&&f[y]==x&&!ls(y))\n        f[y]=rs(x)=0,pu(x);\n}\nint main(){\n    in(n,m);\n    for(int i=1;i<=n;++i)in(v[i]);\n    int opt,x,y;\n    while(m--){\n        in(opt,x,y);\n        if(opt==0)sl(x,y),out(s[y],ln);\n        if(opt==1)link(x,y);\n        if(opt==2)cut(x,y);\n        if(opt==3)splay(x),v[x]=y;\n    }\n    flush();\n}\n```\n\n## 进阶\n\n### 维护树链信息\n\n[LG 1501 \\[国家集训队\\]Tree II](https:\/\/www.luogu.com.cn\/problem\/P1501)\n\n经典的`link-cut tree`维护树链信息,区间加区间乘区间查询\n\n关键在于打标记和下推,记得先下推乘法再下推加法\n\n```cpp\n#include<bits\/stdc++.h>\n#define il __inline__ __attribute__ ((always_inline))\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\nconst int N=100011,P=51061;\n#define int long long\nint n,q,s[N],siz[N],v[N],c[2][N],f[N],st[N],add[N],mul[N];\nbool rev[N];\n#define ls(x) c[0][x]\n#define rs(x) c[1][x]\nil void pu(int x){\n    s[x]=(s[ls(x)]+s[rs(x)]+v[x])%P;\n    siz[x]=siz[ls(x)]+siz[rs(x)]+1;\n}\nil void pr(int x){int t=ls(x);ls(x)=rs(x);rs(x)=t;rev[x]^=1;}\nil void pd(int x){\n    if(rev[x]){\n        if(ls(x))pr(ls(x));\n        if(rs(x))pr(rs(x));\n        rev[x]=0;\n    }\n    if(mul[x]^1){\n        if(ls(x)){\n            mul[ls(x)]=mul[ls(x)]*mul[x]%P;\n            add[ls(x)]=add[ls(x)]*mul[x]%P;\n            s[ls(x)]=s[ls(x)]*mul[x]%P;\n            v[ls(x)]=v[ls(x)]*mul[x]%P;\n        }\n        if(rs(x)){\n            mul[rs(x)]=mul[rs(x)]*mul[x]%P;\n            add[rs(x)]=add[rs(x)]*mul[x]%P;\n            s[rs(x)]=s[rs(x)]*mul[x]%P;\n            v[rs(x)]=v[rs(x)]*mul[x]%P;\n        }\n        mul[x]=1;\n    }\n    if(add[x]){\n        if(ls(x)){\n            add[ls(x)]=(add[ls(x)]+add[x])%P;\n            s[ls(x)]=(s[ls(x)]+add[x]*siz[ls(x)]%P)%P;\n            v[ls(x)]=(v[ls(x)]+add[x])%P;\n        }\n        if(rs(x)){\n            add[rs(x)]=(add[rs(x)]+add[x])%P;\n            s[rs(x)]=(s[rs(x)]+add[x]*siz[rs(x)]%P)%P;\n            v[rs(x)]=(v[rs(x)]+add[x])%P;\n        }\n        add[x]=0;\n    }\n}\nil int g(int x){return rs(f[x])==x;}\nil int nrt(int x){return ls(f[x])==x||rs(f[x])==x;}\nil void rotate(int x){\n    int y=f[x],z=f[y],l=g(x),r=!l,w=c[r][x];\n    if(nrt(y))c[g(y)][z]=x;\n    c[r][x]=y,c[l][y]=w;\n    if(w)f[w]=y;\n    f[x]=z,f[y]=x;\n    pu(y),pu(x);\n}\nil void splay(int x){\n    int z=0,y=st[++z]=x;\n    while(nrt(y))st[++z]=y=f[y];\n    while(z)pd(st[z--]);\n    for(;nrt(x);rotate(x))if(nrt(f[x]))\n        rotate(g(f[x])^g(x)?x:f[x]);\n}\nil void access(int x){\n    for(int y=0;x;x=f[y=x])\n        splay(x),rs(x)=y,pu(x);\n}\nil void mrt(int x){access(x),splay(x),pr(x);}\nil int frt(int x){\n    for(access(x),splay(x);ls(x);pd(x),x=ls(x));\n    splay(x);return x;\n}\nil void link(int x,int y){\n    mrt(x);\n    if(frt(y)^x)f[x]=y;\n}\nil void sl(int x,int y){mrt(x),access(y),splay(y);}\nil void cut(int x,int y){\n    mrt(x);\n    if(frt(y)==x&f[y]==x&&!ls(y))\n        f[y]=rs(x)=0,pu(x);\n}\nsigned main(){\n    in(n,q);\n    int x,y,c;char opt;\n    for(int i=1;i<=n;++i)mul[i]=1,siz[i]=1,v[i]=1;\n    for(int i=2;i<=n;++i)in(x,y),link(x,y);\n    while(q--){\n        in(opt,x,y);\n        if(opt=='+')\n            in(c),sl(x,y),\n            s[y]=(s[y]+c*siz[y]%P)%P,v[y]=(v[y]+c)%P,\n            add[y]=(add[y]+c)%P;\n        if(opt=='-')cut(x,y),in(x,y),link(x,y);\n        if(opt=='*'){\n            in(c),sl(x,y),\n            s[y]=s[y]*c%P,v[y]=v[y]*c%P;\n            add[y]=add[y]*c%P,\n            mul[y]=mul[y]*c%P;\n        }\n        if(opt=='\/')sl(x,y),out(s[y],ln);\n    }\n    flush();\n}\n```\n\n### 维护双连通分量\n\n[LG 2542 \\[AHOI2005\\]航线规划](https:\/\/www.luogu.com.cn\/problem\/P2542)\n\n首先看到这种题我们可以考虑倒序添加\n\n假设每个点代表一个双连通分量,那么两个点之间的关键路径数就是链长-1\n\n可以用`LCT`+并查集来维护\n\n连接一条边:\n\n1. 两端在同一个双连通分量中: 什么都不用干\n   \n2. 两端还未连通: 直接`link`\n\n3. 两端已经联通: 缩点\n   \n   将连接两端的路径提取出来,合并这些点\n\n```cpp\nint BL(int x){return bl[x]==x?x:(bl[x]=BL(bl[x]));}\/\/并查集\nvoid set(int x,int y){if(x)bl[x]=y,set(ls(x),x),set(rs(x),x);}\nvoid mg(int x,int y){\n    if(x==y)return;\/\/在同一个双连通分量\n    mrt(x);\n    if(frt(y)!=x){f[x]=y;return;}\/\/未连通\n\n    \/*\n    在find root的过程中已经access(y)提出了x到y的路径\n    我们现在只需要把x的子树的并查集祖先都改成x,然后断开x与子树的连接即可\n    *\/\n    set(rs(x),x),rs(x)=0,pu(x);\n}\nvoid access(int x){\n    \/*\n    缩点的时候x的子树指空了,我们需要在access的时候接回去\n\n    这样原本连接链上其他节点的access后都会指向x了\n    *\/\n    for(int y=0;x;x=f[y=x]=BL(f[x]))\n        splay(x),rs(x)=y,pu(x);\n}\n```\n\n```cpp\n#include<bits\/stdc++.h>\n#pragma GCC optimize(3)\n#define il __inline__ __attribute__ ((always_inline))\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\nil void swap(int &x,int &y){x^=y,y^=x,x^=y;}\nconst int N=30011,M=100011;\nint n,m,s[N],c[2][N],f[N],st[N],bl[N];\nbool rev[N];\n#define ls(x) c[0][x]\n#define rs(x) c[1][x]\nil void pu(int x){s[x]=s[ls(x)]+s[rs(x)]+1;}\nil void pr(int x){swap(ls(x),rs(x));rev[x]^=1;}\nil void pd(int x){\n    if(rev[x]){\n        if(ls(x))pr(ls(x));\n        if(rs(x))pr(rs(x));\n        rev[x]=0;\n    }\n}\nil int g(int x){return rs(f[x])==x;}\nil int nrt(int x){return ls(f[x])==x||rs(f[x])==x;}\nil void rotate(int x){\n    int y=f[x],z=f[y],l=g(x),r=!l,w=c[r][x];\n    if(nrt(y))c[g(y)][z]=x;\n    c[r][x]=y,c[l][y]=w;\n    if(w)f[w]=y;\n    f[y]=x,f[x]=z;\n    pu(y),pu(x);\n}\nil void splay(int x){\n    int z=0,y=st[++z]=x;\n    while(nrt(y))st[++z]=y=f[y];\n    while(z)pd(st[z--]);\n    for(;nrt(x);rotate(x))if(nrt(f[x]))\n        rotate(g(x)^g(f[x])?x:f[x]);\n}\nint BL(int x){return bl[x]==x?x:(bl[x]=BL(bl[x]));}\nil void access(int x){for(int y=0;x;x=f[y=x]=BL(f[x]))splay(x),rs(x)=y,pu(x);}\nil void mrt(int x){access(x),splay(x),pr(x);}\nil int frt(int x){\n    for(access(x),splay(x);ls(x);pd(x),x=ls(x));\n    splay(x);return x;\n}\nil void sl(int x,int y){mrt(x),access(y),splay(y);}\nvoid set(int x,int y){if(x)bl[x]=y,set(ls(x),x),set(rs(x),x);}\nil void mg(int x,int y){\n    if(x==y)return;\n    mrt(x);\n    if(frt(y)!=x){f[x]=y;return;}\n    set(rs(x),x),rs(x)=0,pu(x);\n}\n#include<bits\/extc++.h>\nusing namespace __gnu_pbds;\ngp_hash_table<int,bool>vis[N];\nint X[M],Y[M],A[M],B[M],O[M],ans[M];\nint main(){\n    in(n,m);\n    int c,x,y,q;\n    for(int i=1;i<=n;++i)s[i]=1,bl[i]=i;\n    for(int i=1;i<=m;++i){\n        in(X[i],Y[i]);\n        if(X[i]>Y[i])swap(X[i],Y[i]);\n    }\n    for(q=1;in(O[q]),~O[q];++q){\n        in(x,y);\n        if(x>y)swap(x,y);\n        if(!O[q])vis[x][y]=1;\n        A[q]=x,B[q]=y;\n    }\n    for(int i=1;i<=m;++i)if(!vis[X[i]][Y[i]])mg(BL(X[i]),BL(Y[i]));\n    for(c=0,--q;q;--q){\n        x=BL(A[q]),y=BL(B[q]);\n        if(O[q])sl(x,y),ans[++c]=s[y]-1;\n        else mg(x,y);\n    }\n    while(c)out(ans[c--],ln);\n    flush();\n}\n```\n\n[BZ 2959 长跑](http:\/\/www.lydsy.com\/JudgeOnline\/problem.php?id=2959)\n\n和上一题有点像\n\n缩点的时候顺便和并所有点的信息\n\n```cpp\n#include<bits\/stdc++.h>\n#define il __inline__ __attribute__ ((always_inline))\nil int min(int x,int y){return x<y?x:y;}\nil int max(int x,int y){return x>y?x:y;}\nnamespace IN{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;inline char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}template<typename T>inline void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>inline void in(T &x,arr & ... y){in(x),in(y...);}}using namespace IN;\nnamespace OUT{const char ln='\\n';const int str=1<<20;static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;inline void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}inline void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}inline void out(char c){pt(c);}template<typename T>inline void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>inline void out(T x,arr & ... y){out(x),out(y...);}}using namespace OUT;\nconst int N=150011,inf=2122219134;\nint n,q,s[N],f[N],c[2][N],v[N],bl[N],a[N];\nbool rev[N];\nint BL(int x){return bl[x]==x?x:(bl[x]=BL(bl[x]));}\n#define ls c[0][x]\n#define rs c[1][x]\nil void pu(int x){s[x]=s[ls]+s[rs]+v[x];}\nil void pr(int x){rev[x]^=1,ls^=rs,rs^=ls,ls^=rs;}\nil void pd(int x){\n    if(rev[x]){\n        if(ls)pr(ls);\n        if(rs)pr(rs);\n        rev[x]=0;\n    }\n}\nil int g(int x){return c[1][f[x]]==x;}\nil int nrt(int x){return c[0][f[x]]==x||c[1][f[x]]==x;}\nil void rotate(int x){\n    int y=f[x],z=f[y],l=g(x),r=!l,w=c[r][x];\n    if(nrt(y))c[g(y)][z]=x;\n    c[r][x]=y,c[l][y]=w;\n    if(w)f[w]=y;\n    f[x]=z,f[y]=x;\n    pu(y),pu(x);\n}\nvoid pda(int x){if(nrt(x))pda(f[x]);pd(x);}\nil void splay(int x){\n    for(pda(x);nrt(x);rotate(x))if(nrt(f[x]))\n        rotate(g(x)^g(f[x])?x:f[x]);\n}\nil void access(int x){\n    for(int y=0;x;x=f[y=x]=BL(f[x]))\n        splay(x),rs=y,pu(x);\n}\nil void mrt(int x){access(x),splay(x),pr(x);}\nil int frt(int x){\n    for(access(x),splay(x);ls;pd(x),x=ls);\n    splay(x);return x;\n}\nint tmp;\nvoid get(int x,int y){\n    if(x)tmp+=v[x],bl[x]=y,get(ls,x),get(rs,x);\n}\nint main(){\n    in(n,q);\n    for(int i=1;i<=n;++i)in(a[i]),s[i]=v[i]=a[i],bl[i]=i;\n    int opt,x,y;\n    while(q--){\n        in(opt,x,y);\n        if(opt==1){\n            x=BL(x),y=BL(y);\n            if(x==y)continue;\n            mrt(x);\n            if(frt(y)!=x)f[x]=y;\n            else tmp=0,get(rs,x),rs=0,v[x]+=tmp,pu(x);\n        }\n        if(opt==2){\n            mrt(BL(x));\n            v[BL(x)]+=y-a[x];\n            s[BL(x)]+=y-a[x];\n            a[x]=y;\n        }\n        if(opt==3){\n            x=BL(x),y=BL(y);\n            mrt(x);\n            if(frt(y)!=x)out(-1,ln);\n            else out(s[x],ln);\n        }\n    }\n    flush();\n}\n```\n\n### 维护边权(动态维护生成树)\n\n`link-cut tree`不能直接维护边权\n\n我们可以通过拆边,把边转化为点再向两端连边\n\n可以通过这种方式用`LCT`**动态维护生成树**\n\n> 注意: LCT上节点没有固定的父子关系,不能像树剖一样用点权记录边权\n\n[LG 4234 最小差值生成树](https:\/\/www.luogu.com.cn\/problem\/P4234)\n\n按边权从小到大排序后,依次添加边\n\n问题转化为了: \n\n每次加边的时候,\n\n如果两点为连通,则加边\n\n否则在目前的生成树上找到边权最小的边, 并替换为新边\n\n可以用`LCT`维护\n\n```cpp\n#include<bits\/stdc++.h>\n#pragma GCC optimize(3)\n#define il __inline__ __attribute__ ((always_inline))\nil int min(int x,int y){return x<y?x:y;}\nnamespace IN{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;inline char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}template<typename T>inline void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>inline void in(T &x,arr & ... y){in(x),in(y...);}}using namespace IN;\nconst int N=250001,inf=-1u>>1;\nint n,m,rev[N],c[2][N],f[N],s[N];\nstruct edge{int x,y,w;bool operator<(edge t){return w<t.w;}}e[N];\n#define ls(x) c[0][x]\n#define rs(x) c[1][x]\nil void pu(int x){s[x]=min(x>n?x:inf,min(s[ls(x)],s[rs(x)]));}\nil void pr(int x){rev[x]^=1;int t=ls(x);ls(x)=rs(x),rs(x)=t;}\nil void pd(int x){\n    if(rev[x]){\n        if(ls(x))pr(ls(x));\n        if(rs(x))pr(rs(x));\n        rev[x]=0;\n    }\n}\nil int g(int x){return rs(f[x])==x;}\nil int nrt(int x){return ls(f[x])==x||rs(f[x])==x;}\nil void rotate(int x){\n    int y=f[x],z=f[y],l=g(x),r=!l,w=c[r][x];\n    if(nrt(y))c[g(y)][z]=x;\n    c[r][x]=y,c[l][y]=w;\n    if(w)f[w]=y;\n    f[x]=z,f[y]=x;\n    pu(y),pu(x);\n}\nint st[N];\nil void splay(int x){\n    int z=0,y=st[++z]=x;\n    while(nrt(y))st[++z]=y=f[y];\n    while(z)pd(st[z--]);\n    for(;nrt(x);rotate(x))if(nrt(f[x]))\n        rotate(g(x)^g(f[x])?x:f[x]);\n}\nil void access(int x){for(int y=0;x;x=f[y=x])splay(x),rs(x)=y,pu(x);}\nil void mrt(int x){access(x),splay(x),pr(x);}\nil int frt(int x){\n    for(access(x),splay(x);ls(x);pd(x),x=ls(x));\n    splay(x);return x;\n}\nil void link(int x,int y){mrt(x),f[x]=y;}\nbool b[N];\nint main(){\n    s[0]=inf;\n    in(n,m);\n    for(int i=1;i<=m;++i)in(e[i].x,e[i].y,e[i].w);\n    std::sort(e+1,e+m+1);\n    int x,y,t=n,tt=0,p=1,ans=inf;\n    for(int i=1;i<=m;++i){\n        x=e[i].x,y=e[i].y;++t;\n        if(x==y){b[i]=1;continue;}\/\/要特判,re了不知道多少次就是因为这个\n        mrt(x);\n        if(frt(y)!=x)f[f[x]=t]=y,++tt;\n        else{\n            mrt(x),access(y),splay(y);\n            int now=s[y];\n            b[now-n]=1;splay(now);\n            f[ls(now)]=f[rs(now)]=0;\n            link(x,t),link(t,y);\n        }\n        while(b[p]&&p<=i)++p;\n        if(tt>=n-1)ans=min(ans,e[i].w-e[p].w);\n    }\n    printf(\"%d\\n\",ans);\n}\n```\n\n[LG 4180 \\[BJWC2010\\]严格次小生成树](https:\/\/www.luogu.com.cn\/problem\/P4180)\n\n`LCT`动态维护最小生成树\n\n维护链上的最大值和次大值\n\n先找出最小生成树,然后枚举剩下的边,找出相差最小的,得出答案\n\n这题还可以用kruskal生成树+倍增(或树剖)做,常数会小很多\n\n```cpp\n#include<bits\/stdc++.h>\n#define il __inline__ __attribute__ ((always_inline))\nil int min(int x,int y){return x<y?x:y;}\nil int max(int x,int y){return x>y?x:y;}\nnamespace IN{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;inline char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}template<typename T>inline void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>inline void in(T &x,arr & ... y){in(x),in(y...);}}using namespace IN;\nconst int N=100001;\nint n,m,s[N<<1],S[N<<1],c[2][N<<1],f[N<<1],v[N<<1];\nbool rev[N<<1];\n#define ls c[0][x]\n#define rs c[1][x]\nil void pu(int x){\n    if(s[ls]>s[rs])s[x]=s[ls],S[x]=max(S[ls],s[rs]);\n    else if(s[rs]>s[ls])s[x]=s[rs],S[x]=max(s[ls],S[rs]);\n    else s[x]=s[ls],S[x]=max(S[ls],S[rs]);\n\n    if(v[x]>s[x])S[x]=s[x],s[x]=v[x];\n    else if(v[x]!=s[x]&&v[x]>S[x])S[x]=v[x];\n}\nil void pr(int x){rev[x]^=1,ls^=rs,rs^=ls,ls^=rs;}\nil void pd(int x){\n    if(rev[x]){\n        if(ls)pr(ls);\n        if(rs)pr(rs);\n        rev[x]=0;\n    }\n}\nil int g(int x){return c[1][f[x]]==x;}\nil int nrt(int x){return c[0][f[x]]==x||c[1][f[x]]==x;}\nvoid pda(int x){if(nrt(x))pda(f[x]);pd(x);}\nil void rotate(int x){\n    int y=f[x],z=f[y],l=g(x),r=!l,w=c[r][x];\n    if(nrt(y))c[g(y)][z]=x;\n    c[r][x]=y,c[l][y]=w;\n    if(w)f[w]=y;\n    f[x]=z,f[y]=x;\n    pu(y),pu(x);\n}\nil void splay(int x){\n    for(pda(x);nrt(x);rotate(x))if(nrt(f[x]))\n        rotate(g(x)^g(f[x])?x:f[x]);\n}\nil void access(int x){\n    for(int y=0;x;x=f[y=x])\n        splay(x),rs=y,pu(x);\n}\nil void mrt(int x){access(x),splay(x),pr(x);}\nstruct edge{\n    int x,y,w;\n    bool operator<(edge t){return w<t.w;}\n}e[300001];\nint fa[N];\nint gf(int x){return x==fa[x]?x:(fa[x]=gf(fa[x]));}\nint main(){\n    in(n,m);\n    for(int i=1;i<=m;++i)in(e[i].x,e[i].y,e[i].w);\n    std::sort(e+1,e+m+1);\n    long long tot=0;int x,y,id=n,ans=-1u>>1;\n    for(int i=1;i<=n;++i)fa[i]=i;\n    for(int i=1;i<=m;++i){\n        x=e[i].x,y=e[i].y;\n        if(gf(x)!=gf(y)){\n            fa[fa[x]]=fa[y];\n            tot+=e[i].w;\n            v[++id]=e[i].w;\n            mrt(x),mrt(y),f[x]=f[y]=id;\n        }\n        else{\n            mrt(x),access(y),splay(y);\n            ans=min(ans,e[i].w-(e[i].w>s[y]?s[y]:S[y]));\n        }\n    }\n    printf(\"%lld\\n\",tot+ans);\n}\n```\n\n### 维护子树信息\n\n> 注: 此部分可直接跳过\n\n`LCT`并不擅长维护子树,~~Top tree更适合,退役树我也不会~~\n\n除了维护当前实链的信息,额外维护它的虚子树的信息(`siz2[x]`)\n\n这样我们就可以得到整课树的信息\n\npush up 变成\n\n```cpp\nvoid pu(int x){\n    siz[x]=siz[ls(x)]+1+siz[rs(x)]+siz2[x];\n}\n```\n\n那么如何维护`siz2[x]`呢?\n\n在改变边的虚实状况的时候要及时修改`siz2[x]`\n\n在`rotate,splay`操作中,我们都只是改变了`splay`中结点的相对位置,没有改变任意一条边的虚实情况,所以不对`siz2[x]`进行任何修改。\n\n在`access`操作中,在每次`splay`完后,都会改变刚刚`splay`完的结点的右儿子,即该结点与其原右儿子的连边和该节点和新右儿子的连边的虚实情况发生了变化,我们需要加上新变成虚边所连的子树的贡献,减去刚刚变成实边所连的子树的贡献。\n\n在`link`操作中添加了虚链,要加上新的虚子树的贡献\n\n```cpp\nvoid access(int x){\n    for(int y=0;x;x=f[y=x])\n        splay(x),siz2[x]+=siz[rs(x)]-siz[rs(x)=y],pu(x);\n}\nvoid link(int x,int y){\n    mrt(x),mrt(y),\n    siz2[f[x]=y]+=siz[x];\n}\n```\n\n其他地方和普通的`LCT`一样\n\n注意:\n\n1. 维护的信息要有**可减性**,如子树结点数,子树权值和,但不能直接维护子树最大最小值,因为在将一条虚边变成实边时要排除原先虚边的贡献\n   \n2. 如果维护的信息没有可减性,如维护区间最值,可以对每个结点开一个平衡树维护结点的虚子树中的最值。\n\n[LG4219 \\[BJOI2014\\]大融合](https:\/\/www.luogu.com.cn\/problem\/P4219)\n\n路径数量为断开该边后两端子树大小的乘积\n\n```cpp\n#include<bits\/stdc++.h>\n#pragma GCC optimize(3)\n#define il __inline__ __attribute__ ((always_inline))\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\nconst int N=100011;\nint n,q,siz[N],siz2[N],c[2][N],f[N];\nbool rev[N];\n#define ls(x) c[0][x]\n#define rs(x) c[1][x]\nil void pu(int x){siz[x]=siz[ls(x)]+siz[rs(x)]+1+siz2[x];}\nil void pr(int x){rev[x]^=1;int t=ls(x);ls(x)=rs(x),rs(x)=t;}\nil void pd(int x){\n    if(rev[x]){\n        if(ls(x))pr(ls(x));\n        if(rs(x))pr(rs(x));\n        rev[x]=0;\n    }\n}\nil int g(int x){return rs(f[x])==x;}\nil int nrt(int x){return ls(f[x])==x||rs(f[x])==x;}\nil void rotate(int x){\n    int y=f[x],z=f[y],l=g(x),r=!l,w=c[r][x];\n    if(nrt(y))c[g(y)][z]=x;\n    c[r][x]=y,c[l][y]=w;\n    if(w)f[w]=y;\n    f[x]=z,f[y]=x;\n    pu(y),pu(x);\n}\nvoid pda(int x){\n    if(nrt(x))pda(f[x]);\n    pd(x);\n}\nil void splay(int x){\n    for(pda(x);nrt(x);rotate(x))if(nrt(f[x]))\n        rotate(g(x)^g(f[x])?x:f[x]);\n}\nil void access(int x){\n    for(int y=0;x;x=f[y=x])\n        splay(x),siz2[x]+=siz[rs(x)]-siz[rs(x)=y],pu(x);\n}\nil void mrt(int x){access(x),splay(x),pr(x);}\nint main(){\n    in(n,q);\n    for(int i=1;i<=n;++i)siz[i]=1;\n    char opt;int x,y;\n    while(q--){\n        in(opt,x,y);\n        if(opt=='A')\n            mrt(x),mrt(y),\n            siz2[f[x]=y]+=siz[x];\n        else{\n            mrt(x),access(y),splay(y);  \n            f[x]=ls(y)=0,pu(x);\n            mrt(x),mrt(y);\n            out((long long)siz[x]*siz[y],ln);\n            siz2[f[x]=y]+=siz[x];\n        }\n    }\n    flush();\n}\n```\n\n[SPOJ QTREE5 - Query on a tree V](https:\/\/www.luogu.org\/problemnew\/show\/SP2939)\n\n根据套路,用`LCT`维护子树,信息为最值,每个节点都开一个`multiset`来记录虚子树信息\n\n思考`LCT`的定义,每个`splay`维护的是一条深度单调递增的链(也可以说是实链)\n\n我们定义`lm[x],rm[x]`分别为每条实链的上端和下端能够到达最近的白点的距离\n\n这样就可以方便地更新信息了\n\n每次求解可以`access(x),splay(x)`,然后$x$就是树根所在实链的下端,输出`rm[x]`就可以了\n\n这样不需要换根什么的,也就不需要翻转操作,省去了复杂的pushdown过程\n\n```cpp\n#include<bits\/stdc++.h>\n#pragma GCC optimize(3)\n#define il __inline__ __attribute__ ((always_inline))\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\nconst int N=100011,inf=1000000000;\nint n,q,siz[N],c[2][N],f[N],lm[N],rm[N];\nbool rev[N],col[N];\nusing std::multiset;\nmultiset<int>s2[N];\n#define ls(x) c[0][x]\n#define rs(x) c[1][x]\nil int min(int x,int y){return x<y?x:y;}\nil void pu(int x){\n    siz[x]=siz[ls(x)]+siz[rs(x)]+1;\n    int t=s2[x].empty()?inf:*s2[x].begin();\n    lm[x]=min(lm[ls(x)],siz[ls(x)]+min(col[x]?0:inf,min(t,lm[rs(x)]+1)));\n    rm[x]=min(rm[rs(x)],siz[rs(x)]+min(col[x]?0:inf,min(t,rm[ls(x)]+1)));\n}\nil int g(int x){return rs(f[x])==x;}\nil int nrt(int x){return ls(f[x])==x||rs(f[x])==x;}\nil void rotate(int x){\n    int y=f[x],z=f[y],l=g(x),r=!l,w=c[r][x];\n    if(nrt(y))c[g(y)][z]=x;\n    c[r][x]=y,c[l][y]=w;\n    if(w)f[w]=y;\n    f[y]=x,f[x]=z;\n    pu(y),pu(x);\n}\nil void splay(int x){\n    for(;nrt(x);rotate(x))if(nrt(f[x]))\n        rotate(g(x)^g(f[x])?x:f[x]);\n}\nil void access(int x){\n    for(int y=0;x;x=f[y=x]){\n        splay(x);\n        s2[x].insert(lm[rs(x)]+1);\n        rs(x)=y;\n        multiset<int>::iterator it=s2[x].lower_bound(lm[rs(x)]+1);\n        if(it!=s2[x].end()&&(*it)==lm[rs(x)]+1)s2[x].erase(it);\n        pu(x);\n    }\n}\nstruct edge{int to,nxt;}e[N<<1];\nint cnt=0,head[N];\nil void add(int x,int y){e[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;}\nvoid dfs(int x,int fa){\n    for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n    if(to!=fa){\n        f[to]=x;s2[x].insert(inf+1);pu(x);\n        dfs(to,x);\n    }\n}\nint main(){\n    in(n);\n    lm[0]=rm[0]=inf;\n    int opt,x,y;\n    for(int i=1;i<n;++i)in(x,y),add(x,y),add(y,x);\n    dfs(1,0);\n    in(q);\n    while(q--){\n        in(opt,x);\n        access(x),splay(x);\n        if(!opt)col[x]^=1,pu(x);\n        else out(rm[x]>n?-1:rm[x],ln);\n    }\n    flush();\n}\n```\n\n[LG 4299 首都](https:\/\/www.luogu.com.cn\/problem\/P4299)\n\n`LCT`维护重心\n\n这里利用了两个重心性质:\n\n1. 树中所有点到某个点的距离和中,到重心的距离和是最小的,如果有两个距离和,他们的距离和一样。\n   \n2. 把两棵树通过某一点相连得到一颗新的树,新的树的重心必然在连接原来两棵树重心的路径上。\n\n我们需要维护子树的大小\n\n合并的时候连接两棵树,分离出连接原来两棵树重心的路径,在链上搜索出答案\n\n方法类似平衡树的查找\n\n可以用并查集来记录重心位置,这样不用调用复杂度较高的`find root`\n\n每次合并后记得把新的重心旋转到根,保证复杂度\n\n```cpp\n#include<bits\/stdc++.h>\nconst int N=100011;\nint n,q,s[N],s2[N],c[2][N],f[N],bl[N],ans;\nbool rev[N];\nint BL(int x){return x==bl[x]?x:(bl[x]=BL(bl[x]));}\n#define ls c[0][x]\n#define rs c[1][x]\nvoid pu(int x){s[x]=s[ls]+s[rs]+1+s2[x];}\nvoid pr(int x){rev[x]^=1;ls^=rs,rs^=ls,ls^=rs;}\nvoid pd(int x){\n    if(rev[x]){\n        if(ls)pr(ls);\n        if(rs)pr(rs);\n        rev[x]=0;\n    }\n}\nint g(int x){return c[1][f[x]]==x;}\nint nrt(int x){return c[0][f[x]]==x||c[1][f[x]]==x;}\nvoid rotate(int x){\n    int y=f[x],z=f[y],l=g(x),r=!l,w=c[r][x];\n    if(nrt(y))c[g(y)][z]=x;\n    c[r][x]=y,c[l][y]=w;\n    if(w)f[w]=y;\n    f[x]=z,f[y]=x;\n    pu(y),pu(x);\n}\nvoid pda(int x){if(nrt(x))pda(f[x]);pd(x);}\nvoid splay(int x){\n    for(pda(x);nrt(x);rotate(x))if(nrt(f[x]))\n        rotate(g(x)^g(f[x])?x:f[x]);\n    pu(x);\n}\nvoid access(int x){\n    for(int y=0;x;x=f[y=x])\n        splay(x),s2[x]+=s[rs]-s[rs=y],pu(x);\n}\nvoid mrt(int x){access(x),splay(x),pr(x);}\nvoid link(int x,int y){\n    mrt(x),access(y),splay(y);\n    f[x]=y;\n    s2[y]+=s[x];\n    pu(y);\n}\nint find(int x){\n    bool ff=s[x]&1;\n    int sum=s[x]>>1,cl,cr,as=n+1,lsum=0,rsum=0;\n    while(x){\n        pd(x);\n        cl=s[ls]+lsum,cr=s[rs]+rsum;\n        if(cl<=sum&&cr<=sum){\n            if(ff)return x;\n            else if(as>x)as=x;\n        }\n        if(cl<cr)lsum+=s[ls]+s2[x]+1,x=rs;\n        else rsum+=s[rs]+s2[x]+1,x=ls;\n    }\n    return as;\n}\nint main(){\n    scanf(\"%d%d\",&n,&q);\n    for(int i=1;i<=n;++i)s[i]=1,bl[i]=i,ans^=i;\n    char opt[5];\n    int x,y;\n    while(q--){\n        scanf(\"%s\",opt);\n        if(opt[0]=='X')printf(\"%d\\n\",ans);\n        else if(opt[0]=='Q')\n            scanf(\"%d\",&x),\n            printf(\"%d\\n\",BL(x));\n        else{\n            scanf(\"%d%d\",&x,&y);\n            link(x,y);\n            x=BL(x),y=BL(y);\n            mrt(x),access(y),splay(y);\n            int z=find(y);\n            bl[x]=bl[y]=bl[z]=z;\n            ans^=x^y^z;\n            splay(z);\n        }\n    }\n}\n```\n\n### 维护树上染色联通块\n\n[LG SP16549 QTREE6 - Query on a tree VI](https:\/\/www.luogu.com.cn\/problem\/SP16549)\n\n#### 解法一\n\n化边为点\n\n每个点的父边赋予该点的颜色。我们需要两个LCT,每种对应一个颜色。一条边只有在对应颜色的LCT中才会被连上。\n\n接着可以发现,修改一个点的颜色,只需要在原来颜色对应`LCT`中断开父边,在新颜色`LCT`中连接父边,就可以维护同色连通块了\n\n查询的时候只要找到$x$所在`splay`的根,右子树大小就是答案(相当于边的数目,根的深度最浅,只有右子树)\n\n注意: 1节点是没有父亲的,不过为了模型的建立,要有父边,于是需要加一个虚点,让1的父亲指向它连边\n\n手动模拟一下应该可以懂\n\n这个类型的`LCT`比较特殊,代码可能也会有少许不同,多看代码理解一下\n\n```cpp\n#include<bits\/stdc++.h>\n#pragma GCC optimize(3)\n#define il __inline__ __attribute__ ((always_inline))\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\nconst int N=100011;\nint n,q,cnt,head[N],fa[N],v[N];\nbool col[N];\nstruct edge{int to,nxt;}e[N<<1];\nil void add(int x,int y){e[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;}\nstruct LCT{\n    int s[N],c[2][N],s2[N],f[N];\n    il void build(){for(int i=1;i<=n+1;++i)s[i]=1;}\n    #define ls c[0][x]\n    #define rs c[1][x]\n    il void pu(int x){s[x]=s[ls]+s[rs]+1+s2[x];}\n    il int g(int x){return c[1][f[x]]==x;}\n    il int nrt(int x){return c[0][f[x]]==x||c[1][f[x]]==x;}\n    il void rotate(int x){\n        int y=f[x],z=f[y],l=g(x),r=!l,w=c[r][x];\n        if(nrt(y))c[g(y)][z]=x;\n        c[r][x]=y,c[l][y]=w;\n        if(w)f[w]=y;\n        f[x]=z,f[y]=x;\n        pu(y),pu(x);\n    }\n    il void splay(int x){\n        for(int y;nrt(x);rotate(x))if(nrt(y=f[x]))\n            rotate(g(x)^g(y)?x:y);\n        pu(x);\n    }\n    il void access(int x){for(int y=0;x;x=f[y=x])splay(x),s2[x]+=s[rs]-s[rs=y],pu(x);}\n    il void brt(int x){access(x),splay(x);}\n    il int frt(int x){\n        for(brt(x);ls;x=ls);\n        splay(x);return x;\n    }\n    il void link(int x){\n        splay(x);\n        int y=f[x]=fa[x];\n        brt(y);\n        c[1][y]=x,pu(y);\n    }\n    il void cut(int x){\n        brt(x);\n        ls=f[ls]=0;\n        pu(x);\n    }\n    il int ask(int x){return s[c[1][frt(x)]];}\n}T[2];\nvoid dfs(int x){\n    for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n        if(to!=fa[x])fa[to]=x,dfs(to);\n    T[0].link(x);\n}\nint main(){\n    in(n);\n    T[0].build(),T[1].build();\n    int x,y;\n    for(int i=1;i<n;++i)in(x,y),add(x,y),add(y,x);\n    fa[1]=n+1;dfs(1);\n    in(q);\n    while(q--){\n        in(y,x);\n        if(y)T[col[x]].cut(x),T[col[x]^=1].link(x);\n        else out(T[col[x]].ask(x),ln);\n    }\n    flush();\n}\n```\n\n#### 解法2\n\n类似QTREE5的做法\n\n记录实链顶端和底端的答案\n\n要仔细考虑`push up`\n\n```cpp\n#include<bits\/stdc++.h>\nconst int N=100011;\nint n,q,s[2][N],c[2][N],f[N],sl[N],sr[N],col[N],tc[N],lc[N],rc[N];\n#define ls c[0][x]\n#define rs c[1][x]\nvoid pu(int x){\n    sl[x]=sl[ls]+(((tc[ls]!=2&&col[x]==tc[ls])||!ls)?s[col[x]][x]+1+(lc[rs]==col[x]?sl[rs]:0):0);\n    sr[x]=sr[rs]+(((tc[rs]!=2&&col[x]==tc[rs])||!rs)?s[col[x]][x]+1+(rc[ls]==col[x]?sr[ls]:0):0);\n    lc[x]=ls?lc[ls]:col[x];\n    rc[x]=rs?rc[rs]:col[x];\n    if(tc[ls]==2||tc[rs]==2||(ls&&tc[ls]!=col[x])||(rs&&tc[rs]!=col[x]))tc[x]=2;\n    else tc[x]=col[x];\n}\nint g(int x){return c[1][f[x]]==x;}\nint nrt(int x){return c[0][f[x]]==x||c[1][f[x]]==x;}\nvoid rotate(int x){\n    int y=f[x],z=f[y],l=g(x),r=!l,w=c[r][x];\n    if(nrt(y))c[g(y)][z]=x;\n    c[r][x]=y,c[l][y]=w;\n    if(w)f[w]=y;\n    f[x]=z,f[y]=x;\n    pu(y),pu(x);\n}\nvoid splay(int x){\n    for(;nrt(x);rotate(x))if(nrt(f[x]))\n        rotate(g(x)^g(f[x])?x:f[x]);\n}\nvoid access(int x){\n    for(int y=0;x;x=f[y=x]){\n        splay(x);\n        s[lc[rs]][x]+=sl[rs];\n        rs=y;\n        s[lc[y]][x]-=sl[y];\n        pu(x);\n    }\n}\nint cnt=0,head[N];\nstruct edge{int to,nxt;}e[N<<1];\nvoid add(int x,int y){e[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;}\nvoid dfs(int x,int fa){\n    for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n    if(to!=fa){\n        dfs(to,x);\n        f[to]=x;s[lc[to]][x]+=sl[to];\n    }\n    pu(x);\n}\nint main(){\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;++i)sl[i]=sr[i]=1;\n    int x,y;\n    for(int i=1;i<n;++i){\n        scanf(\"%d%d\",&x,&y);\n        add(x,y),add(y,x);\n    }\n    dfs(1,0);\n    scanf(\"%d\",&q);\n    while(q--){\n        scanf(\"%d%d\",&y,&x);\n        access(x),splay(x);\n        if(y)col[x]^=1,pu(x);\n        else printf(\"%d\\n\",sr[x]);\n    }\n}\n```\n\n[SP16580 QTREE7 - Query on a tree VII](https:\/\/www.luogu.com.cn\/problem\/SP16580)\n\n还是QTREE6的方法\n\n从维护子树大小变成了维护子树最值\n\n```cpp\n#include<bits\/stdc++.h>\n#pragma GCC optimize(3)\n#define il __inline__ __attribute__ ((always_inline))\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\nconst int N=100011,inf=1000000000;\nusing std::multiset;\nint n,q,cnt,head[N],fa[N],v[N];\nbool col[N];\nstruct edge{int to,nxt;}e[N<<1];\nil void add(int x,int y){e[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;}\nstruct LCT{\n    LCT(){s[0]=-inf;}\n    int s[N],c[2][N],f[N];\n    multiset<int>s2[N];\n    #define ls c[0][x]\n    #define rs c[1][x]\n    il int max(int x,int y){return x>y?x:y;}\n    il void pu(int x){\n        s[x]=max(max(s[ls],s[rs]),v[x]);\n        if(!s2[x].empty())s[x]=max(s[x],*s2[x].rbegin());\n    }\n    il int g(int x){return c[1][f[x]]==x;}\n    il int nrt(int x){return c[0][f[x]]==x||c[1][f[x]]==x;}\n    il void rotate(int x){\n        int y=f[x],z=f[y],l=g(x),r=!l,w=c[r][x];\n        if(nrt(y))c[g(y)][z]=x;\n        c[r][x]=y,c[l][y]=w;\n        if(w)f[w]=y;\n        f[x]=z,f[y]=x;\n        pu(y),pu(x);\n    }\n    il void splay(int x){\n        for(int y;nrt(x);rotate(x))if(nrt(y=f[x]))\n            rotate(g(x)^g(y)?x:y);\n        pu(x);\n    }\n    il void access(int x){\n        for(int y=0;x;x=f[y=x]){\n            splay(x);\n            if(rs)s2[x].insert(s[rs]);\n            if(rs=y)s2[x].erase(s2[x].find(s[y]));\n            pu(x);\n        }\n    }\n    il void brt(int x){access(x),splay(x);}\n    il int frt(int x){\n        for(brt(x);ls;x=ls);\n        splay(x);return x;\n    }\n    il void link(int x){\n        splay(x);\n        int y=f[x]=fa[x];\n        brt(y);\n        c[1][y]=x,pu(y);\n    }\n    il void cut(int x){\n        brt(x);\n        ls=f[ls]=0;\n        pu(x);\n    }\n    il int ask(int x){return s[c[1][frt(x)]];}\n}T[2];\nvoid dfs(int x){\n    for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n        if(to!=fa[x])fa[to]=x,dfs(to);\n    T[col[x]].link(x);\n}\nint main(){\n    in(n);\n    int x,y;\n    for(int i=1;i<n;++i)\n        in(x,y),\n        add(x,y),add(y,x);\n    for(int i=1;i<=n;++i)in(col[i]);\n    for(int i=1;i<=n;++i)in(v[i]);\n    fa[1]=n+1;dfs(1);\n    in(q);\n    while(q--){\n        in(y,x);\n        if(y==0)out(T[col[x]].ask(x),ln);\n        else if(y==1)T[col[x]].cut(x),T[col[x]^=1].link(x);\n        else{\n            T[0].brt(x),T[1].brt(x),\n            in(v[x]),\n            T[0].pu(x),T[1].pu(x);\n        }\n    }\n    flush();\n}\n```\n\n### 一些灵活巧妙的link-cut tree用法\n\n[LG 3203 \\[HNOI2010\\]弹飞绵羊](https:\/\/www.luogu.com.cn\/problem\/P3203)\n\n\n\n[LG 3703 \\[SDOI2017\\]树点涂色](https:\/\/www.luogu.com.cn\/problem\/P3703)\n\n`1 x`表示把点$x$到根节点的路径上所有的点染上一种没有用过的新颜色\n\n从这里可以看出每种颜色在树上都是一条链的形式存在\n\n可以发现这和`LCT`很像\n\n那么`1`操作可以看成`access`操作,(如何操作先放着\n\n$x$到根的颜色种数也就是要经过的虚边的条数,设为$S_x$\n\n求$x$到$y$的路径的权值,可以使用树上差分的形式\n\n也就是转化为$S_x + S_y - 2\\times S_{lca(x,y)} + 1$\n\n`3`操作也就是求子树最值\n\n我们回过头来看`access`操作:\n\n1. 原来的实边变虚,意味着要多走一条虚边,将此链所管辖的区域全部+1\n   \n2. 虚边变实边,意味着要多少一条虚边,将此链所管辖的区域全部-1\n\n注意: `LCT`中`splay`的父子关系并不是原树中的父子关系,要找到该`splay`中深度最小的节点(也就是这条链的顶端再操作)\n\n综上可以用 lct+lca+dfs序+线段树 解决\n\n当然也可以通过树剖模拟`access`的形式来解决\n\n```cpp\n#include<bits\/stdc++.h>\n#pragma GCC optimize(3)\n#define il __inline__ __attribute__ ((always_inline))\n#define fur(i,x,y) for(int i(x);i<=y;++i)\n#define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\ntemplate <class T>il T MAX(T x,T y){return x>y?x:y;}\nusing namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\nconst int N=100011;\nint n,q,cnt,head[N],a[N];\nstruct seg{\n    #define ls rt<<1\n    #define rs rt<<1|1\n    #define pu s[rt]=MAX(s[ls],s[rs])\n    int s[N<<2],laz[N<<2];\n    void build(int l=1,int r=n,int rt=1){\n        if(l==r)return void(s[rt]=a[l]);\n        int m=l+r>>1;\n        build(l,m,ls);build(m+1,r,rs);\n        pu;\n    }\n    il void pd(int rt){\n        if(laz[rt]){\n            laz[ls]+=laz[rt];\n            laz[rs]+=laz[rt];\n            s[ls]+=laz[rt];\n            s[rs]+=laz[rt];\n            laz[rt]=0;\n        }\n    }\n    void upd(int L,int R,int v,int l=1,int r=n,int rt=1){\n        if(L<=l&&r<=R){\n            s[rt]+=v,laz[rt]+=v;\n            return;\n        }\n        int m=l+r>>1;\n        pd(rt);\n        if(L<=m)upd(L,R,v,l,m,ls);\n        if(R>m)upd(L,R,v,m+1,r,rs);\n        pu;\n    }\n    int ask(int L,int R,int l=1,int r=n,int rt=1){\n        if(L<=l&&r<=R)return s[rt];\n        int m=l+r>>1,ans=0;\n        pd(rt);\n        if(L<=m)ans=ask(L,R,l,m,ls);\n        if(R>m)ans=MAX(ans,ask(L,R,m+1,r,rs));\n        return ans;\n    }\n    il int operator[](int x){\n        int l=1,r=n,rt=1;\n        while(1){\n            if(l==r)return s[rt];\n            int m=l+r>>1;\n            pd(rt);\n            if(x<=m)r=m,rt=ls;\n            else l=m+1,rt=rs;\n        }\n    }\n    #undef ls\n    #undef rs\n}S;\nstruct edge{int to,nxt;}e[N<<1];\nil void add(int x,int y){e[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;}\nint siz[N],top[N],id[N],sz;\nstruct lct{\n    #define ls c[0][x]\n    #define rs c[1][x]\n    int f[N],c[2][N];\n    il int g(int x){return c[1][f[x]]==x;}\n    il int nrt(int x){return c[0][f[x]]==x||c[1][f[x]]==x;}\n    il void rotate(int x){\n        int y=f[x],z=f[y],l=g(x),r=!l,w=c[r][x];\n        if(nrt(y))c[g(y)][z]=x;\n        c[r][x]=y,c[l][y]=w;\n        if(w)f[w]=y;\n        f[x]=z,f[y]=x;\n    }\n    il void splay(int x){\n        for(;nrt(x);rotate(x))if(nrt(f[x]))\n            rotate(g(x)^g(f[x])?x:f[x]);\n    }\n    il int frt(int x){while(ls)x=ls;return x;}\n    il void access(int x){\n        for(int y=0,t;x;x=f[y=x]){\n            splay(x);\n            if(rs)t=frt(rs),S.upd(id[t],id[t]+siz[t]-1,1);\n            if(rs=y)t=frt(y),S.upd(id[t],id[t]+siz[t]-1,-1);\n        }\n    }\n    #undef ls\n    #undef rs\n}T;\nint f[N],d[N];\nvoid dfs(int x){\n    siz[x]=1;d[x]=d[f[x]]+1;\n    fl(i,x)if(to!=f[x])\n        f[to]=T.f[to]=x,dfs(to),siz[x]+=siz[to];\n}\nvoid bt(int x,int tp){\n    top[x]=tp;a[id[x]=++sz]=d[x];int k=0;\n    fl(i,x)if(to!=f[x]&&siz[to]>siz[k])k=to;\n    if(!k)return;bt(k,tp);\n    fl(i,x)if(!top[to])bt(to,to);\n}\nil int lca(int x,int y){\n    while(top[x]^top[y])\n        d[top[x]]>d[top[y]]?x=f[top[x]]:y=f[top[y]];\n    return d[x]<d[y]?x:y;\n}\nint main(){\n    in(n,q);\n    int opt,x,y;\n    fur(i,2,n)in(x,y),add(x,y),add(y,x);\n    dfs(1);bt(1,1);S.build();\n    while(q--){\n        in(opt,x);\n        if(opt==1)T.access(x);\n        else if(opt==2)\n            in(y),out(S[id[x]]+S[id[y]]-(S[id[lca(x,y)]]<<1)+1,ln);\n        else out(S.ask(id[x],id[x]+siz[x]-1),ln);\n    }\n    flush();\n}\n```","link":null,"tags":["数据结构","树论"],"title":"link-cut tree"},{"categories":[["刷题记录"]],"content":"\n```cpp\n#include<bits\/stdc++.h>\n#define il __inline__ __attribute__ ((always_inline))\nnamespace IN{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;inline char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}template<typename T>inline void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>inline void in(T &x,arr & ... y){in(x),in(y...);}}using namespace IN;\nnamespace OUT{const char ln='\\n';const int str=1<<20;static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;inline void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}inline void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}inline void out(char c){pt(c);}template<typename T>inline void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>inline void out(T x,arr & ... y){out(x),out(y...);}}using namespace OUT;\nconst int N=100011;\nint n,m,s[N],v[N],c[2][N],f[N],st[N];\nbool rev[N];\n#define ls(x) c[0][x]\n#define rs(x) c[1][x]\nil void pu(int x){s[x]=s[ls(x)]^s[rs(x)]^v[x];}\nil void pr(int x){int t=ls(x);ls(x)=rs(x);rs(x)=t;rev[x]^=1;}\nil void pd(int x){\n    if(rev[x]){\n        if(ls(x))pr(ls(x));\n        if(rs(x))pr(rs(x));\n        rev[x]=0;\n    }\n}\nil int g(int x){return rs(f[x])==x;}\nil int nrt(int x){return ls(f[x])==x||rs(f[x])==x;}\nil void rotate(int x){\n    int y=f[x],z=f[y],l=g(x),r=!l,w=c[r][x];\n    if(nrt(y))c[g(y)][z]=x;\n    c[r][x]=y,c[l][y]=w;\n    if(w)f[w]=y;\n    f[x]=z,f[y]=x;\n    pu(y),pu(x);\n}\nil void splay(int x){\n    int z=0,y=st[++z]=x;\n    while(nrt(y))st[++z]=y=f[y];\n    while(z)pd(st[z--]);\n    for(;nrt(x);rotate(x))if(nrt(f[x]))\n        rotate(g(x)^g(f[x])?x:f[x]);\n}\nil void access(int x){\n    for(int y=0;x;x=f[y=x])\n        splay(x),rs(x)=y,pu(x);\n}\nil void mrt(int x){access(x),splay(x),pr(x);}\nil int frt(int x){\n    for(access(x),splay(x);ls(x);pd(x),x=ls(x));\n    splay(x);return x;\n}\nil void link(int x,int y){\n    mrt(x);\n    if(frt(y)^x)f[x]=y;\n}\nil void sl(int x,int y){mrt(x),access(y),splay(y);}\nil void cut(int x,int y){\n    mrt(x);\n    if(frt(y)==x&&f[y]==x&&!ls(y))\n        f[y]=rs(x)=0,pu(x);\n}\nint main(){\n    in(n,m);\n    for(int i=1;i<=n;++i)in(v[i]);\n    int opt,x,y;\n    while(m--){\n        in(opt,x,y);\n        if(opt==0)sl(x,y),out(s[y],ln);\n        if(opt==1)link(x,y);\n        if(opt==2)cut(x,y);\n        if(opt==3)splay(x),v[x]=y;\n    }\n    flush();\n}\n```\n","link":null,"tags":["模板","lct"],"title":"LG 3690 【模板】Link Cut Tree （动态树）"},{"categories":[["刷题记录"]],"content":"\n## 树套树解法\n\n此题对树套树爱好者极不友好！\n\n首先高高兴兴地写了个树状数组套动态开点权值线段树,发现MLE了,多次调整空间后发现要么re要么mle,难道只能用cdq分治或k-dtree了吗？\n\n好不容易写完的代码舍不得随便删掉\n\n既然卡空间,那我离散化坐标,再把树状数组也改成动态开点线段树还不行吗？ 还真不行\n\n我感到了这题深深的恶毒\n\n只能动用黑科技了！\n\n\"线段树的压缩路径\",如果没有询问要访问这个节点,那就不继续向下开点,以节约空间！\n\n内层和外层都开,终于通过了这道恶毒的题\n\n```cpp\n#include<bits\/stdc++.h>\n#define il __inline__ __attribute__ ((always_inline))\n#define fur(i,x,y) for(int i(x);i<=y;++i)\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\nconst int N=2000011,M=6000011;\nint n,m,sz,SZ,RT,rt[M],s[M],ls[M],rs[M],LS[M],RS[M];\nstruct laz{int x,v;}laz[M];\nstruct LAZ{int x,y,v;}LAZ[M];\nstruct que{int opt,x,y,X,Y,a;}Q[N];\nstruct node{int v,id,typ;bool operator<(node t){return v<t.v;}}b[N<<1],B[N<<1];\nvoid upd(int x,int v,int l,int r,int &o){\n    if(!o)o=++sz;\n    s[o]+=v;\n    if(l==r)return;\n    if(laz[o].x){\n        int m=l+r>>1;\n        if(laz[o].x<=m)upd(laz[o].x,laz[o].v,l,m,ls[o]);\n        else upd(laz[o].x,laz[o].v,m+1,r,rs[o]);\n    }\n    laz[o]={x,v};\n}\nint ask(int L,int R,int l,int r,int o){\n    if(!o)return 0;\n    if(L<=l&&r<=R)return s[o];\n    int m=l+r>>1,ans=0;\n    if(laz[o].x){\n        if(laz[o].x<=m)upd(laz[o].x,laz[o].v,l,m,ls[o]);\n        else upd(laz[o].x,laz[o].v,m+1,r,rs[o]);\n        laz[o]={0,0};\n    }\n    if(L<=m)ans=ask(L,R,l,m,ls[o]);\n    if(R>m)ans+=ask(L,R,m+1,r,rs[o]);\n    return ans;\n}\nvoid UPD(int x,int y,int v,int l,int r,int &o){\n    if(!o)o=++SZ;\n    upd(y,v,1,m,rt[o]);\n    if(l==r)return;\n    if(LAZ[o].x){\n        int m=l+r>>1;\n        if(LAZ[o].x<=m)UPD(LAZ[o].x,LAZ[o].y,LAZ[o].v,l,m,LS[o]);\n        else UPD(LAZ[o].x,LAZ[o].y,LAZ[o].v,m+1,r,RS[o]);\n    }\n    LAZ[o]={x,y,v};\n}\nint ASK(int x,int y,int X,int Y,int l=1,int r=n,int o=1){\n    if(!o)return 0;\n    if(x<=l&&r<=X)return ask(y,Y,1,m,rt[o]);\n    int m=l+r>>1,ans=0;\n    if(LAZ[o].x){\n        int m=l+r>>1;\n        if(LAZ[o].x<=m)UPD(LAZ[o].x,LAZ[o].y,LAZ[o].v,l,m,LS[o]);\n        else UPD(LAZ[o].x,LAZ[o].y,LAZ[o].v,m+1,r,RS[o]);\n        LAZ[o]={0,0,0};\n    }\n    if(x<=m)ans=ASK(x,y,X,Y,l,m,LS[o]);\n    if(X>m)ans+=ASK(x,y,X,Y,m+1,r,RS[o]);\n    return ans;\n}\nint main(){\n    int x,y,X,Y,a,opt,d=0,D=0,q=0;\n    in(x,y);\n    while(1){\n        in(opt);if(opt==3)break;\n        ++q;\n        if(opt==1){\n            in(x,y,a);\n            b[++d]={x,q,0};\n            B[++D]={y,q,0};\n        }\n        else{\n            in(x,y,X,Y);\n            b[++d]={x,q,0};\n            b[++d]={X,q,1};\n            B[++D]={y,q,0};\n            B[++D]={Y,q,1};\n        }\n        Q[q]={opt,x,y,X,Y,a};\n    }\n    std::sort(b+1,b+d+1);std::sort(B+1,B+D+1);b[0].v=B[0].v=-(1<<30);\n    fur(i,1,d)(b[i].typ?Q[b[i].id].X:Q[b[i].id].x)=n+=b[i].v!=b[i-1].v;\n    fur(i,1,D)(B[i].typ?Q[B[i].id].Y:Q[B[i].id].y)=m+=B[i].v!=B[i-1].v;\n    fur(i,1,q){\n        x=Q[i].x,y=Q[i].y,X=Q[i].X,Y=Q[i].Y;a=Q[i].a;\n        if(Q[i].opt==1)UPD(x,y,a,1,n,RT);\n        else out(ASK(x,y,X,Y),ln);\n    }\n    flush();\n}\n```\n\n## CDQ解法\n\n这题还是拿来练CDQ好\n\n可以容斥一下:\n\n设$S_{X,Y}$为$(1,1)$到$X,Y$\n\n$(X_1,Y_1)$到$(X_2,Y_2)$转化为$S_{X_2,Y_2}-S_{X_1-1,Y_2}-S_{X_2,Y_1-1}+S_{X_1-1,X_2-1}$\n\n然后就是经典的CDQ分治解决三位数点了\n```cpp\n#include<bits\/stdc++.h>\n#define il __inline__ __attribute__ ((always_inline))\n#define fur(i,x,y) for(int i(x);i<=y;++i)\nil void cmax(int &x,int y){x=x>y?x:y;}\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\nconst int N=2000001;\nint n,ans[N],s[N];\nstruct que{\n    int typ,id,x,y,v;\n    il bool operator<(que t){return x<t.x;}\n}Q[N],T[N];\nil void add(int x,int v){for(;x<=n;x+=x&-x)s[x]+=v;}\nil int ask(int x){int res=0;for(;x;x^=x&-x)res+=s[x];return res;}\nvoid cdq(int l,int r){\n    if(l>=r)return;\n    int m=l+r>>1,j=l;\n    cdq(l,m),cdq(m+1,r);\n    fur(i,m+1,r)if(!Q[i].typ){\n        for(;j<=m&&Q[j].x<=Q[i].x;++j)if(Q[j].typ)add(Q[j].y,Q[j].v);\n        ans[Q[i].id]+=Q[i].v*ask(Q[i].y);\n    }\n    fur(i,l,j-1)if(Q[i].typ)add(Q[i].y,-Q[i].v);\n    for(int i=l,p=l,q=m+1;i<=r;++i)\n        if(p>m)T[i]=Q[q++];\n        else if(q>r)T[i]=Q[p++];\n        else T[i]=Q[p]<Q[q]?Q[p++]:Q[q++];\n    fur(i,l,r)Q[i]=T[i];\n}\nint main(){\n    int x,y,X,Y,a,opt,q=0,d=0;\n    in(x,y);\n    while(1){\n        in(opt);if(opt==3)break;\n        if(opt==1)in(x,y,a),Q[++q]={1,0,x,y,a},cmax(n,y);\n        else in(x,y,X,Y),++d,\n        Q[++q]={0,d,X,Y,1},\n        Q[++q]={0,d,X,y-1,-1},\n        Q[++q]={0,d,x-1,Y,-1},\n        Q[++q]={0,d,x-1,y-1,1},\n        cmax(n,y),cmax(n,Y);\n    }\n    cdq(1,q);\n    fur(i,1,d)out(ans[i],ln);\n    flush();\n}\n```\n","link":null,"tags":["树状数组","树套树","线段树","cdq分治"],"title":"LG 4390 [BOI2007]Mokia 摩基亚"},{"categories":[["刷题记录"]],"content":"\n**树链剖分**套**树套树**\n\n这里的**树套树**使用**树状数组**套**动态开点权值线段树**实现,要先离散化\n\n我的方法算是有点笨但是好写的方法\n\n\n```cpp\n#include<bits\/stdc++.h>\n#pragma GCC optimize(3)\n#define il __inline__ __attribute__ ((always_inline))\n#define fur(i,x,y) for(int i(x);i<=y;++i)\n#define fdr(i,x,y) for(int i(x);i>=y;--i)\n#define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\nusing namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\nconst int N=80011;\nint n,q,cnt,nn,a[N],head[N],c[N<<1];\nstruct node{int v,id,typ;bool operator<(node t){return v<t.v;}}b[N<<1];\nstruct que{int k,x,y;}Q[N];\nstruct edge{int to,nxt;}e[N<<1];\nil void add(int x,int y){e[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;}\nint siz[N],top[N],f[N],d[N],id[N],sz;\nvoid dfs(int x){\n    siz[x]=1;\n    fl(i,x)if(f[x]^to){\n        d[to]=d[x]+1;\n        f[to]=x;\n        dfs(to);\n        siz[x]+=siz[to];\n    }\n}\nvoid bt(int x,int tp){\n    top[x]=tp;id[x]=++sz;int k=0;\n    fl(i,x)if(to^f[x]&&siz[to]>siz[k])k=to;\n    if(!k)return;bt(k,tp);\n    fl(i,x)if(!top[to])bt(to,to);\n}\nint RT[N],s[N*400],ls[N*400],rs[N*400];\nvoid upd(int x,int v,int l,int r,int &rt){\n    if(!rt)rt=++sz;\n    s[rt]+=v;\n    if(l==r)return;\n    int m=l+r>>1;\n    if(x<=m)upd(x,v,l,m,ls[rt]);\n    else upd(x,v,m+1,r,rs[rt]);\n}\nint tl[400],tr[400],cl,cr;\nil void get(int l,int r){\n    for(int i=l-1;i;i^=i&-i)tl[++cl]=RT[i];\n    for(int i=r;i;i^=i&-i)tr[++cr]=RT[i];\n}\nil void ask(int x,int y,int k){\n    cl=cr=0;\n    int t=0;\n    while(top[x]^top[y]){\n        if(d[top[x]]<d[top[y]])x^=y,y^=x,x^=y;\n        t+=id[x]-id[top[x]]+1;get(id[top[x]],id[x]),x=f[top[x]];\n    }\n    if(id[x]>id[y])x^=y,y^=x,x^=y;\n    get(id[x],id[y]);\n    t+=id[y]-id[x]+1;\n    if(t<k){out(\"invalid request!\\n\");return;}\n    int l=1,r=nn;\n    while(l<r){\n        int m=l+r>>1,sum=0;\n        fur(i,1,cl)sum-=s[rs[tl[i]]];\n        fur(i,1,cr)sum+=s[rs[tr[i]]];\n        if(k<=sum){\n            fur(i,1,cl)tl[i]=rs[tl[i]];\n            fur(i,1,cr)tr[i]=rs[tr[i]];\n            l=m+1;\n        }\n        else{\n            fur(i,1,cl)tl[i]=ls[tl[i]];\n            fur(i,1,cr)tr[i]=ls[tr[i]];\n            k-=sum,r=m;\n        }\n    }\n    out(c[l],ln);\n}\nint main(){\n    in(n,q);\n    int k,x,y,t=0;\n    fur(i,1,n)in(a[i]),b[++t]={a[i],i,0};\n    fur(i,2,n)in(x,y),add(x,y),add(y,x);\n    fur(i,1,q){\n        in(k,x,y);\n        if(!k)b[++t]={y,i,1};\n        Q[i]={k,x,y};\n    }\n    sort(b+1,b+t+1);b[0].v=-(1<<30);\n    fur(i,1,t)c[(b[i].typ?Q[b[i].id].y:a[b[i].id])=nn+=b[i].v!=b[i-1].v]=b[i].v;\n    dfs(1);bt(1,1);\n    fur(i,1,n)for(int j=id[i];j<=n;j+=j&-j)upd(a[i],1,1,nn,RT[j]);\n    fur(i,1,q){\n        k=Q[i].k,x=Q[i].x,y=Q[i].y;\n        if(!k){\n            for(int j=id[x];j<=n;j+=j&-j)upd(a[x],-1,1,nn,RT[j]);\n            a[x]=y;\n            for(int j=id[x];j<=n;j+=j&-j)upd(a[x],1,1,nn,RT[j]);\n        }\n        else ask(x,y,k);\n    }\n    flush();\n}\n```\n","link":null,"tags":["树套树","树链剖分","树状数组","线段树"],"title":"LG 4175 [CTSC2008]网络管理"},{"categories":[["刷题记录"]],"content":"\n此题非常之毒瘤,我写的整个人都二逼了\n\n共有一下几种解法:\n\n1. 树状数组套线段树\n2. 线段树套平衡树\n3. 权值线段树套平衡树\n4. 分块\n5. 整体二分\n\n## 树状数组套线段树\n\n离散化+树状数组套动态开点线段树\n\n这应该是一种常数小又好写的方法了,不开o2也轻松过\n\n可以参照[LG 2617 Dynamic Rankings](https:\/\/www.luogu.com.cn\/problem\/P2617)的做法\n\n简要说下思路:\n\n树状数组记录位置,权值线段树记录权值\n\n树状数组的每个节点都是一颗权值线段树\n\n1. 查询区间内一个数的排名: \n   \n   在树状数组上找到区间对应的节点,对应的权值线段树线段树树内查询对应数的排名并求和。\n   \n2. 查询区间内排名为k的数是几:\n      \n   找出树状数组中所有对应节点,然后权值线段树上二分(与主席树的方法相似)\n\n3. 单点修改: \n   \n   相当于树状数组上的单点修改,在对应节点的权值线段树中删除原数,加入新数\n\n4. 前驱:\n   \n   查询排名,然后找排名-1的数\n\n5. 后继:\n   \n   查询排名,然后找排名+1的数\n\n语文不好,不大会表述,相信数据结构这种东西直接看代码更好理解\n\n具体可以看代码\n\n```cpp\n#include<bits\/stdc++.h>\n#define il __inline__ __attribute__ ((always_inline))\n#define fur(i,x,y) for(int i=x;i<=y;++i)\nnamespace IN{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;inline char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}template<typename T>inline void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>inline void in(T &x,arr & ... y){in(x),in(y...);}}using namespace IN;\nnamespace OUT{const char ln='\\n';const int str=1<<20;static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;inline void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}inline void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}inline void out(char c){pt(c);}template<typename T>inline void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>inline void out(T x,arr & ... y){out(x),out(y...);}}using namespace OUT;\n#define N 50011\nint n,q,tot,sz,a[N],c[N<<1],RT[N],s[N*400],ls[N*400],rs[N*400];\nstruct que{int opt,l,r,k;}Q[N];\nstruct node{int v,id,typ;bool operator<(node t)const{return v<t.v;}}b[N<<1];\nvoid upd(int x,int v,int l,int r,int &rt){\n    if(!rt)rt=++sz;\n    s[rt]+=v;\n    if(l==r){return;}\n    int m=l+r>>1;\n    if(x<=m)upd(x,v,l,m,ls[rt]);\n    else upd(x,v,m+1,r,rs[rt]);\n}\nil void UPD(int x,int v){for(int i=x;i<=n;i+=i&-i)upd(a[x],v,1,tot,RT[i]);}\nint tl[20],tr[20];\nil int rnk(int l,int r,int v,int t=0){\/\/还是二分,加了个特判(可以是这个数的第一个或最后一个的排名)\n    int cl=0,cr=0,m,res=0;\n    \/\/获取区间对应的所有根节点位置\n    for(int i=l-1;i;i^=i&-i)tl[++cl]=RT[i];\n    for(int i=r;i;i^=i&-i)tr[++cr]=RT[i];\n    l=1,r=tot;\n    while(l<r){\n        m=l+r>>1;\n        if(v+t<=m){ \/\/比mid小,进入左儿子  (t为特判)\n            fur(i,1,cl)tl[i]=ls[tl[i]];\n            fur(i,1,cr)tr[i]=ls[tr[i]];\n            r=m;\n        }\n        else{ \/\/进入右儿子\n            fur(i,1,cl)res-=s[ls[tl[i]]],tl[i]=rs[tl[i]];\n            fur(i,1,cr)res+=s[ls[tr[i]]],tr[i]=rs[tr[i]];\n            l=m+1;\n        }\n    }\n    return res+1-t;\n}\nil int kth(int l,int r,int k){\/\/ 与Dynamic Rankings一样,二分\n    int cl=0,cr=0,cnt,m;\n    for(int i=l-1;i;i^=i&-i)tl[++cl]=RT[i];\n    for(int i=r;i;i^=i&-i)tr[++cr]=RT[i];\n    l=1,r=tot;\n    while(l<r){\n        m=l+r>>1;cnt=0;\n        fur(i,1,cl)cnt-=s[ls[tl[i]]];\n        fur(i,1,cr)cnt+=s[ls[tr[i]]];\n        if(k<=cnt){\n            fur(i,1,cl)tl[i]=ls[tl[i]];\n            fur(i,1,cr)tr[i]=ls[tr[i]];\n            r=m;\n        }\n        else{\n            fur(i,1,cl)tl[i]=rs[tl[i]];\n            fur(i,1,cr)tr[i]=rs[tr[i]];\n            k-=cnt,l=m+1;\n        }\n    }\n    return c[l];\n}\nil int pre(int l,int r,int k){\/\/求出 排名 后求 排名-1 的数\n    int t=rnk(l,r,k)-1;\n    if(!t)return -2147483647;\n    return kth(l,r,t);\n}\nil int nxt(int l,int r,int k){\/\/类似前驱\n    int t=rnk(l,r,k,1)+1;\n    if(t==r-l+2)return 2147483647;\n    return kth(l,r,t);\n}\nint main(){\n    in(n,q);\n    int opt,l,r,k,d=n,t=0,x;\n    fur(i,1,n)in(x),b[i]={x,i,0};\n    fur(i,1,q){\n        in(opt,l,r);\n        if(opt==3)k=r;\n        else in(k);\n        Q[i]=que{opt,l,r,k};\n        if(opt!=2)b[++d]=node{k,i,1};\n    }\n    \/\/离散化,统一离散化较快,如果要方便话可以像其他题解一样使用lowerbound\n    std::sort(b+1,b+d+1);b[0].v=-(1<<30);\n    fur(i,1,d)c[(b[i].typ?Q[b[i].id].k:a[b[i].id])=tot+=b[i].v!=b[i-1].v]=b[i].v;\n    fur(i,1,n)UPD(i,1);\n    fur(i,1,q){\n        opt=Q[i].opt;l=Q[i].l,r=Q[i].r,k=Q[i].k;\n        if(opt==1)out(rnk(l,r,k),ln);\n        if(opt==2)out(kth(l,r,k),ln);\n        if(opt==3)UPD(l,-1),a[l]=k,UPD(l,1);\n        if(opt==4)out(pre(l,r,k),ln);\n        if(opt==5)out(nxt(l,r,k),ln);\n    }\n    flush();\n}\n```\n\n## 线段树套平衡树\n\n最经典的解法\n\n1. 查询区间内一个数的排名: \n   \n   在线段树上找到区间对应的节点,然后每个节点的平衡树内查询对应数的排名并求和。\n   \n2. 查询区间内排名为k的数是几:\n   \n   这项操作在线段树上不可加,只能退一步\n   \n   二分答案,用操作1判断\n\n3. 单点修改: \n   \n   在线段树上找到所有覆盖这个点的区间,然后在所有区间对应的平衡树中删除原数,加入新数\n\n4. 前驱:\n   \n   在线段树上找到该区间对应的节点,对 这些节点求得的前驱 取$min$\n\n5. 同4\n\n这里的平衡树采用常数小且好写的`treap`\n\n```cpp\n#include<bits\/stdc++.h>\n#define il __inline__ __attribute__ ((always_inline))\n#define fur(i,x,y) for(int i=x;i<=y;++i)\nil int min(int x,int y){return x<y?x:y;}\nil int max(int x,int y){return x>y?x:y;}\nnamespace IN{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;inline char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}template<typename T>inline void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>inline void in(T &x,arr & ... y){in(x),in(y...);}}using namespace IN;\nnamespace OUT{const char ln='\\n';const int str=1<<20;static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;inline void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}inline void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}inline void out(char c){pt(c);}template<typename T>inline void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>inline void out(T x,arr & ... y){out(x),out(y...);}}using namespace OUT;\nconst int N=50011,inf=2147483647,M=3000001;\nint n,q,cnt,a[N],RT[N*20],rnd[M],c[M][2],s[M],val[M];\nil int rand(){static int seed=233;return seed=(int)seed*482711LL%inf;}\nil void pu(int x){s[x]=s[c[x][0]]+s[c[x][1]]+1;}\nil void turn(int &x,int p){\n    int t=c[x][p];\n    c[x][p]=c[t][!p];\n    c[t][!p]=x;\n    pu(x);pu(x=t);\n}\nvoid ins(int &x,int v){\n    if(!x){s[x=++cnt]=1;val[x]=v;rnd[x]=rand();return;}\n    ++s[x];\n    int p=(v>val[x]);\n    ins(c[x][p],v);\n    if(rnd[c[x][p]]<rnd[x])turn(x,p);\n}\nvoid del(int &x,int v){\n    if(val[x]==v){\n        if(!c[x][0]||!c[x][1]){x=c[x][0]|c[x][1];return;}\n        int p=rnd[c[x][0]]>rnd[c[x][1]];\n        turn(x,p);del(c[x][!p],v);\n    }\n    else del(c[x][v>=val[x]],v);\n    pu(x);\n}\nint rnk(int x,int v){\n    if(!x)return 0;\n    if(v<=val[x])return rnk(c[x][0],v);\n    return s[c[x][0]]+1+rnk(c[x][1],v);\n}\nint pre(int x,int v){\n    if(!x)return -inf;\n    if(v>val[x])return max(val[x],pre(c[x][1],v));\n    else return pre(c[x][0],v);\n}\nint nxt(int x,int v){\n    if(!x)return inf;\n    if(v<val[x])return min(val[x],nxt(c[x][0],v));\n    else return nxt(c[x][1],v);\n}\n#define ls rt<<1\n#define rs rt<<1|1\nvoid build(int p,int v,int l=1,int r=n,int rt=1){\n    ins(RT[rt],v);\n    if(l==r)return;\n    int m=l+r>>1;\n    if(p<=m)build(p,v,l,m,ls);\n    else build(p,v,m+1,r,rs);\n}\nvoid upd(int p,int v,int l=1,int r=n,int rt=1){\n    del(RT[rt],a[p]);ins(RT[rt],v);\n    if(l==r)return;\n    int m=l+r>>1;\n    if(p<=m)upd(p,v,l,m,ls);\n    else upd(p,v,m+1,r,rs);\n}\nint RNK(int L,int R,int v,int l=1,int r=n,int rt=1){\n    if(L<=l&&r<=R)return rnk(RT[rt],v);\n    int m=l+r>>1,ans=0;\n    if(L<=m)ans=RNK(L,R,v,l,m,ls);\n    if(R>m)ans+=RNK(L,R,v,m+1,r,rs);\n    return ans;\n}\nint KTH(int L,int R,int k){\n    int l=0,r=1e8,m,ans;\n    while(l<=r){\n        m=l+r>>1;\n        if(RNK(L,R,m)+1<=k)l=m+1,ans=m;\n        else r=m-1;\n    }\n    return ans;\n}\nint PRE(int L,int R,int v,int l=1,int r=n,int rt=1){\n    if(L<=l&&r<=R)return pre(RT[rt],v);\n    int m=l+r>>1,ans=-inf;\n    if(L<=m)ans=PRE(L,R,v,l,m,ls);\n    if(R>m)ans=max(ans,PRE(L,R,v,m+1,r,rs));\n    return ans;\n}\nint NXT(int L,int R,int v,int l=1,int r=n,int rt=1){\n    if(L<=l&&r<=R)return nxt(RT[rt],v);\n    int m=l+r>>1,ans=inf;\n    if(L<=m)ans=NXT(L,R,v,l,m,ls);\n    if(R>m)ans=min(ans,NXT(L,R,v,m+1,r,rs));\n    return ans;\n}\nint main(){\n    in(n,q);\n    fur(i,1,n)in(a[i]),build(i,a[i]);\n    int opt,l,r,k;\n    fur(i,1,q){\n        in(opt,l,r);\n        if(opt==3)upd(l,r),a[l]=r;\n        else in(k);\n        if(opt==1)out(RNK(l,r,k)+1,ln);\n        if(opt==2)out(KTH(l,r,k),ln);\n        if(opt==4)out(PRE(l,r,k),ln);\n        if(opt==5)out(NXT(l,r,k),ln);\n    }\n    flush();\n}\n```\n\n## 权值线段树套平衡树\n\n换个思路,权值线段树外层记录权值,内层记录位置\n\n\n\n## 整体二分\n\n## 分块\n```cpp\n#include<bits\/stdc++.h>\n#define il __inline__ __attribute__ ((always_inline))\n#define fur(i,x,y) for(int i=x;i<=y;++i)\nnamespace IN{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;inline char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}template<typename T>inline void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>inline void in(T &x,arr & ... y){in(x),in(y...);}}using namespace IN;\nnamespace OUT{const char ln='\\n';const int str=1<<20;static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;inline void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}inline void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}inline void out(char c){pt(c);}template<typename T>inline void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>inline void out(T x,arr & ... y){out(x),out(y...);}}using namespace OUT;\n#define N 50011\nint n,q,tot,sz,a[N],c[N<<1],RT[N],s[N*400],ls[N*400],rs[N*400];\nstruct que{int opt,l,r,k;}Q[N];\nstruct node{int v,id,typ;bool operator<(node t)const{return v<t.v;}}b[N<<1];\nvoid upd(int x,int v,int l,int r,int &rt){\n    if(!rt)rt=++sz;\n    s[rt]+=v;\n    if(l==r){return;}\n    int m=l+r>>1;\n    if(x<=m)upd(x,v,l,m,ls[rt]);\n    else upd(x,v,m+1,r,rs[rt]);\n}\nil void UPD(int x,int v){for(int i=x;i<=n;i+=i&-i)upd(a[x],v,1,tot,RT[i]);}\nint tl[20],tr[20];\nil int rnk(int l,int r,int v,int t=0){\/\/还是二分,加了个特判(可以是这个数的第一个或最后一个的排名)\n    int cl=0,cr=0,m,res=0;\n    \/\/获取区间对应的所有根节点位置\n    for(int i=l-1;i;i^=i&-i)tl[++cl]=RT[i];\n    for(int i=r;i;i^=i&-i)tr[++cr]=RT[i];\n    l=1,r=tot;\n    while(l<r){\n        m=l+r>>1;\n        if(v+t<=m){ \/\/比mid小,进入左儿子  (t为特判)\n            fur(i,1,cl)tl[i]=ls[tl[i]];\n            fur(i,1,cr)tr[i]=ls[tr[i]];\n            r=m;\n        }\n        else{ \/\/进入右儿子\n            fur(i,1,cl)res-=s[ls[tl[i]]],tl[i]=rs[tl[i]];\n            fur(i,1,cr)res+=s[ls[tr[i]]],tr[i]=rs[tr[i]];\n            l=m+1;\n        }\n    }\n    return res+1-t;\n}\nil int kth(int l,int r,int k){\/\/ 与Dynamic Rankings一样,二分\n    int cl=0,cr=0,cnt,m;\n    for(int i=l-1;i;i^=i&-i)tl[++cl]=RT[i];\n    for(int i=r;i;i^=i&-i)tr[++cr]=RT[i];\n    l=1,r=tot;\n    while(l<r){\n        m=l+r>>1;cnt=0;\n        fur(i,1,cl)cnt-=s[ls[tl[i]]];\n        fur(i,1,cr)cnt+=s[ls[tr[i]]];\n        if(k<=cnt){\n            fur(i,1,cl)tl[i]=ls[tl[i]];\n            fur(i,1,cr)tr[i]=ls[tr[i]];\n            r=m;\n        }\n        else{\n            fur(i,1,cl)tl[i]=rs[tl[i]];\n            fur(i,1,cr)tr[i]=rs[tr[i]];\n            k-=cnt,l=m+1;\n        }\n    }\n    return c[l];\n}\nil int pre(int l,int r,int k){\/\/求出 排名 后求 排名-1 的数\n    int t=rnk(l,r,k)-1;\n    if(!t)return -2147483647;\n    return kth(l,r,t);\n}\nil int nxt(int l,int r,int k){\/\/类似前驱\n    int t=rnk(l,r,k,1)+1;\n    if(t==r-l+2)return 2147483647;\n    return kth(l,r,t);\n}\nint main(){\n    in(n,q);\n    int opt,l,r,k,d=n,t=0,x;\n    fur(i,1,n)in(x),b[i]={x,i,0};\n    fur(i,1,q){\n        in(opt,l,r);\n        if(opt==3)k=r;\n        else in(k);\n        Q[i]=que{opt,l,r,k};\n        if(opt!=2)b[++d]=node{k,i,1};\n    }\n    \/\/离散化,统一离散化较快,如果要方便话可以像其他题解一样使用lowerbound\n    std::sort(b+1,b+d+1);b[0].v=-(1<<30);\n    fur(i,1,d)c[(b[i].typ?Q[b[i].id].k:a[b[i].id])=tot+=b[i].v!=b[i-1].v]=b[i].v;\n    fur(i,1,n)UPD(i,1);\n    fur(i,1,q){\n        opt=Q[i].opt;l=Q[i].l,r=Q[i].r,k=Q[i].k;\n        if(opt==1)out(rnk(l,r,k),ln);\n        if(opt==2)out(kth(l,r,k),ln);\n        if(opt==3)UPD(l,-1),a[l]=k,UPD(l,1);\n        if(opt==4)out(pre(l,r,k),ln);\n        if(opt==5)out(nxt(l,r,k),ln);\n    }\n    flush();\n}\n```\n","link":null,"tags":["树套树","数据结构"],"title":"LG 3380 【模板】二逼平衡树（树套树）"},{"categories":[["note"]],"content":"\n\n`pbds`是一个比stl还stl的东西\n\n`__gnu_pbds`,全称: `Policy based data structures`\n\n## 引入\n\n按需引入:\n\n```cpp\n#include<ext\/pb_ds\/assoc_container.hpp>\n#include<ext\/pb_ds\/tree_policy.hpp> \/\/tree\n#include<ext\/pb_ds\/hash_policy.hpp> \/\/hash\n#include<ext\/pb_ds\/trie_policy.hpp> \/\/trie\n#include<ext\/pb_ds\/priority_queue.hpp> \/\/priority_queue\nusing namespace __gnu_pbds;\n```\n全部引入:\n\n```cpp\n#include<bits\/extc++.h>\nusing namespace __gnu_pbds;\n```\n\n## Hash\n\n封装的哈希表\n\n可以代替`map`,而且比`map`快得多,$\\mathcal{O(n)}$与$\\mathcal{O(n \\log n)}$的区别\n\n```cpp\ncc_hash_table<int,bool>h;\ngp_hash_table<int,bool>h; \/\/似乎更快一些\n```\n\n操作和`map`差不多,支持`[]`和`find`\n\n## Tree\n\n封装了三种平衡树,`rb_tree`,`splay_tree`,`ov_tree`,建议使用`rb_tree`\n\n```cpp\n#define pii pair<int,int>\n#define mp(x,y) make_pair(x,y) \ntree<pii,null_type,less<pii>,rb_tree_tag,tree_order_statistics_node_update> tr;\npii \/\/存储的类型\nnull_type \/\/无映射(低版本g++为null_mapped_type)\nless<pii> \/\/从小到大排序\nrb_tree_tag \/\/红黑树\ntree_order_statistics_node_update \/\/更新方式 \ntr.insert(mp(x,y)); \/\/插入\ntr.erase(mp(x,y)); \/\/删除\ntr.order_of_key(pii(x,y)); \/\/求排名 \ntr.find_by_order(x); \/\/找k小值,返回迭代器 \ntr.join(b); \/\/将b并入tr,前提是两棵树类型一样且没有重复元素 \ntr.split(v,b); \/\/分裂,key小于等于v的元素属于tr,其余的属于b\ntr.lower_bound(x); \/\/返回第一个大于等于x的元素的迭代器\ntr.upper_bound(x); \/\/返回第一个大于x的元素的迭代器\n```\n\n和`set`一样**不支持重复元素**,记住千万不要插入重复元素\n\n[LG P3369 【模板】普通平衡树](https:\/\/www.luogu.com.cn\/problem\/P3369)\n\n```cpp\n#include<bits\/stdc++.h>\n#include<bits\/extc++.h>\nusing namespace std;\nusing namespace __gnu_pbds;\ntypedef long long ll;\ntree<ll,null_type,less<ll>,rb_tree_tag,tree_order_statistics_node_update>T;\nint n;ll x,ans;\nint main(){\n    scanf(\"%d\",&n);\n    for(int i=1,opt;i<=n;++i){\n        scanf(\"%d%lld\",&opt,&x);\n        if(opt==1)T.insert((x<<20)+i);\n        if(opt==2)T.erase(T.lower_bound(x<<20));\n        if(opt==3)printf(\"%d\\n\",T.order_of_key(x<<20)+1);\n        if(opt==4)ans=*T.find_by_order(x-1),printf(\"%lld\\n\",ans>>20);\n        if(opt==5)ans=*--T.lower_bound(x<<20),printf(\"%lld\\n\",ans>>20);\n        if(opt==6)ans=*T.upper_bound((x<<20)+n),printf(\"%lld\\n\",ans>>20);\n    }\n}\n```\n\n这pbds速度还蛮快的\n\n## Trie\n\n字典树\n\n```cpp\ntypedef trie<string,null_type,trie_string_access_traits<>,pat_trie_tag,trie_prefix_search_node_update>tr;\n\/\/第一个参数必须为字符串类型,tag也有别的tag,但pat最快,与tree相同,node_update支持自定义\ntr.insert(s); \/\/插入s \ntr.erase(s); \/\/删除s \ntr.join(b); \/\/将b并入tr \npair\/\/pair的使用如下：\npair<tr::iterator,tr::iterator>range=base.prefix_range(x);\nfor(tr::iterator it=range.first;it!=range.second;it++)\n    cout<<*it<<' '<<endl;\n\/\/pair中第一个是起始迭代器,第二个是终止迭代器,遍历过去就可以找到所有字符串了。 \n```\n\n## priority_queue\n\n```cpp\npriority_queue<int,greater<int>,TAG>Q;\/\/小根堆,大根堆写less<int>\n\/*其中的TAG为类型,有以下几种：\npairing_heap_tag\nthin_heap_tag\nbinomial_heap_tag\nrc_binomial_heap_tag \nbinary_heap_tag\n其中pairing_help_tag最快*\/\nQ.push(x);\nQ.pop();\nQ.top();\nQ.join(b);\nQ.empty();\nQ.size(); \nQ.modify(it,x);\nQ.erase(it);\n\/\/pbds里的优先队列还可以用迭代器遍历\n```\n\n部分内容引自https:\/\/www.luogu.com.cn\/blog\/Chanis\/gnu-pbds","link":null,"tags":["stl"],"title":"pbds"},{"categories":[["刷题记录"]],"content":"\n整体二分\n\n接近模板题\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\nconst int N=300011;\nint n,q,k,cnt=0,ans[N],head[N],L[N],R[N],V[N];\nll s[N<<1];\nstruct que{ll v;int id;}a[N],b[N];\nil void upd(int x,int v){for(;x<=(q<<1);x+=x&-x)s[x]+=v;}\nil ll ask(int x){ll res=0;for(;x;x^=x&-x)res+=s[x];return res;}\nstruct edge{int to,nxt;}e[N];\nil void add(int x,int y){e[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;}\nvoid solve(int l,int r,int st,int ed){\n    if(l>r||st>ed)return;\n    if(l==r){Fur(i,st,ed)ans[a[i].id]=l;return;}\n    int m=(l+r)>>1,c1=0,c2=0;\n    Fur(i,l,m)upd(L[i],V[i]),upd(R[i]+1,-V[i]);\n    Fur(i,st,ed){\n        ll t=0;\n        fl(j,a[i].id)if(t<=a[i].v)t+=ask(to)+ask(to+q);else break;\n        if(t>=a[i].v)a[st+c1++]=a[i];\n        else a[i].v-=t,b[++c2]=a[i];\n    }\n    Fur(i,l,m)upd(L[i],-V[i]),upd(R[i]+1,V[i]);\n    Fur(i,1,c2)a[st+c1+i-1]=b[i];\n    solve(l,m,st,st+c1-1);\n    solve(m+1,r,st+c1,ed);\n}\nint main(){\n    in(n,q);\n    int x;\n    Fur(i,1,q)in(x),add(x,i);\n    Fur(i,1,n)in(a[i].v),a[i].id=i;\n    in(k);\n    Fur(i,1,k){in(L[i],R[i],V[i]);if(R[i]<L[i])R[i]+=q;}\n    solve(1,k+1,1,n);\n    Fur(i,1,n)if(ans[i]>k)out(\"NIE\\n\");else out(ans[i],ln);\n    flush();\n}\n```\n","link":null,"tags":["整体二分","树状数组"],"title":"LG 3527 [POI2011]MET-Meteors"},{"categories":[["刷题记录"]],"content":"\n## 树套树\n\n外层权值线段树 内层区间修改线段树\n\n内层线段树需使用标记永久化,否则可能TLE\n\n外层可以使用非递归结构提高速度\n\n可以预先离散化提高速度\n\n```cpp\n#include<bits\/stdc++.h>\ntypedef long long ll;\nnamespace IN{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;inline char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}template<typename T>inline void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>inline void in(T &x,arr & ... y){in(x),in(y...);}}using namespace IN;\nnamespace OUT{const char ln='\\n';const int str=1<<20;static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;inline void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}inline void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}inline void out(char c){pt(c);}template<typename T>inline void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>inline void out(T x,arr & ... y){out(x),out(y...);}}using namespace OUT;\nconst int N=50011;\ninline int min(int x,int y){return x<y?x:y;}\ninline int max(int x,int y){return x>y?x:y;}\nint n,nn=0,q,sz=0,RT[N<<2],laz[N*400],ls[N*400],rs[N*400],C[N];\nll s[N*400];\nstruct que{int typ,l,r;ll c;}Q[N];\nstruct node{int v,id;bool operator<(node t){return v<t.v;}}b[N];\nvoid upd(int L,int R,int l,int r,int &rt){\n    if(!rt)rt=++sz;\n    if(L<=l&&r<=R){s[rt]+=r-l+1;++laz[rt];return;}\n    int m=(l+r)>>1;\n    if(L<=m)upd(L,R,l,m,ls[rt]);\n    if(R>m)upd(L,R,m+1,r,rs[rt]);\n    s[rt]=s[ls[rt]]+s[rs[rt]]+(r-l+1)*laz[rt];\n}\nll ask(int L,int R,int l,int r,int rt){\n    if(!rt)return 0;\n    if(L<=l&&r<=R)return s[rt];\n    int m=(l+r)>>1;ll ans=laz[rt]*(min(R,r)-max(L,l)+1);\n    if(L<=m)ans+=ask(L,R,l,m,ls[rt]);\n    if(R>m)ans+=ask(L,R,m+1,r,rs[rt]);\n    return ans;\n}\n#define ls rt<<1\n#define rs rt<<1|1\nvoid UPD(int L,int R,int v){\n    int l=1,r=nn,rt=1;\n    while(l<r){\n        upd(L,R,1,n,RT[rt]);\n        int m=(l+r)>>1;\n        if(v<=m)r=m,rt=ls;\n        else l=m+1,rt=rs;\n    }\n    upd(L,R,1,n,RT[rt]);\n}\nint ASK(int L,int R,ll k){\n    int l=1,r=nn,rt=1;\n    while(l<r){\n        int m=(l+r)>>1;ll t=ask(L,R,1,n,RT[rs]);\n        if(k>t)r=m,rt=ls,k-=t;\n        else l=m+1,rt=rs;\n    }\n    return l;\n}\nint main(){\n    in(n,q);\n    int typ,l,r,d=0;ll c;\n    for(int i=1;i<=q;++i){\n        in(typ,l,r,c);\n        if(typ==1)b[++nn]={c,i};\n        Q[i]={typ,l,r,c};\n    }\n    std::sort(b+1,b+nn+1);b[0].v=-(1<<30);\n    for(int i=1;i<=nn;++i)C[Q[b[i].id].c=d+=(b[i].v!=b[i-1].v)]=b[i].v;\n    for(int i=1;i<=q;++i){\n        l=Q[i].l,r=Q[i].r,c=Q[i].c;\n        if(Q[i].typ==1)UPD(l,r,c);\n        else out(C[ASK(l,r,c)],ln);\n    }\n    flush();\n}\n```\n\n## 整体二分\n\n比树套树常数小多了,简直吊着树套树打\n\n\n```cpp\n#include<bits\/stdc++.h>\n#define il __inline__ __attribute__ ((always_inline))\ntypedef long long ll;\nnamespace IN{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}}using namespace IN;\nnamespace OUT{const char ln='\\n';const int str=1<<20;static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(char c){pt(c);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace OUT;\nconst int N=50001;\nll s[N],S[N];\nint n,q,tot,ans[N];\nil void upd(int x,int v){for(int i=x--;i<=n;i+=i&-i)s[i]+=v,S[i]+=v*x;}\n#define upd(l,r,v) upd(l,v),upd(r+1,-v)\nil ll ask(int x){ll res=0,RES=0;for(int i=x;i;i^=i&-i)res+=s[i],RES+=S[i];return x*res-RES;}\nstruct que{int typ,l,r,id;ll c;}a[N],a2[N];\nvoid solve(int l,int r,int st,int ed){\n    if(st>ed||l>r)return;\n    if(l==r){for(int i=st;i<=ed;++i)ans[a[i].id]=l;return;}\n    for(int i=st;i<=ed;++i)if(a[i].typ^1)goto ski;return;ski:;\n    int m=(l+r)>>1,c1=0,c2=0;\n    for(int i=st;i<=ed;++i)\n    if(a[i].typ&1){\n        if(a[i].c>m)upd(a[i].l,a[i].r,1),a2[++c2]=a[i];\n        else a[st+c1++]=a[i];\n    }\n    else{\n        ll x=ask(a[i].r)-ask(a[i].l-1);\n        if(x>=a[i].c)a2[++c2]=a[i];\n        else a[i].c-=x,a[st+c1++]=a[i];\n    }\n    for(int i=1;i<=c2;++i)if(a2[i].typ&1)upd(a2[i].l,a2[i].r,-1);\n    for(int i=1;i<=c2;++i)a[st+c1+i-1]=a2[i];\n    solve(l,m,st,st+c1-1);\n    solve(m+1,r,st+c1,ed);\n}\nint main(){\n    in(n,q);\n    for(int i=1;i<=q;++i){\n        in(a[i].typ,a[i].l,a[i].r,a[i].c);\n        if(a[i].typ^1)a[i].id=++tot;\n    }\n    solve(1,n,1,q);\n    for(int i=1;i<=tot;++i)out(ans[i],ln);\n    flush();\n}\n```\n","link":null,"tags":["线段树","树套树","整体二分","标记永久化"],"title":"LG 3332 [ZJOI2013]K大数查询"},{"categories":[["算法","离线"],["note"]],"content":"\n\n整体二分是离线算法\n\n顾名思义就是将所有答案一起二分\n\n$solve(l,r,st,ed)$表示答案在$[l,r]$,解决第$st$到$ed$个询问或操作\n\n以静态区间第$k$小为例,[LG P3834 【模板】可持久化线段树 1（主席树）](https:\/\/www.luogu.com.cn\/problem\/P3834)\n\n如果$l=r$,直接$[st,ed]$答案都是$l$\n\n和普通二分一样,设$m=\\frac {l+r}2$\n\n如果 是原序列中的数 且 大于$m$ , 在树状数组中对应位置+1\n\n如果是询问操作,设$x$为树状数组中询问区间的总和,\n\n若$x \\ge k$则分配到左区间,\n\n否则分配到右区间,$k=k-x$.\n\n具体看代码:\n\n```cpp\n#include<bits\/stdc++.h>\nnamespace IN{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;inline char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}template<typename T>inline void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>inline void in(T &x,arr & ... y){in(x),in(y...);}}using namespace IN;\nnamespace OUT{const char ln='\\n';const int str=1<<20;static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;inline void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}inline void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}inline void out(char c){pt(c);}template<typename T>inline void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>inline void out(T x,arr & ... y){out(x),out(y...);}}using namespace OUT;\nconst int N=200011;\nint n,q,ans[N],s[N];\ninline void add(int x,int v){for(;x<=n;x+=x&-x)s[x]+=v;}\ninline int ask(int x){int res=0;for(;x;x-=x&-x)res+=s[x];return res;}\nstruct que{int typ,id,l,r,k;}a[N<<1],a1[N<<1],a2[N<<1];\nvoid solve(int l,int r,int st,int ed){\n    if(st>ed||l>r)return;\n    if(l==r){for(int i=st;i<=ed;++i)ans[a[i].id]=l;return;}\n    int m=(l+r)>>1,c1=0,c2=0;\n    for(int i=st;i<=ed;++i)\n    if(a[i].typ){\n        if(a[i].k<=m)add(a[i].l,1),a1[++c1]=a[i];\n        else a2[++c2]=a[i];\n    }\n    else{\n        int x=ask(a[i].r)-ask(a[i].l-1);\n        if(a[i].k<=x)a1[++c1]=a[i];\n        else a[i].k-=x,a2[++c2]=a[i];\n    }\n    \/\/ 可以清空树状数组,也可以直接将加上的减去,后者更快\n    for(int i=1;i<=c1;++i)if(a1[i].typ)add(a1[i].l,-1);\n    for(int i=1;i<=c1;++i)a[st+i-1]=a1[i];\n    for(int i=1;i<=c2;++i)a[st+c1+i-1]=a2[i];\n    solve(l,m,st,st+c1-1);\n    solve(m+1,r,st+c1,ed);\n}\nint main(){\n    in(n,q);\n    int x,l,r,k;\n    for(int i=1;i<=n;++i)in(x),a[i]={1,0,i,0,x};\n    for(int i=1;i<=q;++i)in(l,r,k),a[n+i]={0,i,l,r,k};\n    solve(-1e9,1e9,1,n+q);\n    for(int i=1;i<=q;++i)out(ans[i],ln);\n    flush();\n}\n```","link":null,"tags":["算法","二分","离线","数据结构"],"title":"整体二分"},{"categories":[["刷题记录"]],"content":"\n离线解法: cdq分治\n\n将问题转化为三维偏序\n\n我们先找出对答案有贡献的点$(i,j)$满足的条件：\n\n$time_i<time_j$\n\n$val_i<val_j,pos_i>pos_j$或$val_i>val_j,pos_i<pos_j$\n\n```cpp\n#include<bits\/stdc++.h>\nnamespace IN{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;inline char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}template<typename T>inline void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>inline void in(T &x,arr & ... y){in(x),in(y...);}}using namespace IN;\nnamespace OUT{const char ln='\\n';const int str=1<<20;static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;inline void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}inline void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}inline void out(char c){pt(c);}template<typename T>inline void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>inline void out(T x,arr & ... y){out(x),out(y...);}}using namespace OUT;\nconst int N=100011,inf=2122219134;\nint n,q,s[N],pos[N];\nlong long ans[50011];\nvoid add(int x,int v){for(;x<=n;x+=x&-x)s[x]+=v;}\nint ask(int x){int res=0;for(;x;x-=x&-x)res+=s[x];return res;}\nstruct node{\n    int v,w,p,id;\n    bool operator<(node t){return p<t.p;}\n}b[N+50000],c[N+50000];\nvoid cdq(int l,int r){\n    if(l>=r)return;\n    int m=(l+r)>>1,j=l;\n    cdq(l,m);cdq(m+1,r);\n    for(int i=m+1;i<=r;++i){\n        for(;j<=m&&b[j].p<=b[i].p;++j)add(b[j].v,b[j].w);\n        ans[b[i].id]+=b[i].w*(ask(n)-ask(b[i].v));\/\/ 统计在i之前的与i组成的逆序对个数\n    }\n    for(int i=l;i<j;++i)add(b[i].v,-b[i].w);\n    j=m;\n    for(int i=r;i>m;--i){\n        for(;j>=l&&b[j].p>=b[i].p;--j)add(b[j].v,b[j].w);\n        ans[b[i].id]+=b[i].w*ask(b[i].v-1);\/\/ 统计在i之后的与i组成的逆序对个数\n    }\n    for(int i=m;i>j;--i)add(b[i].v,-b[i].w);\n    std::merge(b+l,b+m+1,b+m+1,b+r+1,c+l);\/\/使用merge合并比排序更快(归并排序)\n    for(int i=l;i<=r;++i)b[i]=c[i];\n}\nint main(){\n    in(n,q);\n    int x;\n    for(int i=1;i<=n;++i)in(x),b[i]=node{x,1,pos[x]=i,0};\n    for(int i=1;i<q;++i)in(x),b[n+i]=node{x,-1,pos[x],i};\n    cdq(1,n+q-1);\n    for(int i=1;i<q;++i)ans[i]+=ans[i-1];\n    for(int i=0;i<q;++i)out(ans[i],ln);\n    flush();\n}\n```\n\n\n\n在线解法: 树状数组+动态开点线段树\n\ncdq分治是离线解法,万一遇到毒瘤出题人就不能用了\n\n所以我们要学习更加高明的算法\n\n树状数组套动态开点权值线段树, 实现有点类似待修改主席树\n```cpp\n#include<bits\/stdc++.h>\nnamespace IN{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;inline char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}template<typename T>inline void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>inline void in(T &x,arr & ... y){in(x),in(y...);}}using namespace IN;\nnamespace OUT{const char ln='\\n';const int str=1<<20;static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;inline void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}inline void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}inline void out(char c){pt(c);}template<typename T>inline void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>inline void out(T x,arr & ... y){out(x),out(y...);}}using namespace OUT;\nconst int N=100011,inf=2122219134;\nint n,q,pos[N],RT[N],sz=0,s[N*300],ls[N*300],rs[N*300];\nvoid upd(int l,int r,int x,int y,int &rt){\n    if(!rt)rt=++sz;\n    s[rt]+=y;\n    if(l==r)return;\n    int m=(l+r)>>1;\n    if(x<=m)upd(l,m,x,y,ls[rt]);\n    else upd(m+1,r,x,y,rs[rt]);\n}\nint t[N],T[N];\nint ask(int l,int r,int x,int typ){\n    int cnt=0,CNT=0,sum=0;\n    for(int i=l-1;i;i-=i&-i)t[++cnt]=RT[i];\n    for(int i=r;i;i-=i&-i)T[++CNT]=RT[i];\n    l=1,r=n;\n    while(l<r){\n        int m=(l+r)>>1;\n        if(x>m){\n            if(typ){\n                for(int i=1;i<=cnt;++i)sum-=s[ls[t[i]]];\n                for(int i=1;i<=CNT;++i)sum+=s[ls[T[i]]];\n            }\n            for(int i=1;i<=cnt;++i)t[i]=rs[t[i]];\n            for(int i=1;i<=CNT;++i)T[i]=rs[T[i]];\n            l=m+1;\n        }\n        else{\n            if(!typ){\n                for(int i=1;i<=cnt;++i)sum-=s[rs[t[i]]];\n                for(int i=1;i<=CNT;++i)sum+=s[rs[T[i]]];\n            }\n            for(int i=1;i<=cnt;++i)t[i]=ls[t[i]];\n            for(int i=1;i<=CNT;++i)T[i]=ls[T[i]];\n            r=m;\n        }\n    }\n    return sum;\n}\nint main(){\n    in(n,q);\n    int x;\n    long long ans=0;\n    for(int i=1;i<=n;++i){\n        in(x);pos[x]=i;\n        ans+=ask(1,i-1,x,0);\n        for(int j=i;j<=n;j+=j&-j)upd(1,n,x,1,RT[j]);\n    }\n    out(ans,ln);\n    while(--q){\n        in(x);\n        ans-=ask(1,pos[x]-1,x,0);\n        ans-=ask(pos[x]+1,n,x,1);\n        out(ans,ln);\n        for(int j=pos[x];j<=n;j+=j&-j)upd(1,n,x,-1,RT[j]);\n    }\n    flush();\n}\n```\n","link":null,"tags":["离线","cdq分治","线段树","树状数组","逆序对"],"title":"LG 3157 [CQOI2011]动态逆序对"},{"categories":[["刷题记录"]],"content":"\n二维数点模板\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\nconst int N=32000;\nint n,s[N+11],ans[N+11];\nil void add(int x){for(;x<=N;x+=x&-x)++s[x];}\nil int ask(int x){int res=0;for(;x;x-=x&-x)res+=s[x];return res;}\nint main(){\n    in(n);\n    int x,y;\n    Fur(i,1,n){\n        in(x,y);\n        ++ans[ask(++x)];\n        add(x);\n    }\n    Fur(i,0,n-1)out(ans[i],ln);\n    flush();\n}\n```\n","link":null,"tags":["树状数组"],"title":"HDU 1541 Stars"},{"categories":[["刷题记录"]],"content":"\n很妙的一道题\n\n对每位置$i$分别统计$[l,i],l\\in [1,i]$的方案数\n\n设$S_i$表示$\\sum_{j=1}^i [H_i \\ge X]$,$pre$为位置$i-1$的方案数,$now$为位置$i$的方案数\n\n若$H_i\\ge x$,$now=pre+\\sum_{j=1}^i [S_j=S_i]$,这些位置是位置$i-1$不能满足而位置$i$可以满足的\n\n若$H_i\\le x$,$now=pre-\\sum_{j=1}^i [S_j=S_{i-1}]$,这些位置是位置$i$不能满足而位置$i-1$可以满足的\n\n这样就可以$\\Theta(n)$解决了呢\n\n记得开`long long`,$S_0$先赋值为$n$,防止负数re\n```cpp\n#include<bits\/stdc++.h>\nnamespace IN{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;inline char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}template<typename T>inline void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>inline void in(T &x,arr & ... y){in(x),in(y...);}}using namespace IN;\nconst int N=100011;\nint n,k,b[N<<1];\nint main(){\n    in(n,k);\n    int x,pre=0,s=n;\n    long long ans=0;\n    b[s]=1;\n    for(int i=1;i<=n;++i){\n        in(x);\n        if(x>=k)pre+=b[++s]+1;\n        else pre-=b[s--]-1;\n        ++b[s];\n        ans+=pre;\n    }\n    printf(\"%lld\\n\",ans);\n}\n```\n","link":null,"tags":["前缀和","思维"],"title":"LG 3031 [USACO11NOV]Above the Median G"},{"categories":[["刷题记录"]],"content":"\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\nconst int N=100011;\nint n;\nint main(){\n    \n}\n```\n","link":null,"tags":["数据结构","树链剖分"],"title":"LG 4115 Qtree4"},{"categories":[["刷题记录"]],"content":"\n先离散化,然后用树状数组统计两边的数目,比较即可\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\nconst int N=100011;\nint n,a[N],s[N],L[N];\nil void add(int x){for(;x<=n;x+=x&-x)++s[x];}\nil int ask(int x){int res=0;for(;x;x-=x&-x)res+=s[x];return res;}\nstruct node{int id,v;bool operator<(node t){return v>t.v;}}b[N];\nint main(){\n    in(n);\n    Fur(i,1,n)in(b[i].v),b[i].id=i;\n    sort(b+1,b+n+1);\n    int d=0,ans=0;b[0].v=-inf;\n    Fur(i,1,n)a[b[i].id]=d+=(b[i].v!=b[i-1].v);\n    Fur(i,1,n)L[i]=ask(a[i]-1),add(a[i]);\n    clr(s,0);\n    Fdr(i,n,1){\n        int l=L[i],r=ask(a[i]-1);\n        if(l>r)SWAP(l,r);\n        if(r>(l<<1))++ans;\n        add(a[i]);\n    }\n    printf(\"%d\\n\",ans);\n}\n```\n","link":null,"tags":["树状数组","前缀和"],"title":"LG 3608 [USACO17JAN]Balanced Photo G"},{"categories":[["刷题记录"]],"content":"\n首先可以想到按$v_i$排序\n\n接下来就直接按顺序插入并统计就可以了\n\n关于距离之和的统计:\n\n可以分前半部分和后半部分统计\n\n用树状数组维护即可\n\n感觉很水\n\n具体看代码吧\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\nconst int N=20000;\nint n;\nll s[N+11],t[N+11];\nil void add(int x,int v){for(;x<=N;x+=x&-x)s[x]+=v,++t[x];}\nil ll ask(int x){ll res=0;for(;x;x-=x&-x)res+=s[x];return res;}\nil int ASK(int x){int res=0;for(;x;x-=x&-x)res+=t[x];return res;}\nstruct node{int v,x;}a[N+11];\nil bool cmp(node x,node y){return x.v<y.v;}\nint main(){\n    in(n);\n    Fur(i,1,n)in(a[i].v,a[i].x);\n    sort(a+1,a+n+1,cmp);\n    ll ss=0,v,x,ans=0;\n    Fur(i,1,n){\n        v=a[i].v;x=a[i].x;\n        ll pre=ASK(x-1),pres=ask(x-1),res;\n        res=x*pre-pres+(ss-pres)-x*(i-1-pre);\n        ans+=v*res;\n        ss+=x;add(x,x);\n    }\n    printf(\"%lld\\n\",ans);\n}\n```\n","link":null,"tags":["树状数组"],"title":"LG 2345 [USACO04OPEN]MooFest G"},{"categories":[["刷题记录"]],"content":"\n允许离线处理\n\n可以看成三维偏序(坐标和时间)\n\n考虑如果要求的点都在当前点的左上方\n\n那么也就是要求$x_j\\le x_i,y_j\\le y_i,time_j\\le time_i$\n\n$x_i+y_i-\\max(x_j+y_j)$\n\n坐标再旋转并处理三次就可以了\n```cpp\n#include<bits\/stdc++.h>\n#define il inline\nil void cmax(int &x,int y){x=x>y?x:y;}\nil void cmin(int &x,int y){x=x<y?x:y;}\nnamespace IN{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}}using namespace IN;\nnamespace OUT{const char ln='\\n';const int str=1<<20;static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace OUT;\nconst int N=300011;\nusing std::merge;\nint n,q,cnt=0,ans[N],s[1000011],limx,limy,nn;\nstruct node{\n    int x,y,typ,id,ans;\n    il bool operator <(node &t){return x<=t.x;}\n}b[N<<1],a[N<<1],c[N<<1];\nil void upd(int x,int v){for(;x<=limy;x+=x&-x)cmax(s[x],v);}\nil int ask(int x){int res=0;for(;x;x-=x&-x)cmax(res,s[x]);return res;}\nil void clr(int x){for(;x<=limy;x+=x&-x)if(s[x])s[x]=0;else break;}\nvoid cdq(int l,int r){\n    if(l>=r)return;\n    int m=(l+r)>>1,j=l;\n    cdq(l,m);cdq(m+1,r);\n    for(int i=m+1;i<=r;++i)if(!a[i].typ){\n        for(;j<=m&&a[j].x<=a[i].x;++j)if(a[j].typ)\n            upd(a[j].y,a[j].x+a[j].y);\n        int res=ask(a[i].y);\n        if(res)cmin(ans[a[i].id],a[i].x+a[i].y-res);\n    }\n    for(int i=l;i<j;++i)if(a[i].typ)clr(a[i].y);\n    merge(a+l,a+m+1,a+m+1,a+r+1,c+l);\n    for(int i=l;i<=r;++i)a[i]=c[i];\n}\nil void del(){\n    int rx=0,ry=0;nn=0;\n    for(int i=1;i<=n;++i)if(!a[i].typ)\n        cmax(rx,a[i].x),cmax(ry,a[i].y);\n    for(int i=1;i<=n;++i)\n        if(a[i].x<=rx&&a[i].y<=ry)c[++nn]=a[i];\n    for(int i=1;i<=nn;++i)a[i]=c[i];\n}\nint main(){\n    in(n,q);\n    int x,y,typ;\n    for(int i=1;i<=n;++i)\n        in(x,y),++x,++y,b[i]=node{x,y,1,0,0},\n        cmax(limx,x),cmax(limy,y);\n    while(q--){\n        in(typ,x,y);++x,++y;\n        b[++n]=node{x,y,typ&1,cnt+=typ-1,0};\n        cmax(limx,x),cmax(limy,y);\n    }\n    for(int i=1;i<=n;++i)a[i]=b[i];\n    memset(ans,126,sizeof ans);\n    ++limx,++limy;\n    del(),cdq(1,nn);\n    \n    for(int i=1;i<=n;++i)a[i]=b[i],a[i].x=limx-a[i].x;\n    del(),cdq(1,nn);\n\n    for(int i=1;i<=n;++i)a[i]=b[i],a[i].y=limy-a[i].y;\n    del(),cdq(1,nn);\n\n    for(int i=1;i<=n;++i)a[i]=b[i],a[i].x=limx-a[i].x,a[i].y=limy-a[i].y;\n    del(),cdq(1,nn);\n\n    for(int i=1;i<=cnt;++i)out(ans[i]),pt('\\n');\n    flush();\n}\n```\n","link":null,"tags":["离线","cdq分治","数据结构","kdt"],"title":"LG 4169 [Violet]天使玩偶"},{"categories":[["note"]],"content":"\n\n使用fread加速\n\n## 仅数字:\n\n```cpp\nnamespace IN{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;inline char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}template<typename T>inline void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>inline void in(T &x,arr & ... y){in(x),in(y...);}}using namespace IN;\nnamespace OUT{const char ln='\\n';const int str=1<<20;static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;inline void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}inline void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}inline void out(char c){pt(c);}template<typename T>inline void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>inline void out(T x,arr & ... y){out(x),out(y...);}}using namespace OUT;\n```\n\n## 全部:\n\n```cpp\nnamespace IN{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;inline char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}inline void in(string &ch){ch.clear();if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}inline void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}inline void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>inline void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>inline void in(T &x,arr & ... y){in(x),in(y...);}}using namespace IN;\nnamespace OUT{const char ln='\\n';const int str=1<<20;static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;inline void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}inline void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}inline void out(const char* s){while(*s)pt(*s++);}inline void out(char* s){while(*s)pt(*s++);}inline void out(char c){pt(c);}inline void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>inline void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>inline void out(T x,arr & ... y){out(x),out(y...);}}using namespace OUT;\n```\n\n```cpp\n#include<bits\/stdc++.h>\nusing namespace std;\nnamespace IN{\n    const int str=1<<20;\n    static char in_buf[str],*in_s,*in_t;\n    bool __=0;\n    inline char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}\n    inline void in(string &ch){\n        ch.clear();\n        if(__)return;\n        char c;\n        while((c=gc())!=EOF&&isspace(c));\n        if(c==EOF){__=1;return;}\n        ch+=c;\n        while((c=gc())!=EOF&&!isspace(c))ch+=c;\n        if(c==EOF)__=1;\n    }\n    inline void in(char &ch){\n        if(__)return;\n        char c;\n        while((c=gc())!=EOF&&isspace(c));\n        if(c==EOF)__=1;\n        else ch=c;\n    }\n    inline void in(char *ch){\n        *ch='\\0';\n        if(__)return;\n        char c;\n        while((c=gc())!=EOF&&isspace(c));\n        if(c==EOF){__=1;return;}\n        *ch=c;ch++;\n        while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;\n        if(c==EOF)__=1;\n        *ch='\\0';\n    }\n    template<typename T>\n    inline void in(T &x){\n        if(__)return;\n        char c=gc();\n        bool f=0;\n        while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();\n        if(c==EOF){__=1;return;}\n        x=0;\n        while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();\n        if(c==EOF)__=1;\n        if(f)x=-x;\n    }\n    template<typename T,typename ... arr>\n    inline void in(T &x,arr & ... y){in(x),in(y...);}\n}using namespace IN;\nnamespace OUT{\n    const char ln='\\n';\n    const int str=1<<20;\n    static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;\n    inline void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}\n    inline void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}\n    inline void out(const char* s){while(*s)pt(*s++);}\n    inline void out(char* s){while(*s)pt(*s++);}\n    inline void out(char c){pt(c);}\n    inline void out(string s){for(int i=0;s[i];i++)pt(s[i]);}\n    template<typename T>\n    inline void out(T x){\n        if(!x){pt('0');return;}\n        if(x<0)pt('-'),x=-x;\n        char a[50],t=0;\n        while(x)a[t++]=x%10,x\/= 10;\n        while(t--)pt(a[t]+'0');\n    }\n    template<typename T,typename ... arr>\n    inline void out(T x,arr & ... y){out(x),out(y...);}\n}using namespace OUT;\nchar ch[1000000];\nint main(){\n    int n;\n    in(n);\n    for(int i=1;i<=n;++i)in(ch),out(ch,ln);\n    for(int i=1;i<=n;++i)in(ch),out(int(strlen(ch)),ln);\n    in(ch);\n    out(int(strlen(ch)),ln);\n    flush();\n}\n```","link":null,"tags":[],"title":"快速读入输出"},{"categories":[["刷题记录"]],"content":"\n```cpp\n#include<bits\/stdc++.h>\ntypedef long long ll;typedef double db;typedef unsigned long long ull;\ntemplate <class T>inline T min(T x,T y){return x<y?x:y;}\ntemplate <class T>inline T max(T x,T y){return x>y?x:y;}\nnamespace IN{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;inline char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}template<typename T>inline void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>inline void in(T &x,arr & ... y){in(x),in(y...);}}using namespace IN;\nnamespace OUT{const char ln='\\n';const int str=1<<20;static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;inline void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}inline void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}template<typename T>inline void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>inline void out(T x,arr & ... y){out(x),out(y...);}}using namespace OUT;\nconst int N=100011,inf=2122219134;\nusing std::sort;\nint d,n,k,s[N<<1],ans[N];\nstruct node{int x,y,z,ans,w;}b[N],a[N];\nbool cmpx(node x,node y){\n    if(x.x!=y.x)return x.x<y.x;\n    if(x.y!=y.y)return x.y<y.y;\n    return x.z<y.z;\n}\nbool cmpy(node x,node y){\n    if(x.y!=y.y)return x.y<y.y;\n    return x.z<y.z;\n}\ninline void add(int x,int v){for(int i=x;i<=k;i+=i&-i)s[i]+=v;}\ninline int ask(int x){\n    int res=0;\n    for(int i=x;i;i-=i&-i)res+=s[i];\n    return res;\n}\ninline void cdq(int l,int r){\n    if(l>=r)return;\n    int m=(l+r)>>1,j=l;\n    cdq(l,m);cdq(m+1,r);\n    sort(a+l,a+m+1,cmpy);\n    sort(a+m+1,a+r+1,cmpy);\n    for(int i=m+1;i<=r;++i){\n        for(;j<=m&&a[j].y<=a[i].y;++j)\n            add(a[j].z,a[j].w);\n        a[i].ans+=ask(a[i].z);\n    }\n    for(int i=l;i<=j-1;++i)add(a[i].z,-a[i].w);\n}\nint main(){\n    in(d,k);\n    for(int i=1;i<=d;++i)in(b[i].x,b[i].y,b[i].z);\n    sort(b+1,b+d+1,cmpx);\n    for(int i=1,c=1;i<=d;++i,++c)\n    if(b[i].x!=b[i+1].x||b[i].y!=b[i+1].y||b[i].z!=b[i+1].z)\n        a[++n]=b[i],a[n].w=c,c=0;\n    cdq(1,n);\n    for(int i=1;i<=n;++i)ans[a[i].ans+a[i].w]+=a[i].w;\n    for(int i=1;i<=d;++i)out(ans[i]),pt('\\n');\n    flush();\n}\n```\n","link":null,"tags":["cdq分治","数据结构"],"title":"LG 3810 【模板】三维偏序（陌上花开）"},{"categories":[["算法","离线"],["note"]],"content":"\n\n## 二维偏序\n\n先按 第一维 排序, 第二维 用数据结构维护\n\n例题: [\\[SHOI2007\\]园丁的烦恼](https:\/\/www.luogu.com.cn\/problem\/P2163)\n\n离线操作\n\n先将每个询问拆成4个点查询\n\n设$(1,1)$到$(x,y)$中点数为$s(x,y)$.\n\n那么答案就为$s(c,d)-s(a-1,d)-s(c,b-1)+s(a-1,b-1)$\n\n先将 点和询问 按$x$轴排序,点按顺序插入\n\n$y$轴用树状数组维护,查询即可\n\n```cpp\n#include<bits\/stdc++.h>\nnamespace FastIO{const char* ln=\"\\n\";struct Reader{char buf[1<<20],*s,*t;bool EOF_FLG;Reader():s(buf),t(buf),EOF_FLG(false) {};char gt() {return s==t&&((t=(s=buf)+fread(buf,1,1<<20,stdin))==s)?EOF:(*s++);}Reader& operator>>(char* str) {if(EOF_FLG)return *str=0,*this;while((*str=gt())!=' '&&*str!='\\n'&&*str!=EOF)++str;if(*str==EOF)EOF_FLG=true;*str=0;return *this;}template<typename T>Reader&operator>>(T&x) {if(EOF_FLG)return *this;char c=0,d;while(c!=EOF&&(c<'0'||c>'9'))d=c,c=gt();if(c==EOF){EOF_FLG=true;return *this;}else x=0;while(c>='0'&&c<='9')x=(x<<3)+(x<<1)+c-'0',c=gt();if(d=='-')x=-x;return *this;}}in;struct Writer{char buf[1<<20],*s,*t;Writer():s(buf),t(buf+(1<<20)){}~Writer(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,1<<20,stdout),*s++=c):(*s++=c);}template<typename T>Writer&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[40],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}Writer&operator<<(const char*s) {while(*s)pt(*s++);return *this;}}out;}using namespace FastIO;\n#define Fur(i,x,y) for(int i=x;i<=y;i++)\nusing namespace std;\n#define N 500000\nint n,q;\nstruct node{\n    int x,y,id,opt;\n}a[N+1],b[N*4+1];\nint tr[N+1],ans[N+1];\nvoid add(int x){while(x<=N)tr[x]++,x+=(x&-x);};\nint get(int x){int s=0;while(x)s+=tr[x],x-=(x&-x);return s;}\nbool cmp(node x,node y){\n    if(x.x!=y.x)return x.x<y.x;\n    return x.y<y.y;\n}\nint main(){\n    in>>n>>q;\n    int d=0,x,y,xx,yy;\n    Fur(i,1,n)in>>x>>y,a[i].x=x+1,a[i].y=y+1;\n    sort(a+1,a+n+1,cmp);\n    Fur(i,1,q){\n        in>>x>>y>>xx>>yy;\n        x++;y++;xx++;yy++;\n        b[++d].x=x-1,b[d].y=y-1,b[d].opt=1,b[d].id=i;\n        b[++d].x=x-1,b[d].y=yy,b[d].opt=-1,b[d].id=i;\n        b[++d].x=xx,b[d].y=y-1,b[d].opt=-1,b[d].id=i;\n        b[++d].x=xx,b[d].y=yy,b[d].opt=1,b[d].id=i;\n    }\n    sort(b+1,b+d+1,cmp);\n    int j=1;\n    Fur(i,1,d){\n        while(j<=n&&a[j].x<=b[i].x)add(a[j].y),j++;\n        ans[b[i].id]+=get(b[i].y)*b[i].opt;\n    }\n    Fur(i,1,q)out<<ans[i]<<ln;\n}\n```\n\n## 三维偏序\n\n如果按第一维排序,第二、三维用高级数据结构维护,有点麻烦,而且空间时间复杂度高\n\n在允许离线的条件下,**cdq分治**为上等选择\n\ncdq分治有点类似 归并排序求逆序对 的思路\n\n还是全部先按第一维排序\n\n接着把数列拆成相等的两半\n\n分别按第二维排序\n\n处理出 前半部分 对 后半部分 的影响(结果)\n\n这样第一维和第二维都确定的,有顺序的,我们只需要考虑第三维\n\n还是用 简单的数据结构维护就可以了(如 树状数组 、 线段树)\n\n例题: [LG 3810 【模板】三维偏序（陌上花开）](https:\/\/www.luogu.com.cn\/problem\/P3810)\n\n```cpp\n#include<bits\/stdc++.h>\ntypedef long long ll;typedef double db;typedef unsigned long long ull;\nnamespace IN{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;inline char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}template<typename T>inline void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>inline void in(T &x,arr & ... y){in(x),in(y...);}}using namespace IN;\nnamespace OUT{const char ln='\\n';const int str=1<<20;static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;inline void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}inline void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}template<typename T>inline void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>inline void out(T x,arr & ... y){out(x),out(y...);}}using namespace OUT;\nconst int N=100011;\nusing std::sort;\nint d,n,k,s[N<<1],ans[N];\nstruct node{int x,y,z,ans,w;}b[N],a[N];\nbool cmpx(node x,node y){\n    if(x.x!=y.x)return x.x<y.x;\n    if(x.y!=y.y)return x.y<y.y;\n    return x.z<y.z;\n}\nbool cmpy(node x,node y){\n    if(x.y!=y.y)return x.y<y.y;\n    return x.z<y.z;\n}\ninline void add(int x,int v){\n    for(int i=x;i<=k;i+=i&-i)\n        s[i]+=v;\n}\ninline int ask(int x){\n    int res=0;\n    for(int i=x;i;i-=i&-i)\n        res+=s[i];\n    return res;\n}\ninline void cdq(int l,int r){\n    if(l>=r)return;\n    int m=(l+r)>>1,j=l;\n    cdq(l,m);cdq(m+1,r);\n    sort(a+l,a+m+1,cmpy);\n    sort(a+m+1,a+r+1,cmpy);\n    for(int i=m+1;i<=r;++i){\n        for(;j<=m&&a[j].y<=a[i].y;++j)\n            add(a[j].z,a[j].w);\n        a[i].ans+=ask(a[i].z);\n    }\n    for(int i=l;i<=j-1;++i)\n        add(a[i].z,-a[i].w);\n}\nint main(){\n    in(d,k);\n    for(int i=1;i<=d;++i)\n        in(b[i].x,b[i].y,b[i].z);\n    sort(b+1,b+d+1,cmpx);\n    for(int i=1,c=1;i<=d;++i,++c)\n    if(b[i].x!=b[i+1].x||b[i].y!=b[i+1].y||b[i].z!=b[i+1].z)\n        a[++n]=b[i],a[n].w=c,c=0;\n    cdq(1,n);\n    for(int i=1;i<=n;++i)\n        ans[a[i].ans+a[i].w]+=a[i].w;\n    for(int i=1;i<=d;++i)\n        out(ans[i]),pt('\\n');\n    flush();\n}\n```\n\n[LG 3157 \\[CQOI2011\\]动态逆序对](https:\/\/www.luogu.com.cn\/problem\/P3157)\n\n将问题转化为三维偏序\n\n我们先找出对答案有贡献的点$(i,j)$满足的条件：\n\n$time_i<time_j$\n\n$val_i<val_j,pos_i>pos_j$或$val_i>val_j,pos_i<pos_j$\n\n```cpp\n#include<bits\/stdc++.h>\nnamespace IN{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;inline char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}template<typename T>inline void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>inline void in(T &x,arr & ... y){in(x),in(y...);}}using namespace IN;\nnamespace OUT{const char ln='\\n';const int str=1<<20;static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;inline void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}inline void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}inline void out(char c){pt(c);}template<typename T>inline void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>inline void out(T x,arr & ... y){out(x),out(y...);}}using namespace OUT;\nconst int N=100011,inf=2122219134;\nint n,q,s[N],pos[N];\nlong long ans[50011];\nvoid add(int x,int v){for(;x<=n;x+=x&-x)s[x]+=v;}\nint ask(int x){int res=0;for(;x;x-=x&-x)res+=s[x];return res;}\nstruct node{\n    int v,w,p,id;\n    bool operator<(node t){return p<t.p;}\n}b[N+50000],c[N+50000];\nvoid cdq(int l,int r){\n    if(l>=r)return;\n    int m=(l+r)>>1,j=l;\n    cdq(l,m);cdq(m+1,r);\n    for(int i=m+1;i<=r;++i){\n        for(;j<=m&&b[j].p<=b[i].p;++j)add(b[j].v,b[j].w);\n        ans[b[i].id]+=b[i].w*(ask(n)-ask(b[i].v));\/\/ 统计在i之前的与i组成的逆序对个数\n    }\n    for(int i=l;i<j;++i)add(b[i].v,-b[i].w);\n    j=m;\n    for(int i=r;i>m;--i){\n        for(;j>=l&&b[j].p>=b[i].p;--j)add(b[j].v,b[j].w);\n        ans[b[i].id]+=b[i].w*ask(b[i].v-1);\/\/ 统计在i之后的与i组成的逆序对个数\n    }\n    for(int i=m;i>j;--i)add(b[i].v,-b[i].w);\n    std::merge(b+l,b+m+1,b+m+1,b+r+1,c+l);\/\/使用merge合并比排序更快(归并排序)\n    for(int i=l;i<=r;++i)b[i]=c[i];\n}\nint main(){\n    in(n,q);\n    int x;\n    for(int i=1;i<=n;++i)in(x),b[i]=node{x,1,pos[x]=i,0};\n    for(int i=1;i<q;++i)in(x),b[n+i]=node{x,-1,pos[x],i};\n    cdq(1,n+q-1);\n    for(int i=1;i<q;++i)ans[i]+=ans[i-1];\n    for(int i=0;i<q;++i)out(ans[i],ln);\n    flush();\n}\n```","link":null,"tags":["算法","分治","数据结构","离线"],"title":"cdq分治"},{"categories":[["刷题记录"]],"content":"\n$$\n\\prod_{i=1}^n\\prod_{j=1}^n\\frac{lcm(i,j)}{\\gcd(i,j)}\n\\\\\n=\\prod_{i=1}^n\\prod_{j=1}^n\\frac{ij}{\\gcd(i,j)^2}\n\\\\\n=\\prod_{i=1}^n\\prod_{j=1}^n ij \\prod_{d=1}^n {\\frac 1{d^2}}^{\\sum_{i=1}^n\\sum_{j=1}^n [\\gcd(i,j)=d]}\n\\\\\n=(n!)^{2n} \\left (\\prod_{d=1}^n d^{\\sum_{i=1}^n\\sum_{j=1}^n [\\gcd(i,j)=d]} \\right )^{-2}\n$$\n\n其中:\n\n$$\n\\prod_{d=1}^n d^{\\sum_{i=1}^n\\sum_{j=1}^n [\\gcd(i,j)=d]}\n\\\\\n=\\prod_{d=1}^n d^{\\sum_{i=1}^{\\left \\lfloor \\frac nd \\right \\rfloor}\\sum_{j=1}^{\\left \\lfloor \\frac nd \\right \\rfloor} [\\gcd(i,j)=1]}\n\\\\\n=\\prod_{d=1}^n d^{-1+2\\sum_{i=1}^{\\left \\lfloor \\frac nd \\right \\rfloor} \\varphi(i)}\n$$\n\n因为$mod=104857601$是质数,使用可以用欧拉定理\n\n```cpp\n#include<cstdio>\nconst int N=1000001,P=104857601;\nint n,cnt=0,pri[78499],phi[N];\nbool b[N];\ninline int pw(int x,int b){\n    int ans=1;\n    while(b){\n        if(b&1)ans=1ll*ans*x%P;\n        b>>=1;x=1ll*x*x%P;\n    }\n    return ans;\n}\nint main(){\n    scanf(\"%d\",&n);\n    phi[1]=1;\n    for(int i=2;i<=n;++i){\n        if(!b[i])pri[++cnt]=i,phi[i]=i-1;\n        for(int j=1,x;j<=cnt&&(x=i*pri[j])<=n;++j){\n            b[x]=1;\n            if(i%pri[j])phi[x]=phi[i]*(pri[j]-1);\n            else{phi[x]=phi[i]*pri[j];break;}\n        }\n    }\n    for(int i=1;i<=n;++i)phi[i]<<=1,(phi[i]+=phi[i-1])%=(P-1);\n    int ans=1,ANS=1,pre=1;\n    for(int l=1,r,i;l<=n;l=r+1){\n        i=n\/l,r=n\/i;\n        pre=ans;for(int j=l;j<=r;++j)ans=1ll*ans*j%P;\n        ANS=1ll*ANS*pw(1ll*ans*pw(pre,P-2)%P,phi[i]-1)%P;\n    }\n    printf(\"%d\\n\",1ll*pw(ans,n<<1)*pw(1ll*ANS*ANS%P,P-2)%P);\n}\n```\n","link":null,"tags":["数论","欧拉函数","数论分块"],"title":"LG 5221 Product"},{"categories":[["刷题记录"]],"content":"\n~~带 套 路 题~~\n\n$$\n\\sum_{i=1}^n\\sum_{j=1}^n(i+j)^k\\mu^2(\\gcd(i,j))\\gcd(i,j)\n\\\\\n=\\sum_{d=1}^n \\mu^2(d) d \\sum_{i=1}^n\\sum_{j=1}^n(i+j)^k[\\gcd(i,j)=d]\n\\\\\n=\\sum_{d=1}^n \\mu^2(d) d^{k+1} \\sum_{i=1}^{\\left \\lfloor \\frac nd \\right \\rfloor}\\sum_{j=1}^{\\left \\lfloor \\frac nd \\right \\rfloor}(i+j)^k[\\gcd(i,j)=1]\n$$\n\n令$S(n)=\\sum_{i=1}^n\\sum_{j=1}^n(i+j)^k$\n\n$$\n=\\sum_{d=1}^n \\mu^2(d) d^{k+1} \\sum_{i=1}^{\\left \\lfloor \\frac nd \\right \\rfloor}\\sum_{j=1}^{\\left \\lfloor \\frac nd \\right \\rfloor}(i+j)^k \\sum_{x|i,x|j} \\mu(x)\n\\\\\n=\\sum_{d=1}^n \\sum_{x=1}^{\\left \\lfloor \\frac nd \\right \\rfloor}\\mu^2(d) d^{k+1} \\mu(x) x^k S(\\left \\lfloor \\frac n{dx} \\right \\rfloor)\n$$\n\n令$T=dx$\n\n$$\n=\\sum_{T=1}^n \\sum_{d|T} \\mu^2(d) d^{k+1} \\mu(\\frac Td) (\\frac Td)^k S(\\left \\lfloor \\frac nT \\right \\rfloor)\n\\\\\n=\\sum_{T=1}^n S(\\left \\lfloor \\frac nT \\right \\rfloor) T^k \\sum_{d|T} d \\mu^2(d)\\mu(\\frac Td)\n$$\n\n如何快速求令$S(n)$?\n\n设:\n\n$$F(n)=\\sum_{i=1}^n i^k$$\n\n$$G(n)=\\sum_{i=1}^n F(i)$$\n\n那么\n\n$$\nS(n)=\\sum_{i=n+1}^{2n}F(i)-\\sum_{i=1}^nF(i)\n\\\\\n=G(2n)-2G(n)\n$$\n\n筛出$F$的前缀和,然后筛$S(n)$\n\n优化:\n\n> 因为模数是质数,根据欧拉定理: 对于互质的$a,n$满足$a^{\\varphi(n)} \\equiv 1\\pmod n$\n>\n> 可以$k=k \\mod 998244352$\n\n求后半部分\n\n$$f(n)=\\sum_{d|n} d \\mu^2(d)\\mu(\\frac nd)$$\n\n如何线性求$f(n)$?\n\n$f(n)$是若干个积性函数的卷积,所以$f(n)$也是积性函数\n\n那么$f(n)=f(p^k)f(\\frac n{p^k})$\n\n$f(1)=1$\n\n$f(p^1)=p-1$(带入即可得到)\n\n$f(p^2)=-p$(带入即可得到)\n\n$f(p^k)=0(k\\ge 3)$\n\n> $d$和$\\frac nd$中必然有一个有平方因子,所以$\\mu(d)$和$\\mu(\\frac nd)$必有一项为$0$\n> \n> 所以$f(p^k)=0(k\\ge 3)$\n\n接下来就可以线性筛$f(n)$了\n\n```cpp\n#include<cstdio>\n#define il inline\n#define rg register\nconst int N=5000011,P=998244353;\nint n,k,cnt=0,pri[5348514],F[N<<1],f[N];\nbool b[N<<1];\nil int pw(int x){\n    int ans=1,b=k;\n    while(b){\n        if(b&1)ans=1ll*ans*x%P;\n        b>>=1;x=1ll*x*x%P;\n    }\n    return ans;\n}\nil int M(int x){return x>=P?x-P:x;}\nil int S(int n){return M(F[n<<1]-M(F[n]<<1)+P);}\nint main(){\n    long long _;\n    scanf(\"%d%lld\",&n,&_);k=_%(P-1);\n    f[1]=F[1]=1;\n    for(rg int i=2;i<=n;++i){\n        if(!b[i])\n            pri[++cnt]=i,\n            f[i]=i-1,\n            F[i]=pw(i);\n        for(rg int j=1,x;j<=cnt&&(x=i*pri[j])<=n;++j){\n            b[x]=1;\n            F[x]=1ll*F[i]*F[pri[j]]%P;\n            if(i%pri[j])f[x]=1ll*f[i]*f[pri[j]]%P;\n            else{\n                int t=i\/pri[j];\n                if(t%pri[j])f[x]=1ll*(P-pri[j])*f[t]%P;\n                break;\n            }\n        }\n    }\n    for(rg int i=2;i<=n;++i)f[i]=M(f[i-1]+1ll*F[i]*f[i]%P);\n    for(rg int i=n+1;i<=(n<<1);++i){\n        if(!b[i])pri[++cnt]=i,F[i]=pw(i);\n        for(rg int j=1,x;j<=cnt&&(x=i*pri[j])<=n;++j){\n            b[x]=1;\n            F[x]=1ll*F[i]*F[pri[j]]%P;\n            if(!(i%pri[j]))break;\n        }\n    }\n    for(rg int i=2;i<=(n<<1);++i)F[i]=M(F[i]+F[i-1]);\n    for(rg int i=2;i<=(n<<1);++i)F[i]=M(F[i]+F[i-1]);\n    int res=0;\n    for(rg int l=1,r,i;l<=n;l=r+1){\n        i=n\/l,r=n\/i;\n        res=M(res+1ll*M(f[r]-f[l-1]+P)*S(i)%P);\n    }\n    printf(\"%d\\n\",res);\n}\n```\n","link":null,"tags":["数论","莫比乌斯","数论分块","前缀和"],"title":"LG 6156 简单题"},{"categories":[["刷题记录"]],"content":"\n经过一番化简后变成了:\n\n$$\n\\sum_{i=1}^{\\sqrt{2n}} \\sum_{x=L}^{R} [\\gcd(i,x)=1]  \n\\\\\nL=Max(1,i-\\lfloor {n\\over i}\\rfloor)\n\\\\\nR=Min(i-1,\\lfloor {n\\over i }\\rfloor)\n$$\n\n莫比乌斯反演\n\n$$\n\\sum_{i=1}^{\\sqrt{2n}} \\sum_{j=l}^{R} [\\gcd(i,j)=1]\n\\\\\n=\\sum_{i=1}^{\\sqrt{2n}} \\sum_{j=l}^{R} \\sum_{k|i,k|j} \\mu(k)\n\\\\\n=\\sum_{i=1}^{\\sqrt{2n}}\\sum_{k|j,k\\in[L,R]} \\mu(k)\n$$\n\n```cpp\n#include<bits\/stdc++.h>\ntypedef long long ll;\nconst int N=1500011;\ninline int min(int x,int y){return x<y?x:y;}\ninline int max(int x,int y){return x>y?x:y;}\ninline int abs(int x){return x>0?x:-x;}\nll n;\nint m,mu[N],pri[N],cnt=0,head[N];\nbool b[N];\nstruct edge{int to,nxt;}e[N<<4];\ninline void add(int x,int y){e[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;}\ninline ll calc(int x,int k){\n    ll res=0;\n    for(int i=head[x];i&&abs(e[i].to)<=k;i=e[i].nxt)\n        res+=k\/e[i].to;\n    return res;\n}\nint main(){\n    scanf(\"%lld\",&n);\n    m=sqrt((n<<1));\n    mu[1]=1;\n    for(int i=2;i<=m;++i){\n        if(!b[i])pri[++cnt]=i,mu[i]=-1;\n        for(int j=1;j<=cnt&&i*pri[j]<=m;++j){\n            b[i*pri[j]]=1;\n            if(i%pri[j])mu[i*pri[j]]=-mu[i];\n            else break;\n        }\n    }\n    cnt=0;\n    for(int i=1;i<=m;++i)\n        for(int j=1;i*j<=m;++j)\n        if(mu[j])add(i*j,mu[j]*j);\n    ll ans=0;\n    for(int i=1;i<=m;++i)\n        ans+=calc(i,min(i-1,n\/i))-calc(i,max(1,i-(n\/i))-1);\n    printf(\"%lld\\n\",ans);\n}\n```\n","link":null,"tags":["数论","莫比乌斯"],"title":"LG 4844 LJJ爱数数"},{"categories":[["刷题记录"]],"content":"\n$$\n\\sum_{i=1}^A\\sum_{j=1}^B [\\gcd(i,j)=d]\n\\\\\n=\\sum_{i=1}^{\\left \\lfloor \\frac Ad \\right \\rfloor}\\sum_{j=1}^{\\left \\lfloor \\frac Bd\\right \\rfloor} [\\gcd(i,j)=1]\n\\\\\n=\\sum_{i=1}^{\\left \\lfloor \\frac Ad \\right \\rfloor}\\sum_{j=1}^{\\left \\lfloor \\frac Bd\\right \\rfloor} \\sum_{x|i,x|j}\\mu(x)\n\\\\\n=\\sum_{x=1}^n\\mu(x) \\left \\lfloor \\frac A{dx} \\right \\rfloor \\left \\lfloor \\frac B{dx}\\right \\rfloor\n$$\n```cpp\n#include<bits\/stdc++.h>\nconst int N=1000011;\nint n,m,d,mu[N],pri[N],cnt=0;\nbool b[N];\ninline int min(int x,int y){return x<y?x:y;}\nint main(){\n    scanf(\"%d%d%d\",&n,&m,&d);\n    n\/=d;m\/=d;\n    if(n>m)n^=m,m^=n,n^=m;\n    mu[1]=1;\n    for(int i=2;i<=n;++i){\n        if(!b[i])pri[++cnt]=i,mu[i]=-1;\n        for(int j=1;j<=cnt&&i*pri[j]<=n;++j){\n            b[i*pri[j]]=1;\n            if(i%pri[j])mu[i*pri[j]]=-mu[i];\n            else break;\n        }\n    }\n    for(int i=2;i<=n;++i)mu[i]+=mu[i-1];\n    long long res=0;\n    for(int l=1,r,i,j;l<=n;l=r+1){\n        i=n\/l,j=m\/l;\n        r=min(n\/i,m\/j);\n        res+=1ll*(mu[r]-mu[l-1])*i*j;\n    }\n    printf(\"%lld\\n\",res);\n}\n```\n","link":null,"tags":["数论","莫比乌斯","数论分块"],"title":"LG 4450 双亲数"},{"categories":[["刷题记录"]],"content":"\n若$x$分解质因数结果为$x=p_1^{k_1}p_2^{k_2}\\cdots p_n^{k_n}$\n\n令$f(x)=(k_1+1)(k_2+1)\\cdots (k_n+1)$\n\n$f(x)$其实就是$d(x)$,$x$的约数个数\n\n> $p_1^{k_1}$的约数有$1,p_1,p_1^2,\\cdots,p_1^{k_1}$\n> \n> $p_2^{k_2}$的约数有$1,p_2,p_2^2,\\cdots,p_2^{k_2}$\n> \n> $\\cdots$\n> \n> $p_n^{k_n}$的约数有$1,p_n,p_n^2,\\cdots,p_n^{k_n}$\n> \n> 根据乘法原理,$d(x)=(k_1+1)(k_2+1)\\cdots (k_n+1)$\n\n首先可以想到的是\n\n$$\n\\sum_{i=l}^r f(i)=\\sum_{i=1}^r f(i) - \\sum_{i=1}^{l-1} f(i)\n$$\n\n那么\n\n$$\n\\sum_{i=1}^n f(i)\n\\\\\n=\\sum_{i=1}^n \\sum_{j|i}1\n$$\n\n换个枚举顺序\n\n$$\n=\\sum_{j=1}^n \\sum_{j|i}1\n\\\\\n=\\sum_{j=1}^n \\left \\lfloor \\frac nj\\right \\rfloor\n$$\n\n最后数论分块就可以了\n\n```cpp\n#include<cstdio>\nconst int P=998244353;\ntypedef long long ll;\nint calc(ll n){\n    int res=0;\n    for(ll l=1,r,i;l<=n;l=r+1){\n        i=n\/l;r=n\/i;\n        (res+=(r-l+1)*i%P)%=P;\n    }\n    return res;\n}\nint main(){\n    ll l,r;scanf(\"%lld%lld\",&l,&r);\n    printf(\"%d\\n\",(calc(r)-calc(l-1)+P)%P);\n}\n```\n","link":null,"tags":["数论","数论分块"],"title":"LG 3935 Calculating"},{"categories":[["刷题记录"]],"content":"\n首先$L=\\left \\lceil \\frac LK\\right \\rceil,H=\\left \\lceil \\frac HK\\right \\rceil$\n\n问题转化为在$[L,H]$中取 $N$个$\\gcd=1$的数 的方案数\n\n设$f_i$为选出 $N$个不完全相同$\\gcd=i$的数 的方案数\n\n令$x$为$[L,R]$中$i$的倍数的个数,$x=\\sum_{j=L}^H [i|j]=\\left \\lfloor \\frac Hi \\right \\rfloor-\\left \\lfloor \\frac Li \\right \\rfloor$\n\n暂时令$f_i=x^N-x$(所有减去完全相同的)\n\n这时候$f_i$实际上是选出 $N$个不完全相同$i|\\gcd$的数 的方案数\n\n假设我们已经知道了$f_{2i},f_{3i},...$的最终结果\n\n那么把$f_i$减去$f_{2i},f_{3i},...$就可以了\n\n```cpp\n#include<cstdio>\nconst int N=100011,P=1000000007;\nint n,K,L,H,f[N];\ninline int pw(int x,int b){\n    int ans=1;\n    while(b){\n        if(b&1)ans=1ll*ans*x%P;\n        b>>=1;x=1ll*x*x%P;\n    }\n    return ans;\n}\nint main() {\n    scanf(\"%d%d%d%d\",&n,&K,&L,&H);\n    L=L\/K+(L%K!=0);\n    H\/=K;\n    if(L>H)return puts(\"0\"),0;\n    for(int i=1;i<=H-L;++i) {\n        int l=L,r=H;\n        l=l\/i+(l%i!=0);\n        r\/=i;\n        if(l<=r)f[i]=(pw(r-l+1,n)-(r-l+1)+P)%P;\n    }\n    for(int i=H-L;i;--i)\n        for(int j=i<<1;j<=H-L;j+=i)\n            f[i]=(f[i]-f[j]+P)%P;\n    if(L==1)(f[1]+=1)%=P;\n    printf(\"%d\\n\",f[1]);\n}\n```\n","link":null,"tags":["数论","莫比乌斯","容斥","递推"],"title":"LG 3172 [CQOI2015]选数"},{"categories":[["刷题记录"]],"content":"\n$\\sum_{i=1}^n\\sum_{j=1}^n lcm(A_i,A_j)$\n\n设$a_i = \\sum_{j=1}^n [A_j=i]$\n\n那么\n\n$$\nans = \\sum_i^n \\sum_j^n a_ia_j \\frac{ij}{\\gcd(i,j)}\n\\\\\n= \\sum_{d=1}^n \\frac 1d \\sum_{i=1}^n \\sum_{j=1}^n a_ia_j ij[\\gcd(i,j)=d]\n\\\\ \n= \\sum_{d=1}^n \\sum_{i=1}^{\\frac nd} \\sum_{j=1}^{\\frac nd}d \\times a_{id}a_{jd}ij[\\gcd(i,j)=1]\n\\\\\n\\text{唉,到这里我就不会了}\n\\\\\n=\\sum_{p=1}^np\\sum_{i=1}^{n\/p}\\sum_{j=1}^{n\/p}a_{ip}a_{jp}ij\\sum_{d|i,d|j}\\mu(d)\n\\\\\n=\\sum_{p=1}^np\\sum_{d=1}^n\\mu(d)d^2\\sum_{i=1}^{n\/dp}\\sum_{j=1}^{n\/dp}a_{idp}a_{jdp}ij\n\\\\\n=\\sum_{q=1}^nq\\sum_{d|q}d\\mu(d)\\sum_{i=1}^{n\/q}\\sum_{j=1}^{n\/q}a_{iq}a_{jq}ij\n\\\\\n=\\sum_{q=1}^nq\\sum_{d|q}d\\mu(d)\\left(\\sum_{i=1}^{n\/q}a_{iq}i\\right)^2\n$$\n\n```cpp\n#include <cstdio>\nusing namespace std;\n\nint prime[50010], mu[50010], tot, fuck = 50000;\nbool vis[50010];\nlong long sum1[50010], sum2[50010];\nint bucket[50010];\n\nint main(){\n    mu[1] = 1;\n    for (int i = 2; i <= fuck; i++){\n        if (vis[i] == false) prime[++tot] = i, mu[i] = -1;\n        for (int j = 1; j <= tot && i * prime[j] <= fuck; j++){\n            vis[i * prime[j]] = true;\n            if (i % prime[j] == 0) break;\n            mu[i * prime[j]] = -mu[i];\n        }\n        mu[i] *= i;\n    }\n    for (int d = 1; d <= fuck; d++)\n        for (int q = d; q <= fuck; q += d)\n            sum1[q] += mu[d];\n    for (int i = 1; i <= fuck; i++)\n        sum1[i] *= i;\n    int n; scanf(\"%d\", &n);\n    for (int x, i = 1; i <= n; i++)\n        scanf(\"%d\", &x), bucket[x]++;\n    long long ans = 0;\n    for (int q = 1; q <= fuck; q++){\n        int sb = fuck \/ q;\n        for (int i = 1; i <= sb; i++)\n            sum2[q] += bucket[i * q] * (long long)i;\n        ans += sum2[q] * sum1[q] * sum2[q];\n    }\n    printf(\"%lld\\n\", ans);\n    return 0;\n}\n```\n","link":null,"tags":["莫比乌斯","数论"],"title":"LG 3911 最小公倍数之和"},{"categories":[["刷题记录"]],"content":"\n前置知识: \n\n1. [杜教筛](http:\/\/blog.zcmimi.top\/posts\/du-jiao-shai\/)(包括[狄利克雷卷积](http:\/\/blog.zcmimi.top\/posts\/di-li-ke-lei-juan-ji\/))\n   \n2. 数论分块\n   \n3. 欧拉函数 或 莫比乌斯函数 \n   \n~~(会杜教筛的大佬上述都会吧)~~\n\n## 欧拉函数卷积推导\n\n$$\\sum_{i=1}^n\\sum_{j=1}^n ijgcd(i,j)$$\n\n根据 $\\sum\\limits_{i|n}\\varphi(n)=n$ ($1 * \\varphi = Id$)\n\n$$= \\sum_{i=1}^n\\sum_{j=1}^n ij \\sum_{k|i,k|j} \\varphi(k)$$\n\n调换枚举顺序\n\n$$\n= \\sum_{k=1}^n \\varphi(k) \\sum_{k|i,k|j} ij\n\\\\\n= \\sum_{k=1}^n \\varphi(k) \\sum_{k|i}i \\sum_{k|j}j\n\\\\\n= \\sum_{k=1}^n \\varphi(k) (\\sum_{i=1}^{\\left \\lfloor\\frac nk\\right\\rfloor}ki)^2\n\\\\\n= \\sum_{k=1}^n \\varphi(k) k^2(\\sum_{i=1}^{\\left \\lfloor\\frac nk\\right\\rfloor}i)^2\n$$\n\n## 莫比乌斯函数推导\n\n$$\n\\sum_{i=1}^n\\sum_{j=1}^n ijgcd(i,j)\n\\\\\n=\\sum_{d=1}^n d \\sum_{i=1}^n\\sum_{j=1}^n ij [gcd(i,j)=d]\n\\\\\n=\\sum_{d=1}^n d^3 \\sum_{i=1}^{\\left \\lfloor\\frac nd\\right\\rfloor}\\sum_{j=1}^{\\left \\lfloor\\frac nd\\right\\rfloor} ij [gcd(i,j)=1]\n\\\\\n=\\sum_{d=1}^n d^3 \\sum_{i=1}^{\\left \\lfloor\\frac nd\\right\\rfloor}\\sum_{j=1}^{\\left \\lfloor\\frac nd\\right\\rfloor} ij \\sum_{k|i,k|j}\\mu(k)\n\\\\\n=\\sum_{d=1}^n d^3 \\sum_{k=1}^{\\left \\lfloor\\frac nd\\right\\rfloor}\\mu(k) \\sum_{k|i,k|j} ij\n\\\\\n=\\sum_{d=1}^n d^3 \\sum_{k=1}^{\\left \\lfloor\\frac nd\\right\\rfloor}\\mu(k) k^2(\\sum_{k|i}i)^2\n$$\n\n为了方便,设$sum(T)=\\sum_{i=1}^T i$\n\n$$\n=\\sum_{d=1}^n d^3 \\sum_{k=1}^{\\left \\lfloor\\frac nd\\right\\rfloor}\\mu(k)k^2sum(\\left \\lfloor \\frac n{dk}\\right \\rfloor)^2\n$$\n\n令$T=dk$\n\n$$\n=\\sum_{T=1}^n sum(\\left \\lfloor \\frac nT\\right \\rfloor)^2 \\sum_{d|T}d^3 \\frac{T^2}{d^2}\\mu(\\frac Td)\n\\\\\n=\\sum_{T=1}^n sum(\\left \\lfloor \\frac nT\\right \\rfloor)^2 T^2\\sum_{d|T}d\\mu(\\frac Td)\n$$\n\n其中: $\\sum_{d|T}d\\mu(\\frac Td)=\\varphi(T)$($\\mu * Id = \\varphi$)\n\n$$\n=\\sum_{T=1}^n sum(\\left \\lfloor \\frac nT\\right \\rfloor)^2 T^2 \\varphi(T)\n$$\n\n~~上述两种方法推导出的最终结果是一样的~~\n\n接下来:\n\n$\\sum_{k=1}^n \\varphi(k)$用杜教筛求出前缀和\n\n$k^2(\\sum_{i=1}^{\\left \\lfloor\\frac nk\\right\\rfloor}i)^2$可以用数论分块求解\n\n```cpp\n#include<bits\/stdc++.h>\ntypedef long long ll;\nconst int N=5000000,P=1000007;\nstruct hash{\n    int cnt=0,head[P];\n    struct edge{int to,nxt,w;}e[P];\n    void add(int x,int y,int w){e[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;e[cnt].w=w;}\n    void ins(int x,int v){add(x%P,x,v);}\n    int ask(int x){for(int i=head[x%P];i;i=e[i].nxt)if(e[i].to==x)return e[i].w;return -1;}\n}S;\nint pri[N+11],phi[N+11],p,inv,lim;\nbool b[N+11];\nint sum(ll n){n%=p;return (1ll*n*(n+1)>>1)%p;}\nint SUM(ll n){n%=p;return 1ll*n*(n+1)%p*(n+n+1)%p*inv%p;}\nil void init(){\n    phi[1]=1;\n    int cnt=0;\n    for(int i=2;i<=lim;++i){\n        if(!b[i])pri[++cnt]=i,phi[i]=i-1;\n        for(int j=1;j<=cnt&&i*pri[j]<=lim;++j){\n            b[i*pri[j]]=1;\n            if(i%pri[j])phi[i*pri[j]]=phi[i]*(pri[j]-1)%p;\n            else{phi[i*pri[j]]=phi[i]*pri[j]%p;break;}\n        }\n    }\n    for(int i=1;i<=lim;++i)phi[i]=(phi[i-1]+1ll*i*i%p*phi[i]%p)%p;\n}\nint PHI(ll n){\n    if(n<=lim)return phi[n];\n    int t=S.ask(n);if(~t)return t;\n    int res=sum(n);res=1ll*res*res%p;\n    for(ll l=2,r;l<=n;l=r+1){\n        r=n\/(n\/l);\n\t\tint s=(SUM(r)-SUM(l-1)+p)%p;\n        res=(res-1ll*PHI(n\/l)*s%p+p)%p;\n    }\n    S.ins(n,res);\n    return res;\n}\nint pw(int x,int b){\n\tint ans=1;\n\twhile(b){\n\t\tif(b&1)ans=1ll*ans*x%p;\n\t\tb>>=1;x=1ll*x*x%p;\n\t}\n\treturn ans;\n}\nint main(){\n\tll n;\n\tscanf(\"%lld%lld\",&p,&n);\n\tinv=pw(6,p-2),lim=pow(n,2.0\/3);\n    init();\n\tint res=0,s,phi;\n    for(ll l=1,r;l<=n;l=r+1){\n\t\tr=n\/(n\/l);\n\t\ts=sum(n\/l),phi=(PHI(r)-PHI(l-1)+p)%p;\n\t\tres=(res+1ll*s*s%p*phi%p)%p;\n\t}\n\tprintf(\"%d\\n\",res);\n}\n```\n\n下方是更加玄学优化的代码\n```cpp\n#include<bits\/stdc++.h>\ntypedef long long ll;\nconst int N=5000000;\nint b[N+11],pri[N+11],phi[N+11],p,inv,lim,s[N],S[N],sqr,ans[N];ll n;\nint id(ll x){return x<=sqr?x:sqr+n\/x;}\nint PHI(ll n){\n\tint x=id(n);\n    if(n<=lim)return phi[n];\n    if(ans[x])return ans[x];\n    int res=s[x];\n    for(register ll l=2,r,i;l<=n;l=r+1)\n        i=n\/l,r=n\/i,\n        res=(res-1ll*PHI(i)*(S[id(r)]-S[id(l-1)]))%p;\n    return ans[x]=res;\n}\nint pw(int x,int b){\n\tint ans=1;\n\twhile(b){\n\t\tif(b&1)ans=1ll*ans*x%p;\n\t\tb>>=1;x=1ll*x*x%p;\n\t}\n\treturn ans;\n}\nint main(){\n\tscanf(\"%d%lld\",&p,&n);\n\tinv=pw(6,p-2),lim=pow(n,2.0\/3);sqr=sqrt(n);\n    phi[1]=1;\n    int cnt=0,x,res=0;\n    for(register int i=2;i<=lim;++i){\n        if(!b[i])b[i]=pri[++cnt]=i,phi[i]=i-1;\n        for(register int j=1,y;j<=cnt&&pri[j]<=b[i]&&(y=pri[j]*i)<=lim;++j)\n            b[y]=pri[j],phi[y]=i%pri[j]?phi[i]*phi[pri[j]]:phi[i]*pri[j];\n    }\n    for(register int i=1;i<=lim;++i)phi[i]=(phi[i-1]+1ll*i*i%p*phi[i]%p)%p;\n\tfor(register ll l=1,r,i;l<=n;l=r+1)\n        i=n\/l,r=n\/i,\n        x=id(i),\n        i%=p,\n        S[x]=1ll*inv*i%p*(i+1)%p*(i+i+1)%p,\n        s[x]=((1ll*i*(i+1))>>1)%p,s[x]=1ll*s[x]*s[x]%p;    \n    for(register ll l=1,r,i;l<=n;l=r+1)\n\t\ti=n\/l,r=n\/i,\n\t\tres=(res+1ll*s[id(i)]*(PHI(r)-PHI(l-1)))%p;\n\tif(res<0)res+=p;\n\tprintf(\"%d\\n\",res);\n}\n```\n","link":null,"tags":["数论","欧拉函数","杜教筛","莫比乌斯"],"title":"LG 3768 简单的数学题"},{"categories":[["刷题记录"]],"content":"\n一个点$(x,y)$和原点之间的点数为$gcd(x,y)-1$\n\n设$n<m$\n\n$$\n设t=\\sum_{i=1}^n \\sum_{j=1}^m gcd(i,j)\n\\\\\n=\\sum_{d=1}^n d \\sum_{i=1}^n \\sum_{j=1}^m [gcd(i,j)=d]\n\\\\\n=\\sum_{d=1}^n d \\sum_{i=1}^{\\left \\lfloor \\frac nd \\right \\rfloor} \\sum_{j=1}^{\\left \\lfloor \\frac md \\right \\rfloor} [gcd(i,j)=1]\n\\\\\n=\\sum_{d=1}^n d \\sum_{i=1}^{\\left \\lfloor \\frac nd \\right \\rfloor} \\sum_{j=1}^{\\left \\lfloor \\frac md \\right \\rfloor} \\sum_{k|gcd(i,j)}\\mu(k)\n\\\\\n=\\sum_{d=1}^n d \\sum_{k=1}^{\\left \\lfloor \\frac nd \\right \\rfloor}\\mu(k)\\left \\lfloor \\frac n{dk} \\right \\rfloor \\left \\lfloor \\frac m{dk} \\right \\rfloor\n\\\\\nans = 2*t-n*m\n$$\n\n记得long long\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n\t#pragma GCC optimize(3)\n\t#define il __inline__ __attribute__ ((always_inline))\n\t#define rg register\n\t#define ll long long\n\t#define ull unsigned long long\n\t#define db double\n\t#define sht short\n\t#define MB template <class T>il\n\t#define Fur(i,x,y) for(int i=x;i<=y;i++)\n\t#define Fdr(i,x,y) for(int i=x;i>=y;i--)\n\t#define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n\t#define clr(x,y) memset(x,y,sizeof(x))\n\t#define cpy(x,y) memcpy(x,y,sizeof(x))\n\t#define fin(s) freopen(s\".in\",\"r\",stdin)\n\t#define fout(s) freopen(s\".out\",\"w\",stdout)\n\t#define fcin ios::sync_with_stdio(false)\n\t#define l2(n) (int(log2(n)))\n\t#define inf 0x3f3f3f3f\n\tMB T ABS(T x){return x>0?x:-x;}\n\tMB T MAX(T x,T y){return x>y?x:y;}\n\tMB T MIN(T x,T y){return x<y?x:y;}\n\tMB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n\tMB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N  1000000\nint a,b,d,mu[N+11],pri[N+11],tot=0;\nbool f[N+11];\nvoid sm(int n){\n\tf[1]=mu[1]=1;\n\tFur(i,2,n){\n\t\tif(!f[i])pri[++tot]=i,mu[i]=-1;\n\t\tFur(j,1,tot){\n\t\t\tif(pri[j]*i>n)break;\n\t\t\tf[i*pri[j]]=1;\n\t\t\tif(i%pri[j])mu[i*pri[j]]=-mu[i];\n\t\t\telse break;\n\t\t}\n\t}\n\tFur(i,2,n)mu[i]+=mu[i-1];\n}\nint main(){\n\tsm(N);\n\tin>>a>>b;\n\tif(a>b)SWAP(a,b);\n\tll ans=0;\n\tFur(d,1,a){\n\t\tint n=a\/d,m=b\/d;\n\t\tfor(int l=1,r=0;l<=n;l=r+1){\n\t\t\tr=MIN(n\/(n\/l),m\/(m\/l));\n\t\t\tans+=1ll*d*(n\/l)*(m\/l)*(mu[r]-mu[l-1]);\n\t\t}\n\t}\n\tout<<(ll)(1ll*2*ans-a*b)<<ln;\n}\n```\n","link":null,"tags":["数论","欧拉函数"],"title":"LG 1447 [NOI2010]能量采集"},{"categories":[["刷题记录"]],"content":"\n```cpp\n#include<bits\/stdc++.h>\ntypedef long long ll;\n#pragma GCC optimize(3)\n#define il __inline__ __attribute__ ((always_inline))\nconst int N=5000000;\nint mu[N+11],pri[N+1];\nll phi[N+11];\nbool b[N+11];\nil void init(){\n    mu[1]=phi[1]=1;\n    int cnt=0;\n    for(int i=2;i<=N;++i){\n        if(!b[i])pri[++cnt]=i,mu[i]=-1,phi[i]=i-1;\n        for(int j=1;j<=cnt&&i*pri[j]<=N;++j){\n            b[i*pri[j]]=1;\n            if(i%pri[j])mu[i*pri[j]]=-mu[i],phi[i*pri[j]]=phi[i]*(pri[j]-1);\n            else{phi[i*pri[j]]=phi[i]*pri[j];break;}\n        }\n    }\n    for(int i=2;i<=N;++i)mu[i]+=mu[i-1],phi[i]+=phi[i-1];\n}\nconst int P=1000007;\nstruct hash{\n    int cnt=0,head[P];\n    struct edge{int to,nxt;ll w;}e[P];\n    il void add(int x,int y,ll w){e[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;e[cnt].w=w;}\n    il void ins(int x,ll v){add(x%P,x,v);}\n    il ll ask(int x){for(int i=head[x%P];i;i=e[i].nxt)if(e[i].to==x)return e[i].w;return 1ll<<63;}\n}SP,SM;\nll PHI(int n){\n    if(n<=N)return phi[n];\n    ll t=SP.ask(n);if(t!=(1ll<<63))return t;\n    ll res=1ll*n*(n+1)\/2;\n    for(ll l=2,r;l<=n;l=r+1){\n        r=n\/(n\/l);\n        res-=PHI(n\/l)*(r-l+1);\n    }\n    SP.ins(n,res);\n    return res;\n}\nll MU(int n){\n    if(n<=N)return mu[n];\n    ll t=SM.ask(n);if(t!=(1ll<<63))return t;\n    ll res=1;\n    for(ll l=2,r;l<=n;l=r+1){\n        r=n\/(n\/l);\n        res-=MU(n\/l)*(r-l+1);\n    }\n    SM.ins(n,res);\n    return res;\n}\nint main(){\n    init();\n    int T,n;scanf(\"%d\",&T);\n    while(T--){\n        scanf(\"%d\",&n);\n        printf(\"%lld %lld\\n\",PHI(n),MU(n));\n    }\n}\n```\n","link":null,"tags":["杜教筛","莫比乌斯","欧拉函数","数论"],"title":"LG 4213 【模板】杜教筛（Sum）"},{"categories":[["算法","数论"],["note"]],"content":"\n\n前置知识: [狄利克雷卷积](\/posts\/di-li-ke-lei-juan-ji)\n\n求积性函数$f$的前缀和:\n\n$$S(n)=\\sum_{i=1}^nf(i)$$\n\n大部分题目都是可以线性筛的,可是某些丧心病狂的出题人会: $n\\le 10^{12}$!\n\n这时候需要用杜教筛了\n\n我们构造另外一个积性函数$g$,那么\n\n$$\n\\sum_{i=1}^n(g * f)\n\\\\\n=\\sum_{i=1}^n\\sum_{d|i}g(d)f(\\frac id)\n\\\\\n=\\sum_{d=1}^ng(d)\\sum_{d|i}f(\\frac id)\n\\\\\n=\\sum_{d=1}^ng(d)\\sum_{i=1}^{\\frac nd}f(i)\n\\\\\n=\\sum_{d=1}^ng(d)S(\\frac nd)\n$$\n\n容斥一下,那么\n\n$$\ng(1)S(n)\n\\\\\n=\\sum_{d=1}^ng(d)S(\\frac nd)-\\sum_{d=2}^ng(d)S(\\frac nd)\n\\\\\n=\\sum_{i=1}^n(f * g)(i)-\\sum_{i=2}^ng(i)S(\\frac ni)\n$$\n\n可以发现,前半部分是狄利克雷卷积的前缀和的形式,后半部分可以数论分块\n\n最终可以优化到$O(n^{\\frac 23})$\n\n那么如何选好积性函数$g$呢?\n\n## 莫比乌斯函数$\\mu$\n\n如果我们选择$g=1$($1$与$\\mu$互为逆元,$1 * \\mu = \\epsilon$)\n\n$$\n1(1)S(n)=S(n)\n\\\\\n=\\sum_{i=1}^n \\epsilon(i)-\\sum_{i=2}^n1(i)S(\\frac ni)\n\\\\\n=1-\\sum_{i=2}^nS(\\frac ni)\n$$\n\n后半部分数论分块即可\n\n## 欧拉函数$\\varphi$\n\n还是选取$g=1$\n\n$\\varphi *1 = Id$\n\n$$\n1(1)S(n)=S(n)\n\\\\\n=\\sum_{i=1}^n Id(i)-\\sum_{i=2}^n1(i)S(\\frac ni)\n\\\\\n=\\frac{n(n+1)}2-\\sum_{i=2}^nS(\\frac ni)\n$$\n\n前半部分直接得出,后半部分数论分块\n\n## 代码\n\n[LG 4213 【模板】杜教筛（Sum）](https:\/\/www.luogu.com.cn\/problem\/P4213)\n\n```cpp\n#include<bits\/stdc++.h>\ntypedef long long ll;\n#pragma GCC optimize(3)\n#define il __inline__ __attribute__ ((always_inline))\nconst int N=5000000;\nint mu[N+11],pri[N+1];\nll phi[N+11];\nbool b[N+11];\nil void init(){\n    mu[1]=phi[1]=1;\n    int cnt=0;\n    for(int i=2;i<=N;++i){\n        if(!b[i])pri[++cnt]=i,mu[i]=-1,phi[i]=i-1;\n        for(int j=1;j<=cnt&&i*pri[j]<=N;++j){\n            b[i*pri[j]]=1;\n            if(i%pri[j])mu[i*pri[j]]=-mu[i],phi[i*pri[j]]=phi[i]*(pri[j]-1);\n            else{phi[i*pri[j]]=phi[i]*pri[j];break;}\n        }\n    }\n    for(int i=2;i<=N;++i)mu[i]+=mu[i-1],phi[i]+=phi[i-1];\n}\nconst int P=1000007;\nstruct hash{\n    int cnt=0,head[P];\n    struct edge{int to,nxt;ll w;}e[P];\n    il void add(int x,int y,ll w){e[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;e[cnt].w=w;}\n    il void ins(int x,ll v){add(x%P,x,v);}\n    il ll ask(int x){for(int i=head[x%P];i;i=e[i].nxt)if(e[i].to==x)return e[i].w;return 1ll<<63;}\n}SP,SM;\nll PHI(int n){\n    if(n<=N)return phi[n];\n    ll t=SP.ask(n);if(t!=(1ll<<63))return t;\n    ll res=1ll*n*(n+1)\/2;\n    for(ll l=2,r;l<=n;l=r+1){\n        r=n\/(n\/l);\n        res-=PHI(n\/l)*(r-l+1);\n    }\n    SP.ins(n,res);\n    return res;\n}\nll MU(int n){\n    if(n<=N)return mu[n];\n    ll t=SM.ask(n);if(t!=(1ll<<63))return t;\n    ll res=1;\n    for(ll l=2,r;l<=n;l=r+1){\n        r=n\/(n\/l);\n        res-=MU(n\/l)*(r-l+1);\n    }\n    SM.ins(n,res);\n    return res;\n}\nint main(){\n    init();\n    int T,n;scanf(\"%d\",&T);\n    while(T--){\n        scanf(\"%d\",&n);\n        printf(\"%lld %lld\\n\",PHI(n),MU(n));\n    }\n}\n```","link":null,"tags":["数论","卷积","杜教筛"],"title":"杜教筛"},{"categories":[["刷题记录"]],"content":"\n$$\nf=\\sum_{i=1}^{a}\\sum_{j=1}^{b}[gcd(i,j)=d]\n\\\\\nf=\\sum_{i=1}^{\\left \\lfloor \\frac ad \\right \\rfloor} \\sum_{j=1}^{\\left \\lfloor \\frac bd \\right \\rfloor} [gcd(i,j)=1]\n\\\\\n\\because \\sum_{x|n} \\mu(x) = [n=1]\n\\\\\n\\therefore \nf= \\sum_{i=1}^{\\left \\lfloor \\frac ad \\right \\rfloor} \\sum_{j=1}^{\\left \\lfloor \\frac bd \\right \\rfloor}\n\\sum_{k|gcd(i,j)} \\mu(k)\n\\\\\nf=\\sum_{k=1}^{\\left \\lfloor \\frac ad \\right \\rfloor}\\mu(k)\\left \\lfloor \\frac a{dk} \\right \\rfloor \\left \\lfloor \\frac b{dk} \\right \\rfloor\n$$\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n\t#pragma GCC optimize(3)\n\t#define il __inline__ __attribute__ ((always_inline))\n\t#define rg register\n\t#define ll long long\n\t#define ull unsigned long long\n\t#define db double\n\t#define sht short\n\t#define MB template <class T>il\n\t#define Fur(i,x,y) for(int i=x;i<=y;i++)\n\t#define Fdr(i,x,y) for(int i=x;i>=y;i--)\n\t#define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n\t#define clr(x,y) memset(x,y,sizeof(x))\n\t#define cpy(x,y) memcpy(x,y,sizeof(x))\n\t#define fin(s) freopen(s\".in\",\"r\",stdin)\n\t#define fout(s) freopen(s\".out\",\"w\",stdout)\n\t#define fcin ios::sync_with_stdio(false)\n\t#define l2(n) (int(log2(n)))\n\t#define inf 0x3f3f3f3f\n\tMB T ABS(T x){return x>0?x:-x;}\n\tMB T MAX(T x,T y){return x>y?x:y;}\n\tMB T MIN(T x,T y){return x<y?x:y;}\n\tMB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n\tMB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 10000000\nint a,b,d,t,mu[N+11],pri[N+11],tot=0;\nbool f[N+11];\nvoid sm(int n){\n\tf[1]=mu[1]=1;\n\tFur(i,2,n){\n\t\tif(!f[i])pri[++tot]=i,mu[i]=-1;\n\t\tFur(j,1,tot){\n\t\t\tif(pri[j]*i>n)break;\n\t\t\tf[i*pri[j]]=1;\n\t\t\tif(i%pri[j])mu[i*pri[j]]=-mu[i];\n\t\t\telse break;\n\t\t}\n\t}\n\tFur(i,2,n)mu[i]+=mu[i-1];\n}\nint main(){\n\tsm(N);\n\tin>>t;\n\twhile(t--){\n\t\tin>>a>>b>>d;\n\t\tint n=a\/d,m=b\/d,ans=0;\n\t\tif(n>m)SWAP(n,m);\n\t\tfor(int l=1,r=0;l<=n;l=r+1){\n\t\t\tr=MIN(n\/(n\/l),m\/(m\/l));\n\t\t\tans+=(n\/l)*(m\/l)*(mu[r]-mu[l-1]);\n\t\t}\n\t\tout<<ans<<ln;\n\t}\n}\n```\n","link":null,"tags":["数论","莫比乌斯"],"title":"LG 3455 [POI2007]ZAP-Queries"},{"categories":[["刷题记录"]],"content":"\n把题目强行转换为[[POI2007]ZAP-Queries](https:\/\/www.luogu.org\/problemnew\/show\/P3455)\n\n\n$Ans((1,b),(1,d))-Ans((1,b),(1,c-1))-Ans((1,a-1),(1,d))+Ans((1,a-1),(1,c-1))$\n\n\n\n$$\nf=\\sum_{i=1}^{a}\\sum_{j=1}^{b}[gcd(i,j)=d] \\\\\nf=\\sum_{i=1}^{\\left \\lfloor \\frac ad \\right \\rfloor} \\sum_{j=1}^{\\left \\lfloor \\frac bd \\right \\rfloor} [gcd(i,j)=1] \\\\\n\\because \\sum_{x|n} \\mu(x) = [n=1] \\\\\n\\therefore \nf= \\sum_{i=1}^{\\left \\lfloor \\frac ad \\right \\rfloor} \\sum_{j=1}^{\\left \\lfloor \\frac bd \\right \\rfloor}\n\\sum_{k|gcd(i,j)} \\mu(k) \\\\\nf=\\sum_{k=1}^{\\left \\lfloor \\frac ad \\right \\rfloor}\\mu(k)\\left \\lfloor \\frac a{dk} \\right \\rfloor \\left \\lfloor \\frac b{dk} \\right \\rfloor\n$$\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n\t#pragma GCC optimize(3)\n\t#define il __inline__ __attribute__ ((always_inline))\n\t#define rg register\n\t#define ll long long\n\t#define ull unsigned long long\n\t#define db double\n\t#define sht short\n\t#define MB template <class T>il\n\t#define Fur(i,x,y) for(int i=x;i<=y;i++)\n\t#define Fdr(i,x,y) for(int i=x;i>=y;i--)\n\t#define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n\t#define clr(x,y) memset(x,y,sizeof(x))\n\t#define cpy(x,y) memcpy(x,y,sizeof(x))\n\t#define fin(s) freopen(s\".in\",\"r\",stdin)\n\t#define fout(s) freopen(s\".out\",\"w\",stdout)\n\t#define fcin ios::sync_with_stdio(false)\n\t#define l2(n) (int(log2(n)))\n\t#define inf 0x3f3f3f3f\n\tMB T ABS(T x){return x>0?x:-x;}\n\tMB T MAX(T x,T y){return x>y?x:y;}\n\tMB T MIN(T x,T y){return x<y?x:y;}\n\tMB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n\tMB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 50000\nint t,d,mu[N+11],pri[N+11],tot=0;\nbool f[N+11];\nvoid sm(int n){\n\tf[1]=mu[1]=1;\n\tFur(i,2,n){\n\t\tif(!f[i])pri[++tot]=i,mu[i]=-1;\n\t\tFur(j,1,tot){\n\t\t\tif(pri[j]*i>n)break;\n\t\t\tf[i*pri[j]]=1;\n\t\t\tif(i%pri[j])mu[i*pri[j]]=-mu[i];\n\t\t\telse break;\n\t\t}\n\t}\n\tFur(i,2,n)mu[i]+=mu[i-1];\n}\nint ask(int a,int b){\n\tint n=a\/d,m=b\/d,ans=0;\n\tif(n>m)SWAP(n,m);\n\tfor(int l=1,r=0;l<=n;l=r+1){\n\t\tr=MIN(n\/(n\/l),m\/(m\/l));\n\t\tans+=(n\/l)*(m\/l)*(mu[r]-mu[l-1]);\n\t}\t\n\treturn ans;\n}\nint main(){\n\tsm(N);\n\tin>>t;\n\twhile(t--){\n\t\tint a,b,c,D;\n\t\tin>>a>>b>>c>>D>>d;\n\t\tout<<ask(b,D)-ask(b,c-1)-ask(a-1,D)+ask(a-1,c-1)<<ln;\n\t}\n}\n```\n","link":null,"tags":["数论","欧拉函数","莫比乌斯"],"title":"LG 2522 [HAOI2011]Problem-b"},{"categories":[["刷题记录"]],"content":"\n设$n<m$\n$$\n\\prod_{i=1}^n \\prod_{j=1}^m f_{\\gcd(i,j)}\n\\\\\n=\\prod_{d=1}^n{f_d}^{\\sum_{i=1}^n \\sum_{j=1}^m[\\gcd(i,j)=d]}\n\\\\\n=\\prod_{d=1}^n{f_d}^{\\sum_{i=1}^{\\left \\lfloor \\frac nd \\right \\rfloor} \\sum_{j=1}^{\\left \\lfloor \\frac md \\right \\rfloor}[\\gcd(i,j)=1]}\n\\\\\n=\\prod_{d=1}^n{f_d}^{\\sum_{i=1}^{\\left \\lfloor \\frac nd \\right \\rfloor} \\mu(i) \\left \\lfloor \\frac n{id}\\right \\rfloor \\left \\lfloor \\frac m{id}\\right \\rfloor}\n$$\n\n数论分块套数论分块会tle,继续老套路优化\n\n令$T=id$\n\n$$\n=\\prod_{T=1}^n\\sum_{d|T}{f_d}^{\\mu(\\frac Td) \\left \\lfloor \\frac n{T}\\right \\rfloor \\left \\lfloor \\frac m{T}\\right \\rfloor}\n$$\n\n可以先预处理出函数$s(T)=\\sum_{d|T}{f_d}^{\\mu(\\frac Td)}$的前缀积\n\n然后就可以做到数论分块$O(\\sqrt n)$的复杂度了\n```cpp\n#include<bits\/stdc++.h>\nusing namespace std;\n#pragma GCC optimize(3)\n#define il __inline__ __attribute__ ((always_inline))\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\nil int min(int x,int y){return x<y?x:y;}\nconst int N=1000000,P=1000000007;\nint n,cnt=0,pri[78500],mu[N+11],f[N+11],g[N+11],s[N+11];\nbool b[N+11];\nil int pw(int x,int b){\n    int ans=1;\n    while(b){\n        if(b&1)ans=1ll*ans*x%P;\n        b>>=1;x=1ll*x*x%P;\n    }\n    return ans;\n}\nil int inv(int x){return pw(x,P-2);}\nint main(){\n    mu[1]=f[1]=g[1]=s[0]=s[1]=1;\n    for(int i=2;i<=N;++i){\n        f[i]=(f[i-1]+f[i-2])%P;\n        g[i]=inv(f[i]);\n        s[i]=1;\n        if(!b[i])pri[++cnt]=i,mu[i]=-1;\n        for(int j=1;j<=cnt&&i*pri[j]<=N;++j){\n            b[i*pri[j]]=1;\n            if(i%pri[j])mu[i*pri[j]]=-mu[i];\n            else break;\n        }\n    }\n    for(int i=1;i<=N;++i)\n    if(mu[i])for(int j=i;j<=N;j+=i)\n         s[j]=1ll*s[j]*(~mu[i]?f[j\/i]:g[j\/i])%P;\n    for(int i=2;i<=N;++i)s[i]=1ll*s[i]*s[i-1]%P;\n    int T;in(T);\n    while(T--){\n        int n,m,ans=1;\n        in(n,m);\n        if(n>m)n^=m,m^=n,n^=m;\n        for(int l=1,r;l<=n;l=r+1){\n            r=min(n\/(n\/l),m\/(m\/l));\n            ans=1ll*ans*pw(1ll*s[r]*inv(s[l-1])%P,1ll*(n\/l)*(m\/l)%(P-1))%P;\n        }\n        out(ans,ln);\n    }\n    flush();\n}\n```\n","link":null,"tags":["数论","莫比乌斯","斐波那契"],"title":"LG 3704 [SDOI2017]数字表格"},{"categories":[["算法","数论"],["note"]],"content":"\n\nhttps:\/\/www.luogu.com.cn\/blog\/wucstdio\/duo-xiang-shi-suan-fa-di-chang-shuo-wen-ti\n\nhttps:\/\/www.luogu.com.cn\/blog\/user7035\/duo-xiang-shi-zong-jie\n\nhttp:\/\/zory.ink\/posts\/8c82","link":null,"tags":["数论"],"title":"多项式全家桶"},{"categories":[["算法","数论"],["note"]],"content":"\n\n## 数论函数\n\n1. 加法\n   \n   逐项相加\n\n   $$(f+g)(x)=f(x)+g(x)$$\n\n2. 数乘\n   \n   $$(xf)(n)=x\\cdot f(n)$$\n\n## 定义\n\n两个数论函数的狄利克雷卷积∗\n\n$t=f*g$等价于\n\n$$t(n)=\\sum_{i|n}f(i) \\cdot g(\\frac ni)$$\n\n等价于\n\n$$t(n)=\\sum_{ij|n}f(i) \\cdot g(j)$$\n\n## 性质\n\n1. 交换律$f*g=g*f$\n\n2. 结合律$f*(g*h)=(f*g)*h$\n\n3. 分配率$f*h+g*h=(f+g)*h$\n\n4. $(xf)*g=x(f*g)$\n   \n5. 单位元$\\epsilon*f=f$\n\n以上5个结论都可以通过带入得到\n   \n6. 逆元\n   \n   对于每个$f(1) \\not = 0$的函数$f$,都存在$f*g=\\epsilon$\n\n   > 定义\n   > \n   > $$g(n)=\\frac{1}{f(1)}\\left([n=1]-\\sum_{i|n,i\\neq 1}f(i)g(\\frac{n}{i})\\right)$$\n   > \n   > 那么\n   > \n   > $$\\sum_{i|n}f(i)g(\\frac{n}{i})\\\\=f(1)g(n)+\\sum_{i|n,i\\neq1}f(i)g(\\frac{n}{i})\\\\=[n=1]-\\sum_{i|n,i\\neq 1}f(i)g(\\frac{n}{i})+\\sum_{i|n,i\\neq 1}f(i)g(\\frac{n}{i})\\\\=[n=1]$$\n\n## 常用的函数与与常用卷积关系\n\n### 几个常用的函数:\n\n   - $\\epsilon(n)=[n=1]$\n   - $1(n)=1$\n   - $Id(n)=n$\n   - 莫比乌斯函数:\n     $$\\mu(i)=\\begin{cases}1,i=1\\\\(-1)^k,i=p_1\\times p_2\\times \\dots \\times p_k\\\\0,rest\\end{cases}$$\n   - 欧拉函数: $\\varphi(n)=n\\prod_{i=1}^k(1-\\frac 1{p_i})(n={p_1}^x\\times {p_2}^x\\times \\dots \\times {p_k}^x)$\n   - 约数数: $d(n)=\\sum_{d|n}1(d=1*1)$\n   - 约数和: $\\sigma(n)=\\sum_{d|n}d(\\sigma=1*Id)$\n     > $\\sigma_0(n)$表示$n$的因数个数\n     >\n     > $\\sigma_k(n)$表示所有因数的$k$次方和\n   - $\\lambda(n)=(-1)^k$\n\n### 常用卷积关系\n\n1. $\\mu * 1=\\epsilon$(莫比乌斯反演,$\\mu$与$1$互为逆元)\n   \n   如果$f * 1=g$,那么$f=f * \\epsilon=f * 1 * \\mu=\\mu * g$\n\n   证明(摘自 https:\/\/www.luogu.com.cn\/blog\/lx-2003\/mobius-inversion ):\n\n   > 对此只需要定义:\n   >\n   > $$(\\mathbf f\\oplus\\mathbf g)(x)=\\sum_{x\\mid y}\\mathbf f(y\/x)\\mathbf g(y)$$\n   > \n   > 并容易证明:\n   >\n   > $$(\\mathbf f\\ast\\mathbf g)\\oplus\\mathbf h=\\mathbf f\\oplus(\\mathbf g\\oplus\\mathbf h)$$\n   >\n   > 于是\n   > \n   > $$\\mathbf f=(\\mu\\ast\\mathbf1)\\oplus\\mathbf f=\\mu\\oplus(\\mathbf1\\oplus\\mathbf f)=\\mu\\oplus\\mathbf g$$\n2. $\\varphi * 1 = Id$\n   \n   根据1.\n\n   $\\varphi=\\mu*Id$\n\n   证明(摘自 https:\/\/www.luogu.com.cn\/blog\/lx-2003\/mobius-inversion ):\n\n   >设$n=\\prod_{i=1}^t p_i^{k_i}$\n   >\n   >$\\sigma_0$和$\\varphi$在素数幂处的值很容易得到: $k>0$时$\\sigma_0(p^k)=k+1,\\varphi(p^k)=p^{k-1}(p-1)$\n   >\n   >所以:\n   >\n   >$$\\sigma_0(n)=\\prod_{i=1}^t(k_i+1), \\varphi(n)=\\prod_{i=1}^np_i^{k_i-1}(p_i-1)=n\\prod_{i=1}^t\\left(1-\\frac1{p_i}\\right)$$\n   >\n   > $$(\\varphi\\ast\\mathbf1)(p^k)\\\\=\\sum_{i|p^k}\\varphi(i)1(\\frac{p^k}i)\\\\=1+\\sum_{i=1}^k p^{i-1}(p-1)\\\\=1+(p-1)+p^2-p+p^3-p^2+...+p^k-p^{k-1}\\\\=p^k$$\n   >\n   > 带入求解可以得出$Id=\\varphi*1$\n3. $d=1*1$\n4. $1=\\mu * d$\n\n卷积证明莫比乌斯反演: $F=f*1,f=\\mu * F$\n\n强烈推荐: https:\/\/www.luogu.com.cn\/blog\/lx-2003\/mobius-inversion","link":null,"tags":["数论","卷积"],"title":"狄利克雷卷积"},{"categories":[["刷题记录"]],"content":"\n设$n<m$,$\\sigma(d)$为$d$的约数和\n\n先不考虑$\\sigma(\\gcd(i,j))\\le a$\n\n$$\n\\sum_{i=1}^n\\sum_{j=1}^m \\sigma(\\gcd(i,j))\n\\\\\n=\\sum_{d=1}^n \\sigma(d) \\sum_{i=1}^n\\sum_{j=1}^m [\\gcd(i,j)=d]\n\\\\\n=\\sum_{d=1}^n \\sigma(d) \\sum_{i=1}^{\\left \\lfloor \\frac nd \\right \\rfloor}\\sum_{j=1}^{\\left \\lfloor \\frac md \\right \\rfloor} [\\gcd(i,j)=1]\n\\\\\n=\\sum_{d=1}^n \\sigma(d) \\sum_{i=1}^{\\left \\lfloor \\frac nd \\right \\rfloor}\\sum_{j=1}^{\\left \\lfloor \\frac md \\right \\rfloor} \\sum_{x|i,x|j} \\mu(x)\n\\\\\n=\\sum_{d=1}^n \\sigma(d) \\sum_{x=1}^{\\left \\lfloor \\frac nd \\right \\rfloor} \\mu(x) {\\left \\lfloor \\frac n{dx} \\right \\rfloor}{\\left \\lfloor \\frac m{dx} \\right \\rfloor}\n$$\n\n令$T=dx$\n\n$$\n=\\sum_{T=1}^n {\\left \\lfloor \\frac nT \\right \\rfloor}{\\left \\lfloor \\frac mT \\right \\rfloor}\\sum_{d|T}\\sigma(d) \\mu(\\left \\lfloor \\frac Td \\right \\rfloor) \n$$\n\n考虑$a$的限制\n\n设$g(T)=\\sum_{d|T}\\sigma(d) \\mu(\\left \\lfloor \\frac Td \\right \\rfloor)$\n\n可以发现当$d\\ge a$的时候才会产生贡献\n\n将询问按$a$排序\n\n每次询问的时候,按倍数枚举找到所有新的可以产生贡献的$T$,\n\n动态修改$g(T)$,可以选择树状数组这种又短常数又小的好东西\n```cpp\n#include<bits\/stdc++.h>\nusing namespace std;\n#pragma GCC optimize(3)\n#define il __inline__ __attribute__ ((always_inline))\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\nconst int N=100000;\nstruct que{int n,m,a,id;bool operator<(que t)const{return a<t.a;}}q[20001];\nstruct bit{\n    int s[N+11];\n    il void add(int x,int v){for(int i=x;i<=N;i+=i&-i)s[i]+=v;}\n    il int ask(int x){int ans=0;for(int i=x;i;i-=i&-i)ans+=s[i];return ans;}\n    il int ask(int l,int r){return ask(r)-ask(l-1);}\n}S;\nint T,mu[N+11],g[N+11],pri[N],cnt=0,ANS[N];\nbool b[N+11];\nil int min(int x,int y){return x<y?x:y;}\npair<int,int>f[N+11];\nil int sum(int n,int m){\n    int ans=0;\n    for(int l=1,r;l<=n;l=r+1){\n        r=min(n\/(n\/l),m\/(m\/l));\n        ans+=(mu[r]-mu[l-1])*(n\/l)*(m\/l);\n    }\n    return ans;\n}\nint main(){\n    mu[1]=1;f[1]=make_pair(1,1);\n    for(int i=2;i<=N;++i){\n        if(!b[i])pri[++cnt]=i,mu[i]=-1,g[i]=i+1,f[i]=make_pair(i+1,i);\n        for(int j=1;j<=cnt&&pri[j]*i<=N;++j){\n            b[i*pri[j]]=1;\n            if(i%pri[j]){\n                mu[i*pri[j]]=-mu[i];\n                g[i*pri[j]]=pri[j]+1;\n                f[i*pri[j]]=make_pair(f[i].first*f[pri[j]].first,i*pri[j]);\n            }\n            else{\n                g[i*pri[j]]=g[i]*pri[j]+1;\n                f[i*pri[j]]=make_pair(f[i].first\/g[i]*g[i*pri[j]],i*pri[j]);\n                break;\n            }\n        }\n    }\n    sort(f+1,f+N+1);\n    in(T);\n    for(int i=1;i<=T;++i)in(q[i].n,q[i].m,q[i].a),q[i].id=i;\n    sort(q+1,q+T+1);\n    for(int t=1,j=1;t<=T;++t){\n        int n=q[t].n,m=q[t].m,a=q[t].a,&ans=ANS[q[t].id];\n        if(n>m)n^=m,m^=n,n^=m;\n        for(;f[j].first<=a&&j<=N;++j)\n            for(int k=f[j].second;k<=N;k+=f[j].second)\n                S.add(k,f[j].first*mu[k\/f[j].second]);\n        for(int l=1,r;l<=n;l=r+1){\n            r=min(n\/(n\/l),m\/(m\/l));\n            ans+=S.ask(l,r)*(n\/l)*(m\/l);\n        }\n    }\n    for(int i=1;i<=T;++i)out(ANS[i]&(~(1<<31)),ln);\n    flush();\n}\n```\n","link":null,"tags":["数论","莫比乌斯"],"title":"LG 3312 [SDOI2014]数表"},{"categories":[["刷题记录"]],"content":"\n求:\n$$\\sum_{i=1}^n\\sum_{j=1}^mlcm(i,j)$$\n\n设$n<m$\n$$\n\\sum_{i=1}^n\\sum_{j=1}^mlcm(i,j)\n\\\\\n=\\sum_{i=1}^n\\sum_{j=1}^m \\frac{ij}{\\gcd(i,j)}\n\\\\\n=\\sum_{d=1}^n\\sum_{i=1}^n\\sum_{j=1}^m \\frac {ij}d[\\gcd(i,j)=d]\n$$\n\n设$i'=\\left \\lfloor \\frac id \\right \\rfloor,j'=\\left \\lfloor \\frac jd \\right \\rfloor$\n\n$$\n\\\\\n=\\sum_{d=1}^n\\sum_{i=1}^{\\left \\lfloor \\frac nd \\right \\rfloor}\\sum_{j=1}^{\\left \\lfloor \\frac md \\right \\rfloor} ijd[\\gcd(i,j)=1]\n$$\n\n把$\\sum\\limits_{i=1}^{\\left \\lfloor \\frac nd \\right \\rfloor}\\sum\\limits_{j=1}^{\\left \\lfloor \\frac md \\right \\rfloor} ij[\\gcd(i,j)=1]$拆出来,\n\n设$sum(n,m)=$\n\n$$\n\\sum_{i=1}^n\\sum_{j=1}^n ij[\\gcd(i,j)=1]\n\\\\\n=\\sum_{i=1}^n\\sum_{j=1}^m\\sum_{d|gcd(i,j)} ij\\mu(d)\n\\\\\n=\\sum_{d=1}^n\\sum_{d|i}\\sum_{d|j} ij\\mu(d)\n$$\n\n设$i'=\\left \\lfloor \\frac id \\right \\rfloor,j'=\\left \\lfloor \\frac jd \\right \\rfloor$\n\n$$\n=\\sum_{d=1}^n\\mu(d)d^2\\sum_{i=1}^{\\left \\lfloor \\frac nd\\right \\rfloor}\\sum_{j=1}^{\\left \\lfloor \\frac md\\right \\rfloor} ij\n$$\n\n设$g(n,m)=\\sum\\limits_{i=1}^n\\sum\\limits_{j=1}^mij$\n\n$$\ng(n,m)=\\frac{n(n+1)}2\\cdot \\frac{m(n+1)}2\n$$\n\n最后\n\n$$\nans=\\sum_{d=1}^n d\\cdot sum(\\left\\lfloor \\frac nd \\right\\rfloor,\\left\\lfloor \\frac md \\right\\rfloor)\n\\\\\nsum(n,m)=\\sum_{d=1}^n\\mu(d)d^2 g(\\left\\lfloor \\frac nd \\right\\rfloor,\\left\\lfloor \\frac md \\right\\rfloor)\n$$\n```cpp\n#include<cstdio>\nint min(int x,int y){return x<y?x:y;}\nconst int N=10000001,P=20101009;\nint mu[N],pri[664580],cnt=0,s[N];\nbool f[N];\nint g(int n,int m){return 1ll*(1ll*n*(n+1)\/2%P)*(1ll*m*(m+1)\/2%P)%P;}\nint sum(int n,int m){\n    if(n>m)n^=m,m^=n,n^=m;\n    int ans=0;\n    for(int l=1,r;l<=n;l=r+1){\n        r=min(n\/(n\/l),m\/(m\/l));\n        ans+=1ll*((s[r]-s[l-1]+P)%P)*g(n\/l,m\/l)%P;\n        ans%=P;\n    }\n    return ans;\n}\nint main(){\n    int n,m,k,ans=0;\n    scanf(\"%d%d\",&n,&m);\n    if(n>m)n^=m,m^=n,n^=m;\n    mu[1]=1;\n    for(int i=2;i<=n;++i){\n        if(!f[i])pri[++cnt]=i,mu[i]=-1;\n        for(int j=1;j<=cnt&&pri[j]*i<=n;++j){\n            f[i*pri[j]]=1;\n            if(i%pri[j])mu[i*pri[j]]=-mu[i];\n            else break;\n        }\n    }\n    for(int i=1;i<=n;++i)s[i]=(s[i-1]+1ll*mu[i]*i*i%P+P)%P;\n    for(int l=1,r;l<=n;l=r+1){\n        r=min(n\/(n\/l),m\/(m\/l));\n        ans=(ans+1ll*(r-l+1)*(r+l)\/2%P*sum(n\/l,m\/l)%P)%P;\n    }\n    printf(\"%d\\n\",ans);\n}\n```\n","link":null,"tags":["数论","莫比乌斯","数论分块"],"title":"LG 1829 [国家集训队]Crash的数字表格"},{"categories":[["刷题记录"]],"content":"\n题意:求第$k$个没有完全平方数因子的数\n\n可以发现答案具有单调性,可以二分答案,然后判断$[1,n]$中满足条件的个数是否为$k$\n\n这个结果为\n\n$1$($0$个平方因子)的倍数-【$4,9,16,25,...$】($1$个平方因子)的倍数+【$36,100,...$】($2$个平方因子)的倍数...\n\n也就是:\n\n$$\n\\sum_{i=1}^{i^2\\le n} \\mu(i)\\left \\lfloor \\frac n{i^2}\\right \\rfloor\n$$\n\n这样的话只需要线性筛到$\\sqrt{10^9}\\le 40000$,然后二分查找就可以了\n\n\n```cpp\n#include<bits\/stdc++.h>\n#pragma GCC optimize(3)\n#define il __inline__ __attribute__ ((always_inline))\n#define Fur(i,x,y) for(int i(x);i<=y;++i)\nil int min(int x,int y){return x<y?x:y;}\nconst int N=40011;\nint mu[N],pri[4300],cnt=0,k,T;\nbool f[N];\nil bool chk(int n){\n    int sqr=sqrt(n);\n    long long ans=0;\n    for(int l=1,r;l<=sqr;l=r+1){\n        r=min((int)sqrt(n\/(n\/(l*l))),sqr);\n        ans+=n\/(l*l)*(mu[r]-mu[l-1]);\n    }\n    return ans>=k;\n}\nint main(){\n    mu[1]=1;\n    Fur(i,2,40000){\n        if(!f[i])pri[++cnt]=i,mu[i]=-1;\n        Fur(j,1,cnt){\n            if(pri[j]*i>40000)break;\n            f[i*pri[j]]=1;\n            if(i%pri[j])mu[i*pri[j]]=-mu[i];\n            else break;\n        }\n    }\n    Fur(i,2,40000)mu[i]+=mu[i-1];\n    scanf(\"%d\",&T);\n    while(T--){\n        scanf(\"%d\",&k);\n        int l=k,r=k<<1;\n        while(l+1<r){\n            int m=(l>>1)+(r>>1)+((l&1)^(r&1));\n            if(chk(m))r=m;\n            else l=m+1;\n        }\n        printf(\"%d\\n\",chk(l)?l:r);\n    }\n}\n```\n","link":null,"tags":["数论分块","二分","莫比乌斯"],"title":"LG 4318 完全平方数"},{"categories":[["算法","数论"],["note"]],"content":"\n\n该好好复习(总结)一下莫比乌斯函数了呢$\\mathcal{>_\\omega<}$\n\n## 定义\n\n$$\n\\mu (i)=\n\\begin{cases}\n1,i=1\n\\\\\n(-1)^k,i=p_1\\times p_2\\times \\dots \\times p_k\n\\\\\n0,rest\n\\end{cases}\n$$\n\n## 性质\n\n以下证明可以先了解[狄利克雷卷积](\/posts\/di-li-ke-lei-juan-ji)\n\n并强烈推荐了解: https:\/\/www.luogu.com.cn\/blog\/lx-2003\/mobius-inversion\n\n1. $$\n   \\sum_{d|n}\\mu(d)=[n=1]\n   \\\\\\Downarrow\\\\\n   [gcd(a,b)=1]=\\sum_{d|\\gcd(a,b)}\\mu(d)\n   $$\n\n2. $$\\sum_{d|n}\\frac{\\mu(d)}d = \\frac{\\varphi(n)}n$$\n   \n3. $\\mu$是积性函数,若$\\gcd(a,b)=1$,$\\mu(ab)=\\mu(a)\\cdot\\mu(b)$\n   \n4. 反演:\n   $$\n   g(x)=\\sum_{x|d}f(d)\n   \\\\\\Updownarrow\\\\\n   f(x)=\\sum_{x|d}\\mu(\\frac dx) \\cdot g(d)\n   $$\n\n## 线性筛莫比乌斯函数\n\n```cpp\nint mu[N],pri[N],cnt=0;\nbool f[N];\nil void getmu(int n){\n    mu[1]=1;\n    Fur(i,2,n){\n        if(!f[i])mu[i]=-1,pri[++cnt]=i;\n        Fur(j,1,cnt){\n            if(pri[j]*i>n)break;\n            f[i*pri[j]]=1;\n            if(i%pri[j])mu[i*pri[j]]=-mu[i];\n            else break;\n        }\n    }\n}\n```\n\n## 实例\n\n(默认$n<m$)\n\n### Eg1\n\n求:\n\n$$\\sum_{i=1}^n\\sum_{i=1}^m[gcd(i,j)=1]$$\n\n解:\n\n$$\n\\sum_{i=1}^{a}\\sum_{j=1}^{b}[gcd(i,j)=1]\n\\\\\n=\\sum_{i=1}^n \\sum_{j=1}^m\n\\sum_{d|\\gcd(i,j)} \\mu(d)\n\\\\\n=\\sum_{i=1}^n \\sum_{j=1}^m\n\\sum_{d|i,d|j} \\mu(d)\n\\\\\n=\\sum_{d=1}^n\\mu(d)\\left \\lfloor \\frac nd \\right \\rfloor \\left \\lfloor \\frac md\\right \\rfloor\n$$\n\n将复杂度成功降到了$O(\\sqrt n)$\n\n### Eg2\n\n求:\n\n$$\\sum_{i=1}^n\\sum_{i=1}^mgcd(i,j)$$\n\n解:\n\n$$\n\\sum_{i=1}^n\\sum_{j=1}^mgcd(i,j)\n\\\\\n=\\sum_{d=1}^n d\\sum_{i=1}^{n}\\sum_{j=1}^{m}[gcd(i,j)=d]\n\\\\\n=\\sum_{d=1}^n d\\sum_{i=1}^{\\left\\lfloor \\frac nd \\right \\rfloor}\\sum_{j=1}^{\\left\\lfloor \\frac md \\right \\rfloor}[gcd(i,j)=1]\n$$\n\n利用[Eg1](#eg1)的结果\n\n$$\n=\\sum_{d=1}^n d\\sum_{i=1}^{\\left\\lfloor \\frac nd \\right \\rfloor}\\mu(i)\\left \\lfloor \\frac n{id} \\right \\rfloor \\left \\lfloor \\frac m{id}\\right \\rfloor\n$$\n\n这时候分块套分块复杂度可能还是会tle,我们可以继续优化\n\n设$T=id$\n\n$$\n=\\sum_{T=1}^n \\left \\lfloor \\frac nT \\right \\rfloor \\left \\lfloor \\frac mT\\right \\rfloor \\sum_{d|T} d\\mu(\\frac Td)\n$$\n\n成功降到了$O(\\sqrt n)$\n\n### Eg3\n\n求:\n\n$$\\sum_{i=1}^n\\sum_{j=1}^m f(\\gcd(i,j))$$\n\n解:\n\n$$\n\\sum_{i=1}^n\\sum_{j=1}^m f(\\gcd(i,j))\n\\\\\n=\\sum_{d=1}^n f(d) \\sum_{i=1}^n\\sum_{j=1}^m [\\gcd(i,j)=d]\n\\\\\n=\\sum_{d=1}^n f(d) \\sum_{i=1}^{\\left \\lfloor \\frac nd \\right \\rfloor}\\sum_{j=1}^{\\left \\lfloor \\frac md \\right \\rfloor} [\\gcd(i,j)=1]\n\\\\\n=\\sum_{d=1}^n f(d) \\sum_{i=1}^{\\left \\lfloor \\frac nd \\right \\rfloor}\\sum_{j=1}^{\\left \\lfloor \\frac md \\right \\rfloor} \\sum_{x|i,x|j} \\mu(x)\n\\\\\n=\\sum_{d=1}^n f(d) \\sum_{x=1}^{\\left \\lfloor \\frac nd \\right \\rfloor} \\mu(x) {\\left \\lfloor \\frac n{dx} \\right \\rfloor}{\\left \\lfloor \\frac m{dx} \\right \\rfloor}\n$$\n\n令$T=dx$\n\n$$\n=\\sum_{T=1}^n {\\left \\lfloor \\frac nT \\right \\rfloor}{\\left \\lfloor \\frac mT \\right \\rfloor}\\sum_{d|T}f(d) \\mu(\\left \\lfloor \\frac Td \\right \\rfloor) \n$$\n\n求出或维护函数$s(T)=\\sum_{d|T}f(d) \\mu(\\left \\lfloor \\frac Td \\right \\rfloor)$的前缀和,\n\n然后就可以数论分块$O(\\sqrt n)$求解了\n\nhttps:\/\/www.luogu.com.cn\/problem\/P3312\n\n### Eg4\n\n求:\n\n$$\\prod_{i=1}^n \\prod_{j=1}^m f_{\\gcd(i,j)}$$\n\n解:\n\n$$\n\\prod_{i=1}^n \\prod_{j=1}^m f_{\\gcd(i,j)}\n\\\\\n=\\prod_{d=1}^n{f_d}^{\\sum_{i=1}^n \\sum_{j=1}^m[\\gcd(i,j)=d]}\n\\\\\n=\\prod_{d=1}^n{f_d}^{\\sum_{i=1}^{\\left \\lfloor \\frac nd \\right \\rfloor} \\sum_{j=1}^{\\left \\lfloor \\frac md \\right \\rfloor}[\\gcd(i,j)=1]}\n\\\\\n=\\prod_{d=1}^n{f_d}^{\\sum_{i=1}^{\\left \\lfloor \\frac nd \\right \\rfloor} \\mu(i) \\left \\lfloor \\frac n{id}\\right \\rfloor \\left \\lfloor \\frac m{id}\\right \\rfloor}\n$$\n\n令$T=id$\n\n$$\n=\\prod_{T=1}^n\\sum_{d|T}{f_d}^{\\mu(\\frac Td) \\left \\lfloor \\frac n{T}\\right \\rfloor \\left \\lfloor \\frac m{T}\\right \\rfloor}\n$$\n\n求出或维护函数$s(T)=\\sum_{d|T}f(d) \\mu(\\left \\lfloor \\frac Td \\right \\rfloor)$的前缀积,\n\n然后就可以数论分块$O(\\sqrt n)$求解了\n\nhttps:\/\/www.luogu.com.cn\/problem\/P3704\n","link":null,"tags":["数论","算法","容斥","反演"],"title":"莫比乌斯函数"},{"categories":[["刷题记录"]],"content":"\n可以先转化为前缀和再相减\n\n问题变为了求:\n\n$$\n\\sum_{i=1}^n \\sum_{j|i}j\n$$\n\n考虑每个约数$d$,它的贡献次数为$\\left \\lfloor \\frac nd\\right \\rfloor$\n\n那么答案就是\n\n$$\n\\sum_{d=1}^n d\\left \\lfloor \\frac nd\\right \\rfloor\n$$\n\n直接数论分块即可\n```cpp\n#include<cstdio>\ntypedef long long ll;\nll calc(int n){\n    ll ans=0;\n    for(ll l=1,r=0;l<=n;l=r+1){\n        r=n\/(n\/l);\n        ans+=(r-l+1)*(l+r)\/2*(n\/l);\n    }\n    return ans;\n}\nint main(){\n    int l,r;\n    scanf(\"%d%d\",&l,&r);\n    printf(\"%lld\\n\",calc(r)-calc(l-1));\n}\n```\n","link":null,"tags":["数论","数论分块"],"title":"LG 2424 约数和"},{"categories":[["刷题记录"]],"content":"\n求$\\sum_{i=1}^n\\sum_{j=1}^m[i≠j](n \\bmod i)(m \\bmod j),n,m\\le 10^9$\n\n数论分块\n\n先不考虑$i!=j$\n\n$$\n\\sum_{i=1}^n\\sum_{j=1}^m(n \\bmod i)(m \\bmod j)\n\\\\\n=\\sum_{i=1}^n(n-i\\left \\lfloor \\frac ni\\right \\rfloor)\\sum_{j=1}^m(m-j\\left \\lfloor \\frac mj\\right \\rfloor)\n$$\n\n考虑$i=j$,设$k=\\min(n,m)$\n\n$$\n\\sum_{i=1}^n\\sum_{j=1}^m(n \\bmod i)(m \\bmod j)[i=j]\n\\\\\n=\\sum_{i=1}^k(n \\bmod i)(m \\bmod i)\n\\\\\n=\\sum_{i=1}^k(n-i\\left \\lfloor \\frac ni \\right \\rfloor)(m-i\\left \\lfloor \\frac mi \\right \\rfloor)\n\\\\\n=\\sum_{i=1}^knm-ni\\left \\lfloor \\frac mi \\right \\rfloor-mi\\left \\lfloor \\frac ni \\right \\rfloor+i^2 \\left \\lfloor \\frac{nm}{i^2}\\right \\rfloor\n\\\\\n=knm-n\\sum_{i=1}^k i\\left \\lfloor \\frac mi \\right \\rfloor-m\\sum_{i=1}^ki\\left \\lfloor \\frac ni \\right \\rfloor+\\sum_{i=1}^ki^2\\left \\lfloor \\frac ni \\right \\rfloor\\left \\lfloor \\frac mi \\right \\rfloor\n$$\n\n两个相减就是答案\n\n提示: $\\sum_{i=1}^n{i^2}=\\frac{n(n+1)(2n+1)}6$\n\n> 推导过程: \n> \n> 设$S=\\sum_{i=1}^n{i^2}$\n> \n> $(n+1)^3-n^3=3n^2+3n+1$\n> \n> $n^3-(n-1)^3=3(n-1)^2+3(n-1)+1$\n> \n> $\\cdots$\n> \n> $2^3-1^3=3\\times1^2+3\\times 1+1$\n> \n> 上面$n$个式子相加得到:\n> \n> $(n+1)^3-1=3(1^2+2^2+\\dots+n^2)+3(1+2+\\dots+n)+n$\n> \n> $\\therefore S=\\frac13\\left[ (n+1)^3-1- \\frac12n(n+1) \\right]=\\frac{n(n+1)(2n+1)}6$\n```cpp\n#include<cstdio>\nconst int P=19940417;\ninline int min(int x,int y){return x<y?x:y;}\ninline int sum(int l,int r){return 1ll*(l+r)*(r-l+1)\/2%P;}\ninline int mi(int n){return 1ll*n*(n+1)%P*(2*n+1)%P*3323403%P;}\ninline int SUM(int l,int r){return (mi(r)-mi(l-1)+P)%P;}\ninline int calc(int k){\n    int ans=1ll*k*k%P;\n    for(int l=1,r=0;l<=k;l=r+1){\n        r=k\/(k\/l);\n        ans=(ans-1ll*sum(l,r)*(k\/l)%P+P)%P;\n    }\n    return ans;\n}\nint main(){\n    int n,m,ans,k;\n    scanf(\"%d%d\",&n,&m);\n    ans=1ll*calc(n)*calc(m)%P;\n    k=min(n,m);\n    ans=(ans-1ll*k*n%P*m%P+P)%P;\n    for(int l=1,r=0;l<=k;l=r+1){\n        r=min(n\/(n\/l),m\/(m\/l));\n        ans=(ans+1ll*n*sum(l,r)%P*(m\/l)%P)%P;\n        ans=(ans+1ll*m*sum(l,r)%P*(n\/l)%P)%P;\n        ans=(ans-1ll*SUM(l,r)*(n\/l)%P*(m\/l)%P+P)%P;\n    }\n    printf(\"%d\\n\",ans);\n}\n```\n","link":null,"tags":["数论","数论分块"],"title":"BZ 2956 模积和"},{"categories":[["刷题记录"]],"content":"\n求$\\sum_{i=0}^k {n \\choose i} \\bmod 2333$\n\n设$p=2333$\n$$\n\\sum_{i=0}^k {n \\choose i} \\bmod p\n\\\\\n=\\sum_{i=0}^k {\\left \\lfloor \\frac np \\right \\rfloor \\choose \\left \\lfloor \\frac ip \\right \\rfloor} {n \\bmod p \\choose i\\bmod p}\\bmod p\n\\\\\n={\\left \\lfloor \\frac np \\right \\rfloor \\choose 0}\\sum_{i=0}^{p-1}{n \\bmod p \\choose i}+{\\left \\lfloor \\frac np \\right \\rfloor \\choose 1}\\sum_{i=0}^{p-1}{n \\bmod p \\choose i}+\n\\cdots+\n{\\left \\lfloor \\frac np \\right \\rfloor \\choose \\left \\lfloor \\frac kp \\right \\rfloor}\\sum_{i=0}^{k \\bmod p}{n \\bmod p \\choose i}\n$$\n\n设$f(n,k)=\\sum_{i=0}^k {n \\choose i}$\n\n原式可以转化为:\n\n$$\nf(n \\bmod p,p-1) \\cdot f(\\left \\lfloor \\frac np \\right \\rfloor,\\left \\lfloor \\frac kp \\right \\rfloor -1)+{\\left \\lfloor \\frac np \\right \\rfloor \\choose \\left \\lfloor \\frac kp \\right \\rfloor} f(n\\bmod p,k\\bmod p)\n$$\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\nconst int N=2335,p=2333;\nll C[N+11][N+11],F[N+11][N+11];\nvoid init(){\n    C[0][0]=1;\n    Fur(i,1,N)C[i][0]=C[i][i]=1;\n    Fur(i,1,N)Fur(j,1,i-1)C[i][j]=(C[i-1][j]+C[i-1][j-1])%p;\n    F[0][0]=1;\n    Fur(i,1,N)F[i][0]=1;\n    Fur(i,0,N)Fur(j,1,N)F[i][j]=(C[i][j]+F[i][j-1])%p;\n}\nll lucas(ll n,ll m){\n    if(n<m)return 0;\n    if(!n)return 1;\n    return lucas(n\/p,m\/p)*C[n%p][m%p]%p;\n}\nll f(ll n,ll k){\n    if(k<0)return 0;\n    if(!n||!k)return 1;\n    if(n<p&&k<p)return F[n][k];\n    return (f(n\/p,k\/p-1)*F[n%p][p-1]%p+lucas(n\/p,k\/p)*f(n%p,k%p)%p)%p;\n}\nint main(){\n    int T;ll n,k;\n    in(T);init();\n    while(T--){\n        in(n,k);\n        out(f(n,k),ln);\n    }\n    flush();\n}\n```\n","link":null,"tags":["数论","组合数","lucas"],"title":"LG 4345 [SHOI2015]超能粒子炮·改"},{"categories":[["刷题记录"]],"content":"\nbsgs裸题\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\nconst int N=100011;\nint n,g,p;\nstruct hash{\n    struct edge{int to,nxt,w;}e[N];\n    int cnt=0,head[N];\n    il void clear(){cnt=0;clr(head,0);}\n    il void add(int x,int y,int w){e[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;e[cnt].w=w;}\n    il void ins(int x,int v){add(x%N,x,v);}\n    il int ask(int x){fl(i,x%N)if(to==x)return e[i].w;return -1;}\n}S;\nint pw(int x,int b){\n    int ans=1;\n    while(b){\n        if(b&1)ans=1ll*ans*x%p;\n        b>>=1;x=1ll*x*x%p;\n    }\n    return ans;\n}\nint bsgs(int y,int z){\n    S.clear();\n    int m=sqrt(p)+1,x=z%p,t=pw(y,m);\n    Fur(i,0,m)S.ins(x,i),x=1ll*x*y%p;\n    x=1;\n    Fur(i,1,m){\n        x=1ll*x*t%p;\n        int k=S.ask(x);\n        if(~k)return i*m-k;\n    }\n    return -1;\n}\nint main(){\n    in(g,p,n);\n    Fur(i,1,n){\n        int A,B,a,b;\n        in(A,B);\n        a=bsgs(g,A);\n        out(pw(B,a),ln);\n    }\n    flush();\n}\n```\n","link":null,"tags":["数论","bsgs"],"title":"LG 4454 [CQOI2018]破解D-H协议"},{"categories":[["刷题记录"]],"content":"\n给出$n,m$求${n+m} \\choose m$\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\nconst int N=100011;\nint n,m,p,fac[N];\nint pw(int x,int b){\n    int ans=1;\n    while(b){\n        if(b&1)ans=1ll*ans*x%p;\n        b>>=1;x=1ll*x*x%p;\n    }\n    return ans;\n}\nint inv(int x){return pw(x,p-2);}\nint C(int n,int m){\n    if(n<m)return 0;\n    return 1ll*fac[n]*inv(fac[m])%p*inv(fac[n-m])%p;\n}\nint lucas(int n,int m){\n    if(n<m)return 0;\n    if(!n)return 1;\n    return 1ll*lucas(n\/p,m\/p)*C(n%p,m%p)%p;\n}\nint main(){\n    fac[0]=1;\n    int T;in(T);\n    while(T--){\n        in(n,m,p);\n        Fur(i,1,p)fac[i]=1ll*fac[i-1]*i%p;\n        out(lucas(n+m,m),ln);\n    }\n    flush();\n}\n```\n","link":null,"tags":["lucas","组合数","数论"],"title":"HDU 3037 Saving Beans"},{"categories":[["刷题记录"]],"content":"\n题意：\n\n求$G^{\\sum d|{N\\choose d}}\\bmod 999911659$\n\n$1 \\le G \\le 10^9,1 \\le N \\le 10^9$\n\n$999911659$是质数,根据欧拉定理:\n\n$G^{\\sum d|{N\\choose d}}\\bmod 999911659 = G^{\\sum d|{N\\choose d} \\bmod 999911658}\\bmod 999911659$\n\n关键求$\\sum d|{N\\choose d} \\bmod 999911658$\n\n模数太大,直接lucas取模会炸\n\n我们可以考虑**将模数分解质因数**\n\n$999911658=2\\times 3 \\times 4679 \\times 35617$\n\n可以用**lucas**后**枚举约数**算出\n\n$$\n\\begin{cases}\na_1=\\sum d|{N\\choose d} \\pmod 2\n\\\\\na_2=\\sum d|{N\\choose d} \\pmod 3\n\\\\\na_3=\\sum d|{N\\choose d} \\pmod {4679}\n\\\\\na_4=\\sum d|{N\\choose d} \\pmod {35617}\n\\end{cases}\n$$\n\n然后通过**crt**求:\n\n$$\n\\begin{cases}\nx \\equiv a_1 \\pmod 2\n\\\\\nx \\equiv a_2 \\pmod 3\n\\\\\nx \\equiv a_3 \\pmod {4679}\n\\\\\nx \\equiv a_4 \\pmod {35617}\n\\end{cases}\n$$\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\nconst int N=100011,M=999911658;\nll n,G,fac[N],p,b[5]={0,2,3,4679,35617},a[5];\nll pw(ll x,ll b,ll mod=p){\n    ll ans=1;\n    while(b){\n        if(b&1)ans=ans*x%mod;\n        b>>=1;x=x*x%mod;\n    }\n    return ans;\n}\nll inv(ll x){return pw(x,p-2);}\nll C(ll n,ll m){\n    if(n<m)return 0;\n    return fac[n]*inv(fac[m])%p*inv(fac[n-m])%p;\n}\nll lucas(ll n,ll m){\n    if(n<m)return 0;\n    if(!n)return 1;\n    return lucas(n\/p,m\/p)*C(n%p,m%p)%p;\n}\nll crt(){\n    ll ans=0;\n    Fur(i,1,4){\n        p=b[i];\n        ans=(ans+a[i]*(M\/p)%M*inv(M\/p))%M;\n    }\n    return ans;\n}\nint main(){\n    in(n,G);\n    if(G%(M+1)==0)return puts(\"0\"),0;\n    fac[0]=1;\n    Fur(t,1,4){\n        p=b[t];\n        Fur(i,1,p)fac[i]=fac[i-1]*i%p;\n        for(int i=1;i*i<=n;++i)\n        if(n%i==0){\n            a[t]=(a[t]+lucas(n,i))%p;\n            if(i*i!=n)a[t]=(a[t]+lucas(n,n\/i))%p;\n        }\n    }\n    printf(\"%lld\\n\",pw(G,crt(),M+1));\n}\n```\n","link":null,"tags":["组合数","数论","lucas","crt","欧拉定理"],"title":"LG 2480 [SDOI2010]古代猪文"},{"categories":[["刷题记录"]],"content":"\n先预处理出每次的攻击力$c_i$,推荐使用multiset\n\n问题变成了:\n\n$c_ix \\equiv a_i \\pmod{p_i}$\n\n可是题目并没有保证$a_i\\le p_i$\n\n\n\n**仔细阅读题目**,可以发现当$a_i>p_i$的时候一定满足$p_i=1$\n\n那么在这个情况答案就是$\\max_{i=1}^n(\\left \\lceil \\frac{a_i}{c_i} \\right \\rceil)$\n\n\n\n接下来就是$a_i \\le p_i$的情况了\n\n标准的Excrt要求$x$的系数必须为$1$\n\n我们可以转化为Exgcd解不定方程\n\n$c_ix \\equiv a_i \\pmod{p_i}$\n\n$c_ix + p_iy = a_i$\n\n可以用Exgcd解出一组解$sx,sy$,并得出\n\n$x=sx+\\lambda \\frac{p_i}{\\gcd(c_i,p_i)}$\n\n也就是\n\n$x\\equiv sx \\pmod{\\frac{p_i}{\\gcd(c_i,p_i)}}$\n\n这样就可以用Excrt求解了\n\n特判: \n\n1. 所有$a_i=p_i$,那么所有$sx=0$,按照上面的方法解是不对的(答案会等于0)\n   \n   直接求出杀死每条龙所需的刀数然后所有刀数求一个lcm即可\n\n   也就是$lcm_{i=1}^n(\\frac{p_i}{\\gcd(c_i,p_i)})$\n\n2. 当$c_i$是$p_i$的倍数的时候杀不死这条龙\n   \n   但这时如果$a_i=p_i$,这个方程相当于没用,可以换成$x \\equiv 0 \\pmod 1$之类的\n   \n记得全部开`long long`,用龟速乘\n```cpp\n#include<bits\/stdc++.h>\n#pragma GCC optimize(3)\n#define il __inline__ __attribute__ ((always_inline))\n#define ll long long\n#define MB template <class T>il\n#define Fur(i,x,y) for(int i(x);i<=y;++i)\nMB T MAX(T x,T y){return x>y?x:y;}\nMB T GCD(T x,T y){return y?GCD(y,x%y):x;}\nusing namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\nconst int N=100011;\nil ll mul(ll x,ll y,ll p){\n    ll res=0;\n    while(y){\n        if(y&1)res=(res+x)%p;\n        y>>=1;x=(x+x)%p;\n    }\n    return res;\n}\nll exgcd(ll a,ll b,ll &x,ll &y){\n    if(!b){x=1;y=0;return a;}\n    ll gcd=exgcd(b,a%b,x,y),t=x;\n    x=y;y=t-a\/b*y;\n    return gcd;\n}\nint n,m;ll a[N],p[N],c[N],ext[N];\nil ll excrt(){\n    ll ans=a[1],M=p[1],t,y;\n    Fur(i,2,n){\n        ll b=p[i],c=(a[i]-ans%b+b)%b,gcd=exgcd(M,b,t,y); \/\/Mx \\equiv c \\pmod b\n        if(c%gcd)return -1;\n        t=mul(t,c\/gcd,b\/gcd);\n        ans+=t*M;\n        M*=b\/gcd;\n        ans=(ans%M+M)%M;\n    }\n    return ans;\n}\nil void solve2(){\n    ll ans=1;\n    Fur(i,1,n)ll x=p[i]\/GCD(p[i],c[i]),ans=ans\/GCD(ans,x)*x;\n    out(ans,ln);\n}\nil void solve3(){\n    ll ans=0;\n    Fur(i,1,n)ans=MAX(ans,(a[i]+c[i]-1)\/c[i]);\n    out(ans,ln);\n}\nil void solve(){\n    in(n,m);\n    Fur(i,1,n)in(a[i]);\n    Fur(i,1,n)in(p[i]);\n    Fur(i,1,n)in(ext[i]);\n    multiset<ll>s;ll x;\n    Fur(i,1,m)in(x),s.insert(x);\n    Fur(i,1,n){\n        multiset<ll>::iterator it;\n        if(a[i]<=*s.begin())it=s.begin();\n        else it=--s.upper_bound(a[i]);\n        c[i]=*it;\n        s.erase(it);s.insert(ext[i]);\n    }\n    Fur(i,1,n)if(p[i]!=a[i])goto skip;\n    solve2();return;\/\/ 所有ai=pi\n    skip:;\n    Fur(i,1,n)if(p[i]!=1)goto SKIP;\n    solve3();return;\/\/ 所有pi=1\n    SKIP:;\n    Fur(i,1,n)c[i]%=p[i];\n    Fur(i,1,n)if(p[i]==c[i]){\n        if(a[i]==p[i])c[i]=1,p[i]=1,a[i]=0;\n        else return void(out(\"-1\\n\"));\n    }\n    Fur(i,1,n){\n        ll sx,sy,gcd=exgcd(c[i],p[i],sx,sy);\n        if(a[i]%gcd)return void(out(\"-1\\n\"));\n        p[i]\/=gcd;\n        sx=(sx%p[i]+p[i])%p[i];\n        a[i]=mul(sx,a[i]\/gcd,p[i]);\n    }\n    out(excrt(),ln);\n}\nint main(){\n    int T;in(T);\n    while(T--)solve();\n    flush();\n}\n```\n","link":null,"tags":["数论","exgcd","excrt"],"title":"LG 4774 [NOI2018]屠龙勇士"},{"categories":[["刷题记录"]],"content":"\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\nconst int N=100011;\nint n;\nint main(){\n    \n}\n```\n","link":null,"tags":["fft","ntt","crt"],"title":"LG 4245 【模板】任意模数NTT"},{"categories":[["刷题记录"]],"content":"\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;rg char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\nconst int N=100011;\nint n;ll m[N],a[N];\nll exgcd(ll a,ll b,ll &x,ll &y){\n    if(!b){x=1,y=0;return a;}\n    ll gcd=exgcd(b,a%b,x,y),t=x;\n    x=y;y=t-a\/b*y;\n    return gcd;\n}\nll mul(ll x,ll b,ll p){\n    ll ans=0;\n    while(b){\n        if(b&1)ans=(ans+x)%p;\n        b>>=1;x=(x+x)%p;\n    }\n    return ans;\n}\nll excrt(){\n    ll ans=a[1],M=m[1],t,y;\n    Fur(i,2,n){\n        ll b=m[i],c=(a[i]-ans%b+b)%b,\n            gcd=exgcd(M,b,t,y);\n        if(c%gcd)return -1;\n        t=mul(t,c\/gcd,b\/gcd);\n        ans+=t*M;\n        M*=b\/gcd;\n        ans=(ans%M+M)%M;\n    }\n    return ans;\n}\nint main(){\n    in(n);\n    Fur(i,1,n)in(m[i],a[i]);\n    printf(\"%lld\\n\",excrt());\n}\n```\n","link":null,"tags":["crt","excrt","数论"],"title":"LG 1495 【模板】中国剩余定理"},{"categories":[["刷题记录"]],"content":"\n$K^x \\equiv 1 \\pmod M$\n\n求最小的非负整数$x$\n\n~~最近刚学了bsgs,一眼看成exbsgs~~\n\nexbsgs可以,但是比较麻烦\n\n看到最后是$1$,我们可以想到欧拉定理:\n\n$$K^{\\varphi(M)} \\equiv 1 \\pmod M(\\gcd(K,M)=1)$$\n\n可以发现,答案是$\\varphi(M)$的约数,那么枚举$\\varphi(M)$的约数即可(可以一直尝试枚举删掉约数)\n\n当$\\gcd(K,M)!=1$时无解\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\nconst int N=100011;\nint m,k,pri[N],t[N];\nint getphi(int m){\n    int phi=m,p;\n    for(int i=2;i*i<=m;++i)\n    if(m%i==0){\n        while(m%i==0)m\/=i;\n        phi-=phi\/i;\n    }\n    if(m)phi-=phi\/m;\n    return phi;\n}\nint pw(int x,int b,int p){\n    int ans=1;\n    while(b){\n        if(b&1)ans=1ll*ans*x%p;\n        b>>=1;x=1ll*x*x%p;\n    }\n    return ans;\n}\nint main(){\n    in(m,k);\n    if(GCD(m,k)!=1)return puts(\"Let's go Blue Jays!\"),0;\n    int p,phi=getphi(m),cnt=0;\n    p=phi;\n    for(int i=2;i*i<=phi;++i)\n    if(phi%i==0){\n        pri[++cnt]=i;\n        while(phi%i==0)phi\/=i,++t[cnt];\n    }\n    if(phi!=1)pri[++cnt]=phi,t[cnt]=1;\n    Fur(x,1,cnt){\n        Fur(i,1,t[x])\n        if(pw(k,p\/pri[x],m)==1)p\/=pri[x];\n        else break;\n    }\n    printf(\"%d\\n\",p);\n}\n```\n","link":null,"tags":["bsgs","二进制","数论","欧拉定理"],"title":"LG 4861 按钮"},{"categories":[["刷题记录"]],"content":"\n$$\n\\overbrace{111\\dots111}^{\\text{N个1}} \\equiv k \\pmod m\n\\\\\n\\frac{10^N-1}9\\equiv k \\pmod m\n\\\\\n10^N\\equiv 9k+1 \\pmod m\n$$\n\n顺利地推出是bsgs,($m$是质数,也就不用exbsgs了)\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define register\n    #define ll __int128\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\nconst int N=10000007;\n\/\/ struct hash{\n\/\/     struct edge{int nxt;ll to,w;}e[N];\n\/\/     int head[N],cnt=0;\n\/\/     il void add(int x,ll y,ll w){e[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;e[cnt].w=w;}\n\/\/     il void ins(ll x,ll v){add(x%N,x,v);}\n\/\/     il ll ask(ll x){fl(i,x%N)if(to==x)return e[i].w;return -1;}\n\/\/ }S;\nmap<ll,ll>S;\nil ll pw(ll x,ll b,ll p){\n    ll ans=1;\n    while(b){\n        if(b&1)ans=ans*x%p;\n        b>>=1;x=x*x%p;\n    }\n    return ans;\n}\nll bsgs(ll y,ll z,ll p){\n    y%=p;z%=p;\n    if(!y){if(!z)return 1;return -1;}\n    ll m=(ll)sqrt((db)p)+1,x=z%p,t=pw(y,m,p);\n    Fur(i,0,m)S[x]=i+1,x=x*y%p;\n    x=1;\n    Fur(i,1,m){\n        x=x*t%p;\n        ll k=S[x]-1;\n        if(~k)return ((i*m-k)%p+p)%p;\n    }\n    return -1;\n}\nint main(){\n    ll k,m;\n    in(k,m);\n    printf(\"%lld\\n\",bsgs(10,9*k+1,m));\n}\n```\n","link":null,"tags":["数论","bsgs"],"title":"LG 4884 多少个1"},{"categories":[["刷题记录"]],"content":"\n# 扩展中国剩余定理\n\n给定方程组:\n\n$$\n\\begin{cases}\nx \\equiv a_1\\ ({\\rm mod}\\ m_1)\n\\\\\nx\\equiv a_2\\ ({\\rm mod}\\ m_2)\n\\\\\n...\n\\\\\nx \\equiv a_n\\ ({\\rm mod}\\ m_n)\n\\end{cases}\n$$\n\n求最小的非负整数$x$\n\n假设我们求出了前$i-1$组的解$x_{i-1}$\n\n设$M=\\operatorname{lcm}(m_1,m_2,\\cdots,m_{i-1})$\n\n则$x_{i-1}+\\lambda M \\equiv a_{i-1} \\pmod{m_{i-1}}(\\lambda \\in \\Z)$\n\n那么我们需要求出最小的非负整数$t$使:\n\n$x_{i-1}+tM\\equiv a_i \\pmod{m_i}$\n\n也就是$Mt\\equiv a_i-x_{i-1} \\pmod{m_i}$\n\n可以使用Exgcd求解$t$ ($ax\\equiv c \\pmod b$)\n\n如果无解,则整个方程误解\n\n若有解,$x_i=x_{i-1}+tM$\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;rg char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\nconst int N=100011;\nint n;ll a[N],m[N];\nll exgcd(ll a,ll b,ll &x,ll &y){\n    if(!b){x=1,y=0;return a;}\n    ll gcd=exgcd(b,a%b,x,y),t=x;\n    x=y;y=t-a\/b*y;\n    return gcd;\n}\nll mul(ll x,ll b,ll p){\n    ll ans=0;\n    while(b){\n        if(b&1)ans=(ans+x)%p;\n        b>>=1;x<<=1;x%=p;\n    }\n    return ans;\n}\nll excrt(){\n    ll ans=a[1],M=m[1],t,y;\n    Fur(i,2,n){\n        ll b=m[i],c=(a[i]-ans%b+b)%b,\n            gcd=exgcd(M,b,t,y);\n        if(c%gcd)return -1;\n        t=mul(t,c\/gcd,b\/gcd);\n        ans+=t*M;\n        M*=b\/gcd;\n        ans=(ans%M+M)%M;\n    }\n    return ans;\n}\nint main(){\n    in(n);\n    Fur(i,1,n)in(m[i],a[i]);\n    printf(\"%lld\\n\",excrt());\n}\n```\n","link":null,"tags":["数论","crt","excrt"],"title":"LG 4777 【模板】扩展中国剩余定理"},{"categories":[["算法","数论"],["note"]],"content":"\n\n# 扩展中国剩余定理\n\n给定方程组:\n\n$$\n\\begin{cases}\nx \\equiv a_1\\ ({\\rm mod}\\ m_1)\n\\\\\nx\\equiv a_2\\ ({\\rm mod}\\ m_2)\n\\\\\n...\n\\\\\nx \\equiv a_n\\ ({\\rm mod}\\ m_n)\n\\end{cases}\n$$\n\n求最小的非负整数$x$\n\n假设我们求出了前$i-1$组的解$x_{i-1}$\n\n设$M=\\operatorname{lcm}(m_1,m_2,\\cdots,m_{i-1})$\n\n则$x_{i-1}+\\lambda M \\equiv a_{i-1} \\pmod{m_{i-1}}(\\lambda \\in \\Z)$\n\n那么我们需要求出最小的非负整数$t$使:\n\n$x_{i-1}+tM\\equiv a_i \\pmod{m_i}$\n\n也就是$Mt\\equiv a_i-x_{i-1} \\pmod{m_i}$\n\n可以使用Exgcd求解$t$ ($ax\\equiv c \\pmod b$)\n\n如果无解,则整个方程误解\n\n若有解,$x_i=x_{i-1}+tM$\n\n[LG P4777 【模板】扩展中国剩余定理（EXcrt）](https:\/\/www.luogu.com.cn\/problem\/P4777)\n\n代码:\n\n```cpp\nconst int N=100011;\nint n;ll m[N],a[N];\nll exgcd(ll a,ll b,ll &x,ll &y){\n    if(!b){x=1,y=0;return a;}\n    ll gcd=exgcd(b,a%b,x,y),t=x;\n    x=y;y=t-a\/b*y;\n    return gcd;\n}\nll mul(ll x,ll b,ll p){\n    ll ans=0;\n    while(b){\n        if(b&1)ans=(ans+x)%p;\n        b>>=1;x=(x+x)%p;\n    }\n    return ans;\n}\nll excrt(){\n    ll ans=a[1],M=m[1],t,y;\n    Fur(i,2,n){\n        ll b=m[i],c=(a[i]-ans%b+b)%b,\n            gcd=exgcd(M,b,t,y);\n        if(c%gcd)return -1;\n        t=mul(t,c\/gcd,b\/gcd);\n        ans+=t*M;\n        M*=b\/gcd;\n        ans=(ans%M+M)%M;\n    }\n    return ans;\n}\nint main(){\n    in(n);\n    Fur(i,1,n)in(m[i],a[i]);\n    printf(\"%lld\\n\",excrt());\n}\n```","link":null,"tags":["算法","数论"],"title":"excrt"},{"categories":[],"content":"\n\n# test\n\n## test\n\n### test\n\n#### test\n\n$Q\\omega Q$\n\n$$\nQ\\omega Q\n$$\n\n**QwQ**\n\n*QwQ*\n\n~~QwQ~~\n\n<u>QwQ<\/u>\n\n```plain\n$Q\\omega Q$\n\n$$Q\\omega Q$$\n```\n\n`$Q\\omega Q$`\n\n`$$Q\\omega Q$$`\n\n## C++\n\n```cpp\n#include<bits\/stdc++.h>\nusing namespace std;\nint main(){\n    cout<<\"hello the world\"<<endl;\n}\n```\n\n## Python\n\n```python\nprint(\"hello the world\")\n```\n\n## Bash\n\n```bash\necho \"hello the world\"\n```\n\n## JavaScript\n\n```javascript\nconsole.log(\"hello the world\");\n```\n\n## Free Pascal\n\n```\nbegin\n    writeln(\"hello the world\");\nend.\n```\n\n## Java\n\n```java\nSystem.out.println(\"hello the world\")\n```\n\n## Ruby\n\n```ruby\nprint \"hello the world\"\n```","link":null,"tags":["test"],"title":"test"},{"categories":[["刷题记录"]],"content":"\n线段树合并的时候取$\\min(\\text{交换前},\\text{交换后})$\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\nconst int N=200011;\nint n,sz=0,s[N*20],ls[N*20],rs[N*20];\nll ans=0,u=0,v=0;\nint upd(int p,int l=1,int r=n){\n    int rt=++sz;s[rt]=1;\n    if(l==r)return rt;\n    int m=(l+r)>>1;\n    if(p<=m)ls[rt]=upd(p,l,m);\n    else rs[rt]=upd(p,m+1,r);\n    return rt;\n}\nint mg(int x,int y,int l=1,int r=n){\n    if(!x||!y)return x|y;\n    if(l==r)return s[x]+=s[y],x;\n    u+=1ll*s[rs[x]]*s[ls[y]];\n    v+=1ll*s[ls[x]]*s[rs[y]];\n    int m=(l+r)>>1;\n    ls[x]=mg(ls[x],ls[y],l,m);\n    rs[x]=mg(rs[x],rs[y],m+1,r);\n    s[x]=s[ls[x]]+s[rs[x]];\n    return x;\n}\nint dfs(){\n    int pos,val;in(val);\n    if(val)pos=upd(val);\n    else{\n        int ls=dfs(),rs=dfs();\n        u=0,v=0;\n        pos=mg(ls,rs);\n        ans+=MIN(u,v);\n    }\n    return pos;\n}\nint main(){\n    in(n);\n    dfs();\n    printf(\"%lld\\n\",ans);\n}\n```\n","link":null,"tags":["线段树合并","逆序对","dfs"],"title":"LG 3521 [POI2011]ROT-Tree Rotations"},{"categories":[["算法","数论"],["note"]],"content":"\n\n## Lucas定理\n\n$$C_n^m\\pmod p\\equiv C_{n\\mod p}^{m\\mod p} \\cdot C_{\\lfloor n\/p\\rfloor}^{\\lfloor m\/p\\rfloor}\\pmod p$$\n\n就是一个组合数可以拆成P进制下的乘积\n\n这个算法可以处理当m,n非常大而$p$较小的时候的取模\n\n```cpp\nint C(int n,int m){\n    if(n<m)return 0;\n    return 1ll*fac[n]*inv(fac[m])%p*inv(fac[n-m])%p;\n}\nint lucas(int n,int m){\n    if(n<m)return 0;\n    if(!n)return 1;\n    return 1ll*lucas(n\/p,m\/p)*C(n%p,m%p)%p;\n}\n```\n\n扩展：仅当$(n\\&m)=m$时,$C(n,m) \\equiv 1 \\bmod 2$\n\n## 扩展lucas\n\n当模数$p$过大或者$p$不是质数的时候就不能直接用lucas了\n\n似乎扩展lucas和lucas没太大关系,会`exgcd`和`crt`就可以了\n\n设$p=p_1^{k_1}p_2^{k_2}\\dots p_n^{k_n}$\n\n求出每个${n\\choose m} \\equiv a_i \\pmod {p_i^{k_i}}$\n\n得到同余方程组\n\n$$\n\\begin{cases}\n{n\\choose m} \\equiv a_1 \\pmod {p_1^{k_1}}\n\\\\\n{n\\choose m} \\equiv a_2 \\pmod {p_1^{k_2}}\n\\\\\n\\vdots\n\\\\\n{n\\choose m} \\equiv a_n \\pmod {p_n^{k_n}}\n\\end{cases}\n$$\n\n使用`crt`即可求出$n\\choose m$的值\n\n$p^t$不是质数,那么如何求${n\\choose m} \\mod p^t$呢?\n\n可以计算${n\\choose m}=\\frac{n!}{m!(n-m)!}$,分别计算出$n!,m!,(n-m)!$在模$p^t$意义下的值\n\n假设$p=3,t=2,n=19$,\n\n$$\nn!=1\\cdot 2\\cdot 3\\cdots 19\n\\\\\n=(1\\cdot 2\\cdot 4\\cdot 5\\cdot 7\\cdot 8\\cdot 10\\cdot 11\\cdot 13\\cdot 14\\cdot 16\\cdot 17\\cdot 19)\\cdot (3\\cdot 6\\cdot 9\\cdot 12\\cdot 15\\cdot 18)\n\\\\ \n=(1\\cdot 2\\cdot 4\\cdot 5\\cdot 7\\cdot 8\\cdot 10\\cdot 11\\cdot 13\\cdot 14\\cdot 16\\cdot 17\\cdot 19)\\cdot 3^6\\cdot(1\\cdot2\\cdot3\\cdot4\\cdot5\\cdot6)\n$$\n\n可以发现后面的部分相当于$\\left\\lfloor \\frac np \\right\\rfloor!$,递归计算即可\n\n前半部分以$p^t$为周期,即\n\n$1\\cdot 2\\cdot 4\\cdot 5\\cdot 7\\cdot 8 \\equiv 10\\cdot 11\\cdot 13\\cdot 14\\cdot 16\\cdot 17 \\pmod {3^2}$\n\n只需要计算不满足周期的数$19$就可以了","link":null,"tags":["数论","组合数","算法","二进制"],"title":"Lucas"},{"categories":[["刷题记录"]],"content":"\n先离散化权值为排名,从大到小排序\n\n遍历所有点,用权值树状数组统计,结果是 遍历完该子树后答案 - 遍历该子树前答案\n\n(为什么一开始会去想什么dsu on tree和线段树合并\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\nconst int N=100011;\nint n,cnt=0,rnk[N],SZ=0,head[N],s[N],ANS[N];\nstruct node{int v,p;bool operator<(node t){return v>t.v;}}b[N];\nstruct edge{int to,nxt;}e[N];\nil void add(int x,int y){e[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;}\nil void upd(int p){for(int i=p;i<=SZ;i+=i&-i)++s[i];}\nil int ask(int p){int ans=0;for(int i=p;i;i-=i&-i)ans+=s[i];return ans;}\nvoid dfs(int x){\n    ANS[x]-=ask(rnk[x]-1);\n    fl(i,x)dfs(to);\n    ANS[x]+=ask(rnk[x]-1);\n    upd(rnk[x]);\n}\nint main(){\n    in(n);\n    int x;\n    Fur(i,1,n)in(b[i].v),b[i].p=i;\n    sort(b+1,b+n+1);\n    Fur(i,1,n)rnk[b[i].p]=(SZ+=(b[i].v!=b[i-1].v));\n    Fur(i,2,n)in(x),add(x,i);\n    dfs(1);\n    Fur(i,1,n)out(ANS[i],ln);\n    flush();\n}\n```\n","link":null,"tags":["离散化","树状数组","线段树合并","静态链分治","差分"],"title":"LG 3605 [USACO17JAN]Promotion Counting P"},{"categories":[["刷题记录"]],"content":"\n树上差分,统计的时候每个节点都合并自身子节点的结果\n\n每个点都维护一颗动态开点权值线段树\n\n在$x\\leftrightarrow y$区间加可以看成$x,y$的$w$位置$+1$,$lca(x,y),f_{lca(x,y)}$的$w$位置$-1$\n\n统计的时候不断向上线段树合并\n\n具体看代码\n```cpp\n#include<bits\/stdc++.h>\n#define il __inline__ __attribute__ ((always_inline))\n#define Fur(i,x,y) for(int i(x);i<=y;++i)\n#define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\nconst int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}\nconst int N=100011;\nint n,q,cnt=0,sz=0,head[N],s[N*60],S[N*60],ls[N*60],rs[N*60],RT[N],ans[N];\nil void pu(int rt){s[ls[rt]]>=s[rs[rt]]?(s[rt]=s[ls[rt]],S[rt]=S[ls[rt]]):(s[rt]=s[rs[rt]],S[rt]=S[rs[rt]]);}\nvoid upd(int &rt,int x,int v,int l=1,int r=100000){\n    if(!rt)rt=++sz;\n    if(l==r){s[rt]+=v;S[rt]=l;return;}\n    int m=(l+r)>>1;\n    if(x<=m)upd(ls[rt],x,v,l,m);\n    else upd(rs[rt],x,v,m+1,r);\n    pu(rt);\n}\nint mg(int x,int y,int l=1,int r=100000){\n    if(!x||!y)return x|y;\n    if(l==r)return s[x]+=s[y],S[x]=l,x;\n    int m=(l+r)>>1;\n    ls[x]=mg(ls[x],ls[y],l,m); \n    rs[x]=mg(rs[x],rs[y],m+1,r);\n    pu(x);return x;\n}\nstruct edge{int to,nxt;}e[N<<1];\nil void add(int x,int y){e[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;}\nint d[N],top[N],siz[N],f[N];\nvoid dfs(int x){\n    siz[x]=1;\n    fl(i,x)if(to!=f[x]){\n        f[to]=x;d[to]=d[x]+1;\n        dfs(to);\n        siz[x]+=siz[to];\n    }\n}\nvoid bt(int x,int tp){\n    top[x]=tp;int k=0;\n    fl(i,x)if(to!=f[x]&&siz[to]>siz[k])k=to;\n    if(k)bt(k,tp);\n    fl(i,x)if(!top[to])bt(to,to);\n}\nil int lca(int x,int y){\n    while(top[x]!=top[y])\n        d[top[x]]>d[top[y]]?x=f[top[x]]:y=f[top[y]];\n    return d[x]<d[y]?x:y;\n}\nvoid solve(int x){\n    fl(i,x)if(to!=f[x])\n        solve(to),\n        RT[x]=mg(RT[x],RT[to]);\n    if(s[RT[x]])ans[x]=S[RT[x]];\n}\nint main(){\n    in(n,q);\n    int x,y,w;\n    Fur(i,2,n)in(x,y),add(x,y),add(y,x);\n    dfs(1);bt(1,1);\n    while(q--){\n        in(x,y,w);\n        int t=lca(x,y);\n        upd(RT[x],w,1);upd(RT[y],w,1);\n        upd(RT[t],w,-1);upd(RT[f[t]],w,-1);\n    }\n    solve(1);\n    Fur(i,1,n)out(ans[i]),pt('\\n');\n    flush();\n}\n```\n","link":null,"tags":["线段树合并","lca","差分"],"title":"LG 4556 [Vani有约会]雨天的尾巴"},{"categories":[["刷题记录"]],"content":"\n看题意想到了主席树和LCT\n\nLCT套主席树可行,但是比较麻烦,我们用另一种方法\n\n启发式合并+主席树($\\mathcal{n \\log^2 n}$)\n\n每次将小的插入到大的,顺便更新倍增LCA\n\n每个节点在父节点的基础上插入自身的值\n\n即每个节点的主席树记录的是自身到根节点的路径\n\n具体看代码\n```cpp\n#include<bits\/stdc++.h>\n#define il __inline__ __attribute__ ((always_inline))\n#define Fur(i,x,y) for(int i(x);i<=y;++i)\n#define Fdr(i,x,y) for(int i(x);i>=y;--i)\n#define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\nil void SWAP(int &x,int &y){int t=x;x=y;y=t;}\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\nconst int N=80011;\nstruct node{int v,p;bool operator<(node t){return v<t.v;}}b[N];\nint val[N],rnk[N];\nint cnt=0,head[N];\nint d[N],fa[N],f[17][N],siz[N];\nint SZ=0,sz=0,RT[N],ls[N*600],rs[N*600],s[N*600];\nbool v[N];\nstruct edge{int to,nxt;}e[N<<2];\nil void add(int x,int y){e[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;}\nint gf(int x){return (fa[x]==x)?x:(fa[x]=gf(fa[x]));}\nvoid build(int &x,int l,int r){\n    s[x=++sz]=0;\n    if(l==r)return;\n    int m=(l+r)>>1;\n    build(ls[x],l,m);build(rs[x],m+1,r);\n}\nvoid ins(int &x,int pre,int l,int r,int v){\n    s[x=++sz]=s[pre]+1;\n    ls[x]=ls[pre];rs[x]=rs[pre];\n    if(l==r)return;\n    int m=(l+r)>>1;\n    if(v<=m)ins(ls[x],ls[pre],l,m,v);\n    else ins(rs[x],rs[pre],m+1,r,v);\n}\nint ask(int x,int y,int lca,int flca,int l,int r,int k){\n    if(l==r)return val[l];\n    int m=(l+r)>>1,sum=s[ls[x]]+s[ls[y]]-s[ls[lca]]-s[ls[flca]];\n    if(k<=sum)return ask(ls[x],ls[y],ls[lca],ls[flca],l,m,k);\n    else return ask(rs[x],rs[y],rs[lca],rs[flca],m+1,r,k-sum);\n}\nvoid dfs(int x,int F,int rt){\n    ++siz[rt];\n    d[x]=d[f[0][x]=fa[x]=F]+1;\n    Fur(i,1,16)f[i][x]=f[i-1][f[i-1][x]];\n    v[x]=1;\n    ins(RT[x],RT[F],1,SZ,rnk[x]);\n    fl(i,x)if(to!=F)dfs(to,x,rt);\n}\nil int lca(int x,int y){\n    if(d[x]<d[y])SWAP(x,y);\n    Fdr(i,16,0)if(d[f[i][x]]>=d[y])x=f[i][x];\n    if(x==y)return x;\n    Fdr(i,16,0)if(f[i][x]!=f[i][y])\n        x=f[i][x],y=f[i][y];\n    return f[0][x];\n}\nint main(){\n    int n,m,q,lastans=0;\n    in(n);\n    in(n,m,q);\n    Fur(i,1,n)in(b[i].v),b[i].p=i,fa[i]=i;\n    std::sort(b+1,b+n+1);b[0].v=-(1<<30);\n    Fur(i,1,n)val[rnk[b[i].p]=(SZ+=(b[i].v!=b[i-1].v))]=b[i].v;\n    int x,y,k,t;char ch;\n    Fur(i,1,m)in(x,y),add(x,y),add(y,x);\n    build(RT[0],1,SZ);\n    Fur(i,1,n)if(!v[i])dfs(i,0,i),fa[i]=i;\n    while(q--){\n        in(ch,x,y);\n        x^=lastans;y^=lastans;\n        if(ch=='Q'){\n            in(k);k^=lastans;t=lca(x,y);\n            out(lastans=ask(RT[x],RT[y],RT[t],RT[f[0][t]],1,SZ,k),ln);\n        }\n        else{\n            add(x,y),add(y,x);\n            if(siz[gf(x)]>siz[gf(y)])SWAP(x,y);\n            dfs(x,y,gf(y));\n        }\n    }\n    flush();\n}\n```\n","link":null,"tags":["启发式合并","主席树","lca","倍增"],"title":"LG 3302 [SDOI2013]森林"},{"categories":[["刷题记录"]],"content":"\n题意: \n\n给一棵trie树,可以删掉某一层的所有边\n\n求删掉哪一层边后合并出的trie树最小？\n\n解法: \n\ntrie的启发式合并\n\n```cpp\nint mg(int x,int y){\n    if(!x||!y)return x+y;\n    int now=++cnt;\n    Fur(i,0,25)c[now][i]=mg(c[x][i],c[y][i]);\n    return now;\n}\n```\n\n这个合并的复杂度是$\\Theta(\\log n)$的\n\n证明:\n\n> 每次合并向下递归的时候规模$n$会变成原来的一半$\\frac n2$\n> \n> 所以最多需要合并$\\log_2 n$次\n\n代码: \n```cpp\n#include<bits\/stdc++.h>\n#define il __inline__ __attribute__ ((always_inline))\n#define Fur(i,x,y) for(int i(x);i<=y;++i)\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}}using namespace IO;\nconst int N=600011;\nint n,cnt,c[N][26],a[N];\nint mg(int x,int y){\n    if(!x||!y)return x+y;\n    int now=++cnt;\n    Fur(i,0,25)c[now][i]=mg(c[x][i],c[y][i]);\n    return now;\n}\nvoid dfs(int x,int d){\n    int now=n+1;cnt=n+1;\n    Fur(i,0,25)if(c[x][i])\n        now=mg(now,c[x][i]);\n    a[d]+=cnt-n-1;\n    Fur(i,0,25)if(c[x][i])\n        dfs(c[x][i],d+1);\n}\nint main(){\n    in(n);\n    int x,y,ans=0,as=0;char w;\n    Fur(i,2,n)in(x,y,w),c[x][w-'a']=y;\n    dfs(1,1);\n    Fur(i,1,n)if(a[i]>ans)as=i,ans=a[i];\n    printf(\"%d\\n%d\\n\",n-ans,as);\n}\n```\n","link":null,"tags":["trie","启发式合并"],"title":"LG CF778C Peterson Polyglot"},{"categories":[["算法","树论"],["算法","数据结构"],["算法","技巧"],["note"]],"content":"\n总结一下各种启发式合并\n\n## 什么是启发式合并\n\n可以算是一种技巧\n\n比如要合并集合$A,B$,设$|A|<|B|$\n\n这时候将 向$B$中插入$A$ 的效率要比 向$A$插入$B$ 高\n\n这就是启发式合并的思想\n\n> Q: 很简单,但有什么用?\n> \n> A: 假设我们要合并$n$个元素\n> \n> 按普通方法,最坏的复杂度$\\Theta(n^2)$\n> \n> 假设我们按照启发式合并,可以证明每个元素最多被合并$\\log n$次\n> \n> 这样以来总复杂度不会超过$n \\log n$\n> \n> 是不是很玄学又神奇?\n\n启发式合并还可以可以应用在数据结构上(如线段树,平衡树,堆等),复杂度$O(n \\log^2 n)$\n\n## 链表的启发式合并\n\n[LG 3201 \\[HNOI2009\\]梦幻布丁](https:\/\/www.luogu.com.cn\/problem\/P3201)\n\n其实可以说是前向星\n\n每次都把短的链表接到长的链表上\n\n统计短的链表上每个元素改变后造成的影响\n\n```cpp\nconst int N=1000011;\nint n,q,a[N],ans=0,st[N],bl[N],head[N],nxt[N],sz[N];\nil void mg(int x,int y){\n    for(int i=head[x];i;i=nxt[i])ans-=(a[i-1]==y)+(a[i+1]==y);\n    for(int i=head[x];i;i=nxt[i])a[i]=y;\n    sz[y]+=sz[x];nxt[st[x]]=head[y];head[y]=head[x];\n    head[x]=st[x]=sz[x]=0;\n}\nint main(){\n    in(n,q);\n    Fur(i,1,n){\n        in(a[i]);\n        if(a[i]!=a[i-1])++ans;\n        bl[a[i]]=a[i];\n        if(!st[a[i]])st[a[i]]=i;\n        ++sz[a[i]];nxt[i]=head[a[i]];head[a[i]]=i;\n    }\n    while(q--){\n        int opt,x,y;\n        in(opt);\n        if(opt==2)out(ans,ln);\n        else{\n            in(x,y);\n            if(x!=y){\n                if(sz[bl[x]]>sz[bl[y]])SWAP(bl[x],bl[y]);\n                if(sz[bl[x]])mg(bl[x],bl[y]);\n            }\n        }\n    }\n}\n```\n\n## 堆的启发式合并\n\n[LG 5290 \\[十二省联考2019\\]春节十二响](https:\/\/www.luogu.com.cn\/problem\/P5290)\n\n题目的意思就是相同子树中的点不能分配到同一段内存\n\n每个点都开一个大根堆\n\n合并一个点和它的子节点的时候最大值互相对应\n\n启发式合并\n\n具体看代码\n\n```cpp\nconst int N=200011;\nint n,cnt=0,head[N],a[N],id[N],dfn=0,tmp[N],tp=0;\nstruct edge{int to,nxt;}e[N];\nil void add(int x,int y){e[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;}\nstd::priority_queue<int>q[N];\nil int max(int x,int y){return x>y?x:y;}\nil void swap(int &x,int &y){int t=x;x=y;y=t;}\nvoid dfs(int x){\n    id[x]=++dfn;\n    fl(i,x){\n        dfs(to);\n        if(q[id[x]].size()<q[id[to]].size())swap(id[x],id[to]);\n        int t=q[id[to]].size();tp=0;\n        while(t--)\n            tmp[++tp]=max(q[id[x]].top(),q[id[to]].top()),\n            q[id[x]].pop(),q[id[to]].pop();\n        while(tp)q[id[x]].push(tmp[tp--]);\n    }\n    q[id[x]].push(a[x]);\n}\nint main(){\n    in(n);\n    int x;\n    Fur(i,1,n)in(a[i]);\n    Fur(i,2,n)in(x),add(x,i);\n    dfs(1);\n    ll ans=0;\n    while(!q[id[1]].empty())\n        ans+=q[id[1]].top(),\n        q[id[1]].pop();\n    printf(\"%lld\\n\",ans);\n}\n```\n\n## Trie的启发式合并\n\n[CF 788 C](https:\/\/www.luogu.com.cn\/problem\/CF778C)\n\n题意: \n\n给一棵trie树,可以删掉某一层的所有边\n\n求删掉哪一层边后合并出的trie树最小？\n\n解法: \n\ntrie的启发式合并\n\n```cpp\nint mg(int x,int y){\n    if(!x||!y)return x+y;\n    int now=++cnt;\n    Fur(i,0,25)c[now][i]=mg(c[x][i],c[y][i]);\n    return now;\n}\n```\n\n这个合并的复杂度是$\\Theta(\\log n)$的\n\n证明:\n\n> 每次合并向下递归的时候规模$n$会变成原来的一半$\\frac n2$\n> \n> 所以最多需要合并$\\log_2 n$次\n\n代码: \n\n```cpp\nconst int N=600011;\nint n,cnt,c[N][26],a[N];\nint mg(int x,int y){\n    if(!x||!y)return x+y;\n    int now=++cnt;\n    Fur(i,0,25)c[now][i]=mg(c[x][i],c[y][i]);\n    return now;\n}\nvoid dfs(int x,int d){\n    int now=n+1;cnt=n+1;\n    Fur(i,0,25)if(c[x][i])\n        now=mg(now,c[x][i]);\n    a[d]+=cnt-n-1;\n    Fur(i,0,25)if(c[x][i])\n        dfs(c[x][i],d+1);\n}\nint main(){\n    in(n);\n    int x,y,ans=0,as=0;char w;\n    Fur(i,2,n)in(x,y,w),c[x][w-'a']=y;\n    dfs(1,1);\n    Fur(i,1,n)if(a[i]>ans)as=i,ans=a[i];\n    printf(\"%d\\n%d\\n\",n-ans,as);\n}\n```\n\n## 数据结构+启发式合并\n\n[LG 3302 \\[SDOI2013\\]森林](https:\/\/www.luogu.com.cn\/problem\/P3302)\n\n看题意想到了主席树和LCT\n\nLCT套主席树可行,但是比较麻烦,我们用另一种方法\n\n启发式合并+主席树($\\mathcal{n \\log^2 n}$)\n\n每次将小的插入到大的,顺便更新倍增LCA\n\n每个节点在父节点的基础上插入自身的值\n\n即每个节点的主席树记录的是自身到根节点的路径\n\n具体看代码\n\n```cpp\n#include<bits\/stdc++.h>\n#define il __inline__ __attribute__ ((always_inline))\n#define Fur(i,x,y) for(int i(x);i<=y;++i)\n#define Fdr(i,x,y) for(int i(x);i>=y;--i)\n#define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\nil void SWAP(int &x,int &y){int t=x;x=y;y=t;}\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\nconst int N=80011;\nstruct node{int v,p;bool operator<(node t){return v<t.v;}}b[N];\nint val[N],rnk[N];\nint cnt=0,head[N];\nint d[N],fa[N],f[17][N],siz[N];\nint SZ=0,sz=0,RT[N],ls[N*600],rs[N*600],s[N*600];\nbool v[N];\nstruct edge{int to,nxt;}e[N<<2];\nil void add(int x,int y){e[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;}\nint gf(int x){return (fa[x]==x)?x:(fa[x]=gf(fa[x]));}\nvoid build(int &x,int l,int r){\n    s[x=++sz]=0;\n    if(l==r)return;\n    int m=(l+r)>>1;\n    build(ls[x],l,m);build(rs[x],m+1,r);\n}\nvoid ins(int &x,int pre,int l,int r,int v){\n    s[x=++sz]=s[pre]+1;\n    ls[x]=ls[pre];rs[x]=rs[pre];\n    if(l==r)return;\n    int m=(l+r)>>1;\n    if(v<=m)ins(ls[x],ls[pre],l,m,v);\n    else ins(rs[x],rs[pre],m+1,r,v);\n}\nint ask(int x,int y,int lca,int flca,int l,int r,int k){\n    if(l==r)return val[l];\n    int m=(l+r)>>1,sum=s[ls[x]]+s[ls[y]]-s[ls[lca]]-s[ls[flca]];\n    if(k<=sum)return ask(ls[x],ls[y],ls[lca],ls[flca],l,m,k);\n    else return ask(rs[x],rs[y],rs[lca],rs[flca],m+1,r,k-sum);\n}\nvoid dfs(int x,int F,int rt){\n    ++siz[rt];\n    d[x]=d[f[0][x]=fa[x]=F]+1;\n    Fur(i,1,16)f[i][x]=f[i-1][f[i-1][x]];\n    v[x]=1;\n    ins(RT[x],RT[F],1,SZ,rnk[x]);\n    fl(i,x)if(to!=F)dfs(to,x,rt);\n}\nil int lca(int x,int y){\n    if(d[x]<d[y])SWAP(x,y);\n    Fdr(i,16,0)if(d[f[i][x]]>=d[y])x=f[i][x];\n    if(x==y)return x;\n    Fdr(i,16,0)if(f[i][x]!=f[i][y])\n        x=f[i][x],y=f[i][y];\n    return f[0][x];\n}\nint main(){\n    int n,m,q,lastans=0;\n    in(n);\n    in(n,m,q);\n    Fur(i,1,n)in(b[i].v),b[i].p=i,fa[i]=i;\n    std::sort(b+1,b+n+1);b[0].v=-(1<<30);\n    Fur(i,1,n)val[rnk[b[i].p]=(SZ+=(b[i].v!=b[i-1].v))]=b[i].v;\n    int x,y,k,t;char ch;\n    Fur(i,1,m)in(x,y),add(x,y),add(y,x);\n    build(RT[0],1,SZ);\n    Fur(i,1,n)if(!v[i])dfs(i,0,i),fa[i]=i;\n    while(q--){\n        in(ch,x,y);\n        x^=lastans;y^=lastans;\n        if(ch=='Q'){\n            in(k);k^=lastans;t=lca(x,y);\n            out(lastans=ask(RT[x],RT[y],RT[t],RT[f[0][t]],1,SZ,k),ln);\n        }\n        else{\n            add(x,y),add(y,x);\n            if(siz[gf(x)]>siz[gf(y)])SWAP(x,y);\n            dfs(x,y,gf(y));\n        }\n    }\n    flush();\n}\n```\n\n## 线段树合并\n\n```cpp\nint mg(int x,int y,int l=1,int r=100000){\n    if(!x||!y)return x|y;\n    if(l==r)return s[x]+=s[y],S[x]=l,x;\/\/合并两个节点的信息\n    int m=(l+r)>>1;\n    ls[x]=mg(ls[x],ls[y],l,m); \n    rs[x]=mg(rs[x],rs[y],m+1,r);\n    pushup(x);return x;\n}\n```\n\n例题: \n\n[LG 4556 \\[Vani有约会\\]雨天的尾巴 \/【模板】线段树合并](https:\/\/www.luogu.com.cn\/problem\/P4556)\n\n树上差分,统计的时候每个节点都合并自身子节点的结果\n\n每个点都维护一颗动态开点权值线段树\n\n在$x\\leftrightarrow y$区间加可以看成$x,y$的$w$位置$+1$,$lca(x,y),f_{lca(x,y)}$的$w$位置$-1$\n\n统计的时候不断向上线段树合并\n\n具体看代码\n\n```cpp\n#include<bits\/stdc++.h>\n#define il __inline__ __attribute__ ((always_inline))\n#define Fur(i,x,y) for(int i(x);i<=y;++i)\n#define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\nconst int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}\nconst int N=100011;\nint n,q,cnt=0,sz=0,head[N],s[N*60],S[N*60],ls[N*60],rs[N*60],RT[N],ans[N];\nil void pu(int rt){s[ls[rt]]>=s[rs[rt]]?(s[rt]=s[ls[rt]],S[rt]=S[ls[rt]]):(s[rt]=s[rs[rt]],S[rt]=S[rs[rt]]);}\nvoid upd(int &rt,int x,int v,int l=1,int r=100000){\n    if(!rt)rt=++sz;\n    if(l==r){s[rt]+=v;S[rt]=l;return;}\n    int m=(l+r)>>1;\n    if(x<=m)upd(ls[rt],x,v,l,m);\n    else upd(rs[rt],x,v,m+1,r);\n    pu(rt);\n}\nint mg(int x,int y,int l=1,int r=100000){\n    if(!x||!y)return x|y;\n    if(l==r)return s[x]+=s[y],S[x]=l,x;\n    int m=(l+r)>>1;\n    ls[x]=mg(ls[x],ls[y],l,m); \n    rs[x]=mg(rs[x],rs[y],m+1,r);\n    pu(x);return x;\n}\nstruct edge{int to,nxt;}e[N<<1];\nil void add(int x,int y){e[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;}\nint d[N],top[N],siz[N],f[N];\nvoid dfs(int x){\n    siz[x]=1;\n    fl(i,x)if(to!=f[x]){\n        f[to]=x;d[to]=d[x]+1;\n        dfs(to);\n        siz[x]+=siz[to];\n    }\n}\nvoid bt(int x,int tp){\n    top[x]=tp;int k=0;\n    fl(i,x)if(to!=f[x]&&siz[to]>siz[k])k=to;\n    if(k)bt(k,tp);\n    fl(i,x)if(!top[to])bt(to,to);\n}\nil int lca(int x,int y){\n    while(top[x]!=top[y])\n        d[top[x]]>d[top[y]]?x=f[top[x]]:y=f[top[y]];\n    return d[x]<d[y]?x:y;\n}\nvoid solve(int x){\n    fl(i,x)if(to!=f[x])\n        solve(to),\n        RT[x]=mg(RT[x],RT[to]);\n    if(s[RT[x]])ans[x]=S[RT[x]];\n}\nint main(){\n    in(n,q);\n    int x,y,w;\n    Fur(i,2,n)in(x,y),add(x,y),add(y,x);\n    dfs(1);bt(1,1);\n    while(q--){\n        in(x,y,w);\n        int t=lca(x,y);\n        upd(RT[x],w,1);upd(RT[y],w,1);\n        upd(RT[t],w,-1);upd(RT[f[t]],w,-1);\n    }\n    solve(1);\n    Fur(i,1,n)out(ans[i]),pt('\\n');\n    flush();\n}\n```\n\n[LG 3521 \\[POI2011\\]ROT-Tree Rotations](https:\/\/www.luogu.com.cn\/problem\/P3521)\n\n给一棵$n(1 \\le n \\le 200000)$个叶子的二叉树,可以交换每个点的左右子树,要求前序遍历叶子的逆序对最少","link":null,"tags":["数据结构","技巧","算法"],"title":"启发式合并"},{"categories":[["刷题记录"]],"content":"\n题目的意思就是相同子树中的点不能分配到同一段内存\n\n每个点都开一个大根堆\n\n合并一个点和它的子节点的时候最大值互相对应\n\n启发式合并\n\n具体看代码\n```cpp\n#include<bits\/stdc++.h>\n#define il __inline__ __attribute__ ((always_inline))\n#define Fur(i,x,y) for(int i(x);i<=y;++i)\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}}using namespace IO;\nconst int N=200011;\nint n,cnt=0,head[N],a[N],id[N],dfn=0,tmp[N],tp=0;\nstruct edge{int to,nxt;}e[N];\nil void add(int x,int y){e[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;}\nstd::priority_queue<int>q[N];\nil int max(int x,int y){return x>y?x:y;}\nil void swap(int &x,int &y){int t=x;x=y;y=t;}\nvoid dfs(int x){\n    id[x]=++dfn;\n    for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt){\n        dfs(to);\n        if(q[id[x]].size()<q[id[to]].size())swap(id[x],id[to]);\n        int t=q[id[to]].size();tp=0;\n        while(t--)\n            tmp[++tp]=max(q[id[x]].top(),q[id[to]].top()),\n            q[id[x]].pop(),q[id[to]].pop();\n        while(tp)q[id[x]].push(tmp[tp--]);\n    }\n    q[id[x]].push(a[x]);\n}\nint main(){\n    in(n);\n    int x;\n    Fur(i,1,n)in(a[i]);\n    Fur(i,2,n)in(x),add(x,i);\n    dfs(1);\n    long long ans=0;\n    while(!q[id[1]].empty())\n        ans+=q[id[1]].top(),\n        q[id[1]].pop();\n    printf(\"%lld\\n\",ans);\n}\n```\n","link":null,"tags":["堆","启发式合并"],"title":"LG 5290 [十二省联考2019]春节十二响"},{"categories":[["算法","动态规划"],["note"]],"content":"\n## 01背包\n\n每个物品只能使用一次\n\n## 普通多重背包\n\n将可以用多次的物品拆为多个单次使用的物品\n\n转化为01背包\n\n## 二进制优化多重背包\n\n但每个物品可以用的次数特别大的时候,如果还是直接拆很有可能会tle\n\n[LG 1776 宝物筛选](https:\/\/www.luogu.com.cn\/problem\/P1776)\n\n这时候可以使用二进制优化,\n\n原理其实挺简单的: \n\n比如$7$可以拆成$1,2,4$,用$1,2,4$可以凑出$1-7$中的任意一个数\n\n根据这个原理,可以把物品拆成$\\log_2 \\text{次数}$个物品(价值和空间也跟着翻倍),降低时间复杂度\n\n代码如下:\n\n```cpp\nint n,W,tot=0,f[N];\nstruct node{int v,w;}a[N];\nint main(){\n    in(n,W);\n    int v,w,m;\n    for(int i=1;i<=n;++i){\n        in(v,w,m);\n        for(int t=1;t<=m;t<<=1)\n            a[++tot]=node{v*t,w*t},\n            m-=t;\n        if(m)a[++tot]=node{v*m,w*m};\n    }\n    Fur(i,1,tot)\n    for(int i=1;i<=tot;++i)\n        for(int j=W;j>=a[i].w;--j)\n            f[j]=max(f[j],f[j-a[i].w]+a[i].v);\n    printf(\"%d\\n\",f[W]);\n}\n```\n\n## 单调队列优化多重背包\n\n还是这题[LG 1776 宝物筛选](https:\/\/www.luogu.com.cn\/problem\/P1776)\n\n普通转移方程: \n\n$$f(i,j)=max_{k\\le m_i}\\{f(i-1,j−kw)+kv\\}$$\n\n我们要将这个方程转化为可以单调队列优化的形式:\n\n设$d=j \\mod w_i,s=\\left \\lfloor \\frac j{w_i}\\right \\rfloor$,那么\n\n$$f(i,j)=max_{s-k\\le m_i}\\{f(i-1,d+kw)-kv\\}+vs$$\n\n枚举$d$,对于每个$d$都用单调队列优化即可\n\n代码如下: \n```cpp\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\nint n,V,ans,head,tail,q[40010],q2[40010],dp[40010];\nint main(){\n    scanf(\"%d%d\",&n,&V);\n    for(int i=1;i<=n;i++){\n        int v,w,c;\n        scanf(\"%d%d%d\",&w,&v,&c);\n        if(v==0){ans+=w*c;continue;}\n        int k=V\/v;\n        c=min(c,k);\n        for(int d=0;d<v;d++){\n            head=tail=0;\n            k=(V-d)\/v;\n            for(int j=0;j<=k;j++){\n                while(head<tail&&dp[d+j*v]-j*w>=q2[tail-1])tail--;\n                q[tail]=j;\n                q2[tail++]=dp[d+j*v]-j*w;\n                while(head<tail&&q[head]<j-c)++head;\n                dp[d+j*v]=max(dp[d+j*v],q2[head]+j*w);\n            }\n        }\n    }\n    printf(\"%d\",ans+dp[V]);\n}\n```","link":null,"tags":["动态规划","技巧"],"title":"多重背包的优化"},{"categories":[["刷题记录"]],"content":"\n其实可以说是前向星\n\n每次都把短的链表接到长的链表上\n\n统计短的链表上每个元素改变后造成的影响\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define register\n    #define ll long long\n    #define ull unsignbl long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\nconst int N=1000011;\nint n,q,a[N],ans=0,st[N],bl[N],head[N],nxt[N],sz[N];\nil void mg(int x,int y){\n    for(int i=head[x];i;i=nxt[i])ans-=(a[i-1]==y)+(a[i+1]==y);\n    for(int i=head[x];i;i=nxt[i])a[i]=y;\n    sz[y]+=sz[x];nxt[st[x]]=head[y];head[y]=head[x];\n    head[x]=st[x]=sz[x]=0;\n}\nint main(){\n    in(n,q);\n    Fur(i,1,n){\n        in(a[i]);\n        if(a[i]!=a[i-1])++ans;\n        bl[a[i]]=a[i];\n        if(!st[a[i]])st[a[i]]=i;\n        ++sz[a[i]];nxt[i]=head[a[i]];head[a[i]]=i;\n    }\n    while(q--){\n        int opt,x,y;\n        in(opt);\n        if(opt==2)out(ans,ln);\n        else{\n            in(x,y);\n            if(x!=y){\n                if(sz[bl[x]]>sz[bl[y]])SWAP(bl[x],bl[y]);\n                if(sz[bl[x]])mg(bl[x],bl[y]);\n            }\n        }\n    }\n    flush();\n}\n```\n","link":null,"tags":["启发式合并","链表"],"title":"LG 3201 [HNOI2009]梦幻布丁"},{"categories":[["刷题记录"]],"content":"\n可以想到贪心: \n\n如果目前有可以摧毁的目标水晶,那么摧毁最靠后的\n\n否则摧毁第一个水晶\n\n证明: \n\n> 如果一个水晶目前无法摧毁,它必须等前面若干个水晶被摧毁它才能移动到目标位置\n> \n> 所以当目标水晶没有可以摧毁的时候,摧毁序列第一个可以移动最多的目标水晶\n\n> 当有超过一个目标水晶可以摧毁的时候,从后往前摧毁显然是最优的\n\n那么要如何实现这个贪心呢?\n\n很容易想到数据结构\n\n1. 平衡树暴力操作: 数据范围$3\\times 10^6$,显然是不行的\n   \n2. 线段树 目标水晶最多$1.5\\times 10^6$,且线段树常数不大,可行\n\n实现: \n\n1. 线段树维护\n\n维护$d_1,d_2,\\dots,d_{cnt}$表示目标水晶到可以摧毁的位置的距离\n\n维护最小值\n\n若最小值为$0$,这找到最靠后的$d_x=0$,摧毁,也就是距离赋值为无穷大,然后将$d_i,i\\in[x+1,cnt]$都减去$1$\n\n否则一直摧毁第一个水晶直到最小值为$0$,也就是所有$d_i$都减去$min(d_i)$\n\n代码如下:\n\n```cpp\n#include<bits\/stdc++.h>\n#define il __inline__ __attribute__ ((always_inline))\n#define Fur(i,x,y) for(int i=x;i<=y;++i)\nil int MIN(int x,int y){return x<y?x:y;}\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}}using namespace IO;\nconst int N=1500011;\nint n,w,cnt=0,s[N<<2],laz[N<<2],a[N],old[N],ANS[N<<1],ans=0,oth[N<<1];\n#define ls rt<<1\n#define rs rt<<1|1\nil void pu(int rt){s[rt]=MIN(s[ls],s[rs]);}\nil void pd(int rt){\n    if(laz[rt]){\n        laz[ls]+=laz[rt];s[ls]-=laz[rt];\n        laz[rs]+=laz[rt];s[rs]-=laz[rt];\n        laz[rt]=0;\n    }\n}\nvoid build(int l,int r,int rt){\n    if(l==r){s[rt]=a[l];return;}\n    int m=(l+r)>>1;\n    build(l,m,ls);build(m+1,r,rs);\n    pu(rt);\n}\nvoid upd(int L,int c,int l,int r,int rt){\n    if(L<=l){s[rt]-=c;laz[rt]+=c;return;}\n    int m=(l+r)>>1;\n    pd(rt);\n    if(L<=m)upd(L,c,l,m,ls);\n    upd(L,c,m+1,r,rs);\n    pu(rt);\n}\nint ask(int l,int r,int rt){\n    if(l==r){\n        s[rt]=(1<<30);\n        ANS[++ans]=old[l];\n        return l;\n    }\n    int m=(l+r)>>1,res;\n    pd(rt);\n    if(!s[rs])res=ask(m+1,r,rs);\n    else res=ask(l,m,ls);\n    pu(rt);\n    return res;\n}\nint main(){\n    in(n,w);\n    int x,b=1,now=0;\n    Fur(i,1,n){\n        if((b<<1)<=i)b<<=1;\n        in(x);\n        if(x==w)a[++cnt]=i-b,old[cnt]=i;\n        else oth[++now]=i;\n    }\n    now=0;\n    build(1,cnt,1);\n    Fur(t,1,cnt){\n        if(s[1]){\n            Fur(j,1,s[1])ANS[++ans]=oth[++now];\n            upd(1,s[1],1,cnt,1);\n        }\n        x=ask(1,cnt,1)+1;\n        if(x<=cnt)upd(x,1,1,cnt,1);\n    }\n    out(ans);pt('\\n');\n    Fur(i,1,ans)out(ANS[i]),pt(' ');\n    flush();\n}\n```\n\n2. 巧妙的模拟\n\n可以只维护所有$2$次幂位置在原序列中的位置\n\n每次修改只需要修改$\\log_2 n$个位置,复杂度完全可以接受\n\n根据这个特性,暴力跑的比正解线段树还快\n\n代码如下: \n```cpp\n#include<bits\/stdc++.h>\n#define il __inline__ __attribute__ ((always_inline))\n#define Fur(i,x,y) for(int i=x;i<=y;++i)\n#define Fdr(i,x,y) for(int i=x;i>=y;--i)\nil int MIN(int x,int y){return x<y?x:y;}\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}}using namespace IO;\nconst int N=3000011;\nint n,tot=0,b=0,w,a[N],p[N],ans=0,ANS[N];\nint main(){\n    in(n,w);\n    Fur(i,1,n){\n        in(a[i]);\n        if(a[i]==w)++tot;\n    }\n    a[n+1]=-1;\n    while((1<<b)<=n)p[b+1]=(1<<b),++b;\n    while(tot){\n        bool f=0;\n        Fdr(i,b,1)if(a[p[i]]==w){\n            ANS[++ans]=p[i];\n            a[p[i]]=0;\n            Fur(j,i,b)if(p[j]<=n)\n                while(!a[++p[j]]);\n            --tot;f=1;break;\n        }\n        if(!f){\n            ANS[++ans]=p[1],a[p[1]]=0;\n            Fur(i,1,b)if(p[i]<=n)\n                while(!a[++p[i]]);\n        }\n    }\n    out(ans);pt('\\n');\n    Fur(i,1,ans)out(ANS[i]),pt(' ');\n    flush();\n}\n```\n","link":null,"tags":["贪心","线段树"],"title":"LG 5584 【SWTR-01】Sunny's Crystals"},{"categories":[["刷题记录"]],"content":"\n能凑出的钱: 使用多重背包(二进制优化)\n\n找零: 使用完全背包\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\nconst int N=20011;\nint n,T,f[N],g[N],v[111];\nvoid upd(int x,int c){Fdr(j,T*2,x)f[j]=MIN(f[j],f[j-x]+c);}\nint main(){\n    in(n,T);\n    clr(f,0x3f);clr(g,0x3f);\n    f[0]=g[0]=0;\n    Fur(i,1,n)in(v[i]);\n    Fur(i,1,n)\n        Fur(j,v[i],T)\n            g[j]=MIN(g[j],g[j-v[i]]+1);\n    Fur(i,1,n){\n        int c;in(c);\n        for(int t=1;t<=c;t<<=1)\n            upd(v[i]*t,t),c-=t;\n        if(c)upd(v[i]*c,c);\n    }\n    int ans=inf;\n    Fur(i,T,T*2)\n        ans=MIN(ans,f[i]+g[i-T]);\n    if(ans>T)ans=-1;\n    printf(\"%d\\n\",ans);\n}\n```\n","link":null,"tags":["背包","动态规划"],"title":"LG 2851 [USACO06DEC]最少的硬币The Fewest Coins"},{"categories":[["刷题记录"]],"content":"\n多重背包优化模板\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\nconst int N=100011;\nint n,W,tot=0,f[N];\nstruct node{int v,w;}a[N];\nint main(){\n    in(n,W);\n    int v,w,m;\n    Fur(i,1,n){\n        in(v,w,m);\n        for(int t=1;t<=m;t<<=1)\n            a[++tot]=node{v*t,w*t},m-=t;\n        if(m)a[++tot]=node{v*m,w*m};\n    }\n    Fur(i,1,tot)\n        Fdr(j,W,a[i].w)\n            f[j]=MAX(f[j],f[j-a[i].w]+a[i].v);\n    printf(\"%d\\n\",f[W]);\n}\n```\n","link":null,"tags":["多重背包","动态规划","二进制优化"],"title":"LG 1776 宝物筛选"},{"categories":[["算法","数论"],["note"]],"content":"\n\nNTT基本上跟FFT一样,就是把单位根换成了原根(原根和单位根一样具有FFT需要的特殊性质)\n\n前置知识: \n\n1. [FFT](\/posts\/fft)\n   \n2. [原根](\/posts\/原根)\n\n## 原根的性质\n\n设$p$是质数,$g$为模$p$的原根,$n|(p-1)$,$g_n=g^{(p-1)\/n}$\n\n> 单位根:\n> \n> $\\omega_n^n=1,\\omega_n^{n\/2}=-1$\n\n原根:\n\n$g_n^n=g^{p-1}\\equiv 1\\mod p$\n\n$g_n^{n\/2}=g^{(p-1)\/2}$\n\n其中$\\left(g^{(p-1)\/2}\\right)^2=1,g_n^{n\/2}=\\pm1$\n\n由于$g$是原根,所以$g^{p-1}\\neq g^{(p-1)\/2}$,所以$g_n^{n\/2}=-1$\n\n> 单位根：$w_{dn}^{dk}=w_n^k$\n\n原根:\n\n$g_{dn}^{dk}=g^{dk(p-1)\/(dn)}=g^{k(p-1)\/n}=g_n^k$\n\n> 单位根: $({w_n^k})^2=w_{n\/2}^k$\n\n原根: \n\n$(g_n^k)^2=g_n^{2k}=g_{n\/2}^k$\n\n$(g_n^{k+n\/2})^2=g_n^{2k+n}\\equiv g_n^{2k}=g_{n\/2}^k$\n\nFFT需要单位复数根该有的性质原根都有\n\n## 实现\n\n和FFT基本上一样\n\n```cpp\n#pragma GCC optimize(3)\n#include<bits\/stdc++.h>\n#define For(i,x,y) for(int i=x;i<=y;++i)\n#define il __inline__ __attribute__ ((always_inline))\nil int gi(){char c;int x=0,f=0;while((c=getchar())<'0'||'9'<c)f^=(c=='-');while('0'<=c&&c<='9')x*=10,x+=c-48,c=getchar();return f?-x:x;}\nconst int N=3000011,P=998244353,G=3,Gi=332748118;\nint n,m,limit=1,l=0,r[N],a[N],b[N];\nil int pw(int x,int p){\n    int ans=1;\n    while(p){\n        if(p&1)ans=1ll*ans*x%P;\n        x=1ll*x*x%P;p>>=1;\n    }\n    return ans;\n}\nil void ntt(int *A,int typ){\n    For(i,0,limit-1)\n        if(i<r[i])std::swap(A[i],A[r[i]]);\n    for(int len=1;len<limit;len<<=1){\n        int Wn=pw(~typ?G:Gi,(P-1)\/(len<<1));\n        \/\/Gi指1\/G在模P下的逆元,相当于pw(G,P-2)\n        for(int i=0;i<limit;i+=(len<<1)){\n            int w=1;\n            For(k,0,len-1){\/\/蝴蝶操作\n                int t=1ll*w*A[i+k+len]%P;\n                A[i+k+len]=(A[i+k]-t+P)%P;\n                A[i+k]=(A[i+k]+t)%P;\n                w=1ll*w*Wn%P;\n            }\n        }\n    }\n}\nint main(){\n    n=gi(),m=gi();\n    For(i,0,n)a[i]=(gi()+P)%P;\n    For(i,0,m)b[i]=(gi()+P)%P;\n    while(limit<=n+m)limit<<=1,++l;\n    For(i,0,limit-1)\n        r[i]=(r[i>>1]>>1)|((i&1)<<(l-1));\n    ntt(a,1);ntt(b,1);\n    For(i,0,limit)a[i]=1ll*a[i]*b[i]%P;\n    ntt(a,-1);\n    int inv=pw(limit,P-2);\/\/limit在模P下的逆元\n    For(i,0,n+m)printf(\"%d \",1ll*a[i]*inv%P);\n}\n```\n\n原根表:\n\n| p         | r  | k  | g  |\n| -- | - | - | - |\n| 81788929    | 21   | 39   | 7    |\n| 104857601   | 21   | 50   | 3    |\n| 104857601   | 22   | 25   | 3    |\n| 113246209   | 21   | 54   | 7    |\n| 113246209   | 22   | 27   | 7    |\n| 132120577   | 21   | 63   | 5    |\n| 136314881   | 21   | 65   | 3    |\n| 138412033   | 21   | 66   | 5    |\n| 155189249   | 21   | 74   | 6    |\n| 167772161   | 23   | 20   | 3    |\n| 249561089   | 21   | 119  | 3    |\n| 377487361   | 21   | 180  | 7    |\n| 377487361   | 22   | 90   | 7    |\n| 383778817   | 21   | 183  | 5    |\n| 415236097   | 22   | 99   | 5    |\n| 415236097   | 21   | 198  | 5    |\n| 469762049   | 24   | 28   | 3    |\n| 469762049   | 21   | 224  | 3    |\n| 469762049   | 23   | 56   | 3    |\n| 469762049   | 22   | 112  | 3    |\n| 576716801   | 21   | 275  | 6    |\n| 645922817   | 22   | 154  | 3    |\n| 645922817   | 21   | 308  | 3    |\n| 666894337   | 21   | 318  | 5    |\n| 683671553   | 22   | 163  | 3    |\n| 740294657   | 21   | 353  | 3    |\n| 897581057   | 22   | 214  | 3    |\n| 897581057   | 21   | 428  | 3    |\n| 918552577   | 22   | 219  | 5    |\n| 935329793   | 22   | 223  | 3    |\n| 935329793   | 21   | 446  | 3    |\n| 950009857   | 21   | 453  | 7    |\n| 962592769   | 21   | 459  | 7    |\n| 998244353   | 23   | 119  | 3    |\n| 1004535809  | 21   | 479  | 3    |\n| 1107296257  | 23   | 132  | 10   |\n| 1107296257  | 24   | 66   | 10   |\n| 1107296257  | 21   | 528  | 10   |\n| 1138753537  | 21   | 543  | 5    |\n| 1161822209  | 22   | 277  | 3    |\n| 1161822209  | 21   | 554  | 3    |\n| 1205862401  | 21   | 575  | 3    |\n| 1212153857  | 22   | 289  | 3    |\n| 1212153857  | 21   | 578  | 3    |\n| 1214251009  | 21   | 579  | 7    |\n| 1218445313  | 21   | 581  | 3    |\n| 1224736769  | 22   | 292  | 3    |\n| 1224736769  | 21   | 584  | 3    |\n| 1281359873  | 21   | 611  | 3    |\n| 1300234241  | 23   | 155  | 3    |\n| 1300234241  | 21   | 620  | 3    |\n| 1306525697  | 21   | 623  | 3    |\n| 1327497217  | 21   | 633  | 5    |\n| 1438646273  | 21   | 686  | 3    |\n| 1484783617  | 21   | 708  | 5    |\n| 1570766849  | 21   | 749  | 3    |\n| 1709178881  | 21   | 815  | 3    |\n| 1835008001  | 21   | 875  | 6    |\n| 1866465281  | 22   | 445  | 3    |\n| 1866465281  | 21   | 890  | 3    |\n| 1893728257  | 21   | 903  | 5    |\n| 1931476993  | 21   | 921  | 5    |\n| 2088763393  | 22   | 498  | 5    |\n| 2113929217  | 22   | 504  | 5    |\n| 2113929217  | 25   | 63   | 5    |\n| 2113929217  | 23   | 252  | 5    |\n| 2130706433  | 22   | 508  | 3    |\n| 2130706433  | 23   | 254  | 3    |\n| 2281701377  | 27   | 17   | 3    |\n| 2483027969  | 23   | 296  | 3    |\n| 2483027969  | 25   | 74   | 3    |\n| 2533359617  | 24   | 151  | 3    |\n| 2533359617  | 23   | 302  | 3    |\n| 2558525441  | 23   | 305  | 3    |\n| 2671771649  | 22   | 637  | 3    |\n| 2680160257  | 22   | 639  | 7    |\n| 2717908993  | 22   | 648  | 5    |\n| 2717908993  | 24   | 162  | 5    |\n| 2722103297  | 22   | 649  | 3    |\n| 2780823553  | 22   | 663  | 10   |\n| 2885681153  | 24   | 172  | 3    |\n| 2885681153  | 26   | 43   | 3    |\n| 2910846977  | 22   | 694  | 3    |\n| 2998927361  | 22   | 715  | 3    |\n| 3112173569  | 22   | 742  | 2    |\n| 3221225473  | 24   | 192  | 3    |\n| 3221225473  | 25   | 96   | 3    |\n| 3221225473  | 26   | 48   | 3    |\n| 3238002689  | 22   | 772  | 2    |\n| 3238002689  | 23   | 386  | 2    |\n| 3313500161  | 22   | 790  | 2    |\n| 3414163457  | 23   | 407  | 3    |\n| 3435134977  | 22   | 819  | 2    |\n| 3451912193  | 22   | 823  | 2    |\n| 3489660929  | 23   | 416  | 2    |\n| 3489660929  | 25   | 104  | 2    |\n| 3489660929  | 22   | 832  | 2    |\n| 3510632449  | 22   | 837  | 2    |\n| 3577741313  | 22   | 853  | 2    |\n| 3615490049  | 23   | 431  | 2    |\n| 3615490049  | 22   | 862  | 2    |\n| 3628072961  | 22   | 865  | 2    |\n| 3665821697  | 23   | 437  | 2    |\n| 3686793217  | 22   | 879  | 2    |\n| 3749707777  | 23   | 447  | 2    |\n| 3892314113  | 23   | 464  | 2    |\n| 3892314113  | 25   | 116  | 2    |\n| 3892314113  | 24   | 232  | 2    |\n| 3892314113  | 22   | 928  | 2    |\n| 3938451457  | 22   | 939  | 2    |\n| 3942645761  | 23   | 470  | 2    |\n| 3942645761  | 24   | 235  | 2    |\n| 3942645761  | 22   | 940  | 2    |\n| 4013948929  | 22   | 957  | 2    |\n| 4194304001  | 24   | 250  | 2    |\n| 4253024257  | 23   | 507  | 2    |\n| 4630511617  | 26   | 69   | 2    |\n| 4630511617  | 25   | 138  | 2    |\n| 4882169857  | 24   | 291  | 2    |\n| 4882169857  | 23   | 582  | 2    |\n| 5158993921  | 23   | 615  | 2    |\n| 5175771137  | 23   | 617  | 2    |\n| 5251268609  | 23   | 626  | 2    |\n| 5528092673  | 23   | 659  | 2    |\n| 5536481281  | 24   | 330  | 2    |\n| 5578424321  | 23   | 665  | 2    |\n| 5788139521  | 24   | 345  | 2    |\n| 5788139521  | 23   | 690  | 2    |\n| 5838471169  | 25   | 174  | 2    |\n| 5838471169  | 26   | 87   | 2    |\n| 6014631937  | 23   | 717  | 2    |\n| 6165626881  | 23   | 735  | 2    |\n| 6333399041  | 23   | 755  | 2    |\n| 6434062337  | 23   | 767  | 2    |\n| 6534725633  | 23   | 779  | 2    |\n| 6593445889  | 24   | 393  | 2    |\n| 6660554753  | 23   | 794  | 2    |\n| 6719275009  | 23   | 801  | 2    |\n| 6811549697  | 25   | 203  | 2    |\n| 6811549697  | 23   | 812  | 2    |\n| 6996099073  | 23   | 834  | 2    |\n| 6996099073  | 24   | 417  | 2    |\n| 7096762369  | 24   | 423  | 2    |\n| 7348420609  | 24   | 438  | 2    |\n| 7348420609  | 25   | 219  | 2    |\n| 7474249729  | 23   | 891  | 2    |\n| 7566524417  | 23   | 902  | 2    |\n| 7717519361  | 26   | 115  | 2    |\n| 7717519361  | 25   | 230  | 2    |\n| 7717519361  | 23   | 920  | 2    |\n| 7818182657  | 23   | 932  | 2    |\n| 7843348481  | 23   | 935  | 2    |\n| 7918845953  | 27   | 59   | 2    |\n| 8170504193  | 24   | 487  | 2    |\n| 8220835841  | 25   | 245  | 2    |\n| 8220835841  | 23   | 980  | 2    |\n| 8279556097  | 23   | 987  | 2    |\n| 8858370049  | 26   | 132  | 2    |\n| 8858370049  | 27   | 66   | 2    |\n| 9177137153  | 24   | 547  | 2    |\n| 9227468801  | 25   | 275  | 2    |\n| 9865003009  | 24   | 588  | 2    |\n| 10267656193 | 24   | 612  | 2    |\n| 10267656193 | 26   | 153  | 2    |\n| 10267656193 | 25   | 306  | 2    |\n| 10619977729 | 24   | 633  | 2    |\n| 10871635969 | 26   | 162  | 2    |\n| 10871635969 | 24   | 648  | 2    |\n| 10871635969 | 25   | 324  | 2    |\n| 11123294209 | 24   | 663  | 2    |\n| 11173625857 | 25   | 333  | 2    |\n| 11173625857 | 24   | 666  | 2    |\n| 11341398017 | 26   | 169  | 2    |\n| 11341398017 | 25   | 338  | 2    |\n| 11693719553 | 24   | 697  | 2    |\n| 12297699329 | 24   | 733  | 2    |\n| 12348030977 | 27   | 92   | 2    |\n| 12348030977 | 25   | 368  | 2    |\n| 12348030977 | 26   | 184  | 2    |\n| 13186891777 | 25   | 393  | 2    |\n| 13757317121 | 26   | 205  | 2    |\n| 13857980417 | 25   | 413  | 2    |\n| 13857980417 | 24   | 826  | 2    |\n| 14042529793 | 24   | 837  | 2    |\n| 14092861441 | 26   | 210  | 2    |\n| 14092861441 | 27   | 105  | 2    |\n| 14092861441 | 24   | 840  | 2    |\n| 15065939969 | 24   | 898  | 2    |\n| 15065939969 | 25   | 449  | 2    |\n| 15619588097 | 24   | 931  | 2    |\n| 15653142529 | 24   | 933  | 2    |\n| 15854469121 | 24   | 945  | 2    |\n| 16475226113 | 24   | 982  | 2    |\n| 16575889409 | 24   | 988  | 2    |\n| 16626221057 | 24   | 991  | 2    |\n| 17314086913 | 26   | 258  | 2    |\n| 17314086913 | 25   | 516  | 2    |\n| 17314086913 | 27   | 129  | 2    |\n| 18387828737 | 26   | 274  | 2    |\n| 19998441473 | 26   | 298  | 2    |\n| 19998441473 | 25   | 596  | 2    |\n| 20501757953 | 25   | 611  | 2    |\n","link":null,"tags":["数论","高精度","算法","ntt"],"title":"ntt"},{"categories":[["刷题记录"]],"content":"\nbsgs模板题\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\nconst int N=1000007;\nint y,z,p;\nstruct hash{\n    int cnt=0,head[N];\n    struct edge{int to,nxt,w;}e[N];\n    il void add(int x,int y,int w){e[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;e[cnt].w=w;}\n    il void ins(int x,int v){add(x%N,x,v);}\n    il int ask(int x){fl(i,x%N)if(to==x)return e[i].w;return -1;}\n}S;\nil int pw(int x,int b){\n    int ans=1;\n    while(b){\n        if(b&1)ans=1ll*ans*x%p;\n        b>>=1;x=1ll*x*x%p;\n    }\n    return ans;\n}\nint main(){\n    in(p,y,z);\n    int m=sqrt(p)+1,x=z%p,f=pw(y,m),ff=1;\n    Fur(i,0,m)S.ins(x,i),x=1ll*x*y%p;\n    x=1;\n    Fur(i,1,m){\n        x=1ll*x*f%p;\n        int k=S.ask(x);\n        if(~k){\n            ff=0;\n            printf(\"%d\\n\",((1ll*i*m-k)%p+p)%p);\n            break;\n        }\n    }\n    if(ff)printf(\"no solution\\n\");\n}\n```\n","link":null,"tags":["bsgs","数论"],"title":"LG 3846 [TJOI2007]可爱的质数"},{"categories":[["算法","数论"],["note"]],"content":"\n## FFT\n\n~~fst fst tle~~\n\n> DFT: 离散傅里叶变换\n>\n> IDFT: 离散傅里叶逆变换\n>\n> FFT: 快速傅里叶变换\n>\n> FNTT\/NTT: 快速傅里叶变换的优化版\n>\n> FWT: 快速沃尔什变换,利用类似FFT的东西解决一类卷积问题\n>\n> MTT: 毛爷爷的FFT,非常nb\/任意模数\n>\n> FMT: 快速莫比乌斯变化\n>\n> (摘自https:\/\/www.cnblogs.com\/zwfymqz\/p\/8244902.html)\n\n为什么要用到FFT呢?\n\n以高精度乘法举个例子:\n\n你现在要计算$a\\times b,a,b>10^{1000000}$\n\n设$len_a=n,len_b=m$\n\n如果用普通的高精度乘法$\\mathcal{O(nm)}$,直接tle\n\n但是FFT可以做到$\\mathcal{O((n+m) \\log (n+m))}$\n\n原理: 先把多项式转化为用点值表示$\\mathcal{O(n \\log n)}$\n\n然后再用点值相乘来计算$\\mathcal{O(n)}$\n\n然后再通过点值还原多项式\n\n\n\n下面是前置知识:\n\n## 多项式\n\n### 系数表示法\n\n形式: $f(x)=\\sum_{i=0}^{n-1} a_ix^i$\n\n比如$123456$也可以看做一个多项式:\n\n$f(10)=6+5\\cdot10+4\\cdot10^2+3\\cdot10^3+2\\cdot 10^4+1\\cdot 10^5$\n\n### 点值表示法\n\n取$n$个点$x_1,x_2, \\dots ,x_n$\n\n代入$f(x)$会得到$n$个不同的$y_i$\n\n$f(x)$被$(x_1,y_1),(x_2,y_2),\\dots (x_n,y_n)$唯一确定\n\n定理:\n\n> 一个$n-1$次多项式在$n$个不同点的取值唯一确定了该多项式。\n\n证明: (反证法)\n\n> 假设命题不成立,那么存在两个不同的$n-1$次多项式$A(x),B(x)$满足: $\\forall i\\in[1,n], A(x_i)=B(x_i)$\n>\n> 令$C(x)=A(x)-B(x)$,那么$C(x)$也是一个$n-1$次多项式,且$\\forall i\\in[1,n], C(x_i)=0$\n>\n> 这样的话$C(x)$有$n$个根,与代数基本定理($n$次多项式有且仅有$n$个根)不符,所以$C(x)$不是$n-1$次多项式\n>\n> 所以原命题成立\n>\n> (摘自https:\/\/zhuanlan.zhihu.com\/p\/31584464)\n\n## 复数\n\n复数由实部(real)和虚部(image)组成,形如$a+bi$\n\n$i$是虚树单位,$i^2=-1,i=\\sqrt{-1}$\n\n### 复数运算法则:\n\n$(a+bi)+(c+di)=(a+c)+(b+d)i$\n\n$(a+bi)-(c+di)=(a-c)+(b-d)i$\n\n$(a+bi)\\cdot(c+di)=(ac-bd)+(ad+bc)i$\n\n复数$z=a+bi$在复平面中对应坐标为$(a,b)$\n\n复平面中$x$轴又称实轴,$y$轴又称虚轴\n\n### 共轭复数\n\n复数$z=a+bi$的共轭复数$z'=a-bi$,$z'$称为$z$的复共轭\n\n性质:\n\n$z\\cdot z' = a^2 + b^2$\n\n$|z|=|z'|$(模长相等,到原点的距离相等)\n\n\n## 单位根\n\n若$\\omega^n=1$则$\\omega$为$n$次单位根\n\n在复平面上,以原点为圆心,$1$为半径作圆,所得的圆叫单位圆。\n\n以圆心为起点,圆的$n$等分点为终点,做$n$个向量。\n\n其中幅角为正且最小的向量称为$n$次单位向量,记为$\\omega_n^1$\n\n根据复数乘法的运算法则,其余$n−1$个复数为$\\omega_n^2,\\omega_n^3,\\dots,\\omega_n^n$\n\n$\\omega_n^0=\\omega_n^n=1$,在复平面上对应的点为$(1,0)$\n\n<html>\n\n<svg version=\"1.1\" xmlns=\"http:\/\/www.w3.org\/2000\/svg\" xmlns:xlink=\"http:\/\/www.w3.org\/1999\/xlink\" width=\"584\" height=\"294\"><defs><clipPath id=\"HfoVspciGtkQ\"><path fill=\"none\" stroke=\"none\" d=\" M 0 0 L 584 0 L 584 294 L 0 294 L 0 0 Z\"\/><\/clipPath><\/defs><g transform=\"scale(1,1)\" clip-path=\"url(#HfoVspciGtkQ)\"><g><rect fill=\"rgb(255,255,255)\" stroke=\"none\" x=\"0\" y=\"0\" width=\"584\" height=\"294\" fill-opacity=\"1\"\/><path fill=\"none\" stroke=\"rgb(192,192,192)\" paint-order=\"fill stroke markers\" d=\" M 34.5 0.5 L 34.5 294.5 M 34.5 0.5 L 34.5 294.5 M 100.5 0.5 L 100.5 294.5 M 167.5 0.5 L 167.5 294.5 M 300.5 0.5 L 300.5 294.5 M 367.5 0.5 L 367.5 294.5 M 433.5 0.5 L 433.5 294.5 M 500.5 0.5 L 500.5 294.5 M 567.5 0.5 L 567.5 294.5\" stroke-opacity=\"1\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-miterlimit=\"10\"\/><path fill=\"none\" stroke=\"rgb(192,192,192)\" paint-order=\"fill stroke markers\" d=\" M 7.5 0.5 L 7.5 294.5 M 20.5 0.5 L 20.5 294.5 M 47.5 0.5 L 47.5 294.5 M 60.5 0.5 L 60.5 294.5 M 74.5 0.5 L 74.5 294.5 M 87.5 0.5 L 87.5 294.5 M 114.5 0.5 L 114.5 294.5 M 127.5 0.5 L 127.5 294.5 M 140.5 0.5 L 140.5 294.5 M 154.5 0.5 L 154.5 294.5 M 180.5 0.5 L 180.5 294.5 M 194.5 0.5 L 194.5 294.5 M 207.5 0.5 L 207.5 294.5 M 220.5 0.5 L 220.5 294.5 M 247.5 0.5 L 247.5 294.5 M 260.5 0.5 L 260.5 294.5 M 273.5 0.5 L 273.5 294.5 M 287.5 0.5 L 287.5 294.5 M 313.5 0.5 L 313.5 294.5 M 327.5 0.5 L 327.5 294.5 M 340.5 0.5 L 340.5 294.5 M 353.5 0.5 L 353.5 294.5 M 380.5 0.5 L 380.5 294.5 M 393.5 0.5 L 393.5 294.5 M 407.5 0.5 L 407.5 294.5 M 420.5 0.5 L 420.5 294.5 M 447.5 0.5 L 447.5 294.5 M 460.5 0.5 L 460.5 294.5 M 473.5 0.5 L 473.5 294.5 M 487.5 0.5 L 487.5 294.5 M 513.5 0.5 L 513.5 294.5 M 527.5 0.5 L 527.5 294.5 M 540.5 0.5 L 540.5 294.5 M 553.5 0.5 L 553.5 294.5 M 580.5 0.5 L 580.5 294.5\" stroke-opacity=\"0.23529411764705882\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-miterlimit=\"10\"\/><path fill=\"none\" stroke=\"rgb(192,192,192)\" paint-order=\"fill stroke markers\" d=\" M 0.5 16.5 L 584.5 16.5 M 0.5 16.5 L 584.5 16.5 M 0.5 82.5 L 584.5 82.5 M 0.5 216.5 L 584.5 216.5 M 0.5 282.5 L 584.5 282.5\" stroke-opacity=\"1\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-miterlimit=\"10\"\/><path fill=\"none\" stroke=\"rgb(192,192,192)\" paint-order=\"fill stroke markers\" d=\" M 0.5 2.5 L 584.5 2.5 M 0.5 2.5 L 584.5 2.5 M 0.5 29.5 L 584.5 29.5 M 0.5 42.5 L 584.5 42.5 M 0.5 56.5 L 584.5 56.5 M 0.5 69.5 L 584.5 69.5 M 0.5 96.5 L 584.5 96.5 M 0.5 109.5 L 584.5 109.5 M 0.5 122.5 L 584.5 122.5 M 0.5 136.5 L 584.5 136.5 M 0.5 162.5 L 584.5 162.5 M 0.5 176.5 L 584.5 176.5 M 0.5 189.5 L 584.5 189.5 M 0.5 202.5 L 584.5 202.5 M 0.5 229.5 L 584.5 229.5 M 0.5 242.5 L 584.5 242.5 M 0.5 256.5 L 584.5 256.5 M 0.5 269.5 L 584.5 269.5\" stroke-opacity=\"0.23529411764705882\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-miterlimit=\"10\"\/><path fill=\"none\" stroke=\"rgb(0,0,0)\" paint-order=\"fill stroke markers\" d=\" M 233.5 2.5 L 233.5 294.5\" stroke-opacity=\"1\" stroke-miterlimit=\"10\"\/><path fill=\"none\" stroke=\"rgb(0,0,0)\" paint-order=\"fill stroke markers\" d=\" M 233.5 1.5 L 229.5 5.5\" stroke-opacity=\"1\" stroke-miterlimit=\"10\"\/><path fill=\"none\" stroke=\"rgb(0,0,0)\" paint-order=\"fill stroke markers\" d=\" M 233.5 1.5 L 237.5 5.5\" stroke-opacity=\"1\" stroke-miterlimit=\"10\"\/><path fill=\"none\" stroke=\"rgb(0,0,0)\" paint-order=\"fill stroke markers\" d=\" M 0.5 149.5 L 582.5 149.5\" stroke-opacity=\"1\" stroke-miterlimit=\"10\"\/><path fill=\"none\" stroke=\"rgb(0,0,0)\" paint-order=\"fill stroke markers\" d=\" M 583.5 149.5 L 579.5 145.5\" stroke-opacity=\"1\" stroke-miterlimit=\"10\"\/><path fill=\"none\" stroke=\"rgb(0,0,0)\" paint-order=\"fill stroke markers\" d=\" M 583.5 149.5 L 579.5 153.5\" stroke-opacity=\"1\" stroke-miterlimit=\"10\"\/><text fill=\"rgb(0,0,0)\" stroke=\"none\" font-family=\"geogebra-sans-serif, sans-serif\" font-size=\"12px\" font-style=\"normal\" font-weight=\"normal\" text-decoration=\"normal\" x=\"23\" y=\"165\" text-anchor=\"start\" dominant-baseline=\"alphabetic\" fill-opacity=\"1\">–1.5<\/text><text fill=\"none\" stroke=\"rgb(255,255,255)\" font-family=\"geogebra-sans-serif, sans-serif\" font-size=\"12px\" font-style=\"normal\" font-weight=\"normal\" text-decoration=\"normal\" x=\"23\" y=\"165\" text-anchor=\"start\" dominant-baseline=\"alphabetic\" stroke-opacity=\"1\" stroke-linejoin=\"bevel\" stroke-miterlimit=\"10\" stroke-width=\"3\">–1.5<\/text><text fill=\"rgb(0,0,0)\" stroke=\"none\" font-family=\"geogebra-sans-serif, sans-serif\" font-size=\"12px\" font-style=\"normal\" font-weight=\"normal\" text-decoration=\"normal\" x=\"23\" y=\"165\" text-anchor=\"start\" dominant-baseline=\"alphabetic\" fill-opacity=\"1\">–1.5<\/text><text fill=\"rgb(0,0,0)\" stroke=\"none\" font-family=\"geogebra-sans-serif, sans-serif\" font-size=\"12px\" font-style=\"normal\" font-weight=\"normal\" text-decoration=\"normal\" x=\"95\" y=\"165\" text-anchor=\"start\" dominant-baseline=\"alphabetic\" fill-opacity=\"1\">–1<\/text><text fill=\"none\" stroke=\"rgb(255,255,255)\" font-family=\"geogebra-sans-serif, sans-serif\" font-size=\"12px\" font-style=\"normal\" font-weight=\"normal\" text-decoration=\"normal\" x=\"95\" y=\"165\" text-anchor=\"start\" dominant-baseline=\"alphabetic\" stroke-opacity=\"1\" stroke-linejoin=\"bevel\" stroke-miterlimit=\"10\" stroke-width=\"3\">–1<\/text><text fill=\"rgb(0,0,0)\" stroke=\"none\" font-family=\"geogebra-sans-serif, sans-serif\" font-size=\"12px\" font-style=\"normal\" font-weight=\"normal\" text-decoration=\"normal\" x=\"95\" y=\"165\" text-anchor=\"start\" dominant-baseline=\"alphabetic\" fill-opacity=\"1\">–1<\/text><text fill=\"rgb(0,0,0)\" stroke=\"none\" font-family=\"geogebra-sans-serif, sans-serif\" font-size=\"12px\" font-style=\"normal\" font-weight=\"normal\" text-decoration=\"normal\" x=\"156\" y=\"165\" text-anchor=\"start\" dominant-baseline=\"alphabetic\" fill-opacity=\"1\">–0.5<\/text><text fill=\"none\" stroke=\"rgb(255,255,255)\" font-family=\"geogebra-sans-serif, sans-serif\" font-size=\"12px\" font-style=\"normal\" font-weight=\"normal\" text-decoration=\"normal\" x=\"156\" y=\"165\" text-anchor=\"start\" dominant-baseline=\"alphabetic\" stroke-opacity=\"1\" stroke-linejoin=\"bevel\" stroke-miterlimit=\"10\" stroke-width=\"3\">–0.5<\/text><text fill=\"rgb(0,0,0)\" stroke=\"none\" font-family=\"geogebra-sans-serif, sans-serif\" font-size=\"12px\" font-style=\"normal\" font-weight=\"normal\" text-decoration=\"normal\" x=\"156\" y=\"165\" text-anchor=\"start\" dominant-baseline=\"alphabetic\" fill-opacity=\"1\">–0.5<\/text><text fill=\"rgb(0,0,0)\" stroke=\"none\" font-family=\"geogebra-sans-serif, sans-serif\" font-size=\"12px\" font-style=\"normal\" font-weight=\"normal\" text-decoration=\"normal\" x=\"292\" y=\"165\" text-anchor=\"start\" dominant-baseline=\"alphabetic\" fill-opacity=\"1\">0.5<\/text><text fill=\"none\" stroke=\"rgb(255,255,255)\" font-family=\"geogebra-sans-serif, sans-serif\" font-size=\"12px\" font-style=\"normal\" font-weight=\"normal\" text-decoration=\"normal\" x=\"292\" y=\"165\" text-anchor=\"start\" dominant-baseline=\"alphabetic\" stroke-opacity=\"1\" stroke-linejoin=\"bevel\" stroke-miterlimit=\"10\" stroke-width=\"3\">0.5<\/text><text fill=\"rgb(0,0,0)\" stroke=\"none\" font-family=\"geogebra-sans-serif, sans-serif\" font-size=\"12px\" font-style=\"normal\" font-weight=\"normal\" text-decoration=\"normal\" x=\"292\" y=\"165\" text-anchor=\"start\" dominant-baseline=\"alphabetic\" fill-opacity=\"1\">0.5<\/text><text fill=\"rgb(0,0,0)\" stroke=\"none\" font-family=\"geogebra-sans-serif, sans-serif\" font-size=\"12px\" font-style=\"normal\" font-weight=\"normal\" text-decoration=\"normal\" x=\"365\" y=\"165\" text-anchor=\"start\" dominant-baseline=\"alphabetic\" fill-opacity=\"1\">1<\/text><text fill=\"none\" stroke=\"rgb(255,255,255)\" font-family=\"geogebra-sans-serif, sans-serif\" font-size=\"12px\" font-style=\"normal\" font-weight=\"normal\" text-decoration=\"normal\" x=\"365\" y=\"165\" text-anchor=\"start\" dominant-baseline=\"alphabetic\" stroke-opacity=\"1\" stroke-linejoin=\"bevel\" stroke-miterlimit=\"10\" stroke-width=\"3\">1<\/text><text fill=\"rgb(0,0,0)\" stroke=\"none\" font-family=\"geogebra-sans-serif, sans-serif\" font-size=\"12px\" font-style=\"normal\" font-weight=\"normal\" text-decoration=\"normal\" x=\"365\" y=\"165\" text-anchor=\"start\" dominant-baseline=\"alphabetic\" fill-opacity=\"1\">1<\/text><text fill=\"rgb(0,0,0)\" stroke=\"none\" font-family=\"geogebra-sans-serif, sans-serif\" font-size=\"12px\" font-style=\"normal\" font-weight=\"normal\" text-decoration=\"normal\" x=\"425\" y=\"165\" text-anchor=\"start\" dominant-baseline=\"alphabetic\" fill-opacity=\"1\">1.5<\/text><text fill=\"none\" stroke=\"rgb(255,255,255)\" font-family=\"geogebra-sans-serif, sans-serif\" font-size=\"12px\" font-style=\"normal\" font-weight=\"normal\" text-decoration=\"normal\" x=\"425\" y=\"165\" text-anchor=\"start\" dominant-baseline=\"alphabetic\" stroke-opacity=\"1\" stroke-linejoin=\"bevel\" stroke-miterlimit=\"10\" stroke-width=\"3\">1.5<\/text><text fill=\"rgb(0,0,0)\" stroke=\"none\" font-family=\"geogebra-sans-serif, sans-serif\" font-size=\"12px\" font-style=\"normal\" font-weight=\"normal\" text-decoration=\"normal\" x=\"425\" y=\"165\" text-anchor=\"start\" dominant-baseline=\"alphabetic\" fill-opacity=\"1\">1.5<\/text><text fill=\"rgb(0,0,0)\" stroke=\"none\" font-family=\"geogebra-sans-serif, sans-serif\" font-size=\"12px\" font-style=\"normal\" font-weight=\"normal\" text-decoration=\"normal\" x=\"498\" y=\"165\" text-anchor=\"start\" dominant-baseline=\"alphabetic\" fill-opacity=\"1\">2<\/text><text fill=\"none\" stroke=\"rgb(255,255,255)\" font-family=\"geogebra-sans-serif, sans-serif\" font-size=\"12px\" font-style=\"normal\" font-weight=\"normal\" text-decoration=\"normal\" x=\"498\" y=\"165\" text-anchor=\"start\" dominant-baseline=\"alphabetic\" stroke-opacity=\"1\" stroke-linejoin=\"bevel\" stroke-miterlimit=\"10\" stroke-width=\"3\">2<\/text><text fill=\"rgb(0,0,0)\" stroke=\"none\" font-family=\"geogebra-sans-serif, sans-serif\" font-size=\"12px\" font-style=\"normal\" font-weight=\"normal\" text-decoration=\"normal\" x=\"498\" y=\"165\" text-anchor=\"start\" dominant-baseline=\"alphabetic\" fill-opacity=\"1\">2<\/text><text fill=\"rgb(0,0,0)\" stroke=\"none\" font-family=\"geogebra-sans-serif, sans-serif\" font-size=\"12px\" font-style=\"normal\" font-weight=\"normal\" text-decoration=\"normal\" x=\"559\" y=\"165\" text-anchor=\"start\" dominant-baseline=\"alphabetic\" fill-opacity=\"1\">2.5<\/text><text fill=\"none\" stroke=\"rgb(255,255,255)\" font-family=\"geogebra-sans-serif, sans-serif\" font-size=\"12px\" font-style=\"normal\" font-weight=\"normal\" text-decoration=\"normal\" x=\"559\" y=\"165\" text-anchor=\"start\" dominant-baseline=\"alphabetic\" stroke-opacity=\"1\" stroke-linejoin=\"bevel\" stroke-miterlimit=\"10\" stroke-width=\"3\">2.5<\/text><text fill=\"rgb(0,0,0)\" stroke=\"none\" font-family=\"geogebra-sans-serif, sans-serif\" font-size=\"12px\" font-style=\"normal\" font-weight=\"normal\" text-decoration=\"normal\" x=\"559\" y=\"165\" text-anchor=\"start\" dominant-baseline=\"alphabetic\" fill-opacity=\"1\">2.5<\/text><text fill=\"rgb(0,0,0)\" stroke=\"none\" font-family=\"geogebra-sans-serif, sans-serif\" font-size=\"12px\" font-style=\"normal\" font-weight=\"normal\" text-decoration=\"normal\" x=\"212\" y=\"287\" text-anchor=\"start\" dominant-baseline=\"alphabetic\" fill-opacity=\"1\">–1<\/text><text fill=\"none\" stroke=\"rgb(255,255,255)\" font-family=\"geogebra-sans-serif, sans-serif\" font-size=\"12px\" font-style=\"normal\" font-weight=\"normal\" text-decoration=\"normal\" x=\"212\" y=\"287\" text-anchor=\"start\" dominant-baseline=\"alphabetic\" stroke-opacity=\"1\" stroke-linejoin=\"bevel\" stroke-miterlimit=\"10\" stroke-width=\"3\">–1<\/text><text fill=\"rgb(0,0,0)\" stroke=\"none\" font-family=\"geogebra-sans-serif, sans-serif\" font-size=\"12px\" font-style=\"normal\" font-weight=\"normal\" text-decoration=\"normal\" x=\"212\" y=\"287\" text-anchor=\"start\" dominant-baseline=\"alphabetic\" fill-opacity=\"1\">–1<\/text><text fill=\"rgb(0,0,0)\" stroke=\"none\" font-family=\"geogebra-sans-serif, sans-serif\" font-size=\"12px\" font-style=\"normal\" font-weight=\"normal\" text-decoration=\"normal\" x=\"197\" y=\"221\" text-anchor=\"start\" dominant-baseline=\"alphabetic\" fill-opacity=\"1\">–0.5<\/text><text fill=\"none\" stroke=\"rgb(255,255,255)\" font-family=\"geogebra-sans-serif, sans-serif\" font-size=\"12px\" font-style=\"normal\" font-weight=\"normal\" text-decoration=\"normal\" x=\"197\" y=\"221\" text-anchor=\"start\" dominant-baseline=\"alphabetic\" stroke-opacity=\"1\" stroke-linejoin=\"bevel\" stroke-miterlimit=\"10\" stroke-width=\"3\">–0.5<\/text><text fill=\"rgb(0,0,0)\" stroke=\"none\" font-family=\"geogebra-sans-serif, sans-serif\" font-size=\"12px\" font-style=\"normal\" font-weight=\"normal\" text-decoration=\"normal\" x=\"197\" y=\"221\" text-anchor=\"start\" dominant-baseline=\"alphabetic\" fill-opacity=\"1\">–0.5<\/text><text fill=\"rgb(0,0,0)\" stroke=\"none\" font-family=\"geogebra-sans-serif, sans-serif\" font-size=\"12px\" font-style=\"normal\" font-weight=\"normal\" text-decoration=\"normal\" x=\"204\" y=\"87\" text-anchor=\"start\" dominant-baseline=\"alphabetic\" fill-opacity=\"1\">0.5<\/text><text fill=\"none\" stroke=\"rgb(255,255,255)\" font-family=\"geogebra-sans-serif, sans-serif\" font-size=\"12px\" font-style=\"normal\" font-weight=\"normal\" text-decoration=\"normal\" x=\"204\" y=\"87\" text-anchor=\"start\" dominant-baseline=\"alphabetic\" stroke-opacity=\"1\" stroke-linejoin=\"bevel\" stroke-miterlimit=\"10\" stroke-width=\"3\">0.5<\/text><text fill=\"rgb(0,0,0)\" stroke=\"none\" font-family=\"geogebra-sans-serif, sans-serif\" font-size=\"12px\" font-style=\"normal\" font-weight=\"normal\" text-decoration=\"normal\" x=\"204\" y=\"87\" text-anchor=\"start\" dominant-baseline=\"alphabetic\" fill-opacity=\"1\">0.5<\/text><text fill=\"rgb(0,0,0)\" stroke=\"none\" font-family=\"geogebra-sans-serif, sans-serif\" font-size=\"12px\" font-style=\"normal\" font-weight=\"normal\" text-decoration=\"normal\" x=\"219\" y=\"21\" text-anchor=\"start\" dominant-baseline=\"alphabetic\" fill-opacity=\"1\">1<\/text><text fill=\"none\" stroke=\"rgb(255,255,255)\" font-family=\"geogebra-sans-serif, sans-serif\" font-size=\"12px\" font-style=\"normal\" font-weight=\"normal\" text-decoration=\"normal\" x=\"219\" y=\"21\" text-anchor=\"start\" dominant-baseline=\"alphabetic\" stroke-opacity=\"1\" stroke-linejoin=\"bevel\" stroke-miterlimit=\"10\" stroke-width=\"3\">1<\/text><text fill=\"rgb(0,0,0)\" stroke=\"none\" font-family=\"geogebra-sans-serif, sans-serif\" font-size=\"12px\" font-style=\"normal\" font-weight=\"normal\" text-decoration=\"normal\" x=\"219\" y=\"21\" text-anchor=\"start\" dominant-baseline=\"alphabetic\" fill-opacity=\"1\">1<\/text><text fill=\"rgb(0,0,0)\" stroke=\"none\" font-family=\"geogebra-sans-serif, sans-serif\" font-size=\"12px\" font-style=\"normal\" font-weight=\"normal\" text-decoration=\"normal\" x=\"219\" y=\"165\" text-anchor=\"start\" dominant-baseline=\"alphabetic\" fill-opacity=\"1\">0<\/text><text fill=\"none\" stroke=\"rgb(255,255,255)\" font-family=\"geogebra-sans-serif, sans-serif\" font-size=\"12px\" font-style=\"normal\" font-weight=\"normal\" text-decoration=\"normal\" x=\"219\" y=\"165\" text-anchor=\"start\" dominant-baseline=\"alphabetic\" stroke-opacity=\"1\" stroke-linejoin=\"bevel\" stroke-miterlimit=\"10\" stroke-width=\"3\">0<\/text><text fill=\"rgb(0,0,0)\" stroke=\"none\" font-family=\"geogebra-sans-serif, sans-serif\" font-size=\"12px\" font-style=\"normal\" font-weight=\"normal\" text-decoration=\"normal\" x=\"219\" y=\"165\" text-anchor=\"start\" dominant-baseline=\"alphabetic\" fill-opacity=\"1\">0<\/text><path fill=\"none\" stroke=\"rgb(97,97,97)\" paint-order=\"fill stroke markers\" d=\" M 367.23252568911755 149.44244871325463 C 367.23252568911755 223.03584163929233 307.5732931378362 282.695074190574 233.97990021179882 282.695074190574 C 160.38650728576147 282.695074190574 100.72727473448012 223.03584163929233 100.72727473448012 149.44244871325463 C 100.72727473448012 75.84905578721691 160.38650728576147 16.18982323593528 233.97990021179882 16.18982323593528 C 307.5732931378362 16.18982323593528 367.23252568911755 75.84905578721691 367.23252568911755 149.44244871325463 Z\" stroke-opacity=\"0.8\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2.5\"\/><path fill=\"rgb(0,0,0)\" stroke=\"none\" paint-order=\"stroke fill markers\" d=\" M 263.97990021179885 149.44244871325463 C 263.97990021179885 141.48595401806827 260.8191950008363 133.8553366310992 255.19310364739525 128.2292452776581 L 233.97990021179882 149.44244871325463 Z\" fill-opacity=\"0.09803921568627451\"\/><path fill=\"none\" stroke=\"rgb(0,0,0)\" paint-order=\"fill stroke markers\" d=\" M 263.97990021179885 149.44244871325463 C 263.97990021179885 141.48595401806827 260.8191950008363 133.8553366310992 255.19310364739525 128.2292452776581 L 233.97990021179882 149.44244871325463 Z\" stroke-opacity=\"0.6\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\"\/><text fill=\"rgb(0,0,0)\" stroke=\"none\" font-family=\"geogebra-sans-serif, sans-serif\" font-size=\"16px\" font-style=\"normal\" font-weight=\"normal\" text-decoration=\"normal\" x=\"247\" y=\"147\" text-anchor=\"start\" dominant-baseline=\"alphabetic\" fill-opacity=\"1\">θ<\/text><text fill=\"none\" stroke=\"rgb(255,255,255)\" font-family=\"geogebra-sans-serif, sans-serif\" font-size=\"16px\" font-style=\"normal\" font-weight=\"normal\" text-decoration=\"normal\" x=\"247\" y=\"147\" text-anchor=\"start\" dominant-baseline=\"alphabetic\" stroke-opacity=\"1\" stroke-linejoin=\"bevel\" stroke-miterlimit=\"10\" stroke-width=\"3\">θ<\/text><text fill=\"rgb(0,0,0)\" stroke=\"none\" font-family=\"geogebra-sans-serif, sans-serif\" font-size=\"16px\" font-style=\"normal\" font-weight=\"normal\" text-decoration=\"normal\" x=\"247\" y=\"147\" text-anchor=\"start\" dominant-baseline=\"alphabetic\" fill-opacity=\"1\">θ<\/text><path fill=\"none\" stroke=\"rgb(97,97,97)\" paint-order=\"fill stroke markers\" d=\" M 233.97990021179882 149.44244871325463 L 316.1829200175509 67.23942890750214\" stroke-opacity=\"0.8\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2.5\"\/><path fill=\"rgb(97,97,97)\" stroke=\"none\" paint-order=\"stroke fill markers\" fill-rule=\"evenodd\" d=\" M 328.2037352977222 55.21861362733081 L 319.1881238375937 70.24463272754497 L 313.17771619750806 64.23422508745932 Z\" fill-opacity=\"0.8\"\/><path fill=\"none\" stroke=\"rgb(97,97,97)\" paint-order=\"fill stroke markers\" d=\" M 233.97990021179882 149.44244871325463 L 151.77688040604676 231.64546851900712\" stroke-opacity=\"0.8\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2.5\"\/><path fill=\"rgb(97,97,97)\" stroke=\"none\" paint-order=\"stroke fill markers\" fill-rule=\"evenodd\" d=\" M 139.75606512587547 243.66628379917847 L 148.77167658600393 228.6402646989643 L 154.78208422608958 234.65067233904995 Z\" fill-opacity=\"0.8\"\/><path fill=\"none\" stroke=\"rgb(97,97,97)\" paint-order=\"fill stroke markers\" d=\" M 233.97990021179882 149.44244871325463 L 151.77688040604676 67.23942890750214\" stroke-opacity=\"0.8\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2.5\"\/><path fill=\"rgb(97,97,97)\" stroke=\"none\" paint-order=\"stroke fill markers\" fill-rule=\"evenodd\" d=\" M 139.75606512587547 55.21861362733081 L 154.78208422608958 64.23422508745932 L 148.77167658600393 70.24463272754497 Z\" fill-opacity=\"0.8\"\/><path fill=\"none\" stroke=\"rgb(97,97,97)\" paint-order=\"fill stroke markers\" d=\" M 233.97990021179882 149.44244871325463 L 316.1829200175509 231.64546851900712\" stroke-opacity=\"0.8\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2.5\"\/><path fill=\"rgb(97,97,97)\" stroke=\"none\" paint-order=\"stroke fill markers\" fill-rule=\"evenodd\" d=\" M 328.2037352977222 243.66628379917847 L 313.17771619750806 234.65067233904995 L 319.1881238375937 228.6402646989643 Z\" fill-opacity=\"0.8\"\/><path fill=\"none\" stroke=\"rgb(97,97,97)\" paint-order=\"fill stroke markers\" d=\" M 233.97990021179882 149.44244871325463 L 350.23252568911755 149.44244871325463\" stroke-opacity=\"0.8\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2.5\"\/><path fill=\"rgb(97,97,97)\" stroke=\"none\" paint-order=\"stroke fill markers\" fill-rule=\"evenodd\" d=\" M 367.23252568911755 149.44244871325463 L 350.23252568911755 153.69244871325463 L 350.23252568911755 145.19244871325463 Z\" fill-opacity=\"0.8\"\/><path fill=\"none\" stroke=\"rgb(97,97,97)\" paint-order=\"fill stroke markers\" d=\" M 233.97990021179882 149.44244871325463 L 117.72727473448012 149.44244871325463\" stroke-opacity=\"0.8\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2.5\"\/><path fill=\"rgb(97,97,97)\" stroke=\"none\" paint-order=\"stroke fill markers\" fill-rule=\"evenodd\" d=\" M 100.72727473448012 149.44244871325463 L 117.72727473448012 145.19244871325463 L 117.72727473448012 153.69244871325463 Z\" fill-opacity=\"0.8\"\/><path fill=\"none\" stroke=\"rgb(97,97,97)\" paint-order=\"fill stroke markers\" d=\" M 233.97990021179882 149.44244871325463 L 233.97990021179882 265.695074190574\" stroke-opacity=\"0.8\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2.5\"\/><path fill=\"rgb(97,97,97)\" stroke=\"none\" paint-order=\"stroke fill markers\" fill-rule=\"evenodd\" d=\" M 233.97990021179882 282.695074190574 L 229.72990021179882 265.695074190574 L 238.22990021179882 265.695074190574 Z\" fill-opacity=\"0.8\"\/><path fill=\"none\" stroke=\"rgb(97,97,97)\" paint-order=\"fill stroke markers\" d=\" M 233.97990021179882 149.44244871325463 L 233.97990021179882 33.18982323593528\" stroke-opacity=\"0.8\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2.5\"\/><path fill=\"rgb(97,97,97)\" stroke=\"none\" paint-order=\"stroke fill markers\" fill-rule=\"evenodd\" d=\" M 233.97990021179882 16.18982323593528 L 238.22990021179882 33.18982323593528 L 229.72990021179882 33.18982323593528 Z\" fill-opacity=\"0.8\"\/><path fill=\"rgb(97,97,97)\" stroke=\"none\" paint-order=\"stroke fill markers\" d=\" M 237.97990021179882 149.44244871325463 C 237.97990021179882 151.6515877125778 236.189039211122 153.44244871325463 233.97990021179882 153.44244871325463 C 231.77076121247563 153.44244871325463 229.97990021179882 151.6515877125778 229.97990021179882 149.44244871325463 C 229.97990021179882 147.23330971393145 231.77076121247563 145.44244871325463 233.97990021179882 145.44244871325463 C 236.189039211122 145.44244871325463 237.97990021179882 147.23330971393145 237.97990021179882 149.44244871325463 Z\" fill-opacity=\"1\"\/><path fill=\"none\" stroke=\"rgb(0,0,0)\" paint-order=\"fill stroke markers\" d=\" M 237.97990021179882 149.44244871325463 C 237.97990021179882 151.6515877125778 236.189039211122 153.44244871325463 233.97990021179882 153.44244871325463 C 231.77076121247563 153.44244871325463 229.97990021179882 151.6515877125778 229.97990021179882 149.44244871325463 C 229.97990021179882 147.23330971393145 231.77076121247563 145.44244871325463 233.97990021179882 145.44244871325463 C 236.189039211122 145.44244871325463 237.97990021179882 147.23330971393145 237.97990021179882 149.44244871325463 Z\" stroke-opacity=\"1\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-miterlimit=\"10\"\/><text fill=\"rgb(97,97,97)\" stroke=\"none\" font-family=\"geogebra-sans-serif, sans-serif\" font-size=\"16px\" font-style=\"normal\" font-weight=\"normal\" text-decoration=\"normal\" x=\"238\" y=\"141\" text-anchor=\"start\" dominant-baseline=\"alphabetic\" fill-opacity=\"1\">O<\/text><text fill=\"none\" stroke=\"rgb(255,255,255)\" font-family=\"geogebra-sans-serif, sans-serif\" font-size=\"16px\" font-style=\"normal\" font-weight=\"normal\" text-decoration=\"normal\" x=\"238\" y=\"141\" text-anchor=\"start\" dominant-baseline=\"alphabetic\" stroke-opacity=\"1\" stroke-linejoin=\"bevel\" stroke-miterlimit=\"10\" stroke-width=\"3\">O<\/text><text fill=\"rgb(97,97,97)\" stroke=\"none\" font-family=\"geogebra-sans-serif, sans-serif\" font-size=\"16px\" font-style=\"normal\" font-weight=\"normal\" text-decoration=\"normal\" x=\"238\" y=\"141\" text-anchor=\"start\" dominant-baseline=\"alphabetic\" fill-opacity=\"1\">O<\/text><path fill=\"rgb(21,101,192)\" stroke=\"none\" paint-order=\"stroke fill markers\" d=\" M 372.23252568911755 149.44244871325463 C 372.23252568911755 152.2038724624086 369.9939494382715 154.44244871325463 367.23252568911755 154.44244871325463 C 364.4711019399636 154.44244871325463 362.23252568911755 152.2038724624086 362.23252568911755 149.44244871325463 C 362.23252568911755 146.68102496410066 364.4711019399636 144.44244871325463 367.23252568911755 144.44244871325463 C 369.9939494382715 144.44244871325463 372.23252568911755 146.68102496410066 372.23252568911755 149.44244871325463 Z\" fill-opacity=\"1\"\/><path fill=\"none\" stroke=\"rgb(0,0,0)\" paint-order=\"fill stroke markers\" d=\" M 372.23252568911755 149.44244871325463 C 372.23252568911755 152.2038724624086 369.9939494382715 154.44244871325463 367.23252568911755 154.44244871325463 C 364.4711019399636 154.44244871325463 362.23252568911755 152.2038724624086 362.23252568911755 149.44244871325463 C 362.23252568911755 146.68102496410066 364.4711019399636 144.44244871325463 367.23252568911755 144.44244871325463 C 369.9939494382715 144.44244871325463 372.23252568911755 146.68102496410066 372.23252568911755 149.44244871325463 Z\" stroke-opacity=\"1\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-miterlimit=\"10\"\/><path fill=\"rgb(21,101,192)\" stroke=\"none\" paint-order=\"stroke fill markers\" d=\" M 333.2037352977222 55.21861362733081 C 333.2037352977222 57.98003737648477 330.9651590468761 60.21861362733081 328.2037352977222 60.21861362733081 C 325.4423115485682 60.21861362733081 323.2037352977222 57.98003737648477 323.2037352977222 55.21861362733081 C 323.2037352977222 52.45718987817684 325.4423115485682 50.21861362733081 328.2037352977222 50.21861362733081 C 330.9651590468761 50.21861362733081 333.2037352977222 52.45718987817684 333.2037352977222 55.21861362733081 Z\" fill-opacity=\"1\"\/><path fill=\"none\" stroke=\"rgb(0,0,0)\" paint-order=\"fill stroke markers\" d=\" M 333.2037352977222 55.21861362733081 C 333.2037352977222 57.98003737648477 330.9651590468761 60.21861362733081 328.2037352977222 60.21861362733081 C 325.4423115485682 60.21861362733081 323.2037352977222 57.98003737648477 323.2037352977222 55.21861362733081 C 323.2037352977222 52.45718987817684 325.4423115485682 50.21861362733081 328.2037352977222 50.21861362733081 C 330.9651590468761 50.21861362733081 333.2037352977222 52.45718987817684 333.2037352977222 55.21861362733081 Z\" stroke-opacity=\"1\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-miterlimit=\"10\"\/><text fill=\"rgb(21,101,192)\" stroke=\"none\" font-family=\"geogebra-sans-serif, sans-serif\" font-size=\"16px\" font-style=\"normal\" font-weight=\"normal\" text-decoration=\"normal\" x=\"332\" y=\"45\" text-anchor=\"start\" dominant-baseline=\"alphabetic\" fill-opacity=\"1\">ω<\/text><text fill=\"none\" stroke=\"rgb(255,255,255)\" font-family=\"geogebra-sans-serif, sans-serif\" font-size=\"16px\" font-style=\"normal\" font-weight=\"normal\" text-decoration=\"normal\" x=\"332\" y=\"45\" text-anchor=\"start\" dominant-baseline=\"alphabetic\" stroke-opacity=\"1\" stroke-linejoin=\"bevel\" stroke-miterlimit=\"10\" stroke-width=\"3\">ω<\/text><text fill=\"rgb(21,101,192)\" stroke=\"none\" font-family=\"geogebra-sans-serif, sans-serif\" font-size=\"16px\" font-style=\"normal\" font-weight=\"normal\" text-decoration=\"normal\" x=\"332\" y=\"45\" text-anchor=\"start\" dominant-baseline=\"alphabetic\" fill-opacity=\"1\">ω<\/text><text fill=\"rgb(21,101,192)\" stroke=\"none\" font-family=\"geogebra-sans-serif, sans-serif\" font-size=\"14px\" font-style=\"normal\" font-weight=\"normal\" text-decoration=\"normal\" x=\"346\" y=\"52\" text-anchor=\"start\" dominant-baseline=\"alphabetic\" fill-opacity=\"1\">8<\/text><text fill=\"none\" stroke=\"rgb(255,255,255)\" font-family=\"geogebra-sans-serif, sans-serif\" font-size=\"14px\" font-style=\"normal\" font-weight=\"normal\" text-decoration=\"normal\" x=\"346\" y=\"52\" text-anchor=\"start\" dominant-baseline=\"alphabetic\" stroke-opacity=\"1\" stroke-linejoin=\"bevel\" stroke-miterlimit=\"10\" stroke-width=\"3\">8<\/text><text fill=\"rgb(21,101,192)\" stroke=\"none\" font-family=\"geogebra-sans-serif, sans-serif\" font-size=\"14px\" font-style=\"normal\" font-weight=\"normal\" text-decoration=\"normal\" x=\"346\" y=\"52\" text-anchor=\"start\" dominant-baseline=\"alphabetic\" fill-opacity=\"1\">8<\/text><text fill=\"rgb(21,101,192)\" stroke=\"none\" font-family=\"geogebra-sans-serif, sans-serif\" font-size=\"16px\" font-style=\"normal\" font-weight=\"normal\" text-decoration=\"normal\" x=\"354\" y=\"45\" text-anchor=\"start\" dominant-baseline=\"alphabetic\" fill-opacity=\"1\">(cos θ, i sin θ)<\/text><text fill=\"none\" stroke=\"rgb(255,255,255)\" font-family=\"geogebra-sans-serif, sans-serif\" font-size=\"16px\" font-style=\"normal\" font-weight=\"normal\" text-decoration=\"normal\" x=\"354\" y=\"45\" text-anchor=\"start\" dominant-baseline=\"alphabetic\" stroke-opacity=\"1\" stroke-linejoin=\"bevel\" stroke-miterlimit=\"10\" stroke-width=\"3\">(cos θ, i sin θ)<\/text><text fill=\"rgb(21,101,192)\" stroke=\"none\" font-family=\"geogebra-sans-serif, sans-serif\" font-size=\"16px\" font-style=\"normal\" font-weight=\"normal\" text-decoration=\"normal\" x=\"354\" y=\"45\" text-anchor=\"start\" dominant-baseline=\"alphabetic\" fill-opacity=\"1\">(cos θ, sin θ)<\/text><path fill=\"rgb(97,97,97)\" stroke=\"none\" paint-order=\"stroke fill markers\" d=\" M 143.75606512587547 243.66628379917847 C 143.75606512587547 245.87542279850163 141.96520412519862 247.66628379917847 139.75606512587547 247.66628379917847 C 137.54692612655228 247.66628379917847 135.75606512587547 245.87542279850163 135.75606512587547 243.66628379917847 C 135.75606512587547 241.45714479985529 137.54692612655228 239.66628379917847 139.75606512587547 239.66628379917847 C 141.96520412519862 239.66628379917847 143.75606512587547 241.45714479985529 143.75606512587547 243.66628379917847 Z\" fill-opacity=\"1\"\/><path fill=\"none\" stroke=\"rgb(0,0,0)\" paint-order=\"fill stroke markers\" d=\" M 143.75606512587547 243.66628379917847 C 143.75606512587547 245.87542279850163 141.96520412519862 247.66628379917847 139.75606512587547 247.66628379917847 C 137.54692612655228 247.66628379917847 135.75606512587547 245.87542279850163 135.75606512587547 243.66628379917847 C 135.75606512587547 241.45714479985529 137.54692612655228 239.66628379917847 139.75606512587547 239.66628379917847 C 141.96520412519862 239.66628379917847 143.75606512587547 241.45714479985529 143.75606512587547 243.66628379917847 Z\" stroke-opacity=\"1\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-miterlimit=\"10\"\/><text fill=\"rgb(97,97,97)\" stroke=\"none\" font-family=\"geogebra-sans-serif, sans-serif\" font-size=\"16px\" font-style=\"normal\" font-weight=\"normal\" text-decoration=\"normal\" x=\"144\" y=\"236\" text-anchor=\"start\" dominant-baseline=\"alphabetic\" fill-opacity=\"1\">C<\/text><text fill=\"none\" stroke=\"rgb(255,255,255)\" font-family=\"geogebra-sans-serif, sans-serif\" font-size=\"16px\" font-style=\"normal\" font-weight=\"normal\" text-decoration=\"normal\" x=\"144\" y=\"236\" text-anchor=\"start\" dominant-baseline=\"alphabetic\" stroke-opacity=\"1\" stroke-linejoin=\"bevel\" stroke-miterlimit=\"10\" stroke-width=\"3\">C<\/text><text fill=\"rgb(97,97,97)\" stroke=\"none\" font-family=\"geogebra-sans-serif, sans-serif\" font-size=\"16px\" font-style=\"normal\" font-weight=\"normal\" text-decoration=\"normal\" x=\"144\" y=\"236\" text-anchor=\"start\" dominant-baseline=\"alphabetic\" fill-opacity=\"1\">C<\/text><path fill=\"rgb(97,97,97)\" stroke=\"none\" paint-order=\"stroke fill markers\" d=\" M 143.75606512587547 55.21861362733081 C 143.75606512587547 57.427752626653984 141.96520412519862 59.21861362733081 139.75606512587547 59.21861362733081 C 137.54692612655228 59.21861362733081 135.75606512587547 57.427752626653984 135.75606512587547 55.21861362733081 C 135.75606512587547 53.00947462800764 137.54692612655228 51.21861362733081 139.75606512587547 51.21861362733081 C 141.96520412519862 51.21861362733081 143.75606512587547 53.00947462800764 143.75606512587547 55.21861362733081 Z\" fill-opacity=\"1\"\/><path fill=\"none\" stroke=\"rgb(0,0,0)\" paint-order=\"fill stroke markers\" d=\" M 143.75606512587547 55.21861362733081 C 143.75606512587547 57.427752626653984 141.96520412519862 59.21861362733081 139.75606512587547 59.21861362733081 C 137.54692612655228 59.21861362733081 135.75606512587547 57.427752626653984 135.75606512587547 55.21861362733081 C 135.75606512587547 53.00947462800764 137.54692612655228 51.21861362733081 139.75606512587547 51.21861362733081 C 141.96520412519862 51.21861362733081 143.75606512587547 53.00947462800764 143.75606512587547 55.21861362733081 Z\" stroke-opacity=\"1\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-miterlimit=\"10\"\/><text fill=\"rgb(97,97,97)\" stroke=\"none\" font-family=\"geogebra-sans-serif, sans-serif\" font-size=\"16px\" font-style=\"normal\" font-weight=\"normal\" text-decoration=\"normal\" x=\"144\" y=\"47\" text-anchor=\"start\" dominant-baseline=\"alphabetic\" fill-opacity=\"1\">B<\/text><text fill=\"none\" stroke=\"rgb(255,255,255)\" font-family=\"geogebra-sans-serif, sans-serif\" font-size=\"16px\" font-style=\"normal\" font-weight=\"normal\" text-decoration=\"normal\" x=\"144\" y=\"47\" text-anchor=\"start\" dominant-baseline=\"alphabetic\" stroke-opacity=\"1\" stroke-linejoin=\"bevel\" stroke-miterlimit=\"10\" stroke-width=\"3\">B<\/text><text fill=\"rgb(97,97,97)\" stroke=\"none\" font-family=\"geogebra-sans-serif, sans-serif\" font-size=\"16px\" font-style=\"normal\" font-weight=\"normal\" text-decoration=\"normal\" x=\"144\" y=\"47\" text-anchor=\"start\" dominant-baseline=\"alphabetic\" fill-opacity=\"1\">B<\/text><path fill=\"rgb(97,97,97)\" stroke=\"none\" paint-order=\"stroke fill markers\" d=\" M 332.2037352977222 243.66628379917847 C 332.2037352977222 245.87542279850163 330.41287429704533 247.66628379917847 328.2037352977222 247.66628379917847 C 325.994596298399 247.66628379917847 324.2037352977222 245.87542279850163 324.2037352977222 243.66628379917847 C 324.2037352977222 241.45714479985529 325.994596298399 239.66628379917847 328.2037352977222 239.66628379917847 C 330.41287429704533 239.66628379917847 332.2037352977222 241.45714479985529 332.2037352977222 243.66628379917847 Z\" fill-opacity=\"1\"\/><path fill=\"none\" stroke=\"rgb(0,0,0)\" paint-order=\"fill stroke markers\" d=\" M 332.2037352977222 243.66628379917847 C 332.2037352977222 245.87542279850163 330.41287429704533 247.66628379917847 328.2037352977222 247.66628379917847 C 325.994596298399 247.66628379917847 324.2037352977222 245.87542279850163 324.2037352977222 243.66628379917847 C 324.2037352977222 241.45714479985529 325.994596298399 239.66628379917847 328.2037352977222 239.66628379917847 C 330.41287429704533 239.66628379917847 332.2037352977222 241.45714479985529 332.2037352977222 243.66628379917847 Z\" stroke-opacity=\"1\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-miterlimit=\"10\"\/><text fill=\"rgb(97,97,97)\" stroke=\"none\" font-family=\"geogebra-sans-serif, sans-serif\" font-size=\"16px\" font-style=\"normal\" font-weight=\"normal\" text-decoration=\"normal\" x=\"332\" y=\"236\" text-anchor=\"start\" dominant-baseline=\"alphabetic\" fill-opacity=\"1\">D<\/text><text fill=\"none\" stroke=\"rgb(255,255,255)\" font-family=\"geogebra-sans-serif, sans-serif\" font-size=\"16px\" font-style=\"normal\" font-weight=\"normal\" text-decoration=\"normal\" x=\"332\" y=\"236\" text-anchor=\"start\" dominant-baseline=\"alphabetic\" stroke-opacity=\"1\" stroke-linejoin=\"bevel\" stroke-miterlimit=\"10\" stroke-width=\"3\">D<\/text><text fill=\"rgb(97,97,97)\" stroke=\"none\" font-family=\"geogebra-sans-serif, sans-serif\" font-size=\"16px\" font-style=\"normal\" font-weight=\"normal\" text-decoration=\"normal\" x=\"332\" y=\"236\" text-anchor=\"start\" dominant-baseline=\"alphabetic\" fill-opacity=\"1\">D<\/text><path fill=\"rgb(97,97,97)\" stroke=\"none\" paint-order=\"stroke fill markers\" d=\" M 104.72727473448012 149.44244871325463 C 104.72727473448012 151.6515877125778 102.93641373380329 153.44244871325463 100.72727473448012 153.44244871325463 C 98.51813573515695 153.44244871325463 96.72727473448012 151.6515877125778 96.72727473448012 149.44244871325463 C 96.72727473448012 147.23330971393145 98.51813573515695 145.44244871325463 100.72727473448012 145.44244871325463 C 102.93641373380329 145.44244871325463 104.72727473448012 147.23330971393145 104.72727473448012 149.44244871325463 Z\" fill-opacity=\"1\"\/><path fill=\"none\" stroke=\"rgb(0,0,0)\" paint-order=\"fill stroke markers\" d=\" M 104.72727473448012 149.44244871325463 C 104.72727473448012 151.6515877125778 102.93641373380329 153.44244871325463 100.72727473448012 153.44244871325463 C 98.51813573515695 153.44244871325463 96.72727473448012 151.6515877125778 96.72727473448012 149.44244871325463 C 96.72727473448012 147.23330971393145 98.51813573515695 145.44244871325463 100.72727473448012 145.44244871325463 C 102.93641373380329 145.44244871325463 104.72727473448012 147.23330971393145 104.72727473448012 149.44244871325463 Z\" stroke-opacity=\"1\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-miterlimit=\"10\"\/><text fill=\"rgb(97,97,97)\" stroke=\"none\" font-family=\"geogebra-sans-serif, sans-serif\" font-size=\"16px\" font-style=\"normal\" font-weight=\"normal\" text-decoration=\"normal\" x=\"105\" y=\"141\" text-anchor=\"start\" dominant-baseline=\"alphabetic\" fill-opacity=\"1\">E<\/text><text fill=\"none\" stroke=\"rgb(255,255,255)\" font-family=\"geogebra-sans-serif, sans-serif\" font-size=\"16px\" font-style=\"normal\" font-weight=\"normal\" text-decoration=\"normal\" x=\"105\" y=\"141\" text-anchor=\"start\" dominant-baseline=\"alphabetic\" stroke-opacity=\"1\" stroke-linejoin=\"bevel\" stroke-miterlimit=\"10\" stroke-width=\"3\">E<\/text><text fill=\"rgb(97,97,97)\" stroke=\"none\" font-family=\"geogebra-sans-serif, sans-serif\" font-size=\"16px\" font-style=\"normal\" font-weight=\"normal\" text-decoration=\"normal\" x=\"105\" y=\"141\" text-anchor=\"start\" dominant-baseline=\"alphabetic\" fill-opacity=\"1\">E<\/text><path fill=\"rgb(97,97,97)\" stroke=\"none\" paint-order=\"stroke fill markers\" d=\" M 237.97990021179882 282.695074190574 C 237.97990021179882 284.9042131898972 236.189039211122 286.695074190574 233.97990021179882 286.695074190574 C 231.77076121247563 286.695074190574 229.97990021179882 284.9042131898972 229.97990021179882 282.695074190574 C 229.97990021179882 280.48593519125086 231.77076121247563 278.695074190574 233.97990021179882 278.695074190574 C 236.189039211122 278.695074190574 237.97990021179882 280.48593519125086 237.97990021179882 282.695074190574 Z\" fill-opacity=\"1\"\/><path fill=\"none\" stroke=\"rgb(0,0,0)\" paint-order=\"fill stroke markers\" d=\" M 237.97990021179882 282.695074190574 C 237.97990021179882 284.9042131898972 236.189039211122 286.695074190574 233.97990021179882 286.695074190574 C 231.77076121247563 286.695074190574 229.97990021179882 284.9042131898972 229.97990021179882 282.695074190574 C 229.97990021179882 280.48593519125086 231.77076121247563 278.695074190574 233.97990021179882 278.695074190574 C 236.189039211122 278.695074190574 237.97990021179882 280.48593519125086 237.97990021179882 282.695074190574 Z\" stroke-opacity=\"1\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-miterlimit=\"10\"\/><text fill=\"rgb(97,97,97)\" stroke=\"none\" font-family=\"geogebra-sans-serif, sans-serif\" font-size=\"16px\" font-style=\"normal\" font-weight=\"normal\" text-decoration=\"normal\" x=\"238\" y=\"275\" text-anchor=\"start\" dominant-baseline=\"alphabetic\" fill-opacity=\"1\">F<\/text><text fill=\"none\" stroke=\"rgb(255,255,255)\" font-family=\"geogebra-sans-serif, sans-serif\" font-size=\"16px\" font-style=\"normal\" font-weight=\"normal\" text-decoration=\"normal\" x=\"238\" y=\"275\" text-anchor=\"start\" dominant-baseline=\"alphabetic\" stroke-opacity=\"1\" stroke-linejoin=\"bevel\" stroke-miterlimit=\"10\" stroke-width=\"3\">F<\/text><text fill=\"rgb(97,97,97)\" stroke=\"none\" font-family=\"geogebra-sans-serif, sans-serif\" font-size=\"16px\" font-style=\"normal\" font-weight=\"normal\" text-decoration=\"normal\" x=\"238\" y=\"275\" text-anchor=\"start\" dominant-baseline=\"alphabetic\" fill-opacity=\"1\">F<\/text><path fill=\"rgb(97,97,97)\" stroke=\"none\" paint-order=\"stroke fill markers\" d=\" M 237.97990021179882 16.18982323593528 C 237.97990021179882 18.398962235258452 236.189039211122 20.18982323593528 233.97990021179882 20.18982323593528 C 231.77076121247563 20.18982323593528 229.97990021179882 18.398962235258452 229.97990021179882 16.18982323593528 C 229.97990021179882 13.980684236612106 231.77076121247563 12.189823235935279 233.97990021179882 12.189823235935279 C 236.189039211122 12.189823235935279 237.97990021179882 13.980684236612106 237.97990021179882 16.18982323593528 Z\" fill-opacity=\"1\"\/><path fill=\"none\" stroke=\"rgb(0,0,0)\" paint-order=\"fill stroke markers\" d=\" M 237.97990021179882 16.18982323593528 C 237.97990021179882 18.398962235258452 236.189039211122 20.18982323593528 233.97990021179882 20.18982323593528 C 231.77076121247563 20.18982323593528 229.97990021179882 18.398962235258452 229.97990021179882 16.18982323593528 C 229.97990021179882 13.980684236612106 231.77076121247563 12.189823235935279 233.97990021179882 12.189823235935279 C 236.189039211122 12.189823235935279 237.97990021179882 13.980684236612106 237.97990021179882 16.18982323593528 Z\" stroke-opacity=\"1\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-miterlimit=\"10\"\/><text fill=\"rgb(97,97,97)\" stroke=\"none\" font-family=\"geogebra-sans-serif, sans-serif\" font-size=\"16px\" font-style=\"normal\" font-weight=\"normal\" text-decoration=\"normal\" x=\"238\" y=\"16\" text-anchor=\"start\" dominant-baseline=\"alphabetic\" fill-opacity=\"1\">G<\/text><text fill=\"none\" stroke=\"rgb(255,255,255)\" font-family=\"geogebra-sans-serif, sans-serif\" font-size=\"16px\" font-style=\"normal\" font-weight=\"normal\" text-decoration=\"normal\" x=\"238\" y=\"16\" text-anchor=\"start\" dominant-baseline=\"alphabetic\" stroke-opacity=\"1\" stroke-linejoin=\"bevel\" stroke-miterlimit=\"10\" stroke-width=\"3\">G<\/text><text fill=\"rgb(97,97,97)\" stroke=\"none\" font-family=\"geogebra-sans-serif, sans-serif\" font-size=\"16px\" font-style=\"normal\" font-weight=\"normal\" text-decoration=\"normal\" x=\"238\" y=\"16\" text-anchor=\"start\" dominant-baseline=\"alphabetic\" fill-opacity=\"1\">G<\/text><\/g><\/g><\/svg>\n\n<\/html>\n\n向量$\\overrightarrow{O\\omega_8}$表示的复数就是$8$次单位根,$\\omega_8^1$\n\n> 拓展:\n>\n> 欧拉公式: $e^{i\\theta}=\\cos\\theta + i \\sin \\theta$(在复平面内坐标为$(\\cos \\theta, \\sin \\theta)$)\n>\n> $\\omega_n^k=e^{i 2\\pi \\frac kn}$\n> (可以理解为从$\\omega_n^0(1,0)$开始走长度为$2\\pi \\frac kn$的圆弧后到达的位置)\n>\n> 欧拉公式: $e^{i\\pi}=-1$(复平面中的$(-1,0)$)\n>\n> 关于证明和理解,可以参考:\n> \n> [数学常数与欧拉公式](\/posts\/数学常数与欧拉公式)\n> \n> https:\/\/www.bilibili.com\/video\/av63666593\n>\n> https:\/\/www.bilibili.com\/video\/av79134103\n\n性质:\n\n$\\omega_n^k= \\cos 2\\pi\\frac kn+ i \\sin 2\\pi \\frac kn$\n\n$\\omega_{2n}^{2k}=\\omega_n^k$\n\n> $\\omega_{2n}^{2k}=\\cos 2\\pi\\frac {2k}{2n}+ i \\sin 2\\pi \\frac {2k}{2n}=\\cos 2\\pi\\frac kn+ i \\sin 2\\pi \\frac kn=\\omega_n^k$\n\n$\\omega_n^0=\\omega_n^n=1$\n\n$\\omega_n^{k+\\frac n2}=-\\omega_n^k$\n\n> $\\omega _{n}^{\\frac{n}{2}}=\\cos\\frac{n}{2}\\cdot\\frac{2\\pi}{n}+i\\sin\\frac{n}{2}\\cdot\\frac{2\\pi}{n}=-1$\n> (也就是上面说的$e^{i\\pi}$)\n\n\n\n正题开始:\n\n## DFT\n\n将多项式从系数表示法转换为点值表示法\n\n如果暴力代入$n$个点,复杂度还是$\\mathcal{O(n^2)}$的\n\n我们可以利用单位根的性质\n\n假设设$n$为偶数\n\n对于$A(x)=a_0+a_1x+a_2x^2+a_3x^3+\\dots+a_{n-1}x^{n-1}$\n\n$A(x)=(a_0+a_2x^2+a_4x^4+\\dots+a_{n-2}x^{n-2})+x(a_1+a_3x^2+a_5x^4+...+a_{n-1}x^{n-1})$\n\n设$A_1(x)=a_0+a_2x+a_4x^2+\\dots+a_{n-2}x^\\frac{n-2}2,A_2(x)=a_1+a_3x+a_5x^2+...+a_{n-1}x^\\frac{n-2}2$\n\n那么$A(x)=A_1(x^2)+xA_2(x^2)$\n\n设$0 \\le k \\le \\frac{n}{2}-1,k\\in Z$\n\n$A(\\omega_n^k)=A_1(\\omega_\\frac n2 ^k)+\\omega_n^k\\cdot A_2(\\omega_\\frac n2 ^k)$\n\n对于$\\frac n2 \\le k+\\frac n2 \\le n-1$\n\n$A(\\omega_n^{k+\\frac n2})=A_1(\\omega_n^{2k+n})+\\omega_n^{k+\\frac n2}\\cdot A_2(\\omega_n^{2k+n})$\n\n$\\because \\omega_n^{k+\\frac n2}=-\\omega_n^k,\\omega_n^{2k+n}=\\omega_\\frac n2^k$\n\n$\\therefore A(\\omega_n^{k+\\frac n2})=A_1(\\omega_\\frac n2^k)-\\omega_n^k\\cdot A_2(\\omega_\\frac n2^k)$\n\n如果已经知道$A_1,A_2$分别在$\\omega_\\frac n2 ^{0,1,2,...,\\frac n2 -1}$的取值,那么就可以在$\\mathcal{O(n)}$的时间内计算出$A(x)$,而$A_1(x),A_2(x)$的规模都是$A(x)$的一半\n\n复杂度$\\mathcal{T(n)=2T(\\frac n2)+O(n) = O(n \\log n)}$\n\n## IDFT\n\n使用快速傅里叶变换将点值表示的多项式转化为系数表示,这个过程叫做离散傅里叶逆变换\n\n即由$n$维点值向量$(A(x_0),A(x_1),\\dots,A(x_{n-1}))$推出$n$维系数向量$(a_0,a_1,\\dots,a_{n-1})$。\n\n设$y_0,y_1,y_2,...,y_{n-1}$是多项式$A(x)$变换后的点值\n\n设$(d_0,d_1,\\dots,d_{n-1})$为$(a_0,a_1,\\dots,a_{n-1})$离散傅里叶变换后的结果\n\n构造$F(x)=d_0+d_1x+d_2x^2+\\dots+d_{n-1}x^{n-1}$\n\n设向量$(c_0,c_1,\\dots,c_{n-1})$中\n\n$c_k$为$F(x)$在$x=\\omega_n^{-k}$时的点值表示\n\n$$\nc_k=\\sum_{i=0}^{n-1}d_i\\cdot(\\omega_n^{-k})^i\n\\\\\n=\\sum_{i=0}^{n-1}[\\sum_{j=0}^{n-1}a_j(\\omega_n^i)^j]\\cdot(\\omega_n^{-k})^i\n\\\\\n=\\sum_{j=0}^{n-1}a_j\\sum_{i=0}^{n-1}(\\omega_n^i)^j\\cdot(\\omega_n^{-k})^i\n\\\\\n=\\sum_{j=0}^{n-1}a_j\\sum_{i=0}^{n-1}(\\omega_n^i)^{j-k}\n$$\n\n观察$\\sum_{i=0}^{n-1}(\\omega_n^i)^{j-k}$\n\n当$j=k$时$\\sum_{i=0}^{n-1}(\\omega_n^i)^{j-k}=\\sum_{i=0}^{n-1}1=n$\n\n当$j\\not = k$时\n\n$\\sum_{i=0}^{n-1}(\\omega_n^i)^{j-k}=$\n\n$\\sum_{i=0}^{\\frac{n-1}2}(\\omega_n^i)^{j-k}+(\\omega_n^{i+\\frac{n-1}2})^{j-k}=0$\n\n也就是$n$次单位根会互相抵消\n\n$\\therefore \\sum_{i=0}^{n-1}(\\omega_n^i)^{j-k}=[j=k]\\cdot n$\n\n$\\therefore c_k=\\sum_{j=0}^{n-1}a_j\\sum_{i=0}^{n-1}(\\omega_n^i)^{j-k}=\\sum_{j=0}^{n-1}a_j [j=k]\\cdot n=na_k$\n\n$\\therefore a_k=\\frac{c_k}n$\n\n那么我们要将点值表示的多项式转化为系数表示:\n\n1. 将$(\\omega_n^0,\\omega_n^{-1},\\omega_n^{-2},\\dots,w_n^{-(n-1)})$作为差值节点,将点值再做一次DFT\n\n   得到$(c_0,c_1,c_2,\\dots,c_{n-1})$\n\n2. $(\\frac{c_0}n,\\frac{c_1}n,\\frac{c_2}n,\\dots,\\frac{c_{n-1}}n)$就是原来的$(a_0,a_1,a_2,\\dots,a_{n-1})$\n\n\n\n到这里我们就已经大致懂得FFT的原理了,那要怎么实现呢?\n\n## 实现\n\n[LG 3803 【模板】多项式乘法（FFT）](https:\/\/www.luogu.com.cn\/problem\/P3803)\n\n### 普通的递归写法\n\n~~Fst_Fst_**TLE**~~\n\n不断对下标进行奇偶分类,分成两个子序列之后再不断合并\n\n需要辅助数组,容易**TLE,MLE**\n\n### 迭代实现\n\n![](https:\/\/pic1.zhimg.com\/80\/v2-953d1cd6c91a84197775d504defe302c_hd.jpg)\n\n可以发现在不断进行奇偶分类之后,原数在数组中的位置下标最终变成了**下标的二进制反转**\n\n我们可以直接通过枚举来代替递归\n\n从最底层开始向上合并,那么怎么合并呢？\n\n#### 蝴蝶操作\n\n设该层一共有$n$项需要处理\n\n设$A_1(\\omega_{\\frac n2}^k)$和$A_2(\\omega_{\\frac n2}^k)$分别存放在$a_k$和$a_{k+\\frac n2}$\n\n$A_1(\\omega_n^k)$和$A_2(\\omega_n^k)$要存放在$buf(k)$和$buf(k+\\frac n2)$\n\n我们只需设中间变量$t=\\omega_n^k\\cdot a(k+\\frac n2)$\n\n$buf(k+\\frac n2)= a(k) - t$\n\n$buf(k) = a(k)+t$\n\n我们可以发现我们不需要辅助存放的数组$buf$了,直接在原序列操作即可\n\n代码:\n\n```cpp\n#include<bits\/stdc++.h>\n#define db double\n#define For(i,x,y) for(int i=x;i<=y;++i)\nconst int N=4000011;\nconst db Pi=acos(-1.0);\nint n,m,limit=1,l=0,r[N];\nstruct cp{db r,i;cp(db R=0,db I=0){r=R,i=I;}}a[N],b[N];\ncp operator + (cp a,cp b){return cp(a.r+b.r,a.i+b.i);}\ncp operator - (cp a,cp b){return cp(a.r-b.r,a.i-b.i);}\ncp operator * (cp a,cp b){return cp(a.r*b.r-a.i*b.i,a.r*b.i+a.i*b.r);}\nvoid fft(cp *A,int typ){\n    For(i,0,limit-1)\n        if(i<r[i])std::swap(A[i],A[r[i]]);\n    for(int len=1;len<limit;len<<=1){\/\/已处理好的长度块,也就是n\/2\n        cp Wn(cos(Pi\/len),typ*sin(Pi\/len));\/\/单位根\n        for(int i=0;i<limit;i+=(len<<1)){\n            cp w(1,0);\/\/w_n^0\n            For(k,0,len-1){\/\/蝴蝶操作\n                cp t=w*A[i+k+len];\n                A[i+k+len]=A[i+k]-t;\n                A[i+k]=A[i+k]+t;\n                w=w*Wn;\n            }\n        }\n    }\n}\nint main(){\n    scanf(\"%d%d\",&n,&m);\n    For(i,0,n)scanf(\"%lf\",&a[i].r);\n    For(i,0,m)scanf(\"%lf\",&b[i].r);\n\n    while(limit<=n+m)limit<<=1,++l;\n    For(i,0,limit-1)\/\/预处理出不断奇偶分类后的最终位置\n        r[i]=(r[i>>1]>>1)|((i&1)<<(l-1));\n\n    fft(a,1);fft(b,1);\/\/DFT\n    For(i,0,limit)a[i]=a[i]*b[i];\/\/点值相乘\n    fft(a,-1);\/\/IDFT\n    For(i,0,n+m)printf(\"%d \",int(a[i].r\/limit+0.5));\n}\n```\n\n\n\n本文部分内容摘自:(参考资料)\n\nhttps:\/\/zhuanlan.zhihu.com\/p\/31584464\n\nhttps:\/\/www.cnblogs.com\/zwfymqz\/p\/8244902.html\n\n","link":null,"tags":["数论","算法","高精度","fft"],"title":"快速傅里叶变换"},{"categories":[["刷题记录"]],"content":"\n我们要做的是强行将式子转换为bsgs能求解的形式(求$y^x\\equiv z \\pmod p$)\n\n$$\nX_{i+1} \\equiv aX_i+b \\pmod p\n\\\\\nX_{i+1} + \\frac ba \\equiv aX_i+b+\\frac ba \\pmod p\n\\\\\naX_{i+1} + b \\equiv a^2X_i+ab+b \\pmod p\n\\\\\nX_{i+2} \\equiv a^2X_i+ab + b \\pmod p\n$$\n\n继续往下推,并根据等比数列的公式可以得到:\n\n$$\nX_i \\equiv a^{i-1}X_1+\\frac{b(1-a^{i-1})}{1-a} \\pmod p\n$$\n\n带入$t\\equiv X_i \\pmod p$,得\n\n$$\nt \\equiv a^{i-1}X_1+\\frac{b(1-a^{i-1})}{1-a} \\pmod p\n\\\\\n(1-a)t \\equiv (1-a)a^{i-1}X_1+b(1-a^{i-1}) \\pmod p\n\\\\\nt-at \\equiv a^{i-1}(X_1-aX_1)+b-b\\cdot a^{i-1} \\pmod p\n\\\\\na^{i-1}(X_1-aX_1-b)\\equiv t-at-b \\pmod p\n\\\\\na^{i-1}\\equiv \\frac{t-at-b}{X_1-aX_1-b} \\pmod p\n$$\n\n成功强行转换\n\n~~可以用bsgs求解了!~~\n\n还没完,要考虑一下几种特殊情况: \n\n1. $X_1=t$\n   \n   第一天就可以读到\n2. $a=1$\n   \n   题目变为$X_1+kb \\equiv t \\pmod p$\n\n   因为$p$是质数,所以可以直接用费马小定理求逆元\n\n   $b=0$时无解\n3. $a=0$\n   \n   判断$b=t$\n   \n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\nconst int N=1000007;\nint n,p,a,b,X1,t,T;\nil int pw(int x,int b){\n    int ans=1;\n    while(b){\n        if(b&1)ans=1ll*ans*x%p;\n        b>>=1;x=1ll*x*x%p;\n    }\n    return ans;\n}\nil int inv(int x){return pw(x,p-2);}\nstruct hash{\n    int head[N],cnt=0;\n    struct edge{int to,nxt,w;}e[N];\n    il void add(int x,int y,int w){e[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;e[cnt].w=w;}\n    il void clear(){cnt=0;clr(head,0);}\n    il void ins(int x,int v){add(x%N,x,v);}\n    il int ask(int x){\n        for(int i=head[x%N];i;i=e[i].nxt)\n            if(e[i].to==x)return e[i].w;\n        return -1;\n    }\n}S;\n\nil int bsgs(int y,int z){\n    S.clear();\n    int m=sqrt(p)+1,x=z%p,f=pw(y,m);\n    Fur(i,0,m)S.ins(x,i),x=1ll*x*y%p;\n    x=1;\n    Fur(i,1,m){\n        x=1ll*x*f%p;\n        int k=S.ask(x);\n        if(~k)return ((1ll*i*m-k)%p+p)%p;\n    }\n    return -2;\n}\nint main(){\n    in(T);\n    while(T--){\n        in(p,a,b,X1,t);\n        if(X1==t){out(\"1\\n\");continue;}\n        if(!a){out((b==t)?2:-1,ln);continue;}\n        if(a==1){\n            if(!b)out(\"-1\\n\");\n            else out(1ll*inv(b)*(((t-X1)%p+p)%p)%p+1,ln);\n            continue;\n        }\n        int x=1ll*(t-(1ll*a*t%p)+p-b+p)%p*(inv(X1-1ll*a*X1%p+p-b+p)%p)%p;\n        out(bsgs(a,x)+1,ln);\n    }\n    flush();\n}\n```\n","link":null,"tags":["数论","bsgs"],"title":"LG 3306 [SDOI2013]随机数生成器"},{"categories":[["算法","数论"],["note"]],"content":"\n\n求解关于$x$的方程: \n\n$$y^x \\equiv z \\pmod p$$\n\n## bsgs\n\n当$\\gcd(y,p)=1$时\n\n解法: \n\n设$x=am-b$\n\n那么$y^{am} \\equiv z\\cdot a^b \\pmod p$\n\n右边: \n\n枚举$b$的取值$[0,m-1]$,计算右边的值,存入哈希表\n\n左边:\n\n枚举可能的$a$,也就是$[1,m]$,若左边的值在哈希表中出现过,那么当前$a$合法\n\n不难证明当$m=\\sqrt p$的时候复杂度最优,$\\Theta(\\sqrt p)$\n\n关键代码:\n\n```cpp\na%=p;\nif(!a){\n    if(!b)out(\"1\\n\");\n    else out(\"Orz, I cannot find x!\\n\");\n    continue;\n}\nint m=sqrt(p)+1,x=b%p,t=pw(a,m);\nS.clear();\nS.ins(x,0);\nFur(i,1,m)x=1ll*x*a%p,S.ins(x,i);\nx=1;\nbool ff=1;\nFur(i,1,m){\n    x=1ll*x*t%p;\n    int k=S[x];\n    if(~k){\n        ff=0;\n        out(((i*m-k)%p+p)%p,ln);\n        break;\n    }\n}\nif(ff)out(\"Orz, I cannot find x!\\n\");\n```\n\n## ex bsgs\n\n当$\\gcd(y,p)\\not =1$时\n\n$$\ny^x+kp=z\n$$\n\n令$d=\\gcd(y,p)$\n\n可以发现当$d|z$时才有解\n\n除去$d$\n\n$$\n\\frac ydy^{x-1}+k\\frac pd=\\frac zd\n$$\n\n就这样一直递归,除去$d$,直到$d=1$\n\n假设递归了$c$次,所有$d$乘积为$g$,那么\n\n$$\n\\frac {y^c}g y^{x-c}+k\\frac pg=\\frac zg\n$$\n也就是\n$$\ny^{x-c} \\frac {y^c}g \\equiv \\frac zg \\pmod{\\frac pg}\n$$\n于是可以bsgs求解\n\n关键代码: \n\n```cpp\nvoid exbsgs(int y,int z,int p){\n    if(z==1)return void(out(\"0\\n\"));\n    int k=0,a=1;\n    while(1){\n        int d=GCD(y,p);\n        if(d==1)break;\n        if(z%d)return void(out(\"No Solution\\n\"));\n        z\/=d;p\/=d;\n        ++k;\n        a=1ll*a*y\/d%p;\n        if(z==a)return void(out(k,ln));\n    }\n    S.clear();\n    int m=sqrt(p)+1,x=z,f=pw(y,m,p);\n    Fur(i,0,m-1)S.ins(x,i),x=1ll*x*y%p;\n    x=1ll*a*f%p;\n    Fur(i,1,m){\n        int b=S[x];\n        if(~b)return void(out(i*m-b+k,ln));\n        x=1ll*x*f%p;\n    }\n    out(\"No Solution\\n\");\n}\n```\n\n## 例题\n\n[LG 4884 多少个1?](https:\/\/www.luogu.com.cn\/problem\/P4884)\n\n$$\n\\overbrace{111\\dots111}^{\\text{N个1}} \\equiv k \\pmod m\n\\\\\n\\frac{10^N-1}9\\equiv k \\pmod m\n\\\\\n10^N\\equiv 9k+1 \\pmod m\n$$\n\n顺利地推出是bsgs,($m$是质数,也就不用exbsgs了)","link":null,"tags":["数论","算法"],"title":"bsgs"},{"categories":[["刷题记录"]],"content":"\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\nconst int N=100007;\nstruct hash{\n    struct edge{int to,nxt,w;}e[N];\n    int cnt=0,head[N],p=N;\n    il void add(int x,int y,int w){e[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;e[cnt].w=w;}\n    il void clear(){cnt=0;clr(head,0);}\n    il void ins(int x,int v){add(x%p,x,v);}\n    int operator[](int x){\n        for(int i=head[x%p];i;i=e[i].nxt)\n            if(e[i].to==x)return e[i].w;\n        return -1;\n    }\n}S;\nil int pw(int x,int b,int p){\n    int ans=1;\n    while(b){\n        if(b&1)ans=1ll*ans*x%p;\n        b>>=1;x=1ll*x*x%p;\n    }\n    return ans;\n}\nvoid exbsgs(int y,int z,int p){\n    if(z==1)return void(out(\"0\\n\"));\n    int k=0,a=1;\n    while(1){\n        int d=GCD(y,p);\n        if(d==1)break;\n        if(z%d)return void(out(\"No Solution\\n\"));\n        z\/=d;p\/=d;\n        ++k;\n        a=1ll*a*y\/d%p;\n        if(z==a)return void(out(k,ln));\n    }\n    S.clear();\n    int m=sqrt(p)+1,x=z,f=pw(y,m,p);\n    Fur(i,0,m-1)S.ins(x,i),x=1ll*x*y%p;\n    x=1ll*a*f%p;\n    Fur(i,1,m){\n        int b=S[x];\n        if(~b)return void(out(i*m-b+k,ln));\n        x=1ll*x*f%p;\n    }\n    out(\"No Solution\\n\");\n}\nint main(){\n    int y,z,p;\n    while(1){\n        in(y,p,z);\n        if(!y&&!z&&!p)break;\n        exbsgs(y,z,p);\n    }\n    flush();\n}\n```\n","link":null,"tags":["bsgs","数论"],"title":"LG SP3105 MOD - Power Modulo Inverted"},{"categories":[["刷题记录"]],"content":"\n1. 快速幂\n2. Exgcd\n   \n   $xy \\equiv z \\pmod p$\n\n   $yx+pb = z$\n    \n    可以用Exgcd求解\n\n3. bsgs\n   \n   > 求解关于$x$的方程: \n   > \n   > $$y^x \\equiv z \\pmod p$$\n   > \n   > 其中$\\gcd(y,p)=1$\n   > \n   > 解法: \n   > \n   > 设$x=am-b$\n   > \n   > 那么$y^{am} \\equiv z \\cdot y^b \\pmod p$\n   > \n   > 右边: \n   > \n   > 枚举$b$的取值$[0,m-1]$,计算右边的值,存入哈希表\n   > \n   > 左边:\n   > \n   > 枚举可能的$a$,也就是$[1,m]$,若左边的值在哈希表中出现过,那么当前$a$合法\n   > \n   > 不难证明当$m=\\sqrt p$的时候复杂度最优,$\\Theta(\\sqrt p)$\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?__=1,EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\nint T,typ,p;\nil int pw(int x,int b){\n    int ans=1;\n    while(b){\n        if(b&1)ans=1ll*ans*x%p;\n        x=1ll*x*x%p;b>>=1;\n    }\n    return ans;\n}\nstruct hash{\n    #define N 37273\n    int P=N,head[N],cnt;\n    struct edge{int to,nxt,w;}e[N];\n    il void clear(){cnt=0;clr(head,0);}\n    il void add(int x,int y,int w){e[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;e[cnt].w=w;}\n    il void ins(int x,int v){add(x%P,x,v);}\n    int operator[](int x){\n        for(int i=head[x%P];i;i=e[i].nxt)\n            if(e[i].to==x)return e[i].w;\n        return -1;\n    }\n}S;\nint main(){\n    in(T,typ);\n    while(T--){\n        int a,b,t;\n        in(a,b,p);\n        if(typ==1)out(pw(a%p,b),ln);\n        if(typ==2){\/\/xa equiv b\n            a%=p;b%=p;\n            if(!a&&b)out(\"Orz, I cannot find x!\\n\");\n            else out(1ll*pw(a,p-2)*b%p,ln);\n        }\n        if(typ==3){\/\/a^x equiv b;\n            a%=p;\n            if(!a){\n                if(!b)out(\"1\\n\");\n                else out(\"Orz, I cannot find x!\\n\");\n                continue;\n            }\n            int m=sqrt(p)+1,x=b%p,t=pw(a,m);\n            S.clear();\n            S.ins(x,0);\n            Fur(i,1,m)x=1ll*x*a%p,S.ins(x,i);\n            x=1;\n            bool ff=1;\n            Fur(i,1,m){\n                x=1ll*x*t%p;\n                int k=S[x];\n                if(~k){\n                    ff=0;\n                    out(((i*m-k)%p+p)%p,ln);\n                    break;\n                }\n            }\n            if(ff)out(\"Orz, I cannot find x!\\n\");\n        }\n    }\n    flush();\n}\n```\n","link":null,"tags":["数论","exgcd","bsgs","快速幂"],"title":"LG 2485 [SDOI2011]计算器"},{"categories":[["刷题记录"]],"content":"\n设$f[i,j]$表示用完了前$i$种油漆,有$j$对相邻且同色的木块\n\n考虑怎么转移: \n\n要将第$i$种颜色的木块分两种情况插入:\n\n1. 设其中$a$个插到之前弄好的木块中间(无序)\n   \n2. 设另外$b$个插在同色木块中间\n\n其中有$a-b$组满足插空放且不相邻\n\n$f[i,j]=\\sum f[i-1,j-(c_i-a-b)]\\times {c_i-1 \\choose a-1} \\times {j \\choose b} \\times{S_{i-1}+1-j \\choose a-b}$\n\n> ${c_i-1 \\choose a-1}$表示$a$个的方案数\n>\n> ${j \\choose b}$表示$b$个的方案数\n> \n> ${S_{i-1}+1-j \\choose a-b}$表示$a-b$个插进去的方案\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?__=1,EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\nint n,c[20],f[20][80],C[80][80],P=1000000007;\nint main(){\n    C[0][0]=1;\n    Fur(i,1,75){\n        C[i][0]=C[i][i]=1;\n        Fur(j,1,i-1)\n            C[i][j]=(C[i-1][j]+C[i-1][j-1])%P;\n    }\n    in(n);\n    Fur(i,1,n)in(c[i]);\n    f[1][c[1]-1]=1;\n    int s=0;\n    Fur(i,1,n-1){\n        s+=c[i];\n        Fur(j,0,s-1)if(f[i][j])\n            Fur(a,1,c[i+1])\n                Fur(b,0,MIN(a,j))\n                f[i+1][j+c[i+1]-a-b]=(f[i+1][j+c[i+1]-a-b]+\n                1ll*f[i][j]*C[c[i+1]-1][a-1]%P*C[j][b]%P*C[s+1-j][a-b]%P)%P;\n    }\n    printf(\"%d\\n\",f[n][0]);\n}\n```\n","link":null,"tags":["动态规划","组合数学"],"title":"LG 2476 [SCOI2008]着色方案"},{"categories":[["刷题记录"]],"content":"\n设$f(i,k)$表示前$i$位置,操作$k$次,最多剩下多少玉米\n\n> **每一次的拔高操作区间右端点一定是最右边的玉米**\n\n$f(i,k)=max_{j<i}(f(j,k-t))+1,a_i+t\\ge a_j$\n\n直接枚举$\\mathcal{O(n^2k^2)}$会超时,我们得想个办法优化\n\n可以考虑用二维树状数组优化\n\n> 优化为只需要两个树状数组\n> \n> https:\/\/guodonglovesoi.blog.luogu.org\/scoi2014-fang-bo-bo-di-yu-mi-tian\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?__=1,EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\nconst int mx=5511;\nint n,k,f[555][mx];\nstruct bit{\n    int s[mx+11];\n    il void upd(int x,int v){\n        for(int i=x;i<=mx;i+=i&-i)\n            s[i]=MAX(s[i],v);\n    }\n    il int ask(int x){\n        int ans=0;\n        for(int i=x;i;i-=i&-i)\n            ans=MAX(ans,s[i]);\n        return ans;\n    }\n}T[555];\nil void UPD(int x,int a,int v){\n    for(int i=x;i<=505;i+=i&-i)\n        f[i][a]=MAX(f[i][a],v);\n}\nil int ASK(int x,int a){\n    int ans=0;\n    for(int i=x;i;i-=i&-i)\n        ans=MAX(ans,f[i][a]);\n    return ans;\n}\nint main(){\n    in(n,k);\n    int ans=0,res,a;\n    Fur(i,1,n){\n        in(a);\n        Fur(j,0,k)\n            res=MAX(T[j+1].ask(a+j),ASK(j+1,a+j))+1,\n            ans=MAX(ans,res),\n            T[j+1].upd(a+j,res),\n            UPD(j+1,a+j,res);\n    }\n    printf(\"%d\\n\",ans);\n}\n```\n","link":null,"tags":["动态规划","树状数组"],"title":"LG 3287 [SCOI2014]方伯伯的玉米田"},{"categories":[["刷题记录"]],"content":"\n双连通分量缩点后得到的树的直径就是答案\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?__=1,EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\nconst int N=300011;\nint n,m,cnt=1,head[N],st[N],tp=0,bl[N];\nstruct edge{\n    int to,nxt;\n}e[N<<1];\nil void add(int x,int y){\n    e[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;\n}\nint dfn[N],low[N],sz=0;\nvoid tarjan(int x,int la){\n    dfn[x]=low[x]=++sz;st[++tp]=x;\n    fl(i,x)if(i!=la){\n        if(!dfn[to])\n            tarjan(to,i^1),\n            low[x]=MIN(low[x],low[to]);\n        else low[x]=MIN(low[x],dfn[to]);\n    }\n    if(low[x]==dfn[x])\n    while(int k=st[tp--]){\n        bl[k]=x;\n        if(k==x)break;\n    }\n}\nint q[N],d[N];\nint bfs(int x){\n    clr(d,0);d[x]=1;\n    int h=0,t=1,mx=0;\n    q[0]=x;\n    while(h<t){\n        x=q[h++];\n        if(d[x]>d[mx])mx=x;\n        fl(i,x)if(!d[to])\n            d[to]=d[x]+1,q[t++]=to;\n    }\n    return mx;\n}\nint main(){\n    in(n,m);\n    int x,y;\n    Fur(i,1,m)in(x,y),add(x,y),add(y,x);\n    tarjan(1,0);\n    cnt=0;clr(head,0);\n    Fur(i,1,m)\n    if((x=bl[e[i*2].to])!=(y=bl[e[i*2+1].to]))\n        add(x,y),add(y,x);\n    printf(\"%d\\n\",d[bfs(bfs(bl[1]))]-1);\n}\n```\n","link":null,"tags":["树的直径","tarjan","双连通分量"],"title":"LG CF1000E We-Need-More-Bosses"},{"categories":[["刷题记录"]],"content":"\n对于第二问: \n\n看到数据范围可以想到矩阵快速幂求斐波那契数列\n\n矩阵乘法具有分配率: $AC+BC=(A+B)C$\n\n我们可以想到用线段树维护矩阵区间乘\n\n\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?__=1,EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\nconst int N=100011,P=1000000007;\nint n,q;\nstruct mat{int a[2][2];}A={\n    1,0,\n    1,0,\n},B={\n    1,1,\n    1,0,\n},C={\n    1,0,\n    0,1\n},t,s[N<<2],laz[N<<2];\nmat operator+(mat x,mat y){\n    mat c;\n    for(int i=0;i<2;++i)\n        for(int j=0;j<2;++j)\n            c.a[i][j]=(x.a[i][j]+y.a[i][j])%P;\n    return c;\n}\nmat operator*(mat x,mat y){\n    mat c;clr(c.a,0);\n    for(int i=0;i<2;++i)\n        for(int j=0;j<2;++j)\n            for(int k=0;k<2;++k)\n                c.a[i][j]=(c.a[i][j]+1ll*x.a[i][k]*y.a[k][j]%P)%P;\n    return c;\n}\nmat pw(int p){\n    mat a=C,b=B;\n    while(p){\n        if(p&1)a=a*b;\n        p>>=1;b=b*b;\n    }\n    return a;\n}\n#define ls rt<<1\n#define rs rt<<1|1\nvoid pd(int rt){\n    laz[ls]=laz[ls]*laz[rt];\n    laz[rs]=laz[rs]*laz[rt];\n    s[ls]=s[ls]*laz[rt];\n    s[rs]=s[rs]*laz[rt];\n    laz[rt]=C;\n}\nvoid build(int l,int r,int rt){\n    laz[rt]=C;\n    if(l==r){\n        int x;in(x);\n        s[rt]=A*pw(x-1);\n        return;\n    }\n    int m=(l+r)>>1;\n    build(l,m,ls);build(m+1,r,rs);\n    s[rt]=s[ls]+s[rs];\n}\nvoid upd(int L,int R,int l,int r,int rt){\n    if(L<=l&&r<=R){\n        s[rt]=s[rt]*t;\n        laz[rt]=laz[rt]*t;\n        return;\n    }\n    int m=(l+r)>>1;\n    pd(rt);\n    if(L<=m)upd(L,R,l,m,ls);\n    if(R>m)upd(L,R,m+1,r,rs);\n    s[rt]=s[ls]+s[rs];\n}\nmat ask(int L,int R,int l,int r,int rt){\n    if(L<=l&&r<=R)return s[rt];\n    int m=(l+r)>>1;\n    pd(rt);\n    mat ans;clr(ans.a,0);\n    if(L<=m)ans=ask(L,R,l,m,ls);\n    if(R>m)ans=ans+ask(L,R,m+1,r,rs);\n    return ans;\n}\nsigned main(){\n    in(n,q);\n    build(1,n,1);\n    while(q--){\n        int u,l,r,v;\n        in(u,l,r);\n        if(u==1)\n            in(v),t=pw(v),\n            upd(l,r,1,n,1);\n        else out(ask(l,r,1,n,1).a[0][0],ln);\n    }\n    flush();\n}\n```\n","link":null,"tags":["数论","矩阵乘法","快速幂","线段树"],"title":"LG CF718C Sasha-and-Array"},{"categories":[["刷题记录"]],"content":"\n首先可以dfs处理出所有路径的重要度(路径两端子树大小乘积)\n\n然后就是树型dp处理出每个点影响的范围的重要度总和\n\n最后取最大值就可以了\n\n$f(dis,x)$表示与$x$距离不超过$dis$的所有路径的重要度\n\n$f(1,x)=\\sum val(edge)$\n\n$f(k,x)=\\sum f(k-1,to)-f(k-2,x)$\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<18;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?__=1,EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\nconst int N=300011;\nint n,k,cnt=1,head[N],siz[N];\nll f[211][N],val[N],ans=0;\nstruct edge{int to,nxt;}e[N<<1];\nil void add(int x,int y){e[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;}\nvoid dfs(int x){\n    siz[x]=1;\n    fl(i,x)if(!siz[to]){\n        dfs(to);\n        val[i>>1]=1ll*siz[to]*(n-siz[to]);\n        siz[x]+=siz[to];\n    }\n}\nint main(){\n    in(n,k);++k;\n    int x,y;\n    Fur(i,1,n-1)in(x,y),add(x,y),add(y,x);\n    dfs(1);\n    Fur(i,1,n)fl(j,i)f[1][i]+=val[j>>1];\n    Fur(i,2,k)\n        Fur(x,1,n){\n            f[i][x]=f[i-2][x];\n            fl(j,x)f[i][x]+=f[i-1][to]-f[i-2][x];\n        }\n    Fur(x,1,n)ans=MAX(ans,f[k][x]);\n    printf(\"%lld\\n\",ans);\n}\n```\n","link":null,"tags":["dfs","树型dp","容斥"],"title":"LG 5628 【AFOI-19】面基"},{"categories":[["刷题记录"]],"content":"\n直接模拟\n\n复杂度$\\mathcal{O}(\\frac n1 + \\frac n2 + , ... + \\frac nn)=\\mathcal{O}(n \\log n)$\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?__=1,EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\nconst int N=1000011;\nint n,la[N],tot=0,mx=0;\nll ans[N],now=0;\nbool b[N],v[N];\nint main(){\n    in(n);\n    int x;\n    while(n--)in(x),b[x]=1,mx=MAX(mx,x);\n    in(n);\n    v[0]=1;\n    while(n--){\n        in(x);\n        int p=x,&s=la[x];\n        for(;p;--p){\n            while(s<=mx&&v[s])s+=x;\n            if(s>mx)break;\n            v[s]=1;++now;\n            if(b[s])ans[++tot]=now;\n        }\n        now+=p;\n    }\n    out(tot,ln);\n    Fur(i,1,tot)out(ans[i],ln);\n    flush();\n}\n```\n","link":null,"tags":["数论","模拟"],"title":"LG 3536 [POI2012]BON-Vouchers"},{"categories":[["刷题记录"]],"content":"\n假设我们要求的是$A\\cdot B \\equiv 1 \\pmod{x^n}$,\n\n我们已经求出了$B'$满足$A\\cdot B' \\equiv 1 \\pmod{x^\\frac n2}$\n\n$$\n\\because A\\cdot B \\equiv 1 \\pmod {x^n}\n\\\\\n\\because A\\cdot B' \\equiv 1 \\pmod{x^\\frac n2}\n\\\\\n\\therefore A \\cdot (B-B') \\equiv 0 \\pmod{x^\\frac n2}\n\\\\\n\\therefore B-B' \\equiv 0 \\pmod{x^\\frac n2}\n\\\\\n(B-B')^2 \\equiv 0 \\pmod{x^n}\n\\\\\nB^2-2BB'+B'^2 \\equiv 0 \\pmod{x^n}\n\\\\\n\\therefore A(B^2-2BB'+B'^2) \\equiv 0 \\pmod{x^n}\n\\\\\nAB^2-2ABB'+AB'^2 \\equiv 0 \\pmod{x^n}\n\\\\\n\\because A\\cdot B \\equiv 1 \\pmod {x^n}\n\\\\\n\\therefore B-2B'+AB'^2\\equiv 0 \\pmod{x^n}\n\\\\\nB\\equiv 2B'-AB'^2 \\pmod{x^n}\n$$\n\n于是我们可以用倍增+NTT解决(复杂度$\\mathcal{O(n \\log^2 n)}$)\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?__=1,EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\nconst int N=400011,P=998244353,G=3,Gi=332748118;\nint n,l=0,limit=1,r[N],a[N],b[N],c[N];\nil int pw(int x,int p){\n    int ans=1;\n    for(;p;x=1ll*x*x%P,p>>=1)if(p&1)ans=1ll*ans*x%P;\n    return ans;\n}\nil void NTT(int *A,int typ){\n    Fur(i,0,limit-1)\n        if(i<r[i])SWAP(A[i],A[r[i]]);\n    for(int len=1;len<limit;len<<=1){\n        int Wn=pw(~typ?G:Gi,(P-1)\/(len<<1));\n        for(int i=0;i<limit;i+=(len<<1)){\n            int w=1;\n            Fur(k,0,len-1){\n                int t=1ll*w*A[i+k+len]%P;\n                A[i+k+len]=(A[i+k]-t+P)%P;\n                A[i+k]=(A[i+k]+t)%P;\n                w=1ll*w*Wn%P;\n            }\n        }\n    }\n    if(~typ)return;\n    int inv=pw(limit,P-2);\n    Fur(i,0,limit-1)A[i]=1ll*A[i]*inv%P;\n}\nvoid work(int p,int *a,int *b){\n    if(p==1)return void(b[0]=pw(a[0],P-2));\n    work(((p+1)>>1),a,b);\n    limit=1,l=0;\n    while(limit<(p<<1))limit<<=1,++l;\n    Fur(i,0,limit-1)\n        r[i]=(r[i>>1]>>1)|((i&1)<<(l-1));\n    Fur(i,0,p-1)c[i]=a[i];\n    Fur(i,p,limit-1)c[i]=0;\n    NTT(c,1);NTT(b,1);\n    Fur(i,0,limit-1)b[i]=1ll*b[i]*(2ll-1ll*c[i]*b[i]%P+P)%P;\n    NTT(b,-1);\n    Fur(i,p,limit-1)b[i]=0;\n}\nint main(){\n    in(n);\n    Fur(i,0,n-1)in(a[i]);\n    work(n,a,b);\n    Fur(i,0,n-1)out(b[i],\" \");\n    flush();\n}\n```\n","link":null,"tags":["ntt","数论","逆元"],"title":"LG 4238 【模板】多项式乘法逆"},{"categories":[["刷题记录"]],"content":"\n$$\nE_i=\\frac{F_i}{q_i}=\\sum_{j=1}^{i-1}\\frac{q_j}{(i-j)^2}-\\sum_{j=i+1}^n \\frac{q_j}{(j-i)^2}\n$$\n\n设$f_i=q_i,g_i=\\frac 1{i^2},f_0=0,g_0=0$\n\n$$\nE_i=\\sum_{j=1}^i f_j\\cdot g_{i-j}-\\sum_{j=i}^n f_j\\cdot g_{j-i}\n$$\n\n可以发现前半部分是卷积的形式\n\n我们来考虑后半部分\n\n$$\n\\sum_{j=i}^n f_j\\cdot g_{j-i}\n\\\\\n=\\sum_{j=0}^{n-i} f_{i+j}\\cdot g_j\n$$\n\n令$t=n-i,f'_i=f_{n-i}$\n\n$$\n=\\sum_{j=i}^t g_j\\cdot f'_{t-i}\n$$\n\n也成功转化为卷积的形式\n\n可以开始愉快地使用FFT了\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?__=1,EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\nconst int N=400011;\nint n,limit=1,l=0,r[N];\ndb q[N],Pi=acos(-1.0);\nstruct cp{db r,i;cp(db R=0,db I=0){r=R,i=I;}}a[N],b[N],c[N];\ncp operator + (cp a,cp b){return cp(a.r+b.r,a.i+b.i);}\ncp operator - (cp a,cp b){return cp(a.r-b.r,a.i-b.i);}\ncp operator * (cp a,cp b){return cp(a.r*b.r-a.i*b.i,a.r*b.i+a.i*b.r);}\nvoid fft(cp *A,int typ){\n    Fur(i,0,limit-1)\n        if(i<r[i])SWAP(A[i],A[r[i]]);\n    for(int len=1;len<limit;len<<=1){\n        cp Wn(cos(Pi\/len),typ*sin(Pi\/len));\n        for(int i=0;i<limit;i+=(len<<1)){\n            cp w(1,0);\n            Fur(k,0,len-1){\n                cp t=w*A[i+k+len];\n                A[i+k+len]=A[i+k]-t;\n                A[i+k]=A[i+k]+t;\n                w=w*Wn;\n            }\n        }\n    }\n    if(~typ)return;\n    Fur(i,0,limit-1)A[i].r\/=limit;\n}\nint main(){\n    scanf(\"%d\",&n);\n    Fur(i,1,n)\n        scanf(\"%lf\",&a[i].r),\n        b[i].r=(db)1.0\/i\/i,\n        c[n-i]=a[i];\n    while(limit<=n*2)limit<<=1,++l;\n    Fur(i,0,limit-1)\n        r[i]=(r[i>>1]>>1)|((i&1)<<(l-1));\n    fft(a,1),fft(b,1),fft(c,1);\n    Fur(i,0,limit-1)a[i]=a[i]*b[i],c[i]=c[i]*b[i];\n    fft(a,-1),fft(c,-1);\n    Fur(i,1,n)printf(\"%.3f\\n\",a[i].r-c[n-i].r);\n}\n```\n","link":null,"tags":["fft"],"title":"LG 3338 [ZJOI2014]力"},{"categories":[["刷题记录"]],"content":"\n1. 金神石的块数必须是6的倍数\n   $g(x)=1+x^6+x^{12}+...=\\frac 1{1-x^6}$\n2. 木神石最多用9块\n   $g(x)=1+x+x^2+...+x^9=\\frac{1-x^{10}}{1-x}$\n3. 水神石最多用5块\n   $g(x)=1+x+x^2+...+x^5=\\frac{1-x^6}{1-x}$\n4. 火神石的块数必须是4的倍数\n   $g(x)=1+x^4+x^8+...=\\frac 1{1-x^4}$\n5. 土神石最多用7块\n   $g(x)=1+x+x^2+...+x^7=\\frac{1-x^8}{1-x}$\n\n6. 金神石的块数必须是2的倍数\n   $g(x)=1+x^2+x^4+...=\\frac 1{1-x^2}$\n7. 木神石最多用1块\n   $g(x)=1+x=\\frac{1-x^2}{1-x}$\n8. 水神石的块数必须是8的倍数\n   $g(x)=1+x^8+x^{16}+...=\\frac 1{1-x^8}$\n9. 火神石的块数必须是10的倍数\n   $g(x)=1+x^{10}+x^{20}+...=\\frac 1{1-x^{10}}$\n10. 土神石最多用3块\n    $g(x)=1+x+x^2+x^3=\\frac{1-x^4}{1-x}$\n\n$\\frac 1{1-x^6}\\cdot\\frac{1-x^{10}}{1-x}\\cdot\\frac{1-x^6}{1-x}\\cdot\\frac 1{1-x^4}\\cdot\\frac{1-x^8}{1-x}\\cdot\\frac 1{1-x^2}\\cdot\\frac{1-x^2}{1-x}\\cdot\\frac 1{1-x^8}\\cdot\\frac 1{1-x^{10}}\\cdot\\frac{1-x^4}{1-x}$\n\n$=\\frac1{(1-x)^5}$\n\n$=\\sum_{i=0}^\\infty {i+4 \\choose 4}x^i$\n\n> $\\sum_{i=0}^\\infty {i+k-1 \\choose k-1}x^i=\\frac1{(1-x)^k}$\n\n第$n$项的系数是${n+4 \\choose 4}$需要FFT或NTT\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?__=1,EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\nconst int N=4000011,P=998244353,G=3,Gi=332748118;\nchar ch[N];\nint n,limit=1,r[N],l=0;\nint  n1[N],n2[N],n3[N],n4[N],ans[N];\nint pw(int x,int p){\n    int ans=1;\n    for(;p;p>>=1,x=1ll*x*x%P)\n        if(p&1)ans=1ll*ans*x%P;\n    return ans;\n}\nil void ntt(int *A,int typ){\n    Fur(i,0,limit-1)\n        if(i<r[i])SWAP(A[i],A[r[i]]);\n    for(int len=1;len<limit;len<<=1){\n        int Wn=pw(~typ?G:Gi,(P-1)\/(len<<1));\n        for(int i=0;i<limit;i+=(len<<1)){\n            int w=1;\n            Fur(k,0,len-1){\n                int t=1ll*w*A[i+k+len]%P;\n                A[i+k+len]=(A[i+k]-t+P)%P;\n                A[i+k]=(A[i+k]+t)%P;\n                w=1ll*w*Wn%P;\n            }\n        }\n    }\n    if(~typ)return;\n    int inv=pw(limit,P-2);\n    Fur(i,0,limit-1)A[i]=1ll*A[i]*inv%P;\n}\nil void mul(int *A,int *B){\n    ntt(A,1);ntt(B,1);\n    Fur(i,0,limit-1)A[i]=1ll*A[i]*B[i]%P;\n    ntt(A,-1);\n}\nint main(){\n    in(ch);\n    n=strlen(ch);\n    while(limit<=n*4)++l,limit<<=1;\n    Fur(i,0,limit-1)\n        r[i]=(r[i>>1]>>1)|((i&1)<<(l-1));\n    Fur(i,0,n-1)n1[i]=n2[i]=n3[i]=n4[i]=ch[n-i-1]-48;\n    ++n1[0];\n    n2[0]+=2;\n    n3[0]+=3;\n    n4[0]+=4;\n    mul(n1,n2);\n    mul(n1,n3);\n    mul(n1,n4);\n    ll x=0;\n    Fdr(i,n-1,0)\n        x=x*10+n1[i],ans[i]=x\/24,x%=24;\n    int len=n;\n    Fur(i,0,n-1)ans[i+1]+=ans[i]\/10,ans[i]%=10;\n    while(ans[len]>9)ans[len+1]+=ans[len]\/10,ans[len]%=10,++len;\n    Fdr(i,len,0)out(ans[i]);\n    flush();\n}\n```\n","link":null,"tags":["生成函数","数论","ntt","高精度"],"title":"LG 2000 拯救世界"},{"categories":[["刷题记录"]],"content":"\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?__=1,EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\nconst int N=1000011,P=1e9+7;\nint n,k,fac[N],pl[N],pr[N];\nil int pw(int x,int p){\n    int ans=1;\n    while(p){\n        if(p&1)ans=1ll*ans*x%P;\n        x=1ll*x*x%P;p>>=1;\n    }\n    return ans;\n}\nint main(){\n    in(n,k);\n    fac[0]=pl[0]=pr[k+3]=1;\n    Fur(i,1,k+2)\n        fac[i]=1ll*fac[i-1]*i%P,\n        pl[i]=1ll*pl[i-1]*(n-i)%P;\n    Fdr(i,k+2,1)\n        pr[i]=1ll*pr[i+1]*(n-i)%P;\n    int ans=0,y=0;\n    Fur(i,1,k+2){\n        y=(y+pw(i,k))%P;\n        int a=1ll*pl[i-1]*pr[i+1]%P,\n            b=fac[i-1]*((k-i)&1?-1ll:1ll)*fac[k-i+2]%P;\n        ans=(ans+1ll*y*a%P*pw(b,P-2)%P)%P;\n    }\n    printf(\"%d\\n\",(ans+P)%P);\n}\n```\n","link":null,"tags":["数论","多项式","拉格朗日插值"],"title":"LG CF622F The-Sum-of-the-k-th-Powers"},{"categories":[["刷题记录"]],"content":"\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?__=1,EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\nconst int N=2011,P=998244353;\nint n,k,x[N],y[N];\nint pw(int x,int p){\n    int ans=1;\n    while(p){\n        if(p&1)ans=1ll*ans*x%P;\n        x=1ll*x*x%P;p>>=1;\n    }\n    return ans;\n}\nint main(){\n    in(n,k);\n    Fur(i,1,n)in(x[i],y[i]);\n    int ans=0;\n    Fur(i,1,n){\n        int s=1,inv=1;\n        Fur(j,1,n)if(j!=i)\n            s=1ll*s*(k-x[j]+P)%P,\n            inv=1ll*inv*(x[i]-x[j]+P)%P;\n        ans=(ans+1ll*y[i]*s%P*pw(inv,P-2)%P)%P;\n    }\n    printf(\"%d\\n\",(ans+P)%P);\n}\n```\n","link":null,"tags":["拉格朗日插值","模板","数论"],"title":"LG 4781 【模板】拉格朗日插值"},{"categories":[["刷题记录"]],"content":"\n## FFT \n\n~~fst fst tle~~\n\n> DFT: 离散傅里叶变换\n> \n> IDFT: 离散傅里叶逆变换\n> \n> FFT: 快速傅里叶变换\n> \n> FNTT\/NTT: 快速傅里叶变换的优化版\n> \n> FWT: 快速沃尔什变换,利用类似FFT的东西解决一类卷积问题\n> \n> MTT: 毛爷爷的FFT,非常nb\/任意模数\n> \n> FMT: 快速莫比乌斯变化\n> \n> (摘自https:\/\/www.cnblogs.com\/zwfymqz\/p\/8244902.html)\n\n为什么要用到FFT呢?\n\n以高精度乘法举个例子: \n\n你现在要计算$a\\times b,a,b>10^{1000000}$\n\n设$len_a=n,len_b=m$\n\n如果用普通的高精度乘法$\\mathcal{O(nm)}$,直接tle\n\n但是FFT可以做到$\\mathcal{O((n+m) \\log (n+m))}$\n\n原理: 先把多项式转化为用点值表示$\\mathcal{O(n \\log n)}$\n\n然后再用点值相乘来计算$\\mathcal{O(n)}$\n\n然后再通过点值还原多项式\n\n\n\n下面是前置知识: \n\n## 多项式\n\n### 系数表示法\n\n形式: $f(x)=\\sum_{i=0}^{n-1} a_ix^i$\n\n比如$123456$也可以看做一个多项式: \n\n$f(10)=6+5\\cdot10+4\\cdot10^2+3\\cdot10^3+2\\cdot 10^4+1\\cdot 10^5$\n\n### 点值表示法\n\n取$n$个点$x_1,x_2, \\dots ,x_n$\n\n代入$f(x)$会得到$n$个不同的$y_i$\n\n$f(x)$被$(x_1,y_1),(x_2,y_2),\\dots (x_n,y_n)$唯一确定\n\n定理:\n\n> 一个 $n-1$ 次多项式在 $n$ 个不同点的取值唯一确定了该多项式。\n\n证明: (反证法)\n\n> 假设命题不成立,那么存在两个不同的$n-1$次多项式$A(x),B(x)$满足: $\\forall i\\in[1,n], A(x_i)=B(x_i)$\n> \n> 令$C(x)=A(x)-B(x)$,那么$C(x)$也是一个$n-1$次多项式,且$\\forall i\\in[1,n], C(x_i)=0$\n> \n> 这样的话$C(x)$有$n$个根,与代数基本定理($n$次多项式有且仅有$n$个根)不符,所以$C(x)$不是$n-1$次多项式\n>\n> 所以原命题成立\n> \n> (摘自https:\/\/zhuanlan.zhihu.com\/p\/31584464)\n\n## 复数\n\n复数由实部(real)和虚部(image)组成,形如$a+bi$\n\n$i$是虚树单位,$i^2=-1,i=\\sqrt{-1}$\n\n### 复数运算法则:\n\n$(a+bi)+(c+di)=(a+c)+(b+d)i$\n\n$(a+bi)-(c+di)=(a-c)+(b-d)i$\n\n$(a+bi)\\cdot(c+di)=(ac-bd)+(ad+bc)i$\n\n复数$z=a+bi$在复平面中对应坐标为$(a,b)$\n\n复平面中$x$轴又称实轴,$y$轴又称虚轴\n\n### 共轭复数\n\n复数$z=a+bi$的共轭复数$z'=a-bi$,$z'$称为$z$的复共轭\n\n性质: \n\n$z\\cdot z' = a^2 + b^2$\n\n$|z|=|z'|$(模长相等,到原点的距离相等)\n\n\n## 单位根\n\n若$\\omega^n=1$则$\\omega$为$n$次单位根\n\n在复平面上,以原点为圆心,$1$为半径作圆,所得的圆叫单位圆。\n\n以圆心为起点,圆的$n$等分点为终点,做$n$个向量。\n\n其中幅角为正且最小的向量称为$n$次单位向量,记为$\\omega_n^1$\n\n根据复数乘法的运算法则,其余$n−1$个复数为$\\omega_n^2,\\omega_n^3,\\dots,\\omega_n^n$\n\n$\\omega_n^0=\\omega_n^n=1$,在复平面上对应的点为$(1,0)$\n\n<html>\n<svg version=\"1.1\" xmlns=\"http:\/\/www.w3.org\/2000\/svg\" xmlns:xlink=\"http:\/\/www.w3.org\/1999\/xlink\" width=\"584\" height=\"294\"><defs><clipPath id=\"HfoVspciGtkQ\"><path fill=\"none\" stroke=\"none\" d=\" M 0 0 L 584 0 L 584 294 L 0 294 L 0 0 Z\"\/><\/clipPath><\/defs><g transform=\"scale(1,1)\" clip-path=\"url(#HfoVspciGtkQ)\"><g><rect fill=\"rgb(255,255,255)\" stroke=\"none\" x=\"0\" y=\"0\" width=\"584\" height=\"294\" fill-opacity=\"1\"\/><path fill=\"none\" stroke=\"rgb(192,192,192)\" paint-order=\"fill stroke markers\" d=\" M 34.5 0.5 L 34.5 294.5 M 34.5 0.5 L 34.5 294.5 M 100.5 0.5 L 100.5 294.5 M 167.5 0.5 L 167.5 294.5 M 300.5 0.5 L 300.5 294.5 M 367.5 0.5 L 367.5 294.5 M 433.5 0.5 L 433.5 294.5 M 500.5 0.5 L 500.5 294.5 M 567.5 0.5 L 567.5 294.5\" stroke-opacity=\"1\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-miterlimit=\"10\"\/><path fill=\"none\" stroke=\"rgb(192,192,192)\" paint-order=\"fill stroke markers\" d=\" M 7.5 0.5 L 7.5 294.5 M 20.5 0.5 L 20.5 294.5 M 47.5 0.5 L 47.5 294.5 M 60.5 0.5 L 60.5 294.5 M 74.5 0.5 L 74.5 294.5 M 87.5 0.5 L 87.5 294.5 M 114.5 0.5 L 114.5 294.5 M 127.5 0.5 L 127.5 294.5 M 140.5 0.5 L 140.5 294.5 M 154.5 0.5 L 154.5 294.5 M 180.5 0.5 L 180.5 294.5 M 194.5 0.5 L 194.5 294.5 M 207.5 0.5 L 207.5 294.5 M 220.5 0.5 L 220.5 294.5 M 247.5 0.5 L 247.5 294.5 M 260.5 0.5 L 260.5 294.5 M 273.5 0.5 L 273.5 294.5 M 287.5 0.5 L 287.5 294.5 M 313.5 0.5 L 313.5 294.5 M 327.5 0.5 L 327.5 294.5 M 340.5 0.5 L 340.5 294.5 M 353.5 0.5 L 353.5 294.5 M 380.5 0.5 L 380.5 294.5 M 393.5 0.5 L 393.5 294.5 M 407.5 0.5 L 407.5 294.5 M 420.5 0.5 L 420.5 294.5 M 447.5 0.5 L 447.5 294.5 M 460.5 0.5 L 460.5 294.5 M 473.5 0.5 L 473.5 294.5 M 487.5 0.5 L 487.5 294.5 M 513.5 0.5 L 513.5 294.5 M 527.5 0.5 L 527.5 294.5 M 540.5 0.5 L 540.5 294.5 M 553.5 0.5 L 553.5 294.5 M 580.5 0.5 L 580.5 294.5\" stroke-opacity=\"0.23529411764705882\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-miterlimit=\"10\"\/><path fill=\"none\" stroke=\"rgb(192,192,192)\" paint-order=\"fill stroke markers\" d=\" M 0.5 16.5 L 584.5 16.5 M 0.5 16.5 L 584.5 16.5 M 0.5 82.5 L 584.5 82.5 M 0.5 216.5 L 584.5 216.5 M 0.5 282.5 L 584.5 282.5\" stroke-opacity=\"1\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-miterlimit=\"10\"\/><path fill=\"none\" stroke=\"rgb(192,192,192)\" paint-order=\"fill stroke markers\" d=\" M 0.5 2.5 L 584.5 2.5 M 0.5 2.5 L 584.5 2.5 M 0.5 29.5 L 584.5 29.5 M 0.5 42.5 L 584.5 42.5 M 0.5 56.5 L 584.5 56.5 M 0.5 69.5 L 584.5 69.5 M 0.5 96.5 L 584.5 96.5 M 0.5 109.5 L 584.5 109.5 M 0.5 122.5 L 584.5 122.5 M 0.5 136.5 L 584.5 136.5 M 0.5 162.5 L 584.5 162.5 M 0.5 176.5 L 584.5 176.5 M 0.5 189.5 L 584.5 189.5 M 0.5 202.5 L 584.5 202.5 M 0.5 229.5 L 584.5 229.5 M 0.5 242.5 L 584.5 242.5 M 0.5 256.5 L 584.5 256.5 M 0.5 269.5 L 584.5 269.5\" stroke-opacity=\"0.23529411764705882\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-miterlimit=\"10\"\/><path fill=\"none\" stroke=\"rgb(0,0,0)\" paint-order=\"fill stroke markers\" d=\" M 233.5 2.5 L 233.5 294.5\" stroke-opacity=\"1\" stroke-miterlimit=\"10\"\/><path fill=\"none\" stroke=\"rgb(0,0,0)\" paint-order=\"fill stroke markers\" d=\" M 233.5 1.5 L 229.5 5.5\" stroke-opacity=\"1\" stroke-miterlimit=\"10\"\/><path fill=\"none\" stroke=\"rgb(0,0,0)\" paint-order=\"fill stroke markers\" d=\" M 233.5 1.5 L 237.5 5.5\" stroke-opacity=\"1\" stroke-miterlimit=\"10\"\/><path fill=\"none\" stroke=\"rgb(0,0,0)\" paint-order=\"fill stroke markers\" d=\" M 0.5 149.5 L 582.5 149.5\" stroke-opacity=\"1\" stroke-miterlimit=\"10\"\/><path fill=\"none\" stroke=\"rgb(0,0,0)\" paint-order=\"fill stroke markers\" d=\" M 583.5 149.5 L 579.5 145.5\" stroke-opacity=\"1\" stroke-miterlimit=\"10\"\/><path fill=\"none\" stroke=\"rgb(0,0,0)\" paint-order=\"fill stroke markers\" d=\" M 583.5 149.5 L 579.5 153.5\" stroke-opacity=\"1\" stroke-miterlimit=\"10\"\/><text fill=\"rgb(0,0,0)\" stroke=\"none\" font-family=\"geogebra-sans-serif, sans-serif\" font-size=\"12px\" font-style=\"normal\" font-weight=\"normal\" text-decoration=\"normal\" x=\"23\" y=\"165\" text-anchor=\"start\" dominant-baseline=\"alphabetic\" fill-opacity=\"1\">–1.5<\/text><text fill=\"none\" stroke=\"rgb(255,255,255)\" font-family=\"geogebra-sans-serif, sans-serif\" font-size=\"12px\" font-style=\"normal\" font-weight=\"normal\" text-decoration=\"normal\" x=\"23\" y=\"165\" text-anchor=\"start\" dominant-baseline=\"alphabetic\" stroke-opacity=\"1\" stroke-linejoin=\"bevel\" stroke-miterlimit=\"10\" stroke-width=\"3\">–1.5<\/text><text fill=\"rgb(0,0,0)\" stroke=\"none\" font-family=\"geogebra-sans-serif, sans-serif\" font-size=\"12px\" font-style=\"normal\" font-weight=\"normal\" text-decoration=\"normal\" x=\"23\" y=\"165\" text-anchor=\"start\" dominant-baseline=\"alphabetic\" fill-opacity=\"1\">–1.5<\/text><text fill=\"rgb(0,0,0)\" stroke=\"none\" font-family=\"geogebra-sans-serif, sans-serif\" font-size=\"12px\" font-style=\"normal\" font-weight=\"normal\" text-decoration=\"normal\" x=\"95\" y=\"165\" text-anchor=\"start\" dominant-baseline=\"alphabetic\" fill-opacity=\"1\">–1<\/text><text fill=\"none\" stroke=\"rgb(255,255,255)\" font-family=\"geogebra-sans-serif, sans-serif\" font-size=\"12px\" font-style=\"normal\" font-weight=\"normal\" text-decoration=\"normal\" x=\"95\" y=\"165\" text-anchor=\"start\" dominant-baseline=\"alphabetic\" stroke-opacity=\"1\" stroke-linejoin=\"bevel\" stroke-miterlimit=\"10\" stroke-width=\"3\">–1<\/text><text fill=\"rgb(0,0,0)\" stroke=\"none\" font-family=\"geogebra-sans-serif, sans-serif\" font-size=\"12px\" font-style=\"normal\" font-weight=\"normal\" text-decoration=\"normal\" x=\"95\" y=\"165\" text-anchor=\"start\" dominant-baseline=\"alphabetic\" fill-opacity=\"1\">–1<\/text><text fill=\"rgb(0,0,0)\" stroke=\"none\" font-family=\"geogebra-sans-serif, sans-serif\" font-size=\"12px\" font-style=\"normal\" font-weight=\"normal\" text-decoration=\"normal\" x=\"156\" y=\"165\" text-anchor=\"start\" dominant-baseline=\"alphabetic\" fill-opacity=\"1\">–0.5<\/text><text fill=\"none\" stroke=\"rgb(255,255,255)\" font-family=\"geogebra-sans-serif, sans-serif\" font-size=\"12px\" font-style=\"normal\" font-weight=\"normal\" text-decoration=\"normal\" x=\"156\" y=\"165\" text-anchor=\"start\" dominant-baseline=\"alphabetic\" stroke-opacity=\"1\" stroke-linejoin=\"bevel\" stroke-miterlimit=\"10\" stroke-width=\"3\">–0.5<\/text><text fill=\"rgb(0,0,0)\" stroke=\"none\" font-family=\"geogebra-sans-serif, sans-serif\" font-size=\"12px\" font-style=\"normal\" font-weight=\"normal\" text-decoration=\"normal\" x=\"156\" y=\"165\" text-anchor=\"start\" dominant-baseline=\"alphabetic\" fill-opacity=\"1\">–0.5<\/text><text fill=\"rgb(0,0,0)\" stroke=\"none\" font-family=\"geogebra-sans-serif, sans-serif\" font-size=\"12px\" font-style=\"normal\" font-weight=\"normal\" text-decoration=\"normal\" x=\"292\" y=\"165\" text-anchor=\"start\" dominant-baseline=\"alphabetic\" fill-opacity=\"1\">0.5<\/text><text fill=\"none\" stroke=\"rgb(255,255,255)\" font-family=\"geogebra-sans-serif, sans-serif\" font-size=\"12px\" font-style=\"normal\" font-weight=\"normal\" text-decoration=\"normal\" x=\"292\" y=\"165\" text-anchor=\"start\" dominant-baseline=\"alphabetic\" stroke-opacity=\"1\" stroke-linejoin=\"bevel\" stroke-miterlimit=\"10\" stroke-width=\"3\">0.5<\/text><text fill=\"rgb(0,0,0)\" stroke=\"none\" font-family=\"geogebra-sans-serif, sans-serif\" font-size=\"12px\" font-style=\"normal\" font-weight=\"normal\" text-decoration=\"normal\" x=\"292\" y=\"165\" text-anchor=\"start\" dominant-baseline=\"alphabetic\" fill-opacity=\"1\">0.5<\/text><text fill=\"rgb(0,0,0)\" stroke=\"none\" font-family=\"geogebra-sans-serif, sans-serif\" font-size=\"12px\" font-style=\"normal\" font-weight=\"normal\" text-decoration=\"normal\" x=\"365\" y=\"165\" text-anchor=\"start\" dominant-baseline=\"alphabetic\" fill-opacity=\"1\">1<\/text><text fill=\"none\" stroke=\"rgb(255,255,255)\" font-family=\"geogebra-sans-serif, sans-serif\" font-size=\"12px\" font-style=\"normal\" font-weight=\"normal\" text-decoration=\"normal\" x=\"365\" y=\"165\" text-anchor=\"start\" dominant-baseline=\"alphabetic\" stroke-opacity=\"1\" stroke-linejoin=\"bevel\" stroke-miterlimit=\"10\" stroke-width=\"3\">1<\/text><text fill=\"rgb(0,0,0)\" stroke=\"none\" font-family=\"geogebra-sans-serif, sans-serif\" font-size=\"12px\" font-style=\"normal\" font-weight=\"normal\" text-decoration=\"normal\" x=\"365\" y=\"165\" text-anchor=\"start\" dominant-baseline=\"alphabetic\" fill-opacity=\"1\">1<\/text><text fill=\"rgb(0,0,0)\" stroke=\"none\" font-family=\"geogebra-sans-serif, sans-serif\" font-size=\"12px\" font-style=\"normal\" font-weight=\"normal\" text-decoration=\"normal\" x=\"425\" y=\"165\" text-anchor=\"start\" dominant-baseline=\"alphabetic\" fill-opacity=\"1\">1.5<\/text><text fill=\"none\" stroke=\"rgb(255,255,255)\" font-family=\"geogebra-sans-serif, sans-serif\" font-size=\"12px\" font-style=\"normal\" font-weight=\"normal\" text-decoration=\"normal\" x=\"425\" y=\"165\" text-anchor=\"start\" dominant-baseline=\"alphabetic\" stroke-opacity=\"1\" stroke-linejoin=\"bevel\" stroke-miterlimit=\"10\" stroke-width=\"3\">1.5<\/text><text fill=\"rgb(0,0,0)\" stroke=\"none\" font-family=\"geogebra-sans-serif, sans-serif\" font-size=\"12px\" font-style=\"normal\" font-weight=\"normal\" text-decoration=\"normal\" x=\"425\" y=\"165\" text-anchor=\"start\" dominant-baseline=\"alphabetic\" fill-opacity=\"1\">1.5<\/text><text fill=\"rgb(0,0,0)\" stroke=\"none\" font-family=\"geogebra-sans-serif, sans-serif\" font-size=\"12px\" font-style=\"normal\" font-weight=\"normal\" text-decoration=\"normal\" x=\"498\" y=\"165\" text-anchor=\"start\" dominant-baseline=\"alphabetic\" fill-opacity=\"1\">2<\/text><text fill=\"none\" stroke=\"rgb(255,255,255)\" font-family=\"geogebra-sans-serif, sans-serif\" font-size=\"12px\" font-style=\"normal\" font-weight=\"normal\" text-decoration=\"normal\" x=\"498\" y=\"165\" text-anchor=\"start\" dominant-baseline=\"alphabetic\" stroke-opacity=\"1\" stroke-linejoin=\"bevel\" stroke-miterlimit=\"10\" stroke-width=\"3\">2<\/text><text fill=\"rgb(0,0,0)\" stroke=\"none\" font-family=\"geogebra-sans-serif, sans-serif\" font-size=\"12px\" font-style=\"normal\" font-weight=\"normal\" text-decoration=\"normal\" x=\"498\" y=\"165\" text-anchor=\"start\" dominant-baseline=\"alphabetic\" fill-opacity=\"1\">2<\/text><text fill=\"rgb(0,0,0)\" stroke=\"none\" font-family=\"geogebra-sans-serif, sans-serif\" font-size=\"12px\" font-style=\"normal\" font-weight=\"normal\" text-decoration=\"normal\" x=\"559\" y=\"165\" text-anchor=\"start\" dominant-baseline=\"alphabetic\" fill-opacity=\"1\">2.5<\/text><text fill=\"none\" stroke=\"rgb(255,255,255)\" font-family=\"geogebra-sans-serif, sans-serif\" font-size=\"12px\" font-style=\"normal\" font-weight=\"normal\" text-decoration=\"normal\" x=\"559\" y=\"165\" text-anchor=\"start\" dominant-baseline=\"alphabetic\" stroke-opacity=\"1\" stroke-linejoin=\"bevel\" stroke-miterlimit=\"10\" stroke-width=\"3\">2.5<\/text><text fill=\"rgb(0,0,0)\" stroke=\"none\" font-family=\"geogebra-sans-serif, sans-serif\" font-size=\"12px\" font-style=\"normal\" font-weight=\"normal\" text-decoration=\"normal\" x=\"559\" y=\"165\" text-anchor=\"start\" dominant-baseline=\"alphabetic\" fill-opacity=\"1\">2.5<\/text><text fill=\"rgb(0,0,0)\" stroke=\"none\" font-family=\"geogebra-sans-serif, sans-serif\" font-size=\"12px\" font-style=\"normal\" font-weight=\"normal\" text-decoration=\"normal\" x=\"212\" y=\"287\" text-anchor=\"start\" dominant-baseline=\"alphabetic\" fill-opacity=\"1\">–1<\/text><text fill=\"none\" stroke=\"rgb(255,255,255)\" font-family=\"geogebra-sans-serif, sans-serif\" font-size=\"12px\" font-style=\"normal\" font-weight=\"normal\" text-decoration=\"normal\" x=\"212\" y=\"287\" text-anchor=\"start\" dominant-baseline=\"alphabetic\" stroke-opacity=\"1\" stroke-linejoin=\"bevel\" stroke-miterlimit=\"10\" stroke-width=\"3\">–1<\/text><text fill=\"rgb(0,0,0)\" stroke=\"none\" font-family=\"geogebra-sans-serif, sans-serif\" font-size=\"12px\" font-style=\"normal\" font-weight=\"normal\" text-decoration=\"normal\" x=\"212\" y=\"287\" text-anchor=\"start\" dominant-baseline=\"alphabetic\" fill-opacity=\"1\">–1<\/text><text fill=\"rgb(0,0,0)\" stroke=\"none\" font-family=\"geogebra-sans-serif, sans-serif\" font-size=\"12px\" font-style=\"normal\" font-weight=\"normal\" text-decoration=\"normal\" x=\"197\" y=\"221\" text-anchor=\"start\" dominant-baseline=\"alphabetic\" fill-opacity=\"1\">–0.5<\/text><text fill=\"none\" stroke=\"rgb(255,255,255)\" font-family=\"geogebra-sans-serif, sans-serif\" font-size=\"12px\" font-style=\"normal\" font-weight=\"normal\" text-decoration=\"normal\" x=\"197\" y=\"221\" text-anchor=\"start\" dominant-baseline=\"alphabetic\" stroke-opacity=\"1\" stroke-linejoin=\"bevel\" stroke-miterlimit=\"10\" stroke-width=\"3\">–0.5<\/text><text fill=\"rgb(0,0,0)\" stroke=\"none\" font-family=\"geogebra-sans-serif, sans-serif\" font-size=\"12px\" font-style=\"normal\" font-weight=\"normal\" text-decoration=\"normal\" x=\"197\" y=\"221\" text-anchor=\"start\" dominant-baseline=\"alphabetic\" fill-opacity=\"1\">–0.5<\/text><text fill=\"rgb(0,0,0)\" stroke=\"none\" font-family=\"geogebra-sans-serif, sans-serif\" font-size=\"12px\" font-style=\"normal\" font-weight=\"normal\" text-decoration=\"normal\" x=\"204\" y=\"87\" text-anchor=\"start\" dominant-baseline=\"alphabetic\" fill-opacity=\"1\">0.5<\/text><text fill=\"none\" stroke=\"rgb(255,255,255)\" font-family=\"geogebra-sans-serif, sans-serif\" font-size=\"12px\" font-style=\"normal\" font-weight=\"normal\" text-decoration=\"normal\" x=\"204\" y=\"87\" text-anchor=\"start\" dominant-baseline=\"alphabetic\" stroke-opacity=\"1\" stroke-linejoin=\"bevel\" stroke-miterlimit=\"10\" stroke-width=\"3\">0.5<\/text><text fill=\"rgb(0,0,0)\" stroke=\"none\" font-family=\"geogebra-sans-serif, sans-serif\" font-size=\"12px\" font-style=\"normal\" font-weight=\"normal\" text-decoration=\"normal\" x=\"204\" y=\"87\" text-anchor=\"start\" dominant-baseline=\"alphabetic\" fill-opacity=\"1\">0.5<\/text><text fill=\"rgb(0,0,0)\" stroke=\"none\" font-family=\"geogebra-sans-serif, sans-serif\" font-size=\"12px\" font-style=\"normal\" font-weight=\"normal\" text-decoration=\"normal\" x=\"219\" y=\"21\" text-anchor=\"start\" dominant-baseline=\"alphabetic\" fill-opacity=\"1\">1<\/text><text fill=\"none\" stroke=\"rgb(255,255,255)\" font-family=\"geogebra-sans-serif, sans-serif\" font-size=\"12px\" font-style=\"normal\" font-weight=\"normal\" text-decoration=\"normal\" x=\"219\" y=\"21\" text-anchor=\"start\" dominant-baseline=\"alphabetic\" stroke-opacity=\"1\" stroke-linejoin=\"bevel\" stroke-miterlimit=\"10\" stroke-width=\"3\">1<\/text><text fill=\"rgb(0,0,0)\" stroke=\"none\" font-family=\"geogebra-sans-serif, sans-serif\" font-size=\"12px\" font-style=\"normal\" font-weight=\"normal\" text-decoration=\"normal\" x=\"219\" y=\"21\" text-anchor=\"start\" dominant-baseline=\"alphabetic\" fill-opacity=\"1\">1<\/text><text fill=\"rgb(0,0,0)\" stroke=\"none\" font-family=\"geogebra-sans-serif, sans-serif\" font-size=\"12px\" font-style=\"normal\" font-weight=\"normal\" text-decoration=\"normal\" x=\"219\" y=\"165\" text-anchor=\"start\" dominant-baseline=\"alphabetic\" fill-opacity=\"1\">0<\/text><text fill=\"none\" stroke=\"rgb(255,255,255)\" font-family=\"geogebra-sans-serif, sans-serif\" font-size=\"12px\" font-style=\"normal\" font-weight=\"normal\" text-decoration=\"normal\" x=\"219\" y=\"165\" text-anchor=\"start\" dominant-baseline=\"alphabetic\" stroke-opacity=\"1\" stroke-linejoin=\"bevel\" stroke-miterlimit=\"10\" stroke-width=\"3\">0<\/text><text fill=\"rgb(0,0,0)\" stroke=\"none\" font-family=\"geogebra-sans-serif, sans-serif\" font-size=\"12px\" font-style=\"normal\" font-weight=\"normal\" text-decoration=\"normal\" x=\"219\" y=\"165\" text-anchor=\"start\" dominant-baseline=\"alphabetic\" fill-opacity=\"1\">0<\/text><path fill=\"none\" stroke=\"rgb(97,97,97)\" paint-order=\"fill stroke markers\" d=\" M 367.23252568911755 149.44244871325463 C 367.23252568911755 223.03584163929233 307.5732931378362 282.695074190574 233.97990021179882 282.695074190574 C 160.38650728576147 282.695074190574 100.72727473448012 223.03584163929233 100.72727473448012 149.44244871325463 C 100.72727473448012 75.84905578721691 160.38650728576147 16.18982323593528 233.97990021179882 16.18982323593528 C 307.5732931378362 16.18982323593528 367.23252568911755 75.84905578721691 367.23252568911755 149.44244871325463 Z\" stroke-opacity=\"0.8\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2.5\"\/><path fill=\"rgb(0,0,0)\" stroke=\"none\" paint-order=\"stroke fill markers\" d=\" M 263.97990021179885 149.44244871325463 C 263.97990021179885 141.48595401806827 260.8191950008363 133.8553366310992 255.19310364739525 128.2292452776581 L 233.97990021179882 149.44244871325463 Z\" fill-opacity=\"0.09803921568627451\"\/><path fill=\"none\" stroke=\"rgb(0,0,0)\" paint-order=\"fill stroke markers\" d=\" M 263.97990021179885 149.44244871325463 C 263.97990021179885 141.48595401806827 260.8191950008363 133.8553366310992 255.19310364739525 128.2292452776581 L 233.97990021179882 149.44244871325463 Z\" stroke-opacity=\"0.6\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\"\/><text fill=\"rgb(0,0,0)\" stroke=\"none\" font-family=\"geogebra-sans-serif, sans-serif\" font-size=\"16px\" font-style=\"normal\" font-weight=\"normal\" text-decoration=\"normal\" x=\"247\" y=\"147\" text-anchor=\"start\" dominant-baseline=\"alphabetic\" fill-opacity=\"1\">θ<\/text><text fill=\"none\" stroke=\"rgb(255,255,255)\" font-family=\"geogebra-sans-serif, sans-serif\" font-size=\"16px\" font-style=\"normal\" font-weight=\"normal\" text-decoration=\"normal\" x=\"247\" y=\"147\" text-anchor=\"start\" dominant-baseline=\"alphabetic\" stroke-opacity=\"1\" stroke-linejoin=\"bevel\" stroke-miterlimit=\"10\" stroke-width=\"3\">θ<\/text><text fill=\"rgb(0,0,0)\" stroke=\"none\" font-family=\"geogebra-sans-serif, sans-serif\" font-size=\"16px\" font-style=\"normal\" font-weight=\"normal\" text-decoration=\"normal\" x=\"247\" y=\"147\" text-anchor=\"start\" dominant-baseline=\"alphabetic\" fill-opacity=\"1\">θ<\/text><path fill=\"none\" stroke=\"rgb(97,97,97)\" paint-order=\"fill stroke markers\" d=\" M 233.97990021179882 149.44244871325463 L 316.1829200175509 67.23942890750214\" stroke-opacity=\"0.8\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2.5\"\/><path fill=\"rgb(97,97,97)\" stroke=\"none\" paint-order=\"stroke fill markers\" fill-rule=\"evenodd\" d=\" M 328.2037352977222 55.21861362733081 L 319.1881238375937 70.24463272754497 L 313.17771619750806 64.23422508745932 Z\" fill-opacity=\"0.8\"\/><path fill=\"none\" stroke=\"rgb(97,97,97)\" paint-order=\"fill stroke markers\" d=\" M 233.97990021179882 149.44244871325463 L 151.77688040604676 231.64546851900712\" stroke-opacity=\"0.8\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2.5\"\/><path fill=\"rgb(97,97,97)\" stroke=\"none\" paint-order=\"stroke fill markers\" fill-rule=\"evenodd\" d=\" M 139.75606512587547 243.66628379917847 L 148.77167658600393 228.6402646989643 L 154.78208422608958 234.65067233904995 Z\" fill-opacity=\"0.8\"\/><path fill=\"none\" stroke=\"rgb(97,97,97)\" paint-order=\"fill stroke markers\" d=\" M 233.97990021179882 149.44244871325463 L 151.77688040604676 67.23942890750214\" stroke-opacity=\"0.8\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2.5\"\/><path fill=\"rgb(97,97,97)\" stroke=\"none\" paint-order=\"stroke fill markers\" fill-rule=\"evenodd\" d=\" M 139.75606512587547 55.21861362733081 L 154.78208422608958 64.23422508745932 L 148.77167658600393 70.24463272754497 Z\" fill-opacity=\"0.8\"\/><path fill=\"none\" stroke=\"rgb(97,97,97)\" paint-order=\"fill stroke markers\" d=\" M 233.97990021179882 149.44244871325463 L 316.1829200175509 231.64546851900712\" stroke-opacity=\"0.8\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2.5\"\/><path fill=\"rgb(97,97,97)\" stroke=\"none\" paint-order=\"stroke fill markers\" fill-rule=\"evenodd\" d=\" M 328.2037352977222 243.66628379917847 L 313.17771619750806 234.65067233904995 L 319.1881238375937 228.6402646989643 Z\" fill-opacity=\"0.8\"\/><path fill=\"none\" stroke=\"rgb(97,97,97)\" paint-order=\"fill stroke markers\" d=\" M 233.97990021179882 149.44244871325463 L 350.23252568911755 149.44244871325463\" stroke-opacity=\"0.8\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2.5\"\/><path fill=\"rgb(97,97,97)\" stroke=\"none\" paint-order=\"stroke fill markers\" fill-rule=\"evenodd\" d=\" M 367.23252568911755 149.44244871325463 L 350.23252568911755 153.69244871325463 L 350.23252568911755 145.19244871325463 Z\" fill-opacity=\"0.8\"\/><path fill=\"none\" stroke=\"rgb(97,97,97)\" paint-order=\"fill stroke markers\" d=\" M 233.97990021179882 149.44244871325463 L 117.72727473448012 149.44244871325463\" stroke-opacity=\"0.8\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2.5\"\/><path fill=\"rgb(97,97,97)\" stroke=\"none\" paint-order=\"stroke fill markers\" fill-rule=\"evenodd\" d=\" M 100.72727473448012 149.44244871325463 L 117.72727473448012 145.19244871325463 L 117.72727473448012 153.69244871325463 Z\" fill-opacity=\"0.8\"\/><path fill=\"none\" stroke=\"rgb(97,97,97)\" paint-order=\"fill stroke markers\" d=\" M 233.97990021179882 149.44244871325463 L 233.97990021179882 265.695074190574\" stroke-opacity=\"0.8\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2.5\"\/><path fill=\"rgb(97,97,97)\" stroke=\"none\" paint-order=\"stroke fill markers\" fill-rule=\"evenodd\" d=\" M 233.97990021179882 282.695074190574 L 229.72990021179882 265.695074190574 L 238.22990021179882 265.695074190574 Z\" fill-opacity=\"0.8\"\/><path fill=\"none\" stroke=\"rgb(97,97,97)\" paint-order=\"fill stroke markers\" d=\" M 233.97990021179882 149.44244871325463 L 233.97990021179882 33.18982323593528\" stroke-opacity=\"0.8\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2.5\"\/><path fill=\"rgb(97,97,97)\" stroke=\"none\" paint-order=\"stroke fill markers\" fill-rule=\"evenodd\" d=\" M 233.97990021179882 16.18982323593528 L 238.22990021179882 33.18982323593528 L 229.72990021179882 33.18982323593528 Z\" fill-opacity=\"0.8\"\/><path fill=\"rgb(97,97,97)\" stroke=\"none\" paint-order=\"stroke fill markers\" d=\" M 237.97990021179882 149.44244871325463 C 237.97990021179882 151.6515877125778 236.189039211122 153.44244871325463 233.97990021179882 153.44244871325463 C 231.77076121247563 153.44244871325463 229.97990021179882 151.6515877125778 229.97990021179882 149.44244871325463 C 229.97990021179882 147.23330971393145 231.77076121247563 145.44244871325463 233.97990021179882 145.44244871325463 C 236.189039211122 145.44244871325463 237.97990021179882 147.23330971393145 237.97990021179882 149.44244871325463 Z\" fill-opacity=\"1\"\/><path fill=\"none\" stroke=\"rgb(0,0,0)\" paint-order=\"fill stroke markers\" d=\" M 237.97990021179882 149.44244871325463 C 237.97990021179882 151.6515877125778 236.189039211122 153.44244871325463 233.97990021179882 153.44244871325463 C 231.77076121247563 153.44244871325463 229.97990021179882 151.6515877125778 229.97990021179882 149.44244871325463 C 229.97990021179882 147.23330971393145 231.77076121247563 145.44244871325463 233.97990021179882 145.44244871325463 C 236.189039211122 145.44244871325463 237.97990021179882 147.23330971393145 237.97990021179882 149.44244871325463 Z\" stroke-opacity=\"1\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-miterlimit=\"10\"\/><text fill=\"rgb(97,97,97)\" stroke=\"none\" font-family=\"geogebra-sans-serif, sans-serif\" font-size=\"16px\" font-style=\"normal\" font-weight=\"normal\" text-decoration=\"normal\" x=\"238\" y=\"141\" text-anchor=\"start\" dominant-baseline=\"alphabetic\" fill-opacity=\"1\">O<\/text><text fill=\"none\" stroke=\"rgb(255,255,255)\" font-family=\"geogebra-sans-serif, sans-serif\" font-size=\"16px\" font-style=\"normal\" font-weight=\"normal\" text-decoration=\"normal\" x=\"238\" y=\"141\" text-anchor=\"start\" dominant-baseline=\"alphabetic\" stroke-opacity=\"1\" stroke-linejoin=\"bevel\" stroke-miterlimit=\"10\" stroke-width=\"3\">O<\/text><text fill=\"rgb(97,97,97)\" stroke=\"none\" font-family=\"geogebra-sans-serif, sans-serif\" font-size=\"16px\" font-style=\"normal\" font-weight=\"normal\" text-decoration=\"normal\" x=\"238\" y=\"141\" text-anchor=\"start\" dominant-baseline=\"alphabetic\" fill-opacity=\"1\">O<\/text><path fill=\"rgb(21,101,192)\" stroke=\"none\" paint-order=\"stroke fill markers\" d=\" M 372.23252568911755 149.44244871325463 C 372.23252568911755 152.2038724624086 369.9939494382715 154.44244871325463 367.23252568911755 154.44244871325463 C 364.4711019399636 154.44244871325463 362.23252568911755 152.2038724624086 362.23252568911755 149.44244871325463 C 362.23252568911755 146.68102496410066 364.4711019399636 144.44244871325463 367.23252568911755 144.44244871325463 C 369.9939494382715 144.44244871325463 372.23252568911755 146.68102496410066 372.23252568911755 149.44244871325463 Z\" fill-opacity=\"1\"\/><path fill=\"none\" stroke=\"rgb(0,0,0)\" paint-order=\"fill stroke markers\" d=\" M 372.23252568911755 149.44244871325463 C 372.23252568911755 152.2038724624086 369.9939494382715 154.44244871325463 367.23252568911755 154.44244871325463 C 364.4711019399636 154.44244871325463 362.23252568911755 152.2038724624086 362.23252568911755 149.44244871325463 C 362.23252568911755 146.68102496410066 364.4711019399636 144.44244871325463 367.23252568911755 144.44244871325463 C 369.9939494382715 144.44244871325463 372.23252568911755 146.68102496410066 372.23252568911755 149.44244871325463 Z\" stroke-opacity=\"1\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-miterlimit=\"10\"\/><path fill=\"rgb(21,101,192)\" stroke=\"none\" paint-order=\"stroke fill markers\" d=\" M 333.2037352977222 55.21861362733081 C 333.2037352977222 57.98003737648477 330.9651590468761 60.21861362733081 328.2037352977222 60.21861362733081 C 325.4423115485682 60.21861362733081 323.2037352977222 57.98003737648477 323.2037352977222 55.21861362733081 C 323.2037352977222 52.45718987817684 325.4423115485682 50.21861362733081 328.2037352977222 50.21861362733081 C 330.9651590468761 50.21861362733081 333.2037352977222 52.45718987817684 333.2037352977222 55.21861362733081 Z\" fill-opacity=\"1\"\/><path fill=\"none\" stroke=\"rgb(0,0,0)\" paint-order=\"fill stroke markers\" d=\" M 333.2037352977222 55.21861362733081 C 333.2037352977222 57.98003737648477 330.9651590468761 60.21861362733081 328.2037352977222 60.21861362733081 C 325.4423115485682 60.21861362733081 323.2037352977222 57.98003737648477 323.2037352977222 55.21861362733081 C 323.2037352977222 52.45718987817684 325.4423115485682 50.21861362733081 328.2037352977222 50.21861362733081 C 330.9651590468761 50.21861362733081 333.2037352977222 52.45718987817684 333.2037352977222 55.21861362733081 Z\" stroke-opacity=\"1\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-miterlimit=\"10\"\/><text fill=\"rgb(21,101,192)\" stroke=\"none\" font-family=\"geogebra-sans-serif, sans-serif\" font-size=\"16px\" font-style=\"normal\" font-weight=\"normal\" text-decoration=\"normal\" x=\"332\" y=\"45\" text-anchor=\"start\" dominant-baseline=\"alphabetic\" fill-opacity=\"1\">ω<\/text><text fill=\"none\" stroke=\"rgb(255,255,255)\" font-family=\"geogebra-sans-serif, sans-serif\" font-size=\"16px\" font-style=\"normal\" font-weight=\"normal\" text-decoration=\"normal\" x=\"332\" y=\"45\" text-anchor=\"start\" dominant-baseline=\"alphabetic\" stroke-opacity=\"1\" stroke-linejoin=\"bevel\" stroke-miterlimit=\"10\" stroke-width=\"3\">ω<\/text><text fill=\"rgb(21,101,192)\" stroke=\"none\" font-family=\"geogebra-sans-serif, sans-serif\" font-size=\"16px\" font-style=\"normal\" font-weight=\"normal\" text-decoration=\"normal\" x=\"332\" y=\"45\" text-anchor=\"start\" dominant-baseline=\"alphabetic\" fill-opacity=\"1\">ω<\/text><text fill=\"rgb(21,101,192)\" stroke=\"none\" font-family=\"geogebra-sans-serif, sans-serif\" font-size=\"14px\" font-style=\"normal\" font-weight=\"normal\" text-decoration=\"normal\" x=\"346\" y=\"52\" text-anchor=\"start\" dominant-baseline=\"alphabetic\" fill-opacity=\"1\">8<\/text><text fill=\"none\" stroke=\"rgb(255,255,255)\" font-family=\"geogebra-sans-serif, sans-serif\" font-size=\"14px\" font-style=\"normal\" font-weight=\"normal\" text-decoration=\"normal\" x=\"346\" y=\"52\" text-anchor=\"start\" dominant-baseline=\"alphabetic\" stroke-opacity=\"1\" stroke-linejoin=\"bevel\" stroke-miterlimit=\"10\" stroke-width=\"3\">8<\/text><text fill=\"rgb(21,101,192)\" stroke=\"none\" font-family=\"geogebra-sans-serif, sans-serif\" font-size=\"14px\" font-style=\"normal\" font-weight=\"normal\" text-decoration=\"normal\" x=\"346\" y=\"52\" text-anchor=\"start\" dominant-baseline=\"alphabetic\" fill-opacity=\"1\">8<\/text><text fill=\"rgb(21,101,192)\" stroke=\"none\" font-family=\"geogebra-sans-serif, sans-serif\" font-size=\"16px\" font-style=\"normal\" font-weight=\"normal\" text-decoration=\"normal\" x=\"354\" y=\"45\" text-anchor=\"start\" dominant-baseline=\"alphabetic\" fill-opacity=\"1\">(cos θ, i sin θ)<\/text><text fill=\"none\" stroke=\"rgb(255,255,255)\" font-family=\"geogebra-sans-serif, sans-serif\" font-size=\"16px\" font-style=\"normal\" font-weight=\"normal\" text-decoration=\"normal\" x=\"354\" y=\"45\" text-anchor=\"start\" dominant-baseline=\"alphabetic\" stroke-opacity=\"1\" stroke-linejoin=\"bevel\" stroke-miterlimit=\"10\" stroke-width=\"3\">(cos θ, i sin θ)<\/text><text fill=\"rgb(21,101,192)\" stroke=\"none\" font-family=\"geogebra-sans-serif, sans-serif\" font-size=\"16px\" font-style=\"normal\" font-weight=\"normal\" text-decoration=\"normal\" x=\"354\" y=\"45\" text-anchor=\"start\" dominant-baseline=\"alphabetic\" fill-opacity=\"1\">(cos θ, sin θ)<\/text><path fill=\"rgb(97,97,97)\" stroke=\"none\" paint-order=\"stroke fill markers\" d=\" M 143.75606512587547 243.66628379917847 C 143.75606512587547 245.87542279850163 141.96520412519862 247.66628379917847 139.75606512587547 247.66628379917847 C 137.54692612655228 247.66628379917847 135.75606512587547 245.87542279850163 135.75606512587547 243.66628379917847 C 135.75606512587547 241.45714479985529 137.54692612655228 239.66628379917847 139.75606512587547 239.66628379917847 C 141.96520412519862 239.66628379917847 143.75606512587547 241.45714479985529 143.75606512587547 243.66628379917847 Z\" fill-opacity=\"1\"\/><path fill=\"none\" stroke=\"rgb(0,0,0)\" paint-order=\"fill stroke markers\" d=\" M 143.75606512587547 243.66628379917847 C 143.75606512587547 245.87542279850163 141.96520412519862 247.66628379917847 139.75606512587547 247.66628379917847 C 137.54692612655228 247.66628379917847 135.75606512587547 245.87542279850163 135.75606512587547 243.66628379917847 C 135.75606512587547 241.45714479985529 137.54692612655228 239.66628379917847 139.75606512587547 239.66628379917847 C 141.96520412519862 239.66628379917847 143.75606512587547 241.45714479985529 143.75606512587547 243.66628379917847 Z\" stroke-opacity=\"1\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-miterlimit=\"10\"\/><text fill=\"rgb(97,97,97)\" stroke=\"none\" font-family=\"geogebra-sans-serif, sans-serif\" font-size=\"16px\" font-style=\"normal\" font-weight=\"normal\" text-decoration=\"normal\" x=\"144\" y=\"236\" text-anchor=\"start\" dominant-baseline=\"alphabetic\" fill-opacity=\"1\">C<\/text><text fill=\"none\" stroke=\"rgb(255,255,255)\" font-family=\"geogebra-sans-serif, sans-serif\" font-size=\"16px\" font-style=\"normal\" font-weight=\"normal\" text-decoration=\"normal\" x=\"144\" y=\"236\" text-anchor=\"start\" dominant-baseline=\"alphabetic\" stroke-opacity=\"1\" stroke-linejoin=\"bevel\" stroke-miterlimit=\"10\" stroke-width=\"3\">C<\/text><text fill=\"rgb(97,97,97)\" stroke=\"none\" font-family=\"geogebra-sans-serif, sans-serif\" font-size=\"16px\" font-style=\"normal\" font-weight=\"normal\" text-decoration=\"normal\" x=\"144\" y=\"236\" text-anchor=\"start\" dominant-baseline=\"alphabetic\" fill-opacity=\"1\">C<\/text><path fill=\"rgb(97,97,97)\" stroke=\"none\" paint-order=\"stroke fill markers\" d=\" M 143.75606512587547 55.21861362733081 C 143.75606512587547 57.427752626653984 141.96520412519862 59.21861362733081 139.75606512587547 59.21861362733081 C 137.54692612655228 59.21861362733081 135.75606512587547 57.427752626653984 135.75606512587547 55.21861362733081 C 135.75606512587547 53.00947462800764 137.54692612655228 51.21861362733081 139.75606512587547 51.21861362733081 C 141.96520412519862 51.21861362733081 143.75606512587547 53.00947462800764 143.75606512587547 55.21861362733081 Z\" fill-opacity=\"1\"\/><path fill=\"none\" stroke=\"rgb(0,0,0)\" paint-order=\"fill stroke markers\" d=\" M 143.75606512587547 55.21861362733081 C 143.75606512587547 57.427752626653984 141.96520412519862 59.21861362733081 139.75606512587547 59.21861362733081 C 137.54692612655228 59.21861362733081 135.75606512587547 57.427752626653984 135.75606512587547 55.21861362733081 C 135.75606512587547 53.00947462800764 137.54692612655228 51.21861362733081 139.75606512587547 51.21861362733081 C 141.96520412519862 51.21861362733081 143.75606512587547 53.00947462800764 143.75606512587547 55.21861362733081 Z\" stroke-opacity=\"1\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-miterlimit=\"10\"\/><text fill=\"rgb(97,97,97)\" stroke=\"none\" font-family=\"geogebra-sans-serif, sans-serif\" font-size=\"16px\" font-style=\"normal\" font-weight=\"normal\" text-decoration=\"normal\" x=\"144\" y=\"47\" text-anchor=\"start\" dominant-baseline=\"alphabetic\" fill-opacity=\"1\">B<\/text><text fill=\"none\" stroke=\"rgb(255,255,255)\" font-family=\"geogebra-sans-serif, sans-serif\" font-size=\"16px\" font-style=\"normal\" font-weight=\"normal\" text-decoration=\"normal\" x=\"144\" y=\"47\" text-anchor=\"start\" dominant-baseline=\"alphabetic\" stroke-opacity=\"1\" stroke-linejoin=\"bevel\" stroke-miterlimit=\"10\" stroke-width=\"3\">B<\/text><text fill=\"rgb(97,97,97)\" stroke=\"none\" font-family=\"geogebra-sans-serif, sans-serif\" font-size=\"16px\" font-style=\"normal\" font-weight=\"normal\" text-decoration=\"normal\" x=\"144\" y=\"47\" text-anchor=\"start\" dominant-baseline=\"alphabetic\" fill-opacity=\"1\">B<\/text><path fill=\"rgb(97,97,97)\" stroke=\"none\" paint-order=\"stroke fill markers\" d=\" M 332.2037352977222 243.66628379917847 C 332.2037352977222 245.87542279850163 330.41287429704533 247.66628379917847 328.2037352977222 247.66628379917847 C 325.994596298399 247.66628379917847 324.2037352977222 245.87542279850163 324.2037352977222 243.66628379917847 C 324.2037352977222 241.45714479985529 325.994596298399 239.66628379917847 328.2037352977222 239.66628379917847 C 330.41287429704533 239.66628379917847 332.2037352977222 241.45714479985529 332.2037352977222 243.66628379917847 Z\" fill-opacity=\"1\"\/><path fill=\"none\" stroke=\"rgb(0,0,0)\" paint-order=\"fill stroke markers\" d=\" M 332.2037352977222 243.66628379917847 C 332.2037352977222 245.87542279850163 330.41287429704533 247.66628379917847 328.2037352977222 247.66628379917847 C 325.994596298399 247.66628379917847 324.2037352977222 245.87542279850163 324.2037352977222 243.66628379917847 C 324.2037352977222 241.45714479985529 325.994596298399 239.66628379917847 328.2037352977222 239.66628379917847 C 330.41287429704533 239.66628379917847 332.2037352977222 241.45714479985529 332.2037352977222 243.66628379917847 Z\" stroke-opacity=\"1\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-miterlimit=\"10\"\/><text fill=\"rgb(97,97,97)\" stroke=\"none\" font-family=\"geogebra-sans-serif, sans-serif\" font-size=\"16px\" font-style=\"normal\" font-weight=\"normal\" text-decoration=\"normal\" x=\"332\" y=\"236\" text-anchor=\"start\" dominant-baseline=\"alphabetic\" fill-opacity=\"1\">D<\/text><text fill=\"none\" stroke=\"rgb(255,255,255)\" font-family=\"geogebra-sans-serif, sans-serif\" font-size=\"16px\" font-style=\"normal\" font-weight=\"normal\" text-decoration=\"normal\" x=\"332\" y=\"236\" text-anchor=\"start\" dominant-baseline=\"alphabetic\" stroke-opacity=\"1\" stroke-linejoin=\"bevel\" stroke-miterlimit=\"10\" stroke-width=\"3\">D<\/text><text fill=\"rgb(97,97,97)\" stroke=\"none\" font-family=\"geogebra-sans-serif, sans-serif\" font-size=\"16px\" font-style=\"normal\" font-weight=\"normal\" text-decoration=\"normal\" x=\"332\" y=\"236\" text-anchor=\"start\" dominant-baseline=\"alphabetic\" fill-opacity=\"1\">D<\/text><path fill=\"rgb(97,97,97)\" stroke=\"none\" paint-order=\"stroke fill markers\" d=\" M 104.72727473448012 149.44244871325463 C 104.72727473448012 151.6515877125778 102.93641373380329 153.44244871325463 100.72727473448012 153.44244871325463 C 98.51813573515695 153.44244871325463 96.72727473448012 151.6515877125778 96.72727473448012 149.44244871325463 C 96.72727473448012 147.23330971393145 98.51813573515695 145.44244871325463 100.72727473448012 145.44244871325463 C 102.93641373380329 145.44244871325463 104.72727473448012 147.23330971393145 104.72727473448012 149.44244871325463 Z\" fill-opacity=\"1\"\/><path fill=\"none\" stroke=\"rgb(0,0,0)\" paint-order=\"fill stroke markers\" d=\" M 104.72727473448012 149.44244871325463 C 104.72727473448012 151.6515877125778 102.93641373380329 153.44244871325463 100.72727473448012 153.44244871325463 C 98.51813573515695 153.44244871325463 96.72727473448012 151.6515877125778 96.72727473448012 149.44244871325463 C 96.72727473448012 147.23330971393145 98.51813573515695 145.44244871325463 100.72727473448012 145.44244871325463 C 102.93641373380329 145.44244871325463 104.72727473448012 147.23330971393145 104.72727473448012 149.44244871325463 Z\" stroke-opacity=\"1\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-miterlimit=\"10\"\/><text fill=\"rgb(97,97,97)\" stroke=\"none\" font-family=\"geogebra-sans-serif, sans-serif\" font-size=\"16px\" font-style=\"normal\" font-weight=\"normal\" text-decoration=\"normal\" x=\"105\" y=\"141\" text-anchor=\"start\" dominant-baseline=\"alphabetic\" fill-opacity=\"1\">E<\/text><text fill=\"none\" stroke=\"rgb(255,255,255)\" font-family=\"geogebra-sans-serif, sans-serif\" font-size=\"16px\" font-style=\"normal\" font-weight=\"normal\" text-decoration=\"normal\" x=\"105\" y=\"141\" text-anchor=\"start\" dominant-baseline=\"alphabetic\" stroke-opacity=\"1\" stroke-linejoin=\"bevel\" stroke-miterlimit=\"10\" stroke-width=\"3\">E<\/text><text fill=\"rgb(97,97,97)\" stroke=\"none\" font-family=\"geogebra-sans-serif, sans-serif\" font-size=\"16px\" font-style=\"normal\" font-weight=\"normal\" text-decoration=\"normal\" x=\"105\" y=\"141\" text-anchor=\"start\" dominant-baseline=\"alphabetic\" fill-opacity=\"1\">E<\/text><path fill=\"rgb(97,97,97)\" stroke=\"none\" paint-order=\"stroke fill markers\" d=\" M 237.97990021179882 282.695074190574 C 237.97990021179882 284.9042131898972 236.189039211122 286.695074190574 233.97990021179882 286.695074190574 C 231.77076121247563 286.695074190574 229.97990021179882 284.9042131898972 229.97990021179882 282.695074190574 C 229.97990021179882 280.48593519125086 231.77076121247563 278.695074190574 233.97990021179882 278.695074190574 C 236.189039211122 278.695074190574 237.97990021179882 280.48593519125086 237.97990021179882 282.695074190574 Z\" fill-opacity=\"1\"\/><path fill=\"none\" stroke=\"rgb(0,0,0)\" paint-order=\"fill stroke markers\" d=\" M 237.97990021179882 282.695074190574 C 237.97990021179882 284.9042131898972 236.189039211122 286.695074190574 233.97990021179882 286.695074190574 C 231.77076121247563 286.695074190574 229.97990021179882 284.9042131898972 229.97990021179882 282.695074190574 C 229.97990021179882 280.48593519125086 231.77076121247563 278.695074190574 233.97990021179882 278.695074190574 C 236.189039211122 278.695074190574 237.97990021179882 280.48593519125086 237.97990021179882 282.695074190574 Z\" stroke-opacity=\"1\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-miterlimit=\"10\"\/><text fill=\"rgb(97,97,97)\" stroke=\"none\" font-family=\"geogebra-sans-serif, sans-serif\" font-size=\"16px\" font-style=\"normal\" font-weight=\"normal\" text-decoration=\"normal\" x=\"238\" y=\"275\" text-anchor=\"start\" dominant-baseline=\"alphabetic\" fill-opacity=\"1\">F<\/text><text fill=\"none\" stroke=\"rgb(255,255,255)\" font-family=\"geogebra-sans-serif, sans-serif\" font-size=\"16px\" font-style=\"normal\" font-weight=\"normal\" text-decoration=\"normal\" x=\"238\" y=\"275\" text-anchor=\"start\" dominant-baseline=\"alphabetic\" stroke-opacity=\"1\" stroke-linejoin=\"bevel\" stroke-miterlimit=\"10\" stroke-width=\"3\">F<\/text><text fill=\"rgb(97,97,97)\" stroke=\"none\" font-family=\"geogebra-sans-serif, sans-serif\" font-size=\"16px\" font-style=\"normal\" font-weight=\"normal\" text-decoration=\"normal\" x=\"238\" y=\"275\" text-anchor=\"start\" dominant-baseline=\"alphabetic\" fill-opacity=\"1\">F<\/text><path fill=\"rgb(97,97,97)\" stroke=\"none\" paint-order=\"stroke fill markers\" d=\" M 237.97990021179882 16.18982323593528 C 237.97990021179882 18.398962235258452 236.189039211122 20.18982323593528 233.97990021179882 20.18982323593528 C 231.77076121247563 20.18982323593528 229.97990021179882 18.398962235258452 229.97990021179882 16.18982323593528 C 229.97990021179882 13.980684236612106 231.77076121247563 12.189823235935279 233.97990021179882 12.189823235935279 C 236.189039211122 12.189823235935279 237.97990021179882 13.980684236612106 237.97990021179882 16.18982323593528 Z\" fill-opacity=\"1\"\/><path fill=\"none\" stroke=\"rgb(0,0,0)\" paint-order=\"fill stroke markers\" d=\" M 237.97990021179882 16.18982323593528 C 237.97990021179882 18.398962235258452 236.189039211122 20.18982323593528 233.97990021179882 20.18982323593528 C 231.77076121247563 20.18982323593528 229.97990021179882 18.398962235258452 229.97990021179882 16.18982323593528 C 229.97990021179882 13.980684236612106 231.77076121247563 12.189823235935279 233.97990021179882 12.189823235935279 C 236.189039211122 12.189823235935279 237.97990021179882 13.980684236612106 237.97990021179882 16.18982323593528 Z\" stroke-opacity=\"1\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-miterlimit=\"10\"\/><text fill=\"rgb(97,97,97)\" stroke=\"none\" font-family=\"geogebra-sans-serif, sans-serif\" font-size=\"16px\" font-style=\"normal\" font-weight=\"normal\" text-decoration=\"normal\" x=\"238\" y=\"16\" text-anchor=\"start\" dominant-baseline=\"alphabetic\" fill-opacity=\"1\">G<\/text><text fill=\"none\" stroke=\"rgb(255,255,255)\" font-family=\"geogebra-sans-serif, sans-serif\" font-size=\"16px\" font-style=\"normal\" font-weight=\"normal\" text-decoration=\"normal\" x=\"238\" y=\"16\" text-anchor=\"start\" dominant-baseline=\"alphabetic\" stroke-opacity=\"1\" stroke-linejoin=\"bevel\" stroke-miterlimit=\"10\" stroke-width=\"3\">G<\/text><text fill=\"rgb(97,97,97)\" stroke=\"none\" font-family=\"geogebra-sans-serif, sans-serif\" font-size=\"16px\" font-style=\"normal\" font-weight=\"normal\" text-decoration=\"normal\" x=\"238\" y=\"16\" text-anchor=\"start\" dominant-baseline=\"alphabetic\" fill-opacity=\"1\">G<\/text><\/g><\/g><\/svg>\n<\/html>\n\n向量$\\overrightarrow{O\\omega_8}$表示的复数就是$8$次单位根,$\\omega_8^1$\n\n> 拓展: \n> \n> 欧拉公式: $e^{i\\theta}=\\cos\\theta + i \\sin \\theta$(在复平面内坐标为$(\\cos \\theta, \\sin \\theta)$)\n> \n> $\\omega_n^k=e^{i 2\\pi \\frac kn}$\n> (可以理解为从$\\omega_n^0(1,0)$开始走长度为$2\\pi \\frac kn$的圆弧后到达的位置)\n> \n> 欧拉公式: $e^{i\\pi}=-1$(复平面中的$(-1,0)$)\n> \n> 关于证明和理解,可以参考下面两个视频: \n> \n> https:\/\/www.bilibili.com\/video\/av63666593\n> \n> https:\/\/www.bilibili.com\/video\/av79134103\n\n性质:\n\n$\\omega_n^k= \\cos 2\\pi\\frac kn+ i \\sin 2\\pi \\frac kn$\n\n$\\omega_{2n}^{2k}=\\omega_n^k$\n\n> $\\omega_{2n}^{2k}=\\cos 2\\pi\\frac {2k}{2n}+ i \\sin 2\\pi \\frac {2k}{2n}=\\cos 2\\pi\\frac kn+ i \\sin 2\\pi \\frac kn=\\omega_n^k$\n\n$\\omega_n^0=\\omega_n^n=1$\n\n$\\omega_n^{k+\\frac n2}=-\\omega_n^k$\n\n> $\\omega _{n}^{\\frac{n}{2}}=\\cos\\frac{n}{2}\\cdot\\frac{2\\pi}{n}+i\\sin\\frac{n}{2}\\cdot\\frac{2\\pi}{n}=-1$\n> (也就是上面说的$e^{i\\pi}$)\n\n\n\n正题开始: \n\n## DFT \n\n将多项式从系数表示法转换为点值表示法\n\n如果暴力代入$n$个点,复杂度还是$\\mathcal{O(n^2)}$的\n\n我们可以利用单位根的性质\n\n假设设$n$为偶数\n\n对于$A(x)=a_0+a_1x+a_2x^2+a_3x^3+\\dots+a_{n-1}x^{n-1}$\n\n$A(x)=(a_0+a_2x^2+a_4x^4+\\dots+a_{n-2}x^{n-2})+x(a_1+a_3x^2+a_5x^4+...+a_{n-1}x^{n-1})$\n\n设$A_1(x)=a_0+a_2x+a_4x^2+\\dots+a_{n-2}x^\\frac{n-2}2,A_2(x)=a_1+a_3x+a_5x^2+...+a_{n-1}x^\\frac{n-2}2$\n\n那么$A(x)=A_1(x^2)+xA_2(x^2)$\n\n设$0 \\le k \\le \\frac{n}{2}-1,k\\in Z$\n\n$A(\\omega_n^k)=A_1(\\omega_\\frac n2 ^k)+\\omega_n^k\\cdot A_2(\\omega_\\frac n2 ^k)$\n\n对于$\\frac n2 \\le k+\\frac n2 \\le n-1$\n\n$A(\\omega_n^{k+\\frac n2})=A_1(\\omega_n^{2k+n})+\\omega_n^{k+\\frac n2}\\cdot A_2(\\omega_n^{2k+n})$\n\n$\\because \\omega_n^{k+\\frac n2}=-\\omega_n^k,\\omega_n^{2k+n}=\\omega_\\frac n2^k$\n\n$\\therefore A(\\omega_n^{k+\\frac n2})=A_1(\\omega_\\frac n2^k)-\\omega_n^k\\cdot A_2(\\omega_\\frac n2^k)$\n\n如果已经知道$A_1,A_2$分别在$\\omega_\\frac n2 ^{0,1,2,...,\\frac n2 -1}$的取值,那么就可以在$\\mathcal{O(n)}$的时间内计算出$A(x)$,而$A_1(x),A_2(x)$的规模都是$A(x)$的一半\n\n复杂度$\\mathcal{T(n)=2T(\\frac n2)+O(n) = O(n \\log n)}$\n\n## IDFT\n\n使用快速傅里叶变换将点值表示的多项式转化为系数表示,这个过程叫做离散傅里叶逆变换\n\n即由$n$维点值向量$(A(x_0),A(x_1),\\dots,A(x_{n-1}))$推出$n$维系数向量$(a_0,a_1,\\dots,a_{n-1})$。\n\n设$y_0,y_1,y_2,...,y_{n-1}$是多项式$A(x)$变换后的点值\n\n设$(d_0,d_1,\\dots,d_{n-1})$为$(a_0,a_1,\\dots,a_{n-1})$离散傅里叶变换后的结果\n\n构造$F(x)=d_0+d_1x+d_2x^2+\\dots+d_{n-1}x^{n-1}$\n\n设向量$(c_0,c_1,\\dots,c_{n-1})$中\n\n$c_k$为$F(x)$在$x=\\omega_n^{-k}$时的点值表示\n\n$$\n\nc_k=\\sum_{i=0}^{n-1}d_i\\cdot(\\omega_n^{-k})^i\n\\\\\n=\\sum_{i=0}^{n-1}[\\sum_{j=0}^{n-1}a_j(\\omega_n^i)^j]\\cdot(\\omega_n^{-k})^i\n\\\\\n=\\sum_{j=0}^{n-1}a_j\\sum_{i=0}^{n-1}(\\omega_n^i)^j\\cdot(\\omega_n^{-k})^i\n\\\\\n=\\sum_{j=0}^{n-1}a_j\\sum_{i=0}^{n-1}(\\omega_n^i)^{j-k}\n$$\n\n观察$\\sum_{i=0}^{n-1}(\\omega_n^i)^{j-k}$\n\n当$j=k$时$\\sum_{i=0}^{n-1}(\\omega_n^i)^{j-k}=\\sum_{i=0}^{n-1}1=n$\n\n当$j\\not = k$时\n\n$\\sum_{i=0}^{n-1}(\\omega_n^i)^{j-k}=$\n\n$\\sum_{i=0}^{\\frac{n-1}2}(\\omega_n^i)^{j-k}+(\\omega_n^{i+\\frac{n-1}2})^{j-k}=0$\n\n也就是$n$次单位根会互相抵消\n\n$\\therefore \\sum_{i=0}^{n-1}(\\omega_n^i)^{j-k}=[j=k]\\cdot n$\n\n$\\therefore c_k=\\sum_{j=0}^{n-1}a_j\\sum_{i=0}^{n-1}(\\omega_n^i)^{j-k}=\\sum_{j=0}^{n-1}a_j [j=k]\\cdot n=na_k$\n\n$\\therefore a_k=\\frac{c_k}n$\n\n那么我们要将点值表示的多项式转化为系数表示:\n\n1. 将$(\\omega_n^0,\\omega_n^{-1},\\omega_n^{-2},\\dots,w_n^{-(n-1)})$作为差值节点,将点值再做一次DFT\n   \n   得到$(c_0,c_1,c_2,\\dots,c_{n-1})$\n\n2. $(\\frac{c_0}n,\\frac{c_1}n,\\frac{c_2}n,\\dots,\\frac{c_{n-1}}n)$就是原来的$(a_0,a_1,a_2,\\dots,a_{n-1})$\n\n\n\n到这里我们就已经大致懂得FFT的原理了,那要怎么实现呢?\n\n## 实现\n\n[LG 3803 【模板】多项式乘法（FFT）](https:\/\/www.luogu.com.cn\/problem\/P3803)\n\n### 普通的递归写法\n\n~~Fst_Fst_**TLE**~~\n\n不断对下标进行奇偶分类,分成两个子序列之后再不断合并\n\n需要辅助数组,容易**TLE,MLE**\n\n### 迭代实现\n\n![](https:\/\/pic1.zhimg.com\/80\/v2-953d1cd6c91a84197775d504defe302c_hd.jpg)\n\n可以发现在不断进行奇偶分类之后,原数在数组中的位置下标最终变成了**下标的二进制反转**\n\n我们可以直接通过枚举来代替递归\n\n从最底层开始向上合并,那么怎么合并呢？\n\n#### 蝴蝶操作\n\n设该层一共有$n$项需要处理\n\n设$A_1(\\omega_{\\frac n2}^k)$和$A_2(\\omega_{\\frac n2}^k)$分别存放在$a_k$和$a_{k+\\frac n2}$\n\n$A_1(\\omega_n^k)$和$A_2(\\omega_n^k)$要存放在$buf(k)$和$buf(k+\\frac n2)$\n\n我们只需设中间变量$t=\\omega_n^k\\cdot a(k+\\frac n2)$\n\n$buf(k+\\frac n2)= a(k) - t$\n\n$buf(k) = a(k)+t$\n\n我们可以发现我们不需要辅助存放的数组$buf$了,直接在原序列操作即可\n\n代码: \n\n```cpp\n#include<bits\/stdc++.h>\n#define db double\n#define For(i,x,y) for(int i=x;i<=y;++i)\nconst int N=4000011;\nconst db Pi=acos(-1.0);\nint n,m,limit=1,l=0,r[N];\nstruct cp{db r,i;cp(db R=0,db I=0){r=R,i=I;}}a[N],b[N];\ncp operator + (cp a,cp b){return cp(a.r+b.r,a.i+b.i);}\ncp operator - (cp a,cp b){return cp(a.r-b.r,a.i-b.i);}\ncp operator * (cp a,cp b){return cp(a.r*b.r-a.i*b.i,a.r*b.i+a.i*b.r);}\nvoid fft(cp *A,int typ){\n    For(i,0,limit-1)\n        if(i<r[i])std::swap(A[i],A[r[i]]);\n    for(int len=1;len<limit;len<<=1){\/\/已处理好的长度块,也就是n\/2\n        cp Wn(cos(Pi\/len),typ*sin(Pi\/len));\/\/单位根\n        for(int i=0;i<limit;i+=(len<<1)){\n            cp w(1,0);\/\/w_n^0\n            For(k,0,len-1){\/\/蝴蝶操作\n                cp t=w*A[i+k+len];\n                A[i+k+len]=A[i+k]-t;\n                A[i+k]=A[i+k]+t;\n                w=w*Wn;\n            }\n        }\n    }\n}\nint main(){\n    scanf(\"%d%d\",&n,&m);\n    For(i,0,n)scanf(\"%lf\",&a[i].r);\n    For(i,0,m)scanf(\"%lf\",&b[i].r);\n    \n    while(limit<=n+m)limit<<=1,++l;\n    For(i,0,limit-1)\/\/预处理出不断奇偶分类后的最终位置\n        r[i]=(r[i>>1]>>1)|((i&1)<<(l-1));\n\n    fft(a,1);fft(b,1);\/\/DFT\n    For(i,0,limit)a[i]=a[i]*b[i];\/\/点值相乘\n    fft(a,-1);\/\/IDFT\n    For(i,0,n+m)printf(\"%d \",int(a[i].r\/limit+0.5));\n}\n```\n\n\n\n本文部分内容摘自:(参考资料)\n\nhttps:\/\/zhuanlan.zhihu.com\/p\/31584464\n\nhttps:\/\/www.cnblogs.com\/zwfymqz\/p\/8244902.html\n```cpp\n#include<bits\/stdc++.h>\n#define db double\n#define For(i,x,y) for(int i=x;i<=y;++i)\nconst int N=4000011;\nconst db Pi=acos(-1.0);\nint n,m,limit=1,l=0,r[N];\nstruct cp{db r,i;cp(db R=0,db I=0){r=R,i=I;}}a[N],b[N];\ncp operator + (cp a,cp b){return cp(a.r+b.r,a.i+b.i);}\ncp operator - (cp a,cp b){return cp(a.r-b.r,a.i-b.i);}\ncp operator * (cp a,cp b){return cp(a.r*b.r-a.i*b.i,a.r*b.i+a.i*b.r);}\nvoid fft(cp *A,int typ){\n    For(i,0,limit-1)\n        if(i<r[i])std::swap(A[i],A[r[i]]);\n    for(int len=1;len<limit;len<<=1){\n        cp Wn(cos(Pi\/len),typ*sin(Pi\/len));\n        for(int i=0;i<limit;i+=(len<<1)){\n            cp w(1,0);\n            For(k,0,len-1){\n                cp t=w*A[i+k+len];\n                A[i+k+len]=A[i+k]-t;\n                A[i+k]=A[i+k]+t;\n                w=w*Wn;\n            }\n        }\n    }\n}\nint main(){\n    scanf(\"%d%d\",&n,&m);\n    For(i,0,n)scanf(\"%lf\",&a[i].r);\n    For(i,0,m)scanf(\"%lf\",&b[i].r);\n    \n    while(limit<=n+m)limit<<=1,++l;\n    For(i,0,limit-1)\n        r[i]=(r[i>>1]>>1)|((i&1)<<(l-1));\n\n    fft(a,1);fft(b,1);\n    For(i,0,limit)a[i]=a[i]*b[i];\n    fft(a,-1);\n    For(i,0,n+m)printf(\"%d \",int(a[i].r\/limit+0.5));\n}\n```\n","link":null,"tags":["模板","数论","多项式","fft"],"title":"LG 3803 【模板】多项式乘法（FFT）"},{"categories":[["刷题记录"]],"content":"\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?__=1,EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\nconst int N=1000011;\nint n,cnt=0,head[N];\nchar ch[N];\nstruct edge{int to,nxt;}e[N*26];\nil void add(int x,int y){e[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;}\nint tot=1,tr[N][26],f[N],ed[N],q[N*26],fail[N],val[N];\nvoid bld(){\n    int h=0,t=0,x;\n    Fur(i,0,25)\n    if(tr[1][i])fail[tr[1][i]]=1,q[t++]=tr[1][i];\n    else tr[1][i]=1;\n    while(h<t){\n        x=q[h++];\n        Fur(i,0,25)\n        if(tr[x][i])fail[tr[x][i]]=tr[fail[x]][i],q[t++]=tr[x][i];\n        else tr[x][i]=tr[fail[x]][i];\n    }\n    Fdr(i,t,1)val[fail[q[i]]]+=val[q[i]];\n}\nint main(){\n    in(n);\n    Fur(i,1,n){\n        in(ch);\n        int p=1,len=strlen(ch);\n        Fur(j,0,len-1){\n            char c=ch[j]-'a';\n            if(!tr[p][c])f[tr[p][c]=++tot]=p;\n            p=tr[p][c];\n            ++val[p];\n        }\n        ed[i]=p;\n    }\n    bld();\n    Fur(i,1,n)out(val[ed[i]],ln);\n    flush();\n}\n```\n","link":null,"tags":["AC自动机"],"title":"LG 3966 [TJOI2013]单词"},{"categories":[["刷题记录"]],"content":"\nAC自动机建完fail树之后子树的siz就是里面相同字符串的个数\n\n每个询问可以拆成$r$的前缀和-$l$的前缀和\n\n然后离线处理后用树状数组维护就可以了\n\n主席树在线也可以\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\nconst int N=200011,M=500011;\nint n,m,cnt=0,head[N],k[M],ans[M];\nchar ch[N];\nstruct edge{int to,nxt;}e[N*26];\nil void add(int x,int y){e[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;}\nint tot=1,tr[N][26],ed[N],f[N],fail[N],q[N*26];\nil void build(){\n    int h=0,t=0,x;\n    Fur(i,0,25)\n    if(tr[1][i])fail[tr[1][i]]=1,q[t++]=tr[1][i];\n    else tr[1][i]=1;\n\n    while(h<t){\n        x=q[h++];\n        Fur(i,0,25)\n        if(tr[x][i])fail[tr[x][i]]=tr[fail[x]][i],q[t++]=tr[x][i];\n        else tr[x][i]=tr[fail[x]][i];\n    }\n}\nint id[N],sz=0,siz[N];\nvoid dfs(int x){\n    id[x]=++sz;siz[x]=1;\n    fl(i,x)dfs(to),siz[x]+=siz[to];\n}\nint s[N];\nil void upd(int x){for(int i=x;i<=tot;i+=i&-i)++s[i];}\nil int ask(int x){int t=0;for(int i=x;i;i-=i&-i)t+=s[i];return t;}\nint main(){\n    in(n,m);\n    Fur(i,1,n){\n        in(ch);\n        int p=1,len=strlen(ch),c;\n        Fur(j,0,len-1){\n            c=ch[j]-'a';\n            if(!tr[p][c])f[tr[p][c]=++tot]=p;\n            p=tr[p][c];\n        }\n        ed[i]=p;\n    }\n\n    build();\n    Fur(i,2,tot)add(fail[i],i);\n    dfs(1);\n\n    clr(head,0);cnt=0;\n    int l,r,x;\n    Fur(i,1,m){\n        in(l,r,k[i]);\n        if(l>1)add(l-1,-i);\n        add(r,i);\n    }\n    Fur(i,1,n){\n        for(x=ed[i];x!=1;x=f[x])upd(id[x]);\n        fl(j,i){\n            int v=to>0?1:-1;\n            to*=v;x=ed[k[to]];\n            ans[to]+=v*(ask(id[x]+siz[x]-1)-ask(id[x]-1));\n        }\n    }\n    Fur(i,1,m)out(ans[i],ln);\n    flush();\n}\n```\n","link":null,"tags":["AC自动机","离线","树状数组","主席树"],"title":"LG CF547E Mike-and-Friends"},{"categories":[["刷题记录"]],"content":"\n```cpp\n#include<bits\/stdc++.h>\nusing namespace std;\n#define FOR(i,x,y) for(int i=x;i<=y;++i)\nint n;\ndouble a[111][111],eps=1e-8;\nbool cmp(int k,int x,int y){\n    if(abs(abs(a[x][k])-abs(a[y][k]))>eps)return abs(a[x][k])>abs(a[y][k]);\n    FOR(i,k+1,n)if(abs(abs(a[x][i])-abs(a[y][i]))>eps)return abs(a[x][i])>abs(a[y][i]);\n    return 0;\n}\nint main(){\n    scanf(\"%d\",&n);\n    FOR(i,1,n)FOR(j,1,n+1)scanf(\"%lf\",&a[i][j]);\n    int p=1;\n    FOR(i,1,n){\n        int mx=p;\n        FOR(j,p+1,n)if(abs(a[j][i])>abs(a[mx][i]))mx=j;\n        if(!a[mx][i])continue;\n        std::swap(a[p],a[mx]);\n        FOR(j,1,n)if(j!=p){\n            double t=a[j][i]\/a[i][i];\n            FOR(k,i+1,n+1)\n                a[j][k]-=a[i][k]*t;\n        }\n    }\n    FOR(i,1,n)if(abs(a[i][i])<eps){\n        if(abs(a[i][n+1])<eps)return printf(\"0\\n\"),0;\n        else return printf(\"-1\\n\"),0;\n    }\n    FOR(i,1,n){\n        printf(\"x%d=\",i);\n        double t=a[i][n+1]\/a[i][i];\n        if(abs(t)<eps)printf(\"0\\n\");\n        else printf(\"%.2f\\n\",t);\n    }\n}\n```\n","link":null,"tags":[],"title":"LG 2455 [SDOI2006]线性方程组"},{"categories":[["刷题记录"]],"content":"\n```cpp\n#include<bits\/stdc++.h>\n#define FOR(i,x,y) for(int i=x;i<=y;++i)\nint n;\ndouble a[111][111];\nint main(){\n    scanf(\"%d\",&n);\n    FOR(i,1,n)FOR(j,1,n+1)scanf(\"%lf\",&a[i][j]);\n    FOR(i,1,n){\n        int mx=i;\n        FOR(j,i+1,n)if(abs(a[j][i])>abs(a[mx][i]))mx=j;\n        if(!a[mx][i])return printf(\"No Solution\\n\"),0;\n        std::swap(a[i],a[mx]);\n        FOR(j,1,n)if(j!=i){\n            double t=a[j][i]\/a[i][i];\n            FOR(k,i+1,n+1)\n                a[j][k]-=a[i][k]*t;\n        }\n    }\n    FOR(i,1,n)printf(\"%.2f\\n\",a[i][n+1]\/a[i][i]);\n}\n```\n","link":null,"tags":["模板","高斯消元"],"title":"LG 3389 【模板】高斯消元法"},{"categories":[["刷题记录"]],"content":"\n可以发现按dfs序排序后路径是$a_1,a_2,a_3,...,a_k,a_1$\n\n那答案就是$dist(a_1,a_2)+dist(a_2,a_3)+...+dist(a_k,a_1)$\n\n设现在要插入$x$,$y,z$是$x$的前驱后继(dfs序上)\n\n那么$ans+=dist(y,x)+dist(x,z)$,$ans-=dist(y,z)$\n\n删去$x$同理\n\n\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?__=1,EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\nconst int N=200011;\nint n,cnt=0,q,head[N],b[N];\nstruct edge{\n    int to,nxt,w;\n}e[N<<1];\nil void add(int x,int y,int w){e[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;e[cnt].w=w;}\nint d[N],dfn[N],sz=0,siz[N],top[N],f[N];\nll dep[N];\nvoid dfs(int x){\n    b[dfn[x]=++sz]=x;\n    siz[x]=1;\n    fl(i,x)if(to!=f[x]){\n        dep[to]=dep[x]+e[i].w;\n        d[to]=d[x]+1;\n        f[to]=x;\n        dfs(to);\n        siz[x]+=siz[to];\n    }\n}\nvoid bt(int x,int tp){\n    top[x]=tp;int k=0;\n    fl(i,x)if(to!=f[x]&&siz[to]>siz[k])k=to;\n    if(k)bt(k,tp);\n    fl(i,x)if(!top[to])bt(to,to);\n}\nil ll gd(int x,int y){\n    int ox=x,oy=y;\n    while(top[x]!=top[y])\n        d[top[x]]>d[top[y]]?x=f[top[x]]:y=f[top[y]];\n    return dep[ox]+dep[oy]-2ll*dep[d[x]<d[y]?x:y];\n}\nbool v[N];\nset<int>T;\nil int pre(int x){\n    set<int>::iterator p=T.lower_bound(dfn[x]);\n    if(p==T.begin())p=T.end();\n    return b[*(--p)];\n}\nil int nxt(int x){\n    set<int>::iterator p=T.upper_bound(dfn[x]);\n    if(p==T.end())p=T.begin();\n    return b[*p];\n}\nint main(){\n    in(n,q);\n    int x,y,z,w;\n    ll s=0;\n    Fur(i,1,n-1)in(x,y,w),add(x,y,w),add(y,x,w);\n    dfs(1);bt(1,1);\n    while(q--){\n        in(x);\n        if(v[x]){\n            if(T.size()>1)\n                y=pre(x),z=nxt(x),\n                s+=gd(y,z),\n                s-=gd(x,y)+gd(x,z);\n            T.erase(dfn[x]);\n        }\n        else{\n            T.insert(dfn[x]);\n            if(T.size()>1)\n                y=pre(x),z=nxt(x),\n                s-=gd(y,z),\n                s+=gd(x,y)+gd(x,z);\n        }\n        v[x]^=1;\n        out(s,ln);\n    }\n    flush();\n}\n```\n","link":null,"tags":["虚树","lca","set"],"title":"LG 3320 [SDOI2015]寻宝游戏"},{"categories":[["算法","数据结构"],["note"]],"content":"\n以[Dynamic Rankings](https:\/\/www.luogu.com.cn\/problem\/P2617)为例：\n\n如果不带修改,那就是普通的主席树\n\n待修改: 树状数组套动态开点权值线段树\n\n对于修改$a_p$,\n\n受影响的有$[p,n]$\n\n但是我们不需要从$p$修改到$n$\n\n可以套个树状数组记录修改位置\n\n树状数组的每个节点都是一颗线段树\n\n这样修改的时候就可以做到$\\Theta(n \\log^2 n)$\n\n","link":null,"tags":["数据结构","树","算法"],"title":"带修区间第k大"},{"categories":[["刷题记录"]],"content":"\n先来考虑普通的树型dp怎么做\n\n设$SZ_x$表示$x$的子树中有多少个查询点,$d_x$表示$x$的深度\n\n1. 这些新通道的代价和\n\n    考虑每条边要被统计多少次: \n\n    假设$y$是$x$的某个子节点,$x\\leftrightarrow y$会被统计$(k-SZ_y)\\times SZ_y$次,\n\n    (起点可以是$y$的子树中任一查询点,终点可以是$y$子树外的任一查询点,这样的话路径必然经过$x\\leftrightarrow y$)\n\n    那么贡献是$(d_y-d_x)\\times (k-SZ_y)\\times SZ_y$\n\n2. 这些新通道中代价最小\/大的是多少\n\n    有点类似树型dp求树的直径\n\n    $x$的子树中最长的路径是: 子树中深度最大的查询点的深度+子树中深度次大的查询点的深度(若$x$是查询点则包括$x\\leftrightarrow x$,深度为$0$)\n\n    最短路径和上面的求法类似\n\n套上虚树就可以解决这道题了\n\n如果不懂的话就看代码咯\n```cpp\n#include<bits\/stdc++.h>\n#pragma GCC optimize(3)\n#define il __inline__ __attribute__ ((always_inline))\ntypedef long long ll;\n#define ll long long\n#define rg register\n#define For(i,x,y) for(int i(x);i<=y;++i)\n#define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\nil int MAX(int x,int y){return x>y?x:y;}\nil int MIN(int x,int y){return x<y?x:y;}\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?__=1,EOF:*in_s++;}template<typename T>il void in(T &x){if(__)return;rg char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');}}using namespace IO;\nconst int N=1000011,inf=1000000007;\nint n,k,cnt=0,head[N];\nstruct edge{int to,nxt;}e[N<<1];\nil void add(int x,int y){e[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;}\nint siz[N],top[N],f[N],d[N],dfn[N],sz=0;\nvoid dfs(int x){\n    siz[x]=1;dfn[x]=++sz;\n    fl(i,x)if(to!=f[x]){\n        f[to]=x;\n        d[to]=d[x]+1;\n        dfs(to);\n        siz[x]+=siz[to];\n    }\n}\nvoid bt(int x,int tp){\n    top[x]=tp;int k=0;\n    fl(i,x)if(to!=f[x]&&siz[to]>siz[k])k=to;\n    if(k)bt(k,tp);\n    fl(i,x)if(!top[to])bt(to,to);\n}\nil int lca(int x,int y){\n    while(top[x]!=top[y])\n        d[top[x]]>d[top[y]]?x=f[top[x]]:y=f[top[y]];\n    return d[x]<d[y]?x:y;\n}\nint a[N],st[N],tp,SZ[N],mx_d[N],mi_d[N],a1,a2;\nll ans;\nbool v[N];\nil bool cmp(int x,int y){return dfn[x]<dfn[y];}\nvoid dp(int x){\n    if(v[x])SZ[x]=1,mx_d[x]=d[x],mi_d[x]=d[x];\n    else    SZ[x]=0,mx_d[x]=-inf,mi_d[x]=inf;\n    int p1=-inf,p2=-inf,q1=inf,q2=inf;\n    fl(i,x){\n        dp(to);\n\n        mx_d[x]=MAX(mx_d[x],mx_d[to]);\n        if(mx_d[to]>=p1)p2=p1,p1=mx_d[to];\n        else p2=MAX(p2,mx_d[to]);\n\n        mi_d[x]=MIN(mi_d[x],mi_d[to]);\n        if(mi_d[to]<=q1)q2=q1,q1=mi_d[to];\n        else q2=MIN(q2,mi_d[to]);\n\n        ans+=1ll*(k-SZ[to])*SZ[to]*(d[to]-d[x]);\n        SZ[x]+=SZ[to];\n    }\n    a1=MIN(a1,q1+q2-2*d[x]);\n    if(v[x])a1=MIN(a1,q1-d[x]);\n\n    a2=MAX(a2,p1+p2-2*d[x]);\n    if(v[x])a2=MAX(a2,p1-d[x]);\n    head[x]=0;\n}\nint main(){\n    in(n);\n    int q,x,y,t;\n    For(i,1,n-1)in(x),in(y),add(x,y),add(y,x);\n    d[1]=1;dfs(1);bt(1,1);\n    cnt=0;memset(head,0,sizeof head);\n    in(q);\n    while(q--){\n        in(k);\n        For(i,1,k)in(a[i]),v[a[i]]=1;\n        std::sort(a+1,a+k+1,cmp);\n        cnt=0;st[tp=1]=1;\n        For(i,1,k){\n            x=a[i];t=lca(x,st[tp]);\n            while(d[t]<d[st[tp]]){\n                if(d[t]>=d[st[tp-1]]){\n                    add(t,st[tp--]);\n                    if(t!=st[tp])st[++tp]=t;\n                    break;\n                }\n                add(st[tp-1],st[tp]),--tp;\n            }\n            if(st[tp]!=x)st[++tp]=x;\n        }\n        while(tp>1)add(st[tp-1],st[tp]),--tp;\n        ans=0;a1=inf,a2=0;\n        dp(1);\n        out(ans),pt(' '),out(a1),pt(' '),out(a2),pt('\\n');\n        For(i,1,k)v[a[i]]=0;\n    }\n    flush();\n}\n```\n","link":null,"tags":["虚树","lca","动态规划"],"title":"LG 4103 [HEOI2014]大工程"},{"categories":[["算法","树论"],["note"]],"content":"\n换根树链剖分\n\n[loj #139.树链剖分](https:\/\/loj.ac\/problem\/139)\n\n前置知识：树链剖分\n\n题意：树链加,子树加,需要支持换根,查询树链和,子树和\n\n树链加、查询树链和 与普通的树链剖分一样\n\n主要讲：\n\n需要支持换根,子树加,查询子树和\n\n设当前查询的点为$x$\n\n情况1: $x$就是根,直接输出整棵树的和\n\n情况2: 根在$x$子树内:\n\n找到根到$x$路径上的$x$的儿子\n\n```cpp\nint child(int rt,int x){\n    while(top[rt]!=top[x]){\n        rt=top[rt];\n        if(f[rt]==x)return rt;\/\/父亲是x,返回当前点\n        rt=f[rt];\n    }\n    return son[x];\/\/根在x所在的重链上\n}\n```\n\n把整棵树除$t$子树外的部分加上$val$即可\n\n> 举个例子\n> \n> <svg width=\"300px\" height=\"300px\" _=\"SVGRoot\"><g _=\"EditableGraph\"><g _=\"SVGGroup\"><g _=\"GraphEdge\"><path d=\"M 148.30985915492957 45.774647887323944 L 96.30985915492957 98.87323943661971\" fill=\"none\" stroke-width=\"2\" stroke=\"black\" _=\"SVGPath\"><\/path><path d=\"M 148.30985915492957 45.774647887323944 L 96.30985915492957 98.87323943661971\" opacity=\"0\" fill=\"none\" stroke-width=\"30\" stroke=\"black\" _=\"SVGPath\"><\/path><\/g><g _=\"GraphEdge\"><path d=\"M 148.30985915492957 45.774647887323944 L 226.30985915492957 98.87323943661971\" fill=\"none\" stroke-width=\"2\" stroke=\"black\" _=\"SVGPath\"><\/path><path d=\"M 148.30985915492957 45.774647887323944 L 226.30985915492957 98.87323943661971\" opacity=\"0\" fill=\"none\" stroke-width=\"30\" stroke=\"black\" _=\"SVGPath\"><\/path><\/g><g _=\"GraphEdge\"><path d=\"M 96.30985915492957 98.87323943661971 L 70.30985915492957 151.9718309859155\" fill=\"none\" stroke-width=\"2\" stroke=\"black\" _=\"SVGPath\"><\/path><path d=\"M 96.30985915492957 98.87323943661971 L 70.30985915492957 151.9718309859155\" opacity=\"0\" fill=\"none\" stroke-width=\"30\" stroke=\"black\" _=\"SVGPath\"><\/path><\/g><g _=\"GraphEdge\"><path d=\"M 96.30985915492957 98.87323943661971 L 148.3098591549295 151.9718309859155\" fill=\"none\" stroke-width=\"2\" stroke=\"black\" _=\"SVGPath\"><\/path><path d=\"M 96.30985915492957 98.87323943661971 L 148.3098591549295 151.9718309859155\" opacity=\"0\" fill=\"none\" stroke-width=\"30\" stroke=\"black\" _=\"SVGPath\"><\/path><\/g><g _=\"GraphEdge\"><path d=\"M 226.30985915492957 98.87323943661971 L 200.30985915492954 151.9718309859155\" fill=\"none\" stroke-width=\"2\" stroke=\"black\" _=\"SVGPath\"><\/path><path d=\"M 226.30985915492957 98.87323943661971 L 200.30985915492954 151.9718309859155\" opacity=\"0\" fill=\"none\" stroke-width=\"30\" stroke=\"black\" _=\"SVGPath\"><\/path><\/g><g _=\"GraphEdge\"><path d=\"M 226.30985915492957 98.87323943661971 L 252.30985915492957 151.9718309859155\" fill=\"none\" stroke-width=\"2\" stroke=\"black\" _=\"SVGPath\"><\/path><path d=\"M 226.30985915492957 98.87323943661971 L 252.30985915492957 151.9718309859155\" opacity=\"0\" fill=\"none\" stroke-width=\"30\" stroke=\"black\" _=\"SVGPath\"><\/path><\/g><g _=\"GraphEdge\"><path d=\"M 70.30985915492957 151.9718309859155 L 44.30985915492957 205.07042253521126\" fill=\"none\" stroke-width=\"2\" stroke=\"black\" _=\"SVGPath\"><\/path><path d=\"M 70.30985915492957 151.9718309859155 L 44.30985915492957 205.07042253521126\" opacity=\"0\" fill=\"none\" stroke-width=\"30\" stroke=\"black\" _=\"SVGPath\"><\/path><\/g><g _=\"GraphEdge\"><path d=\"M 70.30985915492957 151.9718309859155 L 96.30985915492955 205.07042253521126\" fill=\"none\" stroke-width=\"2\" stroke=\"black\" _=\"SVGPath\"><\/path><path d=\"M 70.30985915492957 151.9718309859155 L 96.30985915492955 205.07042253521126\" opacity=\"0\" fill=\"none\" stroke-width=\"30\" stroke=\"black\" _=\"SVGPath\"><\/path><\/g><\/g><g _=\"SVGGroup\"><g fixed=\"false\" style=\"cursor: pointer;\" _=\"GraphNode\"><circle stroke-width=\"5\" fill=\"white\" stroke=\"black\" r=\"19\" cx=\"148.30985915492957\" cy=\"45.774647887323944\" _=\"SVGCircle\"><\/circle><text font-size=\"14\" dy=\".35em\" text-anchor=\"middle\" stroke-width=\"1\" fill=\"black\" stroke=\"black\" x=\"148.30985915492957\" y=\"45.774647887323944\" style=\"user-select: none;\" _=\"SVGText\">1<\/text><\/g><g fixed=\"false\" style=\"cursor: pointer;\" _=\"GraphNode\"><circle stroke-width=\"5\" fill=\"white\" stroke=\"black\" r=\"19\" cx=\"96.30985915492957\" cy=\"98.87323943661971\" _=\"SVGCircle\"><\/circle><text font-size=\"14\" dy=\".35em\" text-anchor=\"middle\" stroke-width=\"1\" fill=\"black\" stroke=\"black\" x=\"96.30985915492957\" y=\"98.87323943661971\" style=\"user-select: none;\" _=\"SVGText\">2<\/text><\/g><g fixed=\"false\" style=\"cursor: pointer;\" _=\"GraphNode\"><circle stroke-width=\"5\" fill=\"white\" stroke=\"black\" r=\"19\" cx=\"226.30985915492957\" cy=\"98.87323943661971\" _=\"SVGCircle\"><\/circle><text font-size=\"14\" dy=\".35em\" text-anchor=\"middle\" stroke-width=\"1\" fill=\"black\" stroke=\"black\" x=\"226.30985915492957\" y=\"98.87323943661971\" style=\"user-select: none;\" _=\"SVGText\">3<\/text><\/g><g fixed=\"false\" _=\"GraphNode\" style=\"cursor: pointer;\"><circle stroke-width=\"5\" fill=\"white\" stroke=\"black\" r=\"19\" cx=\"70.30985915492957\" cy=\"151.9718309859155\" _=\"SVGCircle\"><\/circle><text font-size=\"14\" dy=\".35em\" text-anchor=\"middle\" stroke-width=\"1\" fill=\"black\" stroke=\"black\" x=\"70.30985915492957\" y=\"151.9718309859155\" _=\"SVGText\" style=\"user-select: none;\">4<\/text><\/g><g fixed=\"false\" _=\"GraphNode\" style=\"cursor: pointer;\"><circle stroke-width=\"5\" fill=\"white\" stroke=\"black\" r=\"19\" cx=\"148.3098591549295\" cy=\"151.9718309859155\" _=\"SVGCircle\"><\/circle><text font-size=\"14\" dy=\".35em\" text-anchor=\"middle\" stroke-width=\"1\" fill=\"black\" stroke=\"black\" x=\"148.3098591549295\" y=\"151.9718309859155\" _=\"SVGText\" style=\"user-select: none;\">5<\/text><\/g><g fixed=\"false\" _=\"GraphNode\" style=\"cursor: pointer;\"><circle stroke-width=\"5\" fill=\"white\" stroke=\"black\" r=\"19\" cx=\"200.30985915492954\" cy=\"151.9718309859155\" _=\"SVGCircle\"><\/circle><text font-size=\"14\" dy=\".35em\" text-anchor=\"middle\" stroke-width=\"1\" fill=\"black\" stroke=\"black\" x=\"200.30985915492954\" y=\"151.9718309859155\" _=\"SVGText\" style=\"user-select: none;\">6<\/text><\/g><g fixed=\"false\" _=\"GraphNode\" style=\"cursor: pointer;\"><circle stroke-width=\"5\" fill=\"white\" stroke=\"black\" r=\"19\" cx=\"252.30985915492957\" cy=\"151.9718309859155\" _=\"SVGCircle\"><\/circle><text font-size=\"14\" dy=\".35em\" text-anchor=\"middle\" stroke-width=\"1\" fill=\"black\" stroke=\"black\" x=\"252.30985915492957\" y=\"151.9718309859155\" _=\"SVGText\" style=\"user-select: none;\">7<\/text><\/g><g fixed=\"false\" _=\"GraphNode\" style=\"cursor: pointer;\"><circle stroke-width=\"5\" fill=\"white\" stroke=\"black\" r=\"19\" cx=\"44.30985915492957\" cy=\"205.07042253521126\" _=\"SVGCircle\"><\/circle><text font-size=\"14\" dy=\".35em\" text-anchor=\"middle\" stroke-width=\"1\" fill=\"black\" stroke=\"black\" x=\"44.30985915492957\" y=\"205.07042253521126\" style=\"user-select: none;\" _=\"SVGText\">8<\/text><\/g><g fixed=\"false\" _=\"GraphNode\" style=\"cursor: pointer;\"><circle stroke-width=\"5\" fill=\"white\" stroke=\"black\" r=\"19\" cx=\"96.30985915492955\" cy=\"205.07042253521126\" _=\"SVGCircle\"><\/circle><text font-size=\"14\" dy=\".35em\" text-anchor=\"middle\" stroke-width=\"1\" fill=\"black\" stroke=\"black\" x=\"96.30985915492955\" y=\"205.07042253521126\" style=\"user-select: none;\" _=\"SVGText\">9<\/text><\/g><\/g><\/g><\/svg>\n> \n> 建树时是以1为根\n> \n> 设当前根为9,x为2\n> \n> 找出的child是4\n> \n> <svg width=\"300px\" height=\"300px\" _=\"SVGRoot\"><g _=\"EditableGraph\"><g _=\"SVGGroup\"><g _=\"GraphEdge\"><path d=\"M261,153.39565279298176Q205.162355744426,154.5050546416901,149.32471148885205,155.6144564903984\" fill=\"none\" stroke-width=\"2\" stroke=\"black\" _=\"SVGPath\"><\/path><path d=\"M261,153.39565279298176Q205.162355744426,154.5050546416901,149.32471148885205,155.6144564903984\" opacity=\"0\" fill=\"none\" stroke-width=\"30\" stroke=\"black\" _=\"SVGPath\"><\/path><\/g><g _=\"GraphEdge\"><path d=\"M261,153.39565279298176Q206.91547342716183,207.19782639649088,152.83094685432368,261\" fill=\"none\" stroke-width=\"2\" stroke=\"black\" _=\"SVGPath\"><\/path><path d=\"M261,153.39565279298176Q206.91547342716183,207.19782639649088,152.83094685432368,261\" opacity=\"0\" fill=\"none\" stroke-width=\"30\" stroke=\"black\" _=\"SVGPath\"><\/path><\/g><g _=\"GraphEdge\"><path d=\"M149.32471148885205,155.6144564903984Q151.05132366814587,97.3072282451992,152.7779358474397,39\" fill=\"none\" stroke-width=\"2\" stroke=\"black\" _=\"SVGPath\"><\/path><path d=\"M149.32471148885205,155.6144564903984Q151.05132366814587,97.3072282451992,152.7779358474397,39\" opacity=\"0\" fill=\"none\" stroke-width=\"30\" stroke=\"black\" _=\"SVGPath\"><\/path><\/g><g _=\"GraphEdge\"><path d=\"M 149.32471148885205 155.6144564903984 L 39 148.97409692923225\" fill=\"none\" stroke-width=\"2\" stroke=\"black\" _=\"SVGPath\"><\/path><path d=\"M 149.32471148885205 155.6144564903984 L 39 148.97409692923225\" opacity=\"0\" fill=\"none\" stroke-width=\"30\" stroke=\"black\" _=\"SVGPath\"><\/path><\/g><g _=\"GraphEdge\"><path d=\"M 152.7779358474397 39 L 260.3385416666667 39\" fill=\"none\" stroke-width=\"2\" stroke=\"black\" _=\"SVGPath\"><\/path><path d=\"M 152.7779358474397 39 L 260.3385416666667 39\" opacity=\"0\" fill=\"none\" stroke-width=\"30\" stroke=\"black\" _=\"SVGPath\"><\/path><\/g><g _=\"GraphEdge\"><path d=\"M152.7779358474397,39Q95.88896792371985,39,39,39\" fill=\"none\" stroke-width=\"2\" stroke=\"black\" _=\"SVGPath\"><\/path><path d=\"M152.7779358474397,39Q95.88896792371985,39,39,39\" opacity=\"0\" fill=\"none\" stroke-width=\"30\" stroke=\"black\" _=\"SVGPath\"><\/path><\/g><g _=\"GraphEdge\"><path d=\"M152.83094685432368,261Q95.91547342716184,261,39,261\" fill=\"none\" stroke-width=\"2\" stroke=\"black\" _=\"SVGPath\"><\/path><path d=\"M152.83094685432368,261Q95.91547342716184,261,39,261\" opacity=\"0\" fill=\"none\" stroke-width=\"30\" stroke=\"black\" _=\"SVGPath\"><\/path><\/g><g _=\"GraphEdge\"><path d=\"M 152.83094685432368 261 L 261 261\" fill=\"none\" stroke-width=\"2\" stroke=\"black\" _=\"SVGPath\"><\/path><path d=\"M 152.83094685432368 261 L 261 261\" opacity=\"0\" fill=\"none\" stroke-width=\"30\" stroke=\"black\" _=\"SVGPath\"><\/path><\/g><\/g><g _=\"SVGGroup\"><g fixed=\"false\" style=\"cursor: pointer;\" _=\"GraphNode\"><circle stroke-width=\"2\" fill=\"white\" stroke=\"black\" r=\"19\" cx=\"261\" cy=\"153.39565279298176\" _=\"SVGCircle\"><\/circle><text font-size=\"14\" dy=\".35em\" text-anchor=\"middle\" stroke-width=\"1\" fill=\"black\" stroke=\"black\" x=\"261\" y=\"153.39565279298176\" style=\"user-select: none;\" _=\"SVGText\">1<\/text><\/g><g fixed=\"false\" style=\"cursor: pointer;\" _=\"GraphNode\"><circle stroke-width=\"2\" fill=\"white\" stroke=\"black\" r=\"19\" cx=\"149.32471148885205\" cy=\"155.6144564903984\" _=\"SVGCircle\"><\/circle><text font-size=\"14\" dy=\".35em\" text-anchor=\"middle\" stroke-width=\"1\" fill=\"black\" stroke=\"black\" x=\"149.32471148885205\" y=\"155.6144564903984\" style=\"user-select: none;\" _=\"SVGText\">2<\/text><\/g><g fixed=\"false\" _=\"GraphNode\" style=\"cursor: pointer;\"><circle stroke-width=\"2\" fill=\"white\" stroke=\"black\" r=\"19\" cx=\"152.83094685432368\" cy=\"261\" _=\"SVGCircle\"><\/circle><text font-size=\"14\" dy=\".35em\" text-anchor=\"middle\" stroke-width=\"1\" fill=\"black\" stroke=\"black\" x=\"152.83094685432368\" y=\"261\" _=\"SVGText\" style=\"user-select: none;\">3<\/text><\/g><g fixed=\"false\" _=\"GraphNode\" style=\"cursor: pointer;\"><circle stroke-width=\"5\" fill=\"white\" stroke=\"black\" r=\"19\" cx=\"152.7779358474397\" cy=\"39\" _=\"SVGCircle\"><\/circle><text font-size=\"14\" dy=\".35em\" text-anchor=\"middle\" stroke-width=\"1\" fill=\"black\" stroke=\"black\" x=\"152.7779358474397\" y=\"39\" style=\"user-select: none;\" _=\"SVGText\">4<\/text><\/g><g fixed=\"false\" _=\"GraphNode\" style=\"cursor: pointer;\"><circle stroke-width=\"2\" fill=\"white\" stroke=\"black\" r=\"19\" cx=\"39\" cy=\"148.97409692923225\" _=\"SVGCircle\"><\/circle><text font-size=\"14\" dy=\".35em\" text-anchor=\"middle\" stroke-width=\"1\" fill=\"black\" stroke=\"black\" x=\"39\" y=\"148.97409692923225\" style=\"user-select: none;\" _=\"SVGText\">5<\/text><\/g><g fixed=\"false\" _=\"GraphNode\" style=\"cursor: pointer;\"><circle stroke-width=\"5\" fill=\"white\" stroke=\"black\" r=\"19\" cx=\"260.3385416666667\" cy=\"39\" _=\"SVGCircle\"><\/circle><text font-size=\"14\" dy=\".35em\" text-anchor=\"middle\" stroke-width=\"1\" fill=\"black\" stroke=\"black\" x=\"260.3385416666667\" y=\"39\" style=\"user-select: none;\" _=\"SVGText\">8<\/text><\/g><g fixed=\"false\" _=\"GraphNode\" style=\"cursor: pointer;\"><circle stroke-width=\"5\" fill=\"white\" stroke=\"black\" r=\"19\" cx=\"39\" cy=\"39\" _=\"SVGCircle\"><\/circle><text font-size=\"14\" dy=\".35em\" text-anchor=\"middle\" stroke-width=\"1\" fill=\"black\" stroke=\"black\" x=\"39\" y=\"39\" style=\"user-select: none;\" _=\"SVGText\">9<\/text><\/g><g fixed=\"false\" _=\"GraphNode\" style=\"cursor: pointer;\"><circle stroke-width=\"2\" fill=\"white\" stroke=\"black\" r=\"19\" cx=\"39\" cy=\"261\" _=\"SVGCircle\"><\/circle><text font-size=\"14\" dy=\".35em\" text-anchor=\"middle\" stroke-width=\"1\" fill=\"black\" stroke=\"black\" x=\"39\" y=\"261\" _=\"SVGText\" style=\"user-select: none;\">6<\/text><\/g><g fixed=\"false\" _=\"GraphNode\" style=\"cursor: pointer;\"><circle stroke-width=\"2\" fill=\"white\" stroke=\"black\" r=\"19\" cx=\"261\" cy=\"261\" _=\"SVGCircle\"><\/circle><text font-size=\"14\" dy=\".35em\" text-anchor=\"middle\" stroke-width=\"1\" fill=\"black\" stroke=\"black\" x=\"261\" y=\"261\" _=\"SVGText\" style=\"user-select: none;\">7<\/text><\/g><\/g><\/g><\/svg>\n\n情况3: 根不在$x$子树内: 与普通树链剖分一样\n\n线段树版:\n```cpp\n#include<bits\/stdc++.h>\nusing namespace std;\n#define ll long long\n#define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n#define N 100011\nint n,cnt=0,RT=1,head[N],c[N];\nstruct edge{\n    int to,nxt;\n}e[N];\nvoid add(int x,int y){\n    e[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;\n}\nint a[N];\nll s[N<<2],laz[N<<2];\n#define ls rt<<1\n#define rs rt<<1|1\n#define pu s[rt]=s[ls]+s[rs]\nvoid pd(int rt,int ln,int rn){\n    if(laz[rt]){\n        laz[ls]+=laz[rt];\n        laz[rs]+=laz[rt];\n        s[ls]+=ln*laz[rt];\n        s[rs]+=rn*laz[rt];\n        laz[rt]=0;\n    }\n}\nvoid build(int l,int r,int rt){\n    if(l==r){\n        s[rt]=a[l];\n        return;\n    }\n    int m=(l+r)>>1;\n    build(l,m,ls);build(m+1,r,rs);\n    pu;\n}\nvoid upd(int L,int R,int v,int l,int r,int rt){\n    if(L<=l&&r<=R){\n        s[rt]+=v*(r-l+1);\n        laz[rt]+=v;\n        return;\n    }\n    int m=(l+r)>>1;\n    pd(rt,m-l+1,r-m);\n    if(L<=m)upd(L,R,v,l,m,ls);\n    if(R>m)upd(L,R,v,m+1,r,rs);\n    pu;\n}\nll ask(int L,int R,int l,int r,int rt){\n    if(L<=l&&r<=R)return s[rt];\n    int m=(l+r)>>1;\n    ll ans=0;\n    pd(rt,m-l+1,r-m);\n    if(L<=m)ans=ask(L,R,l,m,ls);\n    if(R>m)ans+=ask(L,R,m+1,r,rs);\n    return ans;\n}\nint son[N],siz[N],top[N],id[N],f[N],d[N],sz=0;\nvoid dfs(int x){\n    siz[x]=1;\n    son[x]=0;\n    fl(i,x){\n        d[to]=d[x]+1;\n        dfs(to);\n        siz[x]+=siz[to];\n        if(siz[to]>siz[son[x]])son[x]=to;\n    }\n}\nvoid bt(int x,int tp){\n    top[x]=tp;id[x]=++sz;a[id[x]]=c[x];\n    if(!son[x])return;\n    bt(son[x],tp);\n    fl(i,x)if(!top[to])bt(to,to);\n}\nll fh(int x,int y){\n    ll ans=0;\n    while(top[x]!=top[y]){\n        if(d[top[x]]<d[top[y]])swap(x,y);\n        ans+=ask(id[top[x]],id[x],1,n,1);x=f[top[x]];\n    }\n    if(id[x]>id[y])swap(x,y);\n    return ans+ask(id[x],id[y],1,n,1);\n}\nvoid ul(int x,int y,int k){\n    while(top[x]!=top[y]){\n        if(d[top[x]]<d[top[y]])swap(x,y);\n        upd(id[top[x]],id[x],k,1,n,1);x=f[top[x]];\n    }\n    if(id[x]>id[y])swap(x,y);\n    upd(id[x],id[y],k,1,n,1);\n}\nint child(int x,int y){\n    while(top[x]!=top[y]){\n        x=top[x];\n        if(f[x]==y)return x;\n        x=f[x];\n    }\n    return son[y];\n}\nint main(){\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;++i)scanf(\"%d\",&c[i]);\n    int q,x,y,opt,k;\n    for(int i=2;i<=n;++i)\n        scanf(\"%d\",&f[i]),add(f[i],i);\n    dfs(1);bt(1,1);\n    build(1,n,1);\n    scanf(\"%d\",&q);\n    while(q--){\n        scanf(\"%d%d\",&opt,&x);\n        if(opt==1)RT=x;\n        if(opt==2)scanf(\"%d%d\",&y,&k),ul(x,y,k);\n        if(opt==3){\n            scanf(\"%d\",&k);\n            if(x==RT)upd(1,n,k,1,n,1);\n            else if(id[x]<=id[RT]&&id[RT]+siz[RT]<=id[x]+siz[x]){\n                int t=child(RT,x);\n                upd(1,n,k,1,n,1);\n                upd(id[t],id[t]+siz[t]-1,-k,1,n,1);\n            }\n            else upd(id[x],id[x]+siz[x]-1,k,1,n,1);\n        }\n        if(opt==4)scanf(\"%d\",&y),printf(\"%lld\\n\",fh(x,y));\n        if(opt==5){\n            if(x==RT)printf(\"%lld\\n\",s[1]);\n            else if(id[x]<=id[RT]&&id[RT]+siz[RT]<=id[x]+siz[x]){\n                int t=child(RT,x);\n                printf(\"%lld\\n\",s[1]-ask(id[t],id[t]+siz[t]-1,1,n,1));\n            }\n            else printf(\"%lld\\n\",ask(id[x],id[x]+siz[x]-1,1,n,1));\n        }\n    }\n}\n```\n\n树状数组版：\n```cpp\n#include<bits\/stdc++.h>\n#pragma GCC optimize(3)\n#pragma GCC optimize(Ofast)\n#define il inline\nil void SWAP(int &x,int &y){int t=x;x=y;y=t;}\nusing namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\n#define N 100011\n#define ll long long\n#define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\nint n,cnt=0,RT=1,head[N],c[N];\nstruct edge{\n    int to,nxt;\n}e[N];\nil void add(int x,int y){\n    e[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;\n}\nll s[N],S[N];\nil void upd(int x,int v){\n    if(x<=n)\n    for(int i=x;i<=n;i+=i&-i)\n        s[i]+=v,\n        S[i]+=1ll*v*(x-1);\n}\nil ll ask(int x){\n    ll ans=0;\n    for(int i=x;i;i-=i&-i)\n        ans+=1ll*x*s[i]-S[i];\n    return ans;\n}\nil void upd(int l,int r,int v){upd(l,v);upd(r+1,-v);}\nil ll ask(int l,int r){return ask(r)-ask(l-1);}\nint son[N],siz[N],top[N],id[N],f[N],d[N],sz=0;\nvoid dfs(int x){\n    siz[x]=1;\n    son[x]=0;\n    fl(i,x){\n        d[to]=d[x]+1;\n        dfs(to);\n        siz[x]+=siz[to];\n        if(siz[to]>siz[son[x]])son[x]=to;\n    }\n}\nvoid bt(int x,int tp){\n    top[x]=tp;id[x]=++sz;\n    if(!son[x])return;\n    bt(son[x],tp);\n    fl(i,x)if(!top[to])bt(to,to);\n}\nll fh(int x,int y){\n    ll ans=0;\n    while(top[x]!=top[y]){\n        if(d[top[x]]<d[top[y]])SWAP(x,y);\n        ans+=ask(id[top[x]],id[x]);x=f[top[x]];\n    }\n    if(id[x]>id[y])SWAP(x,y);\n    return ans+ask(id[x],id[y]);\n}\nvoid ul(int x,int y,int k){\n    while(top[x]!=top[y]){\n        if(d[top[x]]<d[top[y]])SWAP(x,y);\n        upd(id[top[x]],id[x],k);x=f[top[x]];\n    }\n    if(id[x]>id[y])SWAP(x,y);\n    upd(id[x],id[y],k);\n}\nil int child(int x,int y){\n    while(top[x]!=top[y]){\n        x=top[x];\n        if(f[x]==y)return x;\n        x=f[x];\n    }\n    return son[y];\n}\nint main(){\n    in(n);\n    for(int i=1;i<=n;++i)in(c[i]);\n    int q,x,y,opt,k;\n    for(int i=2;i<=n;++i)\n        in(f[i]),add(f[i],i);\n    dfs(1);bt(1,1);\n    for(int i=1;i<=n;++i)upd(id[i],id[i],c[i]);\n    in(q);\n    while(q--){\n        in(opt,x);\n        if(opt==1)RT=x;\n        if(opt==2)in(y,k),ul(x,y,k);\n        if(opt==3){\n            in(k);\n            if(x==RT)upd(1,n,k);\n            else if(id[x]<=id[RT]&&id[RT]+siz[RT]<=id[x]+siz[x]){\n                int t=child(RT,x);\n                upd(1,k);\n                upd(id[t],id[t]+siz[t]-1,-k);\n            }\n            else upd(id[x],id[x]+siz[x]-1,k);\n        }\n        if(opt==4)in(y),out(fh(x,y),ln);\n        if(opt==5){\n            if(x==RT)out(ask(n),ln);\n            else if(id[x]<=id[RT]&&id[RT]+siz[RT]<=id[x]+siz[x]){\n                int t=child(RT,x);\n                out(ask(n)-ask(id[t],id[t]+siz[t]-1),ln);\n            }\n            else out(ask(id[x],id[x]+siz[x]-1),ln);\n        }\n    }\n    flush();\n}\n```","link":null,"tags":["数据结构","树","技巧"],"title":"换根树链剖分"},{"categories":[["刷题记录"]],"content":"\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?__=1,EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\nconst int N=100011;\nint n,k=0,cnt=0,head[N];\nstruct edge{\n    int to,nxt;\n}e[N<<1];\nil void add(int x,int y){e[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;}\nint siz[N],f[N],d[N],dfn[N],sz=0,top[N];\nvoid dfs(int x){\n    siz[x]=1;\n    dfn[x]=++sz;\n    fl(i,x)if(to!=f[x]){\n        f[to]=x;\n        d[to]=d[x]+1;\n        dfs(to);\n        siz[x]+=siz[to];\n    }\n}\nvoid bt(int x,int tp){\n    top[x]=tp;int k=0;\n    fl(i,x)if(to!=f[x]&&siz[to]>siz[k])k=to;\n    if(k)bt(k,tp);\n    fl(i,x)if(!top[to])bt(to,to);\n}\nint lca(int x,int y){\n    while(top[x]!=top[y])\n        d[top[x]]>d[top[y]]?x=f[top[x]]:y=f[top[y]];\n    return d[x]<d[y]?x:y;\n}\nint a[N],st[N],tp,b[N];\nbool v[N];\nbool cmp(int x,int y){return dfn[x]<dfn[y];}\nint dp(int x){\n    int ans=0,sum=0;\n    fl(i,x)ans+=dp(to),sum+=b[to];\n    if(v[x])b[x]=1,ans+=sum;\n    else if(sum>1)b[x]=0,++ans;\n    else b[x]=sum;\n    head[x]=0;\n    return ans;\n}\nvoid solve(){\n    Fur(i,1,k)v[a[i]]=0;\n    int x,t,tp;\n    in(k);\n    Fur(i,1,k)in(a[i]),v[a[i]]=1;\n    Fur(i,1,k)if(v[f[a[i]]])return void(out(\"-1\\n\"));\n    sort(a+1,a+k+1,cmp);\n    st[tp=1]=1;cnt=0;\n    Fur(i,1,k){\n        x=a[i];t=lca(x,st[tp]);\n        while(d[t]<d[st[tp]]){\n            if(d[t]>=d[st[tp-1]]){\n                add(t,st[tp--]);\n                if(st[tp]!=t)st[++tp]=t;\n                break;\n            }\n            add(st[tp-1],st[tp]),--tp;\n        }\n        if(st[tp]!=x)st[++tp]=x;\n    }\n    while(tp>1)add(st[tp-1],st[tp]),--tp;\n    out(dp(1),ln);\n}\nint main(){\n    in(n);\n    int x,y,q;\n    Fur(i,1,n-1)in(x,y),add(x,y),add(y,x);\n    d[1]=1;dfs(1);bt(1,1);\n    cnt=0;clr(head,0);\n    in(q);\n    while(q--)solve();\n    flush();\n}\n```\n","link":null,"tags":["虚树","动态规划","lca"],"title":"LG CF613D Kingdom-and-its-Cities"},{"categories":[["刷题记录"]],"content":"\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?__=1,EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\nconst int N=100011;\nint n,cnt=0,head[N],d[N],siz[N],ans[N],a[N],f[N],top[N],dfn[N],sz=0;\nstruct edge{int to,nxt;}e[N<<1];\nil void add(int x,int y){e[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;}\nvoid dfs(int x){\n    siz[x]=1;\n    dfn[x]=++sz;\n    fl(i,x)if(to!=f[x]){\n        f[to]=x;\n        d[to]=d[x]+1;\n        dfs(to);\n        siz[x]+=siz[to];\n    }\n}\nvoid bt(int x,int tp){\n    top[x]=tp;int k=0;\n    fl(i,x)if(to!=f[x]&&siz[to]>siz[k])k=to;\n    if(k)bt(k,tp);\n    fl(i,x)if(!top[to])bt(to,to);\n}\nint lca(int x,int y){\n    while(top[x]!=top[y])\n        d[top[x]]>d[top[y]]?x=f[top[x]]:y=f[top[y]];\n    return d[x]<d[y]?x:y;\n}\nint st[N],tp;\nvoid ins(int x){\n    if(!tp)return void(st[++tp]=x);\n    int t=lca(x,st[tp]);\n    if(t==st[tp])return void(st[++tp]=x);\n    while(tp&&d[t]<d[st[tp-1]])add(st[tp-1],st[tp]),--tp;\n    if(d[t]<d[st[tp]])add(t,st[tp--]);\n    if(st[tp]!=t)st[++tp]=t;\n    st[++tp]=x;\n}\nvoid dp(int x){\n    ans[x]=siz[x];\n    fl(i,x){\n        dp(to);\n        ans[x]-=siz[to]+(d[x]-d[to]+1+(x>to))\/2;\n        ans[to]+=(d[x]-d[to]+1+(x>to))\/2;\n    }\n    head[x]=0;\n}\nbool cmp(int x,int y){return dfn[x]<dfn[y];}\nint main(){\n    in(n);\n    int k,x,y,q;\n    Fur(i,1,n-1)in(x,y),add(x,y),add(y,x);\n    dfs(1);bt(1,1);\n    clr(head,0);\n    in(q);\n    while(q--){\n        cnt=0;\n        in(k);\n        Fur(i,1,k)in(a[i]);\n        sort(a+1,a+k+1,cmp);\n        st[tp=0]=1;\n        Fur(i,1,k)if(a[i]!=1)ins(a[i]);\n        while(tp)add(st[tp-1],st[tp]),--tp;\n        dp(1);\n        Fur(i,1,k)out(ans[a[i]],\" \");out(ln);\n    }\n    flush();\n}\n```\n","link":null,"tags":["动态规划","虚树","lca"],"title":"LG 3233 [HNOI2014]世界树"},{"categories":[["刷题记录"]],"content":"\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define FL(i,x) for(int i(HEAD[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?__=1,EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\nconst int N=250011;\nint n,cnt=0,head[N],a[N],HEAD[N];\nstruct edge{int to,nxt,w;}e[N<<1];\nil void add(int x,int y,int w){e[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;e[cnt].w=w;}\nil void ADD(int x,int y){e[++cnt].to=y;e[cnt].nxt=HEAD[x];HEAD[x]=cnt;}\nint dfn[N],sz=0,d[N],siz[N],top[N],f[N];\nll mi[N];\nvoid dfs(int x){\n    dfn[x]=++sz;\n    siz[x]=1;\n    fl(i,x)if(!dfn[to])\n        f[to]=x,\n        d[to]=d[x]+1,\n        mi[to]=MIN(mi[x],1ll*e[i].w),\n        dfs(to),\n        siz[x]+=siz[to];\n}\nvoid bt(int x,int tp){\n    top[x]=tp;int k=0;\n    fl(i,x)if(to!=f[x]&&siz[to]>siz[k])k=to;\n    if(k)bt(k,tp);\n    fl(i,x)if(!top[to])bt(to,to);\n}\nint lca(int x,int y){\n    while(top[x]!=top[y])\n        d[top[x]]>d[top[y]]?x=f[top[x]]:y=f[top[y]];\n    return d[x]<d[y]?x:y;\n}\nbool cmp(int x,int y){return dfn[x]<dfn[y];}\nint st[N],tp;\nvoid ins(int x){\n    if(!tp)return void(st[++tp]=x);\n    int t=lca(x,st[tp]);\n    if(t==st[tp])return;\n    while(tp&&dfn[st[tp-1]]>=dfn[t])ADD(st[tp-1],st[tp]),--tp;\n    if(t!=st[tp])ADD(t,st[tp]),st[tp]=t;\n    st[++tp]=x;\n}\nll dp(int x){\n    if(!HEAD[x])return mi[x];\n    ll sum=0;\n    FL(i,x)sum+=dp(to);\n    HEAD[x]=0;\n    return MIN(sum,mi[x]);\n}\nint main(){\n    in(n);\n    int k,x,y,w,q;\n    Fur(i,1,n-1)in(x,y,w),add(x,y,w),add(y,x,w);\n    mi[1]=1ll<<62;\n    d[1]=1;\n    dfs(1);bt(1,1);\n    in(q);\n    while(q--){\n        cnt=0;\n        in(k);\n        Fur(i,1,k)in(a[i]);\n        sort(a+1,a+k+1,cmp);\n        st[tp=0]=1;\n        Fur(i,1,k)ins(a[i]);\n        while(tp)ADD(st[tp-1],st[tp]),--tp;\n        out(dp(1),ln);\n    }\n    flush();\n}\n```\n","link":null,"tags":["动态规划","虚树","lca"],"title":"LG 2495 [SDOI2011]消耗战"},{"categories":[["刷题记录"]],"content":"\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?__=1,EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\nconst int N=100011;\nint n,m,cnt=1,head[N],fa[N],f[N],g[N];\nstruct edge{\n    int to,nxt;\n}e[N<<2];\nil void add(int x,int y){e[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;}\nint dfn[N],sz=0;\nvoid dp(int x,int y){\n    int s=f[y],ss=0,t;\/\/s:不放,ss: 放\n    for(int i=fa[y];i!=x;i=fa[i])\n        t=MAX(s,ss),ss=s+g[i],s=t+f[i];\n    g[x]+=s;\n    s=ss=0;\n    for(int i=y;i!=x;i=fa[i])\n        t=MAX(s,ss),ss=s+g[i],s=t+f[i];\n    f[x]+=MAX(s,ss);\n}\nvoid dfs(int x){\n    dfn[x]=++sz;\n    fl(i,x)if(!dfn[to])fa[to]=x,dfs(to);\n    fl(i,x)if(x!=fa[to]&&dfn[to]>dfn[x])dp(x,to);\/\/找到环,dp\n}\nint main(){\n    in(n,m);\n    int x,y;\n    Fur(i,1,m)in(x,y),add(x,y),add(y,x);\n    Fur(i,1,n)in(g[i]);\n    dfs(1);\n    printf(\"%d\\n\",MAX(f[1],g[1]));\n}\n```\n","link":null,"tags":["仙人掌","动态规划","tarjan"],"title":"LG 4410 [HNOI2009]无归岛"},{"categories":[["刷题记录"]],"content":"\n所有环的$siz+1$的乘积,注意要高精度\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?__=1,EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\nconst int N=20011;\nvoid ext(){printf(\"0\\n\"),exit(0);}\nint n,m,cnt=1,head[N];\nint ans[N],len=0;\nstruct edge{\n    int to,nxt;\n}e[2000011];\nil void add(int x,int y){\n    e[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;\n    e[++cnt].to=x;e[cnt].nxt=head[y];head[y]=cnt;\n}\nint dfn[N],low[N],sz=0,fa[N];\nbool v[N];\nvoid solve(int x,int y){\n    int t=2;\n    for(int i=y;i!=x;i=fa[i]){\n        ++t;\n        if(v[i])ext();\n        v[i]=1;\n    }\n    Fur(i,0,len)ans[i]*=t;\n    Fur(i,0,len-1)if(ans[i]>9){\n        ans[i+1]+=ans[i]\/10;\n        ans[i]%=10;\n    }\n    while(ans[len]>9)\n        ans[len+1]+=ans[len]\/10,ans[len]%=10,++len;\n}\nvoid tarjan(int x,int la){\n    dfn[x]=low[x]=++sz;\n    fl(i,x)if(i!=la){\n        if(!dfn[to]){\n            fa[to]=x;\n            tarjan(to,i^1);\n            low[x]=MIN(low[x],low[to]);\n        }\n        else low[x]=MIN(low[x],dfn[to]);\n    }\n    fl(i,x)if(fa[to]!=x&&dfn[to]>dfn[x])solve(x,to);\n}\nil void init(){\n    in(n,m);\n    while(m--){\n        int t,x,y;in(t,x);\n        while(--t)in(y),add(x,y),x=y;\n    }\n}\nint main(){\n    init();\n    ans[0]=1;\n    tarjan(1,0);\n    if(sz!=n)ext();\n    Fdr(i,len,0)putchar(ans[i]+48);\n}\n```\n","link":null,"tags":["仙人掌","tarjan"],"title":"LG 4129 [SHOI2006]仙人掌"},{"categories":[["刷题记录"]],"content":"\n求仙人掌直径\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?__=1,EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\nconst int N=100011;\nint n,m,cnt=1,head[N],ans=0,f[N],d[N];\nstruct edge{\n    int to,nxt;\n}e[N<<1];\nil void add(int x,int y){\n    e[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;\n    e[++cnt].to=x;e[cnt].nxt=head[y];head[y]=cnt;\n}\nint dfn[N],low[N],sz=0,fa[N],a[N],q[N];\nvoid solve(int x,int y){\n    int all=d[y]-d[x]+1,j=all;\n    for(int i=y;i!=fa[x];i=fa[i])a[j--]=f[i];\n    Fur(i,1,all)a[i+all]=a[i];\n    int l=0,r=0;q[0]=1;\n    Fur(i,2,all*2){\n        while(l<=r&&i-q[l]>(all>>1))++l;\n        ans=MAX(ans,a[i]+a[q[l]]+i-q[l]);\n        while(l<=r&&a[q[r]]-q[r]<=a[i]-i)--r;\n        q[++r]=i;\n    }\n    Fur(i,2,all)f[x]=MAX(f[x],a[i]+MIN(i-1,all-i+1));\n}\nvoid tarjan(int x,int la){\n    dfn[x]=low[x]=++sz;\n    fl(i,x)if(i!=la){\n        if(!dfn[to]){\n            fa[to]=x;d[to]=d[x]+1;\n            tarjan(to,i^1);\n            low[x]=MIN(low[x],low[to]);\n            if(low[to]>dfn[x]){\n                ans=MAX(ans,f[x]+f[to]+1);\n                f[x]=MAX(f[x],f[to]+1);\n            }\n        }\n        else low[x]=MIN(low[x],dfn[to]);\n    }\n\n    fl(i,x)if(fa[to]!=x&&dfn[to]>dfn[x])solve(x,to);\n}\nil void init(){\n    in(n,m);\n    while(m--){\n        int t,x,y;in(t,x);\n        while(--t)in(y),add(x,y),x=y;\n    }\n}\nint main(){\n    init();\n    tarjan(1,0);\n    printf(\"%d\\n\",ans);\n}\n```\n","link":null,"tags":["仙人掌","tarjan","树的直径","dfs"],"title":"LG 4244 [SHOI2008]仙人掌图-II"},{"categories":[["刷题记录"]],"content":"\n建完广义圆方树后用树链剖分+线段树维护\n\n修改一个点的时候,考虑到要修改它所在的双连通分量中的点,我们可以在（它的父亲）方点建一个对顶堆来维护最小值\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define FL(i,x) for(int i(HEAD[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?__=1,EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\nconst int N=200011;\nint n,m,q,tot,cnt=0,head[N],HEAD[N],val[N];\nstruct node{\n    priority_queue<int,vector<int>,greater<int>>a,b;\n    il void push(int x){a.push(x);}\n    il void del(int x){b.push(x);}\n    il int top(){\n        while(!b.empty()&&a.top()==b.top())a.pop(),b.pop();\n        return a.top();\n    }\n}ne[N];\nstruct edge{int to,nxt;}e[N<<2];\nil void add(int x,int y){\n    e[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;\n    e[++cnt].to=x;e[cnt].nxt=head[y];head[y]=cnt;\n}\nil void ADD(int x,int y){\n    e[++cnt].to=y;e[cnt].nxt=HEAD[x];HEAD[x]=cnt;\n    e[++cnt].to=x;e[cnt].nxt=HEAD[y];HEAD[y]=cnt;\n}\nint dfn[N],low[N],sz=0,st[N],tp=0;\nvoid tarjan(int x,int fa){\n    dfn[x]=low[x]=++sz;st[++tp]=x;\n    fl(i,x)\n    if(!dfn[to]){\n        tarjan(to,x);\n        low[x]=MIN(low[x],low[to]);\n        if(low[to]>=dfn[x]){\n            ADD(++tot,x);\n            while(int k=st[tp--]){\n                ADD(tot,k);\n                if(k==to)break;\n            }\n        }\n    }\n    else if(to!=fa)low[x]=MIN(low[x],dfn[to]);\n}\nint s[N<<2],a[N];\n#define ls rt<<1\n#define rs rt<<1|1\n#define pu s[rt]=MIN(s[ls],s[rs])\nvoid build(int l,int r,int rt){\n    if(l==r)return void(s[rt]=a[l]);\n    int m=(l+r)>>1;\n    build(l,m,ls);build(m+1,r,rs);\n    pu;\n}\nvoid upd(int p,int v,int l=1,int r=tot,int rt=1){\n    if(l==r)return void(s[rt]=v);\n    int m=(l+r)>>1;\n    if(p<=m)upd(p,v,l,m,ls);\n    else upd(p,v,m+1,r,rs);\n    pu;\n}\nint ask(int L,int R,int l=1,int r=tot,int rt=1){\n    if(L<=l&&r<=R)return s[rt];\n    int m=(l+r)>>1;\n    return MIN(((L<=m)?ask(L,R,l,m,ls):inf),((R>m)?ask(L,R,m+1,r,rs):inf));\n}\nint siz[N],top[N],d[N],f[N],son[N],id[N],SZ=0;\nvoid dfs(int x){\n    siz[x]=1;\n    FL(i,x)if(to!=f[x]){\n        f[to]=x;\n        d[to]=d[x]+1;\n        dfs(to);\n        siz[x]+=siz[to];\n        if(siz[to]>siz[son[x]])son[x]=to;\n    }\n}\nvoid bt(int x,int tp){\n    top[x]=tp;id[x]=++SZ;a[id[x]]=val[x];\n    if(son[x])bt(son[x],tp);\n    FL(i,x)if(!top[to])bt(to,to);\n}\nint fm(int x,int y){\n    int ans=inf;\n    while(top[x]!=top[y]){\n        if(d[top[x]]<d[top[y]])SWAP(x,y);\n        ans=MIN(ans,ask(id[top[x]],id[x]));x=f[top[x]];\n    }\n    if(d[x]>d[y])SWAP(x,y);\n    if(x>n)ans=MIN(ans,val[f[x]]);\n    return MIN(ans,ask(id[x],id[y]));\n}\nint main(){\n    in(n,m,q);tot=n;\n    int x,y;\n    char ch;\n    Fur(i,1,n)in(val[i]);\n    Fur(i,1,m)in(x,y),add(x,y);\n    tarjan(1,0);\n    dfs(1);\n    Fur(i,1,n)if(f[i])\n        ne[f[i]].push(val[i]);\n    Fur(i,n+1,tot)val[i]=ne[i].top();\n    bt(1,1);\n    build(1,tot,1);\n    while(q--){\n        in(ch,x,y);\n        if(ch=='C'){\n            upd(id[x],y);\n            if(f[x]){\n                ne[f[x]].del(val[x]);\n                ne[f[x]].push(y);\n                if(val[f[x]]!=ne[f[x]].top())\n                    upd(id[f[x]],val[f[x]]=ne[f[x]].top());\n            }\n            val[x]=y;\n        }\n        else out(fm(x,y),ln);\n    }\n    flush();\n}\n```\n","link":null,"tags":["仙人掌","tarjan","树链剖分","线段树"],"title":"LG CF487E Tourists"},{"categories":[["刷题记录"]],"content":"\n```cpp\n#include<bits\/stdc++.h>\n#define il __inline__ __attribute__ ((always_inline))\n#define MB template <class T>il\n#define Fur(i,x,y) for(int i(x);i<=y;++i)\n#define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n#define FL(i,x) for(int i(HEAD[x]),to;to=e[i].to,i;i=e[i].nxt)\nMB T MAX(T x,T y){return x>y?x:y;}\nMB T MIN(T x,T y){return x<y?x:y;}\nusing namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?__=1,EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\nconst int N=1000011;\nint n,m,cnt=0,head[N],HEAD[N];\nstruct edge{int to,nxt;}e[N<<3];\nil void add(int x,int y){\n    e[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;\n    e[++cnt].to=x;e[cnt].nxt=head[y];head[y]=cnt;\n}\nil void ADD(int x,int y){\n    e[++cnt].to=y;e[cnt].nxt=HEAD[x];HEAD[x]=cnt;\n    e[++cnt].to=x;e[cnt].nxt=HEAD[y];HEAD[y]=cnt;\n}\nint dfn[N],low[N],sz=0,tot,st[N],tp=0;\nvoid tarjan(int x,int fa){\n    dfn[x]=low[x]=++sz;st[++tp]=x;\n    fl(i,x)\n    if(!dfn[to]){\n        tarjan(to,x);\n        low[x]=MIN(low[x],low[to]);\n        if(low[to]>=dfn[x]){\n            ADD(++tot,x);\n            while(int k=st[tp--]){\n                ADD(tot,k);\n                if(k==to)break;\n            }\n        }\n    }\n    else if(to!=fa)low[x]=MIN(low[x],dfn[to]);\n}\nint f[N],siz[N],d[N],top[N],son[N];\nvoid dfs(int x){\n    siz[x]=1;\n    FL(i,x)if(to!=f[x]){\n        f[to]=x;\n        d[to]=d[x]+1;\n        dfs(to);\n        siz[x]+=siz[to];\n        if(siz[to]>siz[son[x]])son[x]=to;\n    }\n}\nvoid bt(int x,int tp){\n    top[x]=tp;\n    if(son[x])bt(son[x],tp);\n    FL(i,x)if(!top[to])bt(to,to);\n}\nint lca(int x,int y){\n    while(top[x]!=top[y])\n        (d[top[x]]>d[top[y]])?x=f[top[x]]:y=f[top[y]];\n    return d[x]<d[y]?x:y;\n}\nint main(){\n    in(n,m);tot=n;\n    int x,y,q;\n    Fur(i,1,m)in(x,y),add(x,y);\n    tarjan(1,0);\n    d[1]=1;dfs(1);bt(1,1);\n    in(q);\n    while(q--){\n        in(x,y);\n        out((d[x]+d[y]-2*d[lca(x,y)])\/2+1,ln);\n    }\n    flush();\n}\n```\n","link":null,"tags":["tarjan","树链剖分","倍增","lca","圆方树"],"title":"LG 4320 道路相遇"},{"categories":[["刷题记录"]],"content":"\n根据仙人掌图构建圆方树\n\n若两个点的lca是原图的点,那么直接$d_x+d_y-2\\times d_{lca(x,y)}$\n\n否则就是两个点到环的距离加上两个点在环上的最短距离\n```cpp\n#include<cstdio>\n#pragma GCC optimize(3)\n#define il __inline__ __attribute__ ((always_inline))\n#define Fur(i,x,y) for(int i(x);i<=y;++i)\n#define Fdr(i,x,y) for(int i(x);i>=y;--i)\nil void swap(int &x,int &y){int t=x;x=y;y=t;}\nil int min(int x,int y){return x<y?x:y;}\nil int abs(int x){return x>0?x:-x;}\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?__=1,EOF:*in_s++;}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\nconst int N=20011;\nint n,m,q,cnt=0,head[N],HEAD[N];\nstruct edge{\n    int to,nxt,w;\n}e[N<<2];\n#define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n#define FL(i,x) for(int i(HEAD[x]),to;to=e[i].to,i;i=e[i].nxt)\nil void add(int x,int y,int w){\n    e[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;e[cnt].w=w;\n    e[++cnt].to=x;e[cnt].nxt=head[y];head[y]=cnt;e[cnt].w=w;\n}\nil void ADD(int x,int y,int w){\n    e[++cnt].to=y;e[cnt].nxt=HEAD[x];HEAD[x]=cnt;e[cnt].w=w;\n    e[++cnt].to=x;e[cnt].nxt=HEAD[y];HEAD[y]=cnt;e[cnt].w=w;\n}\nint dfn[N],low[N],sz=0,fa[N],tot,b[N],id[N];\nint s[N],dep[N];\nvoid solve(int x,int y,int w){\n    ++tot;\n    int t=w,tt=0;\n    for(int i=y;i!=fa[x];i=fa[i]){\n        s[i]=t;\n        t+=b[i];\n        id[i]=tt++;\n    }\n    s[tot]=s[x];s[x]=0;\n    for(int i=y;i!=fa[x];i=fa[i])\n        ADD(tot,i,min(s[i],s[tot]-s[i]));\n}\nvoid tarjan(int x){\n    dfn[x]=low[x]=++sz;\n    fl(i,x)if(to!=fa[x]){\n        if(!dfn[to]){\n            fa[to]=x;b[to]=e[i].w;\n            tarjan(to);\n            low[x]=min(low[x],low[to]);\n        }\n        else low[x]=min(low[x],dfn[to]);\n        if(low[to]>dfn[x])ADD(x,to,e[i].w);\n    }\n    fl(i,x)if(fa[to]!=x&&dfn[to]>dfn[x])\n        solve(x,to,e[i].w);\n}\nint f[16][N],d[N],A,B;\nvoid dfs(int x){\n    for(int j=1;(1<<j)<=d[x];++j)\n        f[j][x]=f[j-1][f[j-1][x]];\n    FL(i,x)if(to!=f[0][x]){\n        f[0][to]=x;\n        d[to]=d[x]+1;\n        dep[to]=dep[x]+e[i].w;\n        dfs(to);\n    }\n}\nint lca(int x,int y){\n    if(d[x]<d[y])swap(x,y);\n    int D=d[x]-d[y];\n    for(int i=0;(1<<i)<=D;++i)if(D&(1<<i))x=f[i][x];\n    if(x==y)return x;\n    Fdr(i,15,0)if((1<<i)<=d[x]&&f[i][x]!=f[i][y])\n        x=f[i][x],y=f[i][y];\n    A=x,B=y;\n    return f[0][x];\n}\nint main(){\n    in(n,m,q);tot=n;\n    int x,y,w;\n    Fur(i,1,m)in(x,y,w),add(x,y,w);\n    tarjan(1);\n    dfs(1);\n    while(q--){\n        in(x,y);\n        w=lca(x,y);\n        if(w<=n)out(dep[x]+dep[y]-2*dep[w],ln);\n        else out(dep[x]+dep[y]-dep[A]-dep[B]+min(s[w]-abs(s[B]-s[A]),abs(s[A]-s[B])),ln);\n    }\n    flush();\n}\n```\n","link":null,"tags":["仙人掌","lca","倍增","圆方树"],"title":"BZ 2125 最短路"},{"categories":[["算法","动态规划"],["算法","技巧"],["note"]],"content":"\n对于类似$f_i=\\min_{j=1}^{i-1}f_j+val(i,j)$的方程\n\n比如$val(i,j)=a_i\\times b_j$,同时包含了$i,j$两个变量,\n\n这样没法直接用单调队列\n\n如果把$val(i,j)$展开能转化成$\\frac{y_{j1}-y_{j2}}{x_{j1}-x_{j2}}\\le k_i$\n\n如果我们将每个决策点看成$(x_j,y_j)$分布在坐标系上,真正有用的决策点就会形成凸壳(可以使用 单调队列 or 数据结构 来维护)\n\n(其实斜率优化dp也叫凸壳优化dp)\n\n实现主要看例题\n\n关于上下凸壳：\n\n如果是$k_i\\le\\frac ab$的形式是下凸壳\n\n$k_i\\ge\\frac ab$否则是上凸壳\n\n## 例题\n\n[[HNOI2008]玩具装箱TOY](https:\/\/www.luogu.com.cn\/problem\/P3195)\n\n[[APIO2014]序列分割](https:\/\/www.luogu.com.cn\/problem\/P3648)\n\n[[APIO2010]特别行动队](https:\/\/www.luogu.com.cn\/problem\/P3628)\n\n[LG 2365 任务安排](https:\/\/www.luogu.com.cn\/problem\/P2365)\n\n[[SDOI2012]任务安排](https:\/\/www.luogu.com.cn\/problem\/P5785)(所得的直线的斜率不是单调的,需要凸壳二分)\n\n[[USACO08MAR]土地征用Land Acquisition](https:\/\/www.luogu.com.cn\/problem\/P2900)\n\n","link":null,"tags":["数论","算法","动态规划"],"title":"斜率优化"},{"categories":[["刷题记录"]],"content":"\n```cpp\n#include<cstdio>\n#pragma GCC optimize(3)\n#define il __inline__ __attribute__ ((always_inline))\n#define Fur(i,x,y) for(int i(x);i<=y;++i)\n#define Fdr(i,x,y) for(int i(x);i>=y;--i)\nil void swap(int &x,int &y){int t=x;x=y;y=t;}\nil int min(int x,int y){return x<y?x:y;}\nil int abs(int x){return x>0?x:-x;}\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?__=1,EOF:*in_s++;}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\nconst int N=20011;\nint n,m,q,cnt=0,head[N],HEAD[N];\nstruct edge{\n    int to,nxt,w;\n}e[N<<2];\n#define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n#define FL(i,x) for(int i(HEAD[x]),to;to=e[i].to,i;i=e[i].nxt)\nil void add(int x,int y,int w){\n    e[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;e[cnt].w=w;\n    e[++cnt].to=x;e[cnt].nxt=head[y];head[y]=cnt;e[cnt].w=w;\n}\nil void ADD(int x,int y,int w){\n    e[++cnt].to=y;e[cnt].nxt=HEAD[x];HEAD[x]=cnt;e[cnt].w=w;\n    e[++cnt].to=x;e[cnt].nxt=HEAD[y];HEAD[y]=cnt;e[cnt].w=w;\n}\nint dfn[N],low[N],sz=0,fa[N],tot,b[N],id[N],s[N];\nvoid solve(int x,int y,int w){\n    ++tot;\n    int t=w,tt=0;\n    for(int i=y;i!=fa[x];i=fa[i]){\n        s[i]=t;\n        t+=b[i];\n        id[i]=tt++;\n    }\n    s[tot]=s[x];s[x]=0;\n    for(int i=y;i!=fa[x];i=fa[i])\n        ADD(tot,i,min(s[i],s[tot]-s[i]));\n}\nvoid tarjan(int x){\n    dfn[x]=low[x]=++sz;\n    fl(i,x)if(to!=fa[x]){\n        if(!dfn[to]){\n            fa[to]=x;b[to]=e[i].w;\n            tarjan(to);\n            low[x]=min(low[x],low[to]);\n        }\n        else low[x]=min(low[x],dfn[to]);\n        if(low[to]>dfn[x])ADD(x,to,e[i].w);\n    }\n    fl(i,x)if(fa[to]!=x&&dfn[to]>dfn[x])\n        solve(x,to,e[i].w);\n}\nint f[N],d[N],dep[N],siz[N],top[N],A,B,st[N],ed[N],df=0;\nvoid dfs(int x){\n    st[x]=++df;\n    siz[x]=1;\n    FL(i,x)if(to!=f[x]){\n        f[to]=x;\n        d[to]=d[x]+1;\n        dep[to]=dep[x]+e[i].w;\n        dfs(to);\n        siz[x]+=siz[to];\n    }\n    ed[x]=df;\n}\nvoid bt(int x,int tp){\n    top[x]=tp;int k=0;\n    FL(i,x)if(to!=f[x]&&siz[to]>siz[k])k=to;\n    if(!k)return;bt(k,tp);\n    FL(i,x)if(!top[to])bt(to,to);\n}\nil int lca(int x,int y){\n    int ox=x,oy=y;\n    while(top[x]!=top[y]){\n        if(d[top[x]]<d[top[y]])swap(x,y);\n        x=f[top[x]];\n    }\n    if(d[x]>d[y])swap(x,y);\n    FL(i,x)if(to!=f[x]){\n        if(st[to]<=st[ox]&&ed[ox]<=ed[to])A=to;\n        if(st[to]<=st[oy]&&ed[oy]<=ed[to])B=to;\n    }\n    return x;\n}\nint main(){\n    in(n,m,q);tot=n;\n    int x,y,w;\n    Fur(i,1,m)in(x,y,w),add(x,y,w);\n    tarjan(1);\n    dfs(1);bt(1,1);\n    while(q--){\n        in(x,y);\n        w=lca(x,y);\n        if(w<=n)out(dep[x]+dep[y]-2*dep[w],ln);\n        else out(dep[x]+dep[y]-dep[A]-dep[B]+min(s[w]-abs(s[B]-s[A]),abs(s[A]-s[B])),ln);\n    }\n    flush();\n}\n```\n","link":null,"tags":["基环树","lca","仙人掌"],"title":"Acwing 360 Freda的传呼机"},{"categories":[["刷题记录"]],"content":"\n二分最大平均快乐值,判负环\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?__=1,EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\nconst int N=100011;\nint n,m,cnt=0,head[N],val[N];\nstruct edge{\n    int to,nxt,w;\n}e[N<<1];\nvoid add(int x,int y,int w){\n    e[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;e[cnt].w=w;\n}\nint main(){\n    in(n,m);\n    Fur(i,1,n)in(val[i]);\n    int x,y,w;\n    Fur(i,1,n)in(x,y,w),add(x,y,w),add(y,x,w);\n    \n}\n```\n","link":null,"tags":["分数规划","bfs"],"title":"LG 2868 [USACO07DEC]观光奶牛Sightseeing-Cows"},{"categories":[["刷题记录"]],"content":"\n将一个骑士与他最痛恨的人连边\n\n先考虑这个如果是树型dp：\n\n$f_x$表示不取$x$,$g_x$表示取$x$\n\n$$\nf_x=\\sum \\max(f_{to},g_{to})\n\\\\\ng_x=\\sum f_{to}\n$$\n\n我们可以用两次树型dp代替基环树dp\n\n第一次： 选择$x$,不选择$x$最痛恨的人\n\n第一次： 选择$x$最痛恨的人,不选择$x$\n\n\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?__=1,EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\nconst int N=1000011;\nint n,cnt=0,head[N],val[N],a[N],rt;\nll f[N],g[N];\nstruct edge{\n    int to,nxt;\n}e[N<<1];\nil void add(int x,int y){\n    e[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;\n}\nbool v[N];\nvoid dp(int x){\n    f[x]=0;g[x]=val[x];\n    v[x]=1;\n    fl(i,x)if(to!=rt){\n        dp(to);\n        f[x]+=max(f[to],g[to]);\n        g[x]+=f[to];\n    }\n    else g[to]=-inf;\n}\nint main(){\n    in(n);\n    Fur(i,1,n)in(val[i],a[i]),add(a[i],i);\n    ll ans=0,res;\n    Fur(i,1,n)if(!v[i]){\n        rt=i;\n        res=0;\n        while(!v[a[rt]]){\n            v[rt]=1;\n            rt=a[rt];\n        }\n        dp(rt);\/\/强制选i\n        res=MAX(f[rt],g[rt]);\n        rt=a[rt];\n        dp(rt);\/\/强制选a[i]\n        ans+=MAX(res,MAX(f[rt],g[rt]));\n    }\n    printf(\"%lld\\n\",ans);\n}\n```\n","link":null,"tags":["基环树","动态规划"],"title":"LG 2607 [ZJOI2008]骑士"},{"categories":[["刷题记录"]],"content":"\n两次dp解决代替基环树dp\n\n所有的$A_i\\rightarrow i$构成了一棵基环树\n\n我们先考虑如果基环树的子树怎么做\n\n也就是树型dp\n\n($f_x$表示不放,$g_x$表示放)\n\n若元素$i$不投放,\n\n$$f_x=\\sum_{A_y=x}\\max(f_y,g_y)$$\n\n否则必须至少有一个元素限制$i$,不能投放\n\n$$g_x=\\max_{A_y=x}\\{f_y+\\sum_{A_z=x,z\\not = y}\\max(f_z,g_z)\\}$$\n\n找到环上的一个点,将它和它限制的那个点断开,先后进行两次树形dp,\n\n第一次是假设环上的这个点对其限制的点不起限制作用\n\n另外一次是强制环上那个点已经限制了其可以限制的点（也就是环上那个点不选）\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?__=1,EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\nconst int N=1000011;\nint n,cnt=0,head[N],A[N],f[N],g[N],RT;\nstruct edge{\n    int to,nxt;\n}e[N<<1];\nil void add(int x,int y){\n    e[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;\n}\nbool v[N];\nvoid dp(int x){\n    v[x]=1;f[x]=0;\n    int res=inf;\n    fl(i,x)if(to!=RT){\n        dp(to);\n        f[x]+=MAX(f[to],g[to]);\n        res=MIN(res,MAX(g[to]-f[to],0));\n    }\n    g[x]=f[x]+1-res;\n}\n\nint main(){\n    in(n);\n    Fur(i,1,n)in(A[i]),add(A[i],i);\n    int ans=0;\n    Fur(i,1,n)if(!v[i]){\n        int res=0;\n        RT=i;\n        while(!v[A[RT]]){\n            v[RT]=1;\n            RT=A[RT];\n        }\n        dp(RT);\n        res=MAX(f[RT],g[RT]);\n        RT=A[RT];\n        dp(RT);\n        ans+=MAX(res,MAX(f[RT],g[RT]));\n    }\n    printf(\"%d\\n\",ans);\n}\n```\n","link":null,"tags":["基环树","动态规划"],"title":"Acwing 361 创世纪"},{"categories":[["刷题记录"]],"content":"\n求基环树直径\n\n先找出环,把环当根节点,找出每棵子树的直径和最大深度$d_x$\n\n接着就要在环上找到两点$x,y$使$d_x+dis(x,y)+d_y$最大\n\n可以破环后用单调队列$\\mathcal O(n)$处理\n```cpp\n#include<cstdio>\nconst int N=1000011;\n#define ll long long\n#define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\ninline ll max(ll x,ll y){return x>y?x:y;}\nint n,cnt=0,head[N],dfn[N],sz=0,pre[N],tt[N],tot=0,q[N];\nbool b[N];\nstruct edge{\n    int to,nxt,w;\n}e[N<<1];\nvoid add(int x,int y,int w){\n    e[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;e[cnt].w=w;\n}\nvoid dfs(int x){\n    dfn[x]=++sz;\n    fl(i,x)if(to!=pre[x]){\n        if(dfn[to]){\n            if(dfn[to]<dfn[x])continue;\n            b[tt[++tot]=x]=1;\n            for(int y=to;y!=x;y=pre[y])b[tt[++tot]=y]=1;\n        }\n        else pre[to]=x,dfs(to);\n    }\n}\nll f[N],d[N],s[N],ans=0;\nvoid dp(int x,int fa){\n    fl(i,x)if(to!=fa&&!b[to]){\n        dp(to,x);\n        f[x]=max(f[x],max(f[to],d[x]+d[to]+e[i].w));\n        d[x]=max(d[x],d[to]+e[i].w);\n    }\n}\nvoid work(int x){\n    ll tmp=0;\n    tot=0;\n    dfs(x);\n    tt[tot+1]=tt[1];\n    int p=0;\n    for(int i=1;i<=tot;++i)\n        fl(j,tt[i])if(to==tt[i+1])\n            s[++p]=e[j].w;\n    for(int i=1;i<=tot+1;++i)\n        tt[i+tot]=tt[i],s[i+tot]=s[i];\n    for(int i=2;i<=tot*2;++i)s[i]+=s[i-1];\n    for(int i=1;i<=tot;++i)dp(tt[i],0),tmp=max(tmp,max(f[tt[i]],d[tt[i]]));\n    int h=1,t=0;\n    for(int i=1;i<=tot*2;++i){\n        while(h<=t&&i-q[h]>=tot)++h;\n        if(h<=t)tmp=max(tmp,d[tt[i]]+d[tt[q[h]]]+s[i-1]-s[q[h]-1]);\n        while(h<=t&&d[tt[i]]-s[i-1]>=d[tt[q[t]]]-s[q[t]-1])--t;\n        q[++t]=i;\n    }\n    ans+=tmp;\n}\nint main(){\n    scanf(\"%d\",&n);\n    int y,w;\n    for(int i=1;i<=n;++i)\n        scanf(\"%d%d\",&y,&w),\n        add(i,y,w),add(y,i,w);\n    for(int i=1;i<=n;++i)if(!dfn[i])work(i);\n    printf(\"%lld\\n\",ans);\n}\n```\n","link":null,"tags":["基环树"],"title":"LG 4381 [IOI2008]Island"},{"categories":[["刷题记录"]],"content":"\n$f[i]=\\max{f[t-r]+p}$\n```cpp\n#include<bits\/stdc++.h>\nconst int N=1000011;\nstruct node{int st,ed,p,next;}a[N];\nint f[N],head[N];\ninline int max(int x,int y){return x>y?x:y;}\nint main(){\n    int n,m,r;\n    scanf(\"%d%d%d\",&n,&m,&r);\n    for(int i=1;i<=m;++i){\n        scanf(\"%d%d%d\",&a[i].st,&a[i].ed,&a[i].p);\n        a[i].next=head[a[i].ed];\n        head[a[i].ed]=i;\n    }\n    for(int j=1;j<=n;++j){\n        f[j]=f[j-1];\n        for(int i=head[j];i;i=a[i].next)\n            f[j]=max(f[j],f[max(0,a[i].st-r)]+a[i].p);\n    }\n    printf(\"%d\\n\",f[n]);\n}\n```\n","link":null,"tags":["动态规划"],"title":"LG 2889 [USACO07NOV]挤奶的时间Milking-Time"},{"categories":[["刷题记录"]],"content":"\n设$f_n$表示$n$个节点可以构成的二叉树的个数,$g_n$表示$n$个节点可以构成的二叉树的叶子节点的总数\n\n打表: 可以发现$g_n=nf_{n-1}$\n\n证明: 对于每棵有$n$个节点的二叉树,若它有$k$个叶子节点,删去后可以得到$k$棵$n-1$个节点的二叉树,而这$k$棵$n-1$个节点的二叉树每棵都有$n$个位置可以放置新的叶子节点\n\n$$\nf_1=1\\\\\nf_n=\\sum_{i=1}^{n-1}f_if_{n-i-1}\n$$\n\n$f$其实就是卡特兰数\n\n代入$ans=\\frac{g_n}{f_n}$得到$\\frac{n(n+1)}{2(2n-1)}$\n```cpp\n#include<cstdio>\nint main(){\n  double n;\n  scanf(\"%lf\",&n);\n  printf(\"%.12f\",n*(n+1)\/2\/(2*n-1));\n}\n```\n","link":null,"tags":["生成函数","数论","卡特兰数"],"title":"LG 3978 [TJOI2015]概率论"},{"categories":[["刷题记录"]],"content":"\n$g(x)=(1+x+x^2+x^3+...+x^{num_1})(1+x^2+x^4+...+x^{2num_2})(1+x^5+x^{10}+x^{15}+...+x^{5num_3})$\n```cpp\n#include<bits\/stdc++.h>\nconst int N=10011;\nint n1,n2,n3,a[N],b[N],c[N];\nint main(){\n    while(~scanf(\"%d%d%d\",&n1,&n2,&n3)&&(n1||n2||n3)){\n        memset(a,0,sizeof a);\n        memset(b,0,sizeof b);\n        memset(c,0,sizeof c);\n        int tot=n1+n2*2+n3*5;\n        for(int i=0;i<=n1;++i)a[i]=1;\n        for(int j=0;j<=tot;++j)\n            for(int i=0;i<=n2*2&&i+j<=tot;i+=2)\n                b[i+j]+=a[j];\n        for(int j=0;j<=tot;++j)\n            for(int i=0;i<=n3*5&&i+j<=tot;i+=5)\n                c[i+j]+=b[j];\n        int i;\n        for(i=0;i<=tot;++i)if(!c[i])break;\n        printf(\"%d\\n\",i);\n    }\n}\n```\n","link":null,"tags":["生成函数","数论"],"title":"HDU 1085 Holding-Bin-Laden-Captive!"},{"categories":[["刷题记录"]],"content":"\n$g(x)=(1+x+x^2+x^3+...)(1+x^2+x^4+x^6+...)(1+x^3+x^6+x^9+...)...$\n\n模拟一下\n\n$\\Theta(n^2)$\n```cpp\n#include<bits\/stdc++.h>\n#define Fur(i,x,y) for(int i=x;i<=y;++i)\nconst int N=121;\nint n,a[2][N];\nint main(){\n    Fur(i,0,120)a[1][i]=1;\n    Fur(i,2,120){\n        memset(a[i&1],0,sizeof a[i&1]);\n        int p=0;\n        while(p<=120){\n            Fur(j,0,120-p)a[i&1][p+j]+=a[!(i&1)][j];\n            p+=i;\n        }\n    }\n    while(~scanf(\"%d\",&n))printf(\"%d\\n\",a[0][n]);\n}\n```\n","link":null,"tags":["生成函数","数论"],"title":"HDU 1028 Ignatius-and-the-Princess-III"},{"categories":[["刷题记录"]],"content":"\n直接模拟,把平衡树当做可以$\\Theta(\\log n)$访问并删除任意位置的链表\n```cpp\n#include<bits\/stdc++.h>\n#pragma GCC optimize(3)\n#define il __inline__ __attribute__ ((always_inline))\nusing namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?__=1,EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\nconst int N=700011;\n#define ls c[rt][0]\n#define rs c[rt][1]\nint n,q,sz[N],c[N][2],val[N],rnd[N],rev[N],RT=0,cnt=0;\nil int ne(int v){\n    val[++cnt]=v;\n    sz[cnt]=1;\n    rnd[cnt]=rand()<<15|rand();\n    return cnt;\n}\nil void pu(int rt){sz[rt]=sz[ls]+sz[rs]+1;}\nvoid sl(int rt,int k,int &x,int &y){\n    if(!rt)return (void)(x=y=0);\n    if(sz[ls]>=k)y=rt,sl(ls,k,x,ls);\n    else x=rt,sl(rs,k-sz[ls]-1,rs,y);\n    pu(rt);\n}\nint mg(int x,int y){\n    if(!x||!y)return x+y;\n    if(rnd[x]<rnd[y]){\n        c[x][1]=mg(c[x][1],y);\n        pu(x);return x;\n    }\n    else{\n        c[y][0]=mg(x,c[y][0]);\n        pu(y);return y;\n    }\n}\nil int get(int p){\n    int x,y,z,t;\n    sl(RT,p,x,z);\n    sl(x,p-1,x,y);\n    t=val[y];\n    RT=mg(mg(x,mg(c[y][0],c[y][1])),z);\n    return t;\n}\nint main(){\n    srand(time(0));\n    in(n);\n    int x,cur=1;\n    for(int i=1;i<=n;++i)RT=mg(RT,ne(i));\n    for(int i=1;i<=n;++i){\n        in(x);\n        cur=(cur+x-1)%(n-i+1)+1;\n        out(get(cur),ln);\n    }\n    flush();\n}\n```\n","link":null,"tags":["平衡树"],"title":"LG 3988 [SHOI2013]发牌"},{"categories":[["刷题记录"]],"content":"\n排序后动态规划\n\n设$f[i][j]$表示前$i$个女生,至少有$j$个比男生高\n\n$f[i][j]=(f[i-1][j]+f[i-1][j-1]\\times(p-j+1))\\times(n-i)!$($p$表示有$p$个男生比前$i$个女生矮)\n\n\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?__=1,EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\nconst int N=211;\nint n,k,a[N],b[N],f[N][N],c[N][N];\nll fac[N];\nint main(){\n    in(n,k);\n    fac[0]=1;\n    Fur(i,1,n)fac[i]=fac[i-1]*i;\n    Fur(i,1,n)in(a[i]);\n    Fur(i,1,n)in(b[i]);\n    sort(a+1,a+n+1);\n    sort(b+1,b+n+1);\n    f[0][0]=1;\n    int p=0;\n    Fur(i,1,n){\n        while(b[i]>a[p+1]&&p<n)++p;\n        Fur(j,0,i){\n            f[i][j]=f[i-1][j];\n            if(p-j+1>0)\n                f[i][j]=f[i][j]+f[i-1][j-1]*(p-j+1);\n        }\n    }\n    c[0][0]=1;\n    Fur(i,1,n){\n        c[i][0]=c[i][i]=1;\n        Fur(j,1,i-1)\n            c[i][j]=c[i-1][j-1]+c[i-1][j];\n    }\n    Fur(i,0,n)f[n][i]=f[n][i]*fac[n-i];\n    Fdr(i,n,0)\n        Fur(j,i+1,n)\n            f[n][i]=f[n][i]-c[j][i]*f[n][j];\n    \n    int ans=0;\n    Fur(i,0,k)ans=ans+f[n][i];\n    cout<<ans<<endl;\n}\n```\n","link":null,"tags":["排序","动态规划","高精","容斥"],"title":"LG 2159 [SHOI2009]舞会"},{"categories":[["刷题记录"]],"content":"\n设当前区间为$[l,r]$\n\n$res=\\sum_{i=l}^r p_i\\times[\\prod_{j=l,j!=i}^r(1-p_j)]$\n\n设$s_{[l,r]}$表示$\\prod_{i=l}^r(1-p_i)$\n\n$res=s_{[l,r]}\\sum_{i=l}^r \\frac{p_i}{1-p_i}$\n\n设$a_i=1-p_i,b_i=\\frac{p_i}{1-p_i}$\n\n$res=\\prod_{i=l}^ra_i\\sum_{i=l}^rb_i$\n\n假设现在区间变成了$[l,r+1]$\n\n设$A=\\prod_{i=l}^ra_i,B=\\sum_{i=l}^rb_i$\n\n$res'=A\\times a_{r+1}(B+b_{r+1})$\n\n$=A(a_{r+1}B+a_{r+1}b_{r+1})$\n\n$=A(a_{r+1}B+p_{r+1})$\n\n若$res'>res$,那么$a_{r+1}B+p_{r+1}>B$\n\n$1-p_{r+1}+\\frac{p_{r+1}}B>1$\n\n$\\therefore B<1$\n\n那么对于每个$l$,只需要找到最远的$r$使$\\sum_{i=l}^rb_i<1$\n\n而这又具有单调性,那么$\\mathcal{O(n)}$就可以解决了\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?__=1,EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\nconst int N=1000011;\nint n;\ndb p[N],b[N];\nint main(){\n    in(n);\n    int x,r=0;\n    db ans=0,A=1,B=0;\n    Fur(i,1,n)in(x),p[i]=(db)x\/1e6,ans=MAX(ans,p[i]);\n    Fur(l,1,n){\n        while(r<n&&B<1){\n            ++r;\n            B+=p[r]\/(1.0-p[r]);\n            A*=(1.0-p[r]);\n        }\n        ans=MAX(ans,A*B);\n        A\/=(1.0-p[l]);B-=p[l]\/(1.0-p[l]);\n    }\n    printf(\"%d\\n\",int(ans*1e6));\n}\n```\n","link":null,"tags":["概率","决策单调性","双指针","思维"],"title":"LG 5242 [USACO19FEB]Cow-Dating"},{"categories":[["刷题记录"]],"content":"\n按斜率建图\n\n然后跑背包\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?__=1,EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\nconst int N=211;\nint n,T,f[40001];\nstruct node{\n    int x,y,t,v;\n}a[N];\nbool chk(node i,node j){\n    return i.x*j.y==i.y*j.x;\n}\nbool cmp(node i,node j){\n    return chk(i,j)?(i.y<j.y):((1.0*i.x\/i.y)<(1.0*j.x\/j.y));\n}\nstruct NODE{int t,v;};\nvector<NODE>e[N];\nint main(){\n    in(n,T);\n    int tot=0;\n    Fur(i,1,n)in(a[i].x,a[i].y,a[i].t,a[i].v);\n    sort(a+1,a+n+1,cmp);\n    Fur(i,1,n){\n        bool ff=0;\n        if(!chk(a[i],a[i-1])||i==1)++tot,ff=1;\n        e[tot].push_back({a[i].t+(ff?0:e[tot][e[tot].size()-1].t),a[i].v+(ff?0:e[tot][e[tot].size()-1].v)});\n    }\n    Fur(i,1,tot){\n        Fdr(j,T,e[i][0].t){\n            int tt=f[j];\n            for(auto k:e[i])\n                if(j>=k.t)tt=MAX(tt,f[j-k.t]+k.v);\n            f[j]=tt;\n        }\n    }\n    printf(\"%d\\n\",f[T]);\n}\n```\n","link":null,"tags":["动态规划","建图","背包"],"title":"LG 3961 [TJOI2013]黄金矿工"},{"categories":[["刷题记录"]],"content":"\n若$A,B$总和不相同,显然是-1\n\n由于元素都大于0,可以使用类似双指针的方法\n\n两个指针在$A,B$数组中移动,若找到$A,B$中和相同的两端,答案就+1\n\n\n```cpp\n#include<cstdio>\n#pragma GCC optimize(3)\n#define ll long long\n#define Fur(i,x,y) for(int i(x);i<=y;++i)\nconst int N=300011;\ninline char gc(){static const int IN_LEN=N*10;static char buf[IN_LEN],*s,*t;return (s==t)&&(t=(s=buf)+fread(buf,1,IN_LEN,stdin)),s==t?-1:*s++;}\ninline void in(int &x){x=0;char c;bool f=0;while((c=gc())<'0'||'9'<c)f^=(c=='-');while('0'<=c&&c<='9')x=x*10+c-48,c=gc();if(f)x=-x;}\nint n,m,a[N],b[N];\nint main(){\n    in(n);\n    Fur(i,1,n)in(a[i]);\n    in(m);\n    Fur(i,1,m)in(b[i]);\n    int ans=0,j=1;\n    ll s=0;\n    Fur(i,1,n){\n        s+=a[i];\n        while(s>=b[j]&&j<=m)s-=b[j++];\n        if(!s)++ans;\n    }\n    if(s!=0||j!=m+1)printf(\"-1\\n\");\n    else printf(\"%d\\n\",ans);\n}\n```\n","link":null,"tags":["双指针","贪心"],"title":"LG CF1036D Vasya-and-Arrays"},{"categories":[["刷题记录"]],"content":"\n结论: \n\n把$x^{\\frac14}$内的因子筛掉,剩下的$x$一定是完全立方数或者不可化简\n\n证明: \n\n若存在$p>x^{\\frac14}$且$b\\times p^3=x$,那么$b>x^{\\frac14}$或$b=1$\n\n$\\because b>x^{\\frac14} \\therefore b\\times p^3 >x$,不符合\n\n$\\therefore b=1$,$x$为完全立方数\n\n实现:\n\n1. 先晒出$(10^{18})^{\\frac14}(\\approx31650)$内的质数\n\n2. 筛掉$x^{\\frac14}$内的因子,筛的过程中统计有没有立方\n\n3. 判断$x$是不是完全立方数(pow(x,1.0\/3)^3+eps==x四舍五入)\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?__=1,EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\nconst int N=31650;\nint pri[3500],tot=0;\nbool v[N+11];\nil void ol(){\n    Fur(i,2,N){\n        if(!v[i])pri[++tot]=i;\n        Fur(j,1,tot){\n            if(i*pri[j]>N)break;\n            v[i*pri[j]]=1;\n            if(i%pri[j]==0)break;\n        }\n    }\n}\nint main(){\n    ol();\n    int n;\n    ll x,ans,t;\n    in(n);\n    while(n--){\n        in(x);\n        ans=1;\n        Fur(i,1,tot){\n            if(pri[i]>x)break;\n            int tt=0;\n            while(x%pri[i]==0){\n                x\/=pri[i];\n                if(++tt==3)ans*=pri[i],tt=0;\n            }\n        }\n        t=(ll)(pow(x,1.0\/3)+0.000000005);\n        if(t*t*t==x)ans*=t;\n        out(ans,ln);\n    }\n    flush();\n}\n```\n","link":null,"tags":["数论","筛法"],"title":"LG 4446 [AHOI2018初中组]根式化简"},{"categories":[["刷题记录"]],"content":"\n先排序\n\n从小到大添加\n\n如果有以$a_i-1$的组,那么$a_i$必然添加在目前以$a_i-1$结尾的组的末尾\n\n否则新建一个组\n\n可以使用 **桶+堆** 实现\n```cpp\n#include<bits\/stdc++.h>\n#include<bits\/extc++.h>\nconst int N=100011;\nint n,a[N];\nstd::priority_queue<int,std::vector<int>,std::greater<int>>q[N];\n__gnu_pbds::cc_hash_table<int,int>T;\nint main(){\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;++i)scanf(\"%d\",&a[i]);\n    std::sort(a+1,a+n+1);\n    int t=0;\n    for(int i=1;i<=n;++i){\n        if(!T[a[i]])T[a[i]]=++t;\n        if(q[T[a[i]-1]].empty())q[T[a[i]]].push(1);\n        else q[T[a[i]]].push(q[T[a[i]-1]].top()+1),q[T[a[i]-1]].pop();\n    }\n    int ans=n;\n    for(int i=1;i<=t;++i)if(!q[i].empty())ans=std::min(ans,q[i].top());\n    printf(\"%d\\n\",ans);\n}\n```\n","link":null,"tags":["排序","贪心"],"title":"LG 4447 [AHOI2018初中组]分组"},{"categories":[["刷题记录"]],"content":"\n最短路松弛的比较方式变为$d_x+w\\le d_{to}$\n\n记得**long long**\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?__=1,EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\nconst int N=300011;\n#define int ll\nint n,m,st,cnt=0,head[N],d[N],pre[N];\nstruct edge{\n    int to,nxt,w;\n}e[N<<1];\nil void add(int x,int y,int w){\n    e[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;e[cnt].w=w;\n}\nstruct node{\n    int x,d;\n    bool operator<(node t)const{\n        return d>t.d;\n    }\n};\npriority_queue<node>q;\nbool v[N];\nil void dij(){\n    clr(d,126);\n    d[st]=0;q.push(node{st,0});\n    while(!q.empty()){\n        int x=q.top().x,len=q.top().d;q.pop();\n        if(v[x])continue;\n        v[x]=1;\n        fl(i,x)if(len+e[i].w<=d[to]){\n            d[to]=len+e[i].w;pre[to]=i;\n            if(!v[to])q.push(node{to,d[to]});\n        }\n    }\n}\nsigned main(){\n    in(n,m);\n    int x,y,w,ans=0;\n    Fur(i,1,m)in(x,y,w),add(x,y,w),add(y,x,w);\n    in(st);\n    dij();\n    Fur(i,1,n)if(i!=st)\n        ans+=e[pre[i]].w;\n    out(ans,ln);\n    Fur(i,1,n)if(i!=st)\n        out((pre[i]+1)>>1,\" \");\n    flush();\n}\n```\n","link":null,"tags":["最短路","生成树"],"title":"LG CF545E Paths-and-Trees"},{"categories":[["刷题记录"]],"content":"\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?__=1,EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\nconst int N=100011;\nint n,k;\nchar ch[N];\nil bool chk(int w){\n    int s=0,t=0,la=1;\n    Fur(i,1,n){\n        if(ch[i]!=ch[la])la=i,s=1;\n        else if(++s>w)++t,s=0,la=i+1;\n    }\n    return t<=k;\n}\nint main(){\n    in(n,k),in(ch+1);\n    int p=0;\n    Fur(i,1,n)\n        if((ch[i]=='F')^(i&1))++p;\n    if(p<=k||n-p<=k)return printf(\"1\\n\"),0;\n    int l=2,r=n\/k+1,ans=r,m;\n    while(l<=r){\n        m=(l+r)>>1;\n        if(chk(m))ans=m,r=m-1;\n        else l=m+1;\n    }\n    printf(\"%d\\n\",ans);\n}\n```\n","link":null,"tags":["二分"],"title":"LG 3718 [AHOI2017初中组]alter"},{"categories":[["刷题记录"]],"content":"\n设$f[k][i][j]$表示前$k$种面值,$A$剩$i$元,$B$剩$j$元最少交换几张\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?__=1,EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\nconst int N=1011;\nint A,B,C,val[7]={0,100,50,20,10,5,1},a[4][7],s[4],cnt[7],f[7][N][N],tot=0;\nint main(){\n    in(A,B,C);\n    Fur(i,1,3)Fur(j,1,6){\n        in(a[i][j]);\n        s[i]+=a[i][j]*val[j];\n        tot+=a[i][j]*val[j];\n        cnt[j]+=a[i][j];\n    }\n\n    clr(f,126);\n    f[0][s[1]][s[2]]=0;\n    int ans=inf;\n    Fur(i,1,6)\n        Fur(j,0,tot)\n            Fur(k,0,tot-j)\n            if(f[i-1][j][k]!=inf)\n                Fur(x1,0,cnt[i])\n                    Fur(x2,0,cnt[i]-x1){\n                        int na=j-(a[1][i]-x1)*val[i],\n                            nb=k-(a[2][i]-x2)*val[i],\n                            x3=cnt[i]-x1-x2;\n                        if(na>=0&&nb>=0&&na+nb<=tot){\n                            int w=ABS(a[1][i]-x1)+ABS(a[2][i]-x2)+ABS(a[3][i]-x3);\n                            f[i][na][nb]=MIN(f[i][na][nb],f[i-1][j][k]+(w>>1));\n                        }\n                    }\n    int s1=s[1]-A+C,s2=s[2]-B+A,s3=s[3]-C+B;\n    if(s1<0||s2<0||s3<0)printf(\"impossible\\n\");\n    else{\n        Fur(i,0,6)ans=f[i][s1][s2];\n        if(ans==inf)printf(\"impossible\\n\");\n        else printf(\"%d\\n\",ans);\n    }\n}\n```\n","link":null,"tags":["动态规划","枚举","背包"],"title":"LG 4026 [SHOI2008]循环的债务"},{"categories":[["刷题记录"]],"content":"\n我们可以把每对$x,y$都看成边\n\n如果当前$x,y$已经连通,那么当前客人一定会悲伤(相当于加上$x\\leftrightarrow y$后形成了环,显然没法实现)\n\n那么答案+1\n\n可以用并查集实现\n\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?__=1,EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\nconst int N=200011;\nint n,m,f[N];\nint gf(int x){return x==f[x]?x:(f[x]=gf(f[x]));}\nint main(){\n    in(n,m);\n    Fur(i,1,n)f[i]=i;\n    int x,y,ans=0;\n    while(m--){\n        in(x,y);\n        if(gf(x)==gf(y))++ans;\n        else f[f[y]]=f[x];\n    }\n    printf(\"%d\\n\",ans);\n}\n```\n","link":null,"tags":["并查集"],"title":"LG CF1209D Cow-and-Snacks"},{"categories":[["刷题记录"]],"content":"\n直接按照规则建图后跑最短路\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?__=1,EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\nint n,m,cnt=0,head[511*511],dx[4]={0,1,0,-1},dy[4]={1,0,-1,0},sx,sy,tx,ty,d[511*511];\nchar a[511][511];\nstruct edge{\n    int to,nxt,w;\n}e[511*511*10];\nil void add(int x,int y,int w){\n    e[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;e[cnt].w=w;\n}\nil int id(int x,int y){return (x-1)*m+y;}\nstruct cmp{\n    bool operator()(int x,int y){\n        return d[x]>d[y];\n    }\n};\nbool v[511*511];\npriority_queue<int,vector<int>,cmp>q;\nvoid bfs(){\n    d[id(sx,sy)]=1;\n    q.push(id(sx,sy));\n    while(!q.empty()){\n        int x=q.top();q.pop();v[x]=0;\n        fl(i,x)if(d[x]+e[i].w<d[to]||!d[to]){\n            d[to]=d[x]+e[i].w;\n            if(!v[to])v[to]=1,q.push(to);\n        }\n    }\n}\nint main(){\n    in(n,m);\n    Fur(i,1,n)in(a[i]+1);\n    Fur(i,1,n)Fur(j,1,m)\n        if(a[i][j]=='C')sx=i,sy=j;\n        else if(a[i][j]=='F')tx=i,ty=j;\n    Fur(i,1,n)Fur(j,1,m)\n    if(a[i][j]!='#')\n    Fur(t,0,3){\n        int x=i+dx[t],y=j+dy[t];\n        if(x<1||x>n||y<1||y>m||a[x][y]=='#')continue;\n        add(id(i,j),id(x,y),1);\n    }\n    Fur(i,1,n)Fur(j,1,m)\n    if(a[i][j]!='#'){\n        int dis=inf,x,y,tt=0,p[4],tot=0;\n        Fur(t,0,3){\n            x=i,y=j,tt=0;\n            while(a[x][y]!='#'){\n                x+=dx[t],y+=dy[t],++tt;\n                if(x<1||x>n||y<1||y>m){tt=inf;break;}\n            }\n            x-=dx[t],y-=dy[t];\n            if(tt!=inf)dis=MIN(dis,tt),p[tot++]=id(x,y);\n        }\n        if(dis!=inf)\n        Fur(t,0,tot-1)add(id(i,j),p[t],dis);\n    }\n    bfs();\n    if(!d[id(tx,ty)])printf(\"nemoguce\\n\");\n    else printf(\"%d\\n\",d[id(tx,ty)]-1);\n}\n```\n","link":null,"tags":["最短路","图论"],"title":"LG 4442 [COCI2017-2018t3]-Portal"},{"categories":[["刷题记录"]],"content":"\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?__=1,EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\nconst int N=100011;\nint n,m,bl[N],blk,a[N],ans[N],ANS[N],v[N],mx=0;\nstruct que{\n    int l,r,a,b,id;\n    il bool operator<(que t)const{\n        return (bl[l]==bl[t.l])?((bl[l]&1)?(r<t.r):(r>t.r)):(l<t.l);\n    }\n}q[N];\nstruct bit{\n    int s[N];\n    il void add(int x,int v){\n        for(int i=x;i<=mx;i+=i&-i)\n            s[i]+=v;\n    }\n    il int get(int x){\n        int res=0;\n        for(int i=x;i;i-=i&-i)\n            res+=s[i];\n        return res;\n    }\n}A,B;\nil void inc(int x){\n    A.add(x,1);\n    if(!v[x]++)B.add(x,1);\n}\nil void dec(int x){\n    A.add(x,-1);\n    if(!--v[x])B.add(x,-1);\n}\nint main(){\n    in(n,m);blk=sqrt(n);\n    Fur(i,1,n)in(a[i]),bl[i]=(i-1)\/blk+1;\n    Fur(i,1,m)in(q[i].l,q[i].r,q[i].a,q[i].b),q[i].id=i,mx=MAX(mx,q[i].b);\n    sort(q+1,q+m+1);\n    int l=1,r=0;\n    Fur(i,1,m){\n        while(l<q[i].l)dec(a[l++]);\n        while(r<q[i].r)inc(a[++r]);\n        while(l>q[i].l)inc(a[--l]);\n        while(r>q[i].r)dec(a[r--]);\n        ans[q[i].id]=A.get(q[i].b)-A.get(q[i].a-1);\n        ANS[q[i].id]=B.get(q[i].b)-B.get(q[i].a-1);\n    }\n    Fur(i,1,m)out(ans[i],\" \",ANS[i],ln);\n    flush();\n}\n```\n","link":null,"tags":["莫队","树状数组"],"title":"LG 4396 [AHOI2013]作业"},{"categories":[["刷题记录"]],"content":"\n设$f[sta]$表示$sta$表示的所有颜色都排列到从1开始的相连的一段,最少要多少次\n\n设$pre[i][j]$表示所有颜色$i$前面总共有多少个颜色$j$,也就是说要将所有颜色$i$移动到颜色$j$左边要移动多少次\n\n即：$\\sum[y<x,c[x]=i,c[y]=j]$\n\n\n$sta[i]$表示$sta$表示的第$i$种颜色的状态\n\n$f[sta]=\\min{f[sta']+\\sum_{sta[j]=1,sta[k]=0}pre[j][k]}$\n\n\n\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?__=1,EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\nconst int N=400011;\nint n,c[N],b[22],tot=0,cnt[22];\nll f[1<<21],pre[22][22];\nint main(){\n    in(n);\n    Fur(i,1,n){\n        in(c[i]);\n        if(!b[c[i]])b[c[i]]=tot++;\n    }\n    Fur(i,1,n){\n        Fur(j,0,tot-1)\n            pre[b[c[i]]][j]+=cnt[j];\n        ++cnt[b[c[i]]];\n    }\n    clr(f,126);\n    f[0]=0;\n    Fur(i,1,(1<<tot)-1)\n        Fur(j,0,tot-1)\n        if((i>>j)&1){\n            ll t=0;\n            Fur(k,0,tot-1)if(!((i>>k)&1)&&j!=k)\n                t+=pre[j][k];\n            f[i]=MIN(f[i],f[i^(1<<j)]+t);\n        }\n    printf(\"%lld\\n\",f[(1<<tot)-1]);\n}\n```\n","link":null,"tags":["逆序对","状态压缩","动态规划"],"title":"LG CF1215E Marbles"},{"categories":[["刷题记录"]],"content":"\n看到**边不能重复用**,$n\\le 200,T\\le 200$就可以想到网络流\n\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?__=1,EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\nconst int N=211,M=40011;\nint n,m,T,cnt=1,head[N],q[N],d[N];\nstruct node{\n    int x,y,w;\n    bool operator<(node t)const{\n        return w<t.w;\n    }\n}E[M];\nstruct edge{int to,nxt,w;}e[M<<1];\nil void add(int x,int y){\n    e[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;e[cnt].w=1;\n    e[++cnt].to=x;e[cnt].nxt=head[y];head[y]=cnt;e[cnt].w=0;\n}\nbool bfs(){\n    clr(d,0);\n    int h=0,t=1,x;\n    q[0]=1;d[1]=1;\n    while(h<t){\n        x=q[h++];if(x==n)return 1;\n        fl(i,x)if(e[i].w&&!d[to])\n            d[to]=d[x]+1,q[t++]=to;\n    }\n    return 0;\n}\nint dfs(int x,int mf){\n    if(x==n||!mf)return mf;\n    int us=0,w;\n    fl(i,x)if(e[i].w&&d[to]==d[x]+1){\n        w=dfs(to,MIN(e[i].w,mf-us));\n        e[i].w-=w;\n        e[i^1].w+=w;\n        us+=w;\n        if(us==mf)return mf;\n    }\n    if(!us)d[x]=-1;\n    return us;\n}\nint main(){\n    in(n,m,T);\n    Fur(i,1,m)in(E[i].x,E[i].y,E[i].w);\n    sort(E+1,E+m+1);\n    Fur(i,1,m){\n        add(E[i].x,E[i].y);add(E[i].y,E[i].x);\n        while(E[i].w==E[i+1].w&&i<m)++i,add(E[i].x,E[i].y),add(E[i].y,E[i].x);\n        while(bfs())T-=dfs(1,inf);\n        if(T<=0)return printf(\"%d\\n\",E[i].w),0;\n    }\n}\n```\n","link":null,"tags":["二分","bfs","网络流"],"title":"LG 1401 城市"},{"categories":[["刷题记录"]],"content":"\n看到交换相邻字母,就想到逆序对\n\n考虑一下,一定是将A的每个字母移动到离它最近的B中相同字母的位置\n\n我们可以用讲位置存起来然后处理一下\n\n之后数组变成了A中每个位置最后在B中的位置\n\n这个数组中逆序对的数目就是答案\n\n\n```cpp\n#include<bits\/stdc++.h>\nusing namespace std;\n#define N 1000011\nint n,cnt[30],s[N];\nchar a[N],b[N];\nvector<int>p[30];\nvoid add(int x){\n    for(int i=x;i<=n;i+=i&-i)\n        ++s[i];\n}\nint get(int x){\n    int ans=0;\n    for(int i=x;i;i-=i&-i)\n        ans+=s[i];\n    return ans;\n}\nstruct node{\n    int v,p;\n    bool operator<(node x)const{\n        return v>x.v;\n    }\n}c[N];\nint main(){\n    scanf(\"%d%s%s\",&n,a+1,b+1);\n    for(int i=1;i<=n;++i)p[b[i]-'A'].push_back(i);\n    for(int i=1;i<=n;++i)c[i]={p[a[i]-'A'][cnt[a[i]-'A']++],i};\n    sort(c+1,c+n+1);\n    long long ans=0;\n    for(int i=1;i<=n;++i){\n        ans+=get(c[i].p-1);\n        add(c[i].p);\n    }\n    printf(\"%lld\\n\",ans);\n}\n```\n","link":null,"tags":["树状数组","逆序对"],"title":"LG 3531 [POI2012]LIT-Letters"},{"categories":[["刷题记录"]],"content":"\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\nconst int N=100011;\nint n,m,cnt=0,head[N],a[N];\nstruct edge{\n    int to,nxt;\n}e[N<<1];\nvoid add(int x,int y){\n    e[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;\n}\nstruct que{\n\n}q[N];\nnamespace INIT{\n    unsigned int SA, SB, SC,p,t;\n    unsigned int rng61(){\n    \tSA^=SA<<16;\n    \tSA^=SA>>5;\n    \tSA^=SA<<1;\n    \tSA=SB;\n    \tSB=SC;\n    \tSC^=t^SA;\n    \treturn SC;\n    }\n    void init(){\n        in(n,p,SA,SB,SC);\n        Fur(i,2,p)add(i-1,i);\n        Fur(i,p+1,n)add(rng61()%(i-1)+1,i);\n        Fur(i,1,n)a[i]=rng61()%n+1;\n        in(m);\n        int x,y;\n        Fur(i,1,m){\n            in(x,y);\n        }\n    }\n}\nint main(){\n}\n```\n","link":null,"tags":["树上莫队","主席树"],"title":"LG 4618 [SDOI2018]原题识别"},{"categories":[["刷题记录"]],"content":"\n这题考验的是仔细读题\n\n可以发现修改带查询的只有1000个,这部分直接暴力求就可以了\n\n区间加可以用差分来解决\n\n剩下的部分：\n\n可以预处理出$[1,i]$的答案$ans_i$\n\n查询$[l,r]$的答案就是$ans_r-ans_{l-1}$\n\n代码很短\n\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\n#define N 800011\n#define int ll\nint n,q,mod,mi,mx,ans[N],s[N];\nsigned main(){\n    in(n,q,mod,mi,mx);\n    char ch;\n    int l,r,v;\n    while(q--){\n        in(ch,l,r);\n        if(ch=='A'){\n            in(v);\n            s[l]+=v;s[r+1]-=v;\n        }\n        else{\n            int now=0,res=0;\n            Fur(i,1,l-1)now+=s[i];\n            Fur(i,l,r)\n                now+=s[i],\n                res+=(mi<=(now*i%mod)&&(now*i%mod)<=mx);\n            out(res,ln);\n        }\n    }\n    int now=0;\n    Fur(i,1,n)\n        now+=s[i],\n        ans[i]=ans[i-1]+(mi<=(now*i)%mod&&(now*i)%mod<=mx);\n    in(q);\n    while(q--)in(l,r),out(ans[r]-ans[l-1],ln);\n    flush();\n}\n```\n","link":null,"tags":["差分","前缀和"],"title":"LG 3948 数据结构"},{"categories":[["刷题记录"]],"content":"\n解法1(在线)：\n\nbfs序,实现较为麻烦\n\n解法2(离线)：\n\n考虑单独的一个节点$u$,它的操作影响的都是在它子树内的与$u$深度差小于等于$k$的节点,那么我们只要维护每层深度的操作总和就行了\n\n修改$x$影响的只有$x$的子树,我们可以在dfs时这样操作：\n\n1.进入该点\n2. 实现该点的所有操作\n3. 递归它的子树\n4. 撤销操作\n\n这样就不会影响到其他点了\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\n#define N 300011\nint n,cnt=0,head[N];\nstruct edge{\n    int to,nxt;\n}e[N<<1];\nil void add(int x,int y){\n    e[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;\n}\nll s[N],ans[N];\nil void upd(int x,int v){\n    for(int i=x;i<=n;i+=i&-i)\n        s[i]+=v;\n}\nil ll ask(int x){\n    ll ans=0;\n    for(int i=x;i;i-=i&-i)\n        ans+=s[i];\n    return ans;\n}\nstruct node{int v,d;};\nvector<node>opt[N];\nvoid dfs(int x,int d,int f){\n    for(auto i:opt[x])\n        upd(MIN(n,d+i.d),i.v);\n    ans[x]=ask(n)-ask(d-1);\n    fl(i,x)if(to!=f)dfs(to,d+1,x);\n    for(auto i:opt[x])\n        upd(MIN(n,d+i.d),-i.v);\n}\nint main(){\n    in(n);\n    int x,y,q,v,d;\n    Fur(i,1,n-1)\n        in(x,y),\n        add(x,y),add(y,x);\n    in(q);\n    while(q--){\n        in(x,d,v);\n        opt[x].push_back(node{v,d});\n    }\n    dfs(1,1,0);\n    Fur(i,1,n)out(ans[i],\" \");\n    flush();\n}\n```\n","link":null,"tags":["差分","树状数组"],"title":"LG CF1076E Vasya-and-a-Tree"},{"categories":[["刷题记录"]],"content":"\n把$x>y$,看成$x\\rightarrow y$的一条边\n\n若最后的图出现环的话那就是不合法的\n\n但是如果按照普通的建图方式的话每次要添加$k(r-l-1-k)$条边\n\n我们可以线段树优化建图\n\n因为$k \\le 3 \\times 10^5$\n\n所以整个区间最多被划分成$3\\times 10^5$段\n\n$log n$的复杂度是可以接受的\n\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\n#define N 200011<<3\nint n,s,q,cnt=0,a[N],pos[N],head[N],deg[N],sz=0,bl[N],d[N],len=0;\nstruct edge{\n    int to,nxt;\n}e[N];\nvoid add(int x,int y){\n    e[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;\n    ++deg[y];\n}\n#define ls rt<<1\n#define rs rt<<1|1\nvoid build(int l,int r,int rt){\n    sz=MAX(sz,rt);\n    if(l==r){\n        bl[rt]=l;\n        pos[l]=rt;\n        return;\n    }\n    int m=(l+r)>>1;\n    add(rt,ls);\n    add(rt,rs);\n    build(l,m,ls);\n    build(m+1,r,rs);\n}\nvoid upd(int L,int R,int p,int l,int r,int rt){\n    if(L>R)return;\n    if(L<=l&&r<=R){\n        add(p,rt);\n        return;\n    }\n    int m=(l+r)>>1;\n    if(L<=m)upd(L,R,p,l,m,ls);\n    if(R>m)upd(L,R,p,m+1,r,rs);\n}\nil void ext(){cout<<\"NIE\\n\";exit(0);}\nvoid topsort(){\n    queue<int>q;\n    q.push(1);\n    a[1]=1e9;\n    clr(d,127);\n    while(!q.empty()){\n        int x=q.front();q.pop();\n        fl(i,x){\n            d[to]=MIN(d[to],a[x]-(bl[to]!=0));\n            if(d[to]<a[to])ext();\n            if(!--deg[to]){\n                if(bl[to])++len;\n                q.push(to);\n                if(!a[to])a[to]=d[to];\n            }\n        }\n    }\n}\nint main(){\n    int x,y,t,l,r,k;\n    in(n,t,q);\n    build(1,n,1);\n    while(t--){\n        in(x,y);\n        a[pos[x]]=y;\n    }\n    while(q--){\n        in(l,r,k);\n        int la=l;\n        ++sz;\n        while(k--){\n            in(x);\n            add(pos[x],sz);\n            upd(la,x-1,sz,1,n,1);\n            la=x+1;\n        }\n        upd(la,r,sz,1,n,1);\n    }\n    topsort();\n    if(len!=n)ext();\n    out(\"TAK\\n\");\n    Fur(i,1,n)out(a[pos[i]],\" \");\n    flush();\n}\n```\n","link":null,"tags":["线段树","差分约束"],"title":"LG 3588 [POI2015]PUS"},{"categories":[["刷题记录"]],"content":"\n先钦定树的重心处理出答案\n\n若当前点是距离最大点对的lca(即在它们之间的路径上),这个点就是最优的\n\n否则最优答案一定在最大点对的lca的子树中\n\n每次都选树的重心来处理,最多需要处理$\\log n$次,总复杂度$\\Theta(n \\log n)$\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\n#define N 100011\nint n,m,cnt=0,head[N];\nstruct edge{\n    int to,nxt,w;\n}e[N<<1];\nil void add(int x,int y,int w){\n    e[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;e[cnt].w=w;\n}\nint siz[N],ans=inf,rt=0,mxs=inf,SZ,d[N],U[N],V[N],q[N],bl[N];\nbool v[N];\nvoid frt(int x,int f){\n    siz[x]=1;\n    int res=0;\n    fl(i,x)if(!v[to]&&to!=f){\n        frt(to,x);\n        siz[x]+=siz[to];\n        res=MAX(res,siz[to]);\n    }\n    res=MAX(res,SZ-siz[x]);\n    if(res<mxs)rt=x,mxs=res;\n}\nvoid gd(int x,int f,int BL){\n    bl[x]=BL;\n    fl(i,x)if(to!=f)d[to]=d[x]+e[i].w,gd(to,x,BL);\n}\nil void op(){\n    cout<<ans<<endl;\n    exit(0);\n}\nvoid sol(int x){\n    if(v[x])op();\n    v[x]=1;d[x]=0;\n    fl(i,x)d[to]=e[i].w,gd(to,x,to);\n    int mx=0,len=0,las=0;\n    Fur(i,1,m)\n        if(d[U[i]]+d[V[i]]>mx)mx=d[U[i]]+d[V[i]],q[len=1]=i;\n        else if(d[U[i]]+d[V[i]]==mx)q[++len]=i;\n    ans=MIN(ans,mx);\n    Fur(i,1,len){\n        if(bl[U[q[i]]]!=bl[V[q[i]]])op();\n        if(!las)las=bl[U[q[i]]];\n        if(bl[U[q[i]]]!=las)op();\n    }\n    mxs=inf,SZ=siz[las];frt(las,0);sol(rt);\n}\nint main(){\n    in(n,m);\n    int x,y,w;\n    Fur(i,2,n)in(x,y,w),add(x,y,w),add(y,x,w);\n    Fur(i,1,m)in(U[i],V[i]);\n    SZ=n,mxs=inf;\n    frt(1,0);\n    sol(rt);\n    op();\n}\n```\n","link":null,"tags":["树链剖分","分治","点分治","树的重心"],"title":"LG 4886 快递员"},{"categories":[["刷题记录"]],"content":"\n$a$是确定的,考虑$b$的情况：\n\n1. 是$a$的祖先\n   \n   可以作为$b$的点的数量是$\\min(d_x,k)$($d_x$指$x$的深度),\n\n   $a$的子树中除$a$外其他点都可以作为$c$\n\n   总方案数为$\\min(d_x,k)\\times(siz_x-1)$\n\n2. 在$a$子树中\n   \n   对于每个$b$,可以作为$c$的点的数量为$siz_b-1$\n\n   我们可以dfs序,记录当前区间中深度为$d$的数\n\n   然后用主席树(可持久化权值线段树)维护\n\n   这样就可以查询深度$\\in [d_a+1,d_a+k]$的所有'点的子树大小-1'的和\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\n#define N 300011\nint n,q,cnt=0,head[N];\nstruct edge{\n    int to,nxt;\n}e[N<<1];\nil void add(int x,int y){\n    e[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;\n}\nint ls[N*20],rs[N*20],rt[N],sz=0;\nll s[N*20];\nvoid build(int l,int r,int &x){\n    s[x=++sz]=0;\n    if(l==r)return;\n    int m=(l+r)>>1;\n    build(l,m,ls[x]);build(m+1,r,rs[x]);\n}\nvoid ins(int p,int v,int l,int r,int &x,int pre){\n    x=++sz;\n    s[x]=s[pre]+v;\n    ls[x]=ls[pre];\n    rs[x]=rs[pre];\n    if(l==r)return;\n    int m=(l+r)>>1;\n    if(p<=m)ins(p,v,l,m,ls[x],ls[pre]);\n    else ins(p,v,m+1,r,rs[x],rs[pre]);\n}\nll ask(int L,int R,int l,int r,int x,int y){\n    if(L<=l&&r<=R)return s[y]-s[x];\n    int m=(l+r)>>1;\n    ll ans=0;\n    if(L<=m)ans=ask(L,R,l,m,ls[x],ls[y]);\n    if(R>m)ans+=ask(L,R,m+1,r,rs[x],rs[y]);\n    return ans;\n}\nint siz[N],d[N],st[N],ed[N],dfn=0,T[N];\nvoid dfs(int x,int f){\n    d[x]=d[f]+1;\n    siz[x]=1;\n    T[st[x]=++dfn]=x;\n    fl(i,x)if(to!=f){\n        dfs(to,x);\n        siz[x]+=siz[to];\n    }\n    ed[x]=dfn;\n}\nint main(){\n    in(n,q);\n    int x,y,w;\n    Fur(i,1,n-1)in(x,y),add(x,y),add(y,x);\n    dfs(1,0);\n    Fur(i,1,n)ins(d[T[i]],siz[T[i]]-1,1,n,rt[i],rt[i-1]);\n    while(q--){\n        in(x,w);\n        out(1ll*(siz[x]-1)*MIN(w,d[x]-1)+ask(d[x],MIN(d[x]+w,n),1,n,rt[st[x]],rt[ed[x]]),ln);\n    }\n    flush();\n}\n```\n","link":null,"tags":["主席树","dfs序"],"title":"LG 3899 [湖南集训]谈笑风生"},{"categories":[["刷题记录"]],"content":"\n我们考虑两个断点（设为$l,r$)符合的条件：\n\n每种颜色的珠子只能出现在其中一条链中\n\n也就是若$[l,r]$中出现了某种颜色$[l,r]$也就包含了所有的这种颜色\n\n我们可以记录颜色出现的前缀和\n\n记录前$i$个位置每种颜色的出现次数,如果位置$i$是 颜色$a[i]$的最后一个位置, 就把颜色 $a[i]$ 的结果清零。\n\n这样若两个位置的前缀和相同,就是合法的\n\n可以通过hash来判断,记录所有hash值,排序后统计\n\n两个分割点 $l,r$ 要尽可能满足 $r−l$ 接近 $\\frac n2$\n\n可以用类似双指针的方式维护\n\n这题卡hash,要双hash\n\n\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\n#define N 1000011\nint n,k,a[N],b[N],c[N],p1=133331,p2=23333,m1=100000007,m2=19260817,ans=inf;\nll s1[N],s2[N],cnt=0;\nstruct node{\n    int id,s1,s2;\n    bool operator<(node x)const{\n        if(s1!=x.s1)return s1<x.s1;\n        if(s2!=x.s2)return s2<x.s2;\n        return id<x.id;\n    }\n}t[N];\nint main(){\n    in(n,k);\n    s1[0]=s2[0]=1;\n    Fur(i,1,n)\n        in(a[i]),\n        s1[i]=s1[i-1]*p1%m1,\n        s2[i]=s2[i-1]*p2%m2;\n    Fdr(i,n,1)if(!b[a[i]])b[a[i]]=i;\n    ll sum1=0,sum2=0;\n    Fur(i,1,n){\n        ++c[a[i]];\n        sum1=(sum1+s1[a[i]])%m1;\n        sum2=(sum2+s2[a[i]])%m2;\n        if(b[a[i]]==i)\n            sum1=(sum1-s1[a[i]]*c[a[i]]%m1+m1)%m1,\n            sum2=(sum2-s2[a[i]]*c[a[i]]%m2+m2)%m2;\n        t[i]=node{i,sum1,sum2};\n    }\n    sort(t+1,t+n+1);\n    int mid=(n+1)\/2;\n    for(int i=1;i<=n;){\n        int nxt=i;\n        while(nxt<=n&&t[nxt].s1==t[i].s1&&t[nxt].s2==t[i].s2)++nxt;\n        cnt+=1ll*(nxt-i)*(nxt-i-1)\/2;\n        for(int l=i,r=i;r<nxt;++r){\n            while(l<r&&t[r].id-t[l].id>=mid)++l;\n            int tp=ABS(n-2*(t[r].id-t[l].id));\n            if(l>i){\n                int tmp=ABS(n-2*(t[r].id-t[l-1].id));\n                tp=MIN(tp,tmp);\n            }\n            ans=MIN(ans,tp);\n        }\n        i=nxt;\n    }\n    cout<<cnt<<\" \"<<ans<<endl;\n}\n```\n","link":null,"tags":["hash","计数","前缀和"],"title":"LG 3587 [POI2015]POD"},{"categories":[["刷题记录"]],"content":"\ndfs序作为下标,深度作为时间轴\n\n\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\n#define N 100011\n#define int ll\nint n,q,cnt=0,head[N],c[N];\nstruct edge{\n    int to,nxt;\n}e[N<<1];\nil void add(int x,int y){\n    e[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;\n}\nint s[N*30],ls[N*30],rs[N*30],sz=0,rt[N];\nvoid build(int l,int r,int &x){\n    s[x=++sz]=inf;\n    if(l==r)return;\n    int m=(l+r)>>1;\n    build(l,m,ls[x]);build(m+1,r,rs[x]);\n}\nvoid ins(int p,int v,int l,int r,int &x,int pre){\n    x=++sz;\n    ls[x]=ls[pre];\n    rs[x]=rs[pre];\n    if(l==r){\n        s[x]=v;\n        return;\n    }\n    int m=(l+r)>>1;\n    if(p<=m)ins(p,v,l,m,ls[x],ls[pre]);\n    else ins(p,v,m+1,r,rs[x],rs[pre]);\n    s[x]=MIN(s[ls[x]],s[rs[x]]);\n}\nint ask(int L,int R,int l,int r,int x){\n    if(L<=l&&r<=R)return s[x];\n    int m=(l+r)>>1,ans=inf;\n    if(L<=m)ans=ask(L,R,l,m,ls[x]);\n    if(R>m)ans=MIN(ans,ask(L,R,m+1,r,rs[x]));\n    return ans;\n}\nint st[N],ed[N],dfn=0,d[N],mxd=0;\nvoid dfs(int x,int f){\n    d[x]=d[f]+1;mxd=MAX(mxd,d[x]);\n    st[x]=++dfn;\n    fl(i,x)if(to!=f)dfs(to,x);\n    ed[x]=dfn;\n}\nvoid bfs(){\n    queue<int>q;q.push(1);\n    build(1,n,rt[0]);\n    int x,ld=0,pre;\n    while(!q.empty()){\n        x=q.front();q.pop();\n        if(d[x]!=ld)pre=rt[d[x]-1];\n        else pre=rt[d[x]];\n        ins(st[x],c[x],1,n,rt[d[x]],pre);\n        fl(i,x)if(d[to]>d[x])q.push(to);\n        ld=d[x];\n    }\n}\nsigned main(){\n    in(n,q);\n    Fur(i,1,n)in(c[i]);\n    int x,y,la=0;\n    Fur(i,1,n-1)in(x,y),add(x,y),add(y,x);\n    dfs(1,0);\n    bfs();\n    while(q--){\n        in(x,y);\n        x=(x+la)%n+1;\n        y=(y+la)%n;\n        la=ask(st[x],ed[x],1,n,rt[MIN(d[x]+y,mxd)]);\n        out(la,ln);\n    }\n    flush();\n}\n```\n","link":null,"tags":["主席树","dfs序"],"title":"LG CF893F Subtree-Minimum-Query"},{"categories":[["刷题记录"]],"content":"\n仔细看题意,发现$k$最大只有$400$\n\n解法1： 堆 贪心\n\n先把和每个点相连的所有边按边权从小到大排序。\n\n考虑一条路径的两个端点,如果这两个端点间的路径第一次被弹出（是两点间最短路）,则我们向其中一端扩展一条与它相连的最短边。\n\n现在假设堆顶有一条路径$u\\rightarrow v$,它的一个端点$v$是由$u\\rightarrow$扩展来的,此时我们可以尝试把与$x$相连的边中比$x\\rightarrow v$权值略大的取出来（即排好序后的下一条边）,压到堆中。\n\n因为要处理两个端点比较麻烦,我们转化成有向路径（只有一个端点）,然后取第$2k$大的。\n\n记住我们需要维护的信息：路径的两个端点$st,ed$,端点$ed$前面的点$x$（即$ed$是由$st\\rightarrow x$扩展来的）,以及这条路径的长度。\n\n解法2： floyd\n\n考虑答案应该小于等于第$k$小的边的长度。因此只有前$k$小的边对答案有贡献。这$k$条边构成的子图的节点数也是$O(k)$的,于是我们就可以做floyd了。\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\n#define N 200011\nint n,m,k;\nstruct edge{\n    int to,w;\n    bool operator<(edge x)const {\n        return w<x.w;\n    }\n};\nvector<edge>e[N];\nstruct node{\n    int x,y,idx;\n    ll v;\n    bool operator<(node a)const{\n        return v>a.v;\n    }\n};\npriority_queue<node>q;\n#include<bits\/extc++.h>\nusing namespace __gnu_pbds;\ncc_hash_table<int,bool>b[N];\nsigned main(){\n    in(n,m,k);\n    int x,y,w;\n    Fur(i,1,m)\n        in(x,y,w),\n        e[x].push_back({y,w}),\n        e[y].push_back({x,w});\n    Fur(i,1,n){\n        b[i][i]=1,sort(e[i].begin(),e[i].end());\n        q.push({i,i,0,e[i][0].w});\n    }\n    k<<=1;\n    while(!q.empty()){\n        node t=q.top();q.pop();\n        int x=t.x,y=t.y;\n        if(!b[x][e[y][t.idx].to]){\n            b[x][e[y][t.idx].to]=1;\n            --k;\n            if(!k)return cout<<t.v<<endl,0;\n            q.push({x,e[y][t.idx].to,0,t.v+e[e[y][t.idx].to][0].w});\n        }\n        if(t.idx+1<e[y].size())\n            q.push({x,y,t.idx+1,t.v-e[y][t.idx].w+e[y][t.idx+1].w});\n    }\n}\n```\n","link":null,"tags":["堆","贪心","floyed"],"title":"LG CF1196F K-th-Path"},{"categories":[["刷题记录"]],"content":"\n模板\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\n#define N 100011\nint n,cnt=0,head[N],val[N];\nstruct edge{\n    int to,nxt;\n}e[N<<1];\nil void add(int x,int y){\n    e[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;\n}\nint RT[N*20],s[N*20],sz=0,ls[N*20],rs[N*20];\nvoid ins(int l,int r,int p,int &x,int pre){\n    s[x=++sz]=s[pre]+1;\n    if(l==r)return;\n    ls[x]=ls[pre];\n    rs[x]=rs[pre];\n    int m=(l+r)>>1;\n    if(p<=m)ins(l,m,p,ls[x],ls[pre]);\n    else ins(m+1,r,p,rs[x],rs[pre]);\n}\nint ask(int k,int l,int r,int x,int y,int lca,int ff){\n    if(l==r)return l;\n    int m=(l+r)>>1,sum=s[ls[x]]+s[ls[y]]-s[ls[lca]]-s[ls[ff]];\n    if(sum>=k)return ask(k,l,m,ls[x],ls[y],ls[lca],ls[ff]);\n    else return ask(k-sum,m+1,r,rs[x],rs[y],rs[lca],rs[ff]);\n}\nint top[N],f[N],d[N],siz[N];\nvoid dfs(int x){\n    siz[x]=1;\n    fl(i,x)if(to!=f[x]){\n        d[to]=d[x]+1;\n        f[to]=x;\n        dfs(to);\n        siz[x]+=siz[to];\n    }\n}\nvoid bt(int x,int tp){\n    top[x]=tp;ins(1,n,val[x],RT[x],RT[f[x]]);\n    int k=0;\n    fl(i,x)if(to!=f[x]&&siz[to]>siz[k])k=to;\n    if(!k)return;bt(k,tp);\n    fl(i,x)if(!top[to])bt(to,to);\n}\nint glca(int x,int y){\n    while(top[x]!=top[y]){\n        if(d[top[x]]<d[top[y]])SWAP(x,y);\n        x=f[top[x]];\n    }\n    return d[x]<d[y]?x:y;\n}\nstruct node{\n    int v,p;\n    bool operator<(node x)const{\n        return v<x.v;\n    }\n}a[N];\nint old[N];\nint main(){\n    int x,y,k,q;\n    in(n,q);\n    Fur(i,1,n)in(a[i].v),a[i].p=i;\n    sort(a+1,a+n+1);\n    int tt=0;\n    Fur(i,1,n)old[val[a[i].p]=(tt+=a[i].v!=a[i-1].v)]=a[i].v;\n    Fur(i,1,n-1)in(x,y),add(x,y),add(y,x);\n    dfs(1);bt(1,1);\n    while(q--){\n        in(x,y,k);\n        int lca=glca(x,y);\n        out(old[ask(k,1,n,RT[x],RT[y],RT[lca],RT[f[lca]])],ln);\n    }\n    flush();\n}\n```\n","link":null,"tags":["树链剖分","主席树"],"title":"LG SP10628 COT Count-on-a-tree"},{"categories":[["刷题记录"]],"content":"\n可以先rmq预处理出区间gcd和区间min\n\n若区间gcd=区间min那么这个区间是合法的\n\n若一个区间合法,那么它一定有合法的子区间\n\n我们可以根据这个性质二分区间长度\n\n~~解↓决↑!~~\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\n#define N 300011\nint n,a[N],v[1000001],s[21][N],b[21][N];\nil void st(){\n    int sz=l2(n);\n    Fur(k,1,sz)\n        Fur(i,1,n-(1<<k)+1)\n            s[k][i]=GCD(s[k-1][i],s[k-1][i+(1<<(k-1))]),\n            b[k][i]=MIN(b[k-1][i],b[k-1][i+(1<<(k-1))]);\n}\nil int get(int l,int r){\n    int k=l2(r-l+1);\n    return MIN(b[k][l],b[k][r-(1<<k)+1])==GCD(s[k][l],s[k][r-(1<<k)+1]);\n}\nint as[N],tt=0,ttt=0;\nil bool chk(int w){\n    tt=0;\n    Fur(i,1,n-w)if(get(i,i+w))as[++tt]=i;\n    return tt;\n}\nint main(){\n    in(n);\n    Fur(i,1,n)in(a[i]),s[0][i]=b[0][i]=a[i];\n    st();\n    int l=0,r=n-1,res=0;\n    while(l<=r){\n        int m=(l+r)>>1;\n        if(chk(m)){\n            res=m;ttt=tt;\n            l=m+1;\n        }\n        else r=m-1;\n    }\n    out(ttt,\" \",res,ln);\n    Fur(i,1,ttt)out(as[i],\" \");\n    flush();\n}\n```\n","link":null,"tags":["rmq","二分"],"title":"LG CF359D Pair-of-Numbers"},{"categories":[["刷题记录"]],"content":"\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\n#define N 200011\n#define int ll\nint n,q,s,t,a[N];\nint qwq(int x){\n    if(x>0)return -x*s;\n    else return -x*t;\n}\nsigned main(){\n    in(n,q,s,t);\n    int l,r,v,la,ans=0;\n    in(la);\n    Fur(i,1,n)in(v),ans+=qwq(a[i]=v-la),la=v;\n    while(q--){\n        in(l,r,v);\n        ans-=qwq(a[l]);\n        ans+=qwq(a[l]+=v);\n        if(r!=n){\n            ans-=qwq(a[r+1]);\n            ans+=qwq(a[r+1]-=v);\n        }\n        out(ans,ln);\n    }\n    flush();\n}\n```\n","link":null,"tags":["差分"],"title":"LG AT2442 フェーン現象"},{"categories":[["刷题记录"]],"content":"\n可以先看一下[LG P4868 Preprefix sum](https:\/\/www.luogu.com.cn\/problem\/P4868),很经典一道题,维护一下后缀和就可以了\n\n这题的话就是把上面那道题变了一下\n\n由于值域太大,我们可以使用 动态开点线段树 或 树状数组+离散化\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\n#define N 100011\nint n,ls[N*20],rs[N*20],sz=1;\nll s[N*20],ps[N*20];\n#define pu s[x]=s[ls[x]]+s[rs[x]],ps[x]=ps[ls[x]]+ps[rs[x]]\nvoid add(int p,int v,int l=0,int r=INT_MAX,int x=1){\n    if(l==r){\n        s[x]+=v;\n        ps[x]+=1ll*v*(INT_MAX-p+1);\n        return;\n    }\n    int m=(l+r)>>1;\n    if(p<=m)add(p,v,l,m,ls[x]?ls[x]:ls[x]=++sz);\n    else add(p,v,m+1,r,rs[x]?rs[x]:rs[x]=++sz);\n    pu;\n}\nll ask(int p,int l=0,int r=INT_MAX,int x=1){\n    if(r<=p)return ps[x]-s[x]*(INT_MAX-p);\n    int m=(l+r)>>1;\n    return ask(p,l,m,ls[x])+((p>m)?ask(p,m+1,r,rs[x]):0);\n}\nint main(){\n    int q;\n    in(n,q);\n    int opt,x,y;\n    Fur(i,1,n){\n        in(x,y);\n        add(x,y);\n    }\n    while(q--){\n        in(opt,x,y);\n        if(opt==1){\n            db ans=(long db)(ask(y)-ask(x-1))\/(long db)(y-x+1);\n            printf(\"%.4f\\n\",ans);\n        }\n        else add(x,y);\n    }\n}\n```\n","link":null,"tags":["期望","前缀和","树状数组","离散化","线段树"],"title":"LG 4915 帕秋莉的魔导书"},{"categories":[["刷题记录"]],"content":"\nCount-on-a-tree-II\ntop: 0\n\n\n树上莫队模板\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\nconst int N=40011,M=100011;\nint n,cnt=0,head[N],val[N],old[N];\nstruct edge{\n    int to,nxt;\n}e[N<<1];\nil void add(int x,int y){\n    e[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;\n}\nint T[N*2],dfn=0,st[N],ed[N],top[N],siz[N],f[N],d[N];\nvoid dfs(int x){\n    T[st[x]=++dfn]=x;\n    siz[x]=1;\n    fl(i,x)if(to!=f[x]){\n        f[to]=x;\n        d[to]=d[x]+1;\n        dfs(to);\n        siz[x]+=siz[to];\n    }\n    T[ed[x]=++dfn]=x;\n}\nvoid bt(int x,int tp){\n    top[x]=tp;\n    int k=0;\n    fl(i,x)if(to!=f[x]&&siz[to]>siz[k])k=to;\n    if(!k)return;bt(k,tp);\n    fl(i,x)if(!top[to])bt(to,to);\n}\nil int lca(int x,int y){\n    while(top[x]!=top[y]){\n        if(d[top[x]]<d[top[y]])SWAP(x,y);\n        x=f[top[x]];\n    }\n    return d[x]<d[y]?x:y;\n}\nint blk,bl[N<<1];\nstruct que{\n    int l,r,lca,id;\n    il bool operator<(que t)const{\n        return (bl[l]==bl[t.l])?((bl[l]&1)?r<t.r:r>t.r):(l<t.l);\n    }\n}Q[M];\nint ans=0,c[N],ANS[M];\nbool v[N];\nil void inc(int x){ans+=!c[val[x]]++;}\nil void dec(int x){ans-=!--c[val[x]];}\nil void op(int x){\n    v[x]?dec(x):inc(x);\n    v[x]^=1;\n}\nstruct node{\n    int v,p;\n    il bool operator<(node t)const{\n        return v<t.v;\n    }\n}a[N];\nint main(){\n    int q,x,y,l=1,r=0;\n    in(n,q);\n    blk=n*2\/sqrt(q*2\/3);\n    Fur(i,1,n*2)bl[i]=(i-1)\/blk+1;\n    Fur(i,1,n)in(a[i].v),a[i].p=i;\n    sort(a+1,a+n+1);\n    int tt=0;\n    Fur(i,1,n)old[val[a[i].p]=(tt+=a[i].v!=a[i-1].v)]=a[i].v;\n    Fur(i,1,n-1)in(x,y),add(x,y),add(y,x);\n    dfs(1);bt(1,1);\n    Fur(i,1,q){\n        in(x,y);\n        if(st[x]>st[y])SWAP(x,y);\n        int t=lca(x,y);\n        if(t==x)Q[i]=que{st[x],st[y],0,i};\n        else Q[i]=que{ed[x],st[y],t,i};\n    }\n    sort(Q+1,Q+q+1);\n    Fur(i,1,q){\n        while(l>Q[i].l)op(T[--l]);\n        while(r<Q[i].r)op(T[++r]);\n        while(l<Q[i].l)op(T[l++]);\n        while(r>Q[i].r)op(T[r--]);\n        if(Q[i].lca)op(Q[i].lca);\n        ANS[Q[i].id]=ans;\n        if(Q[i].lca)op(Q[i].lca);\n    }\n    Fur(i,1,q)out(ANS[i],ln);\n    flush();\n}\n```\n","link":null,"tags":["树上莫队"],"title":"LG SP10707 COT2"},{"categories":[["刷题记录"]],"content":"\n长链剖分模板\n\n长链剖分优化dp\n\n设$f_{x,i}$表示$x$子树内与$x$距离为$i$的点的个数\n\n$$\nf_{x,i}= \\sum f_{to,i-1}\n\\\\\\\\\n(f_{x,0}=1)\n$$\n\n可以发现$x$从它的儿子继承答案\n\n这时就可以用长链剖分优化dp了(一种类似$\\text{dsu on tree}$的方法)\n\n设$len_x$为$x$到叶节点的最长距离\n\n我们将$\\max len_{to}$设为$x$的重儿子\n\n$x$直接继承重儿子的答案,而不用重新再算一次\n\n其他的儿子再按普通方式计算\n\n因为每条链只会被合并一次,因此总复杂度就是$\\Theta(n)$！\n\n\n```cpp\n#include<bits\/stdc++.h>\n#define il __inline__ __attribute__ ((always_inline))\n#define Fur(i,x,y) for(int i(x);i<=y;++i)\n#define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\nusing namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\n#define N 1000011\nint n,cnt=0,head[N];\nstruct edge{\n    int to,nxt;\n}e[N<<1];\nil void add(int x,int y){\n    e[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;\n}\nint len[N],son[N],ans[N],tmp[N],*f[N],*id=tmp;\nvoid dfs(int x,int fa){\n    fl(i,x)if(to!=fa){\n        dfs(to,x);\n        if(len[to]>len[son[x]])son[x]=to;\n    }\n    len[x]=len[son[x]]+1;\n}\nvoid dp(int x,int fa){\n    f[x][0]=1;\n    if(son[x])f[son[x]]=f[x]+1,dp(son[x],x),ans[x]=ans[son[x]]+1;\n    \/*\n    有重儿子\n\n    len_x=len_{son_x}+1 , 所以把后面的空间直接开给son_x\n\n    计算完重儿子x就可以直接继承了\n\n    当然答案的深度+1\n\n    *\/\n    fl(i,x)if(to!=fa&&to!=son[x]){\n        f[to]=id;id+=len[to];dp(to,x);\n        \/\/其他儿子暴力计算\n        Fur(j,1,len[to]){\n            f[x][j]+=f[to][j-1];\n            if(j<ans[x]&&f[x][j]>=f[x][ans[x]]||(j>ans[x]&&f[x][j]>f[x][ans[x]]))ans[x]=j;\n        }\n    }\n    if(f[x][ans[x]]==1)ans[x]=0;\n}\nint main(){\n    in(n);\n    int x,y;\n    Fur(i,1,n-1){\n        in(x,y);\n        add(x,y),add(y,x);\n    }\n    dfs(1,0);\n    f[1]=id;id+=len[1];\/\/分配len_1的空间给1计算\n    dp(1,0);\n    Fur(i,1,n)out(ans[i],ln);\n    flush();\n}\n```\n","link":null,"tags":["长链剖分"],"title":"LG CF1009F Dominant-Indices"},{"categories":[["刷题记录"]],"content":"\n我们可以用倍增求出能控制某个点$x$的最远的点$y$的位置\n\n应该将$f_x$到$y$的点的答案+1\n\n我们可以差分一下,\n\n$++ans_{f_x},--ans_{f_y}$\n\n然后从下加得到的就是当前点的答案\n\n记得开long long\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\n#define N 200011\nint n,head[N],cnt=0,f[21][N],ans[N];\nll d[N],c[N];\nstruct edge{\n    int to,nxt,w;\n}e[N];\nvoid add(int x,int y,int w){\n    e[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;e[cnt].w=w;\n}\nvoid dfs(int x){\n    Fur(k,1,20)f[k][x]=f[k-1][f[k-1][x]];\n    fl(i,x){\n        d[to]=d[x]+e[i].w;f[0][to]=x;\n        dfs(to);\n        ans[x]+=ans[to];\n    }\n    int now=x;\n    Fdr(k,20,0)\n    if(f[k][now]&&d[x]-d[f[k][now]]<=c[x])\n        now=f[k][now];\n    ++ans[f[0][x]];\n    --ans[f[0][now]];\n}\nint main(){\n    in(n);\n    Fur(i,1,n)in(c[i]);\n    int w;\n    Fur(i,2,n)in(f[0][i],w),add(f[0][i],i,w);\n    dfs(1);\n    Fur(i,1,n)out(ans[i],\" \");\n    flush();\n}\n```\n","link":null,"tags":["差分","倍增","前缀和"],"title":"LG CF739B Alyona-and-a-tree"},{"categories":[["刷题记录"]],"content":"\n总和减去最小割即为答案\n\n最小割删掉的边就是要减去的值,这样就可以最小化要减去的值,即答案最大化\n\n那我们如何构造这张图呢?\n\n1. $ST \\xrightarrow{\\text{选文科的值}} (i,j) \\xrightarrow{\\text{选理科的值}}ED$\n   \n2. $ST \\xrightarrow{\\text{同时选文科的额外快乐}}new,new\\rightarrow(i,j),new\\rightarrow(i+1,j)$(其他同理)\n   \n3. $(i,j)\\rightarrow new,(i+1,j)\\rightarrow new,new \\xrightarrow{\\text{同时选理科的额外快乐}}ED$(其他同理)\n\n每个点只能选择文科或理科,当某个点选择了文科,那么它向理科(ED)的边都应该要被断开。\n\n它直接连向ED的边、它和别的点组合连向ED的边都要切断\n\n这些边的权值就会从最终答案中减去\n\n<svg width=\"701px\" height=\"701px\"><g><g><g><path d=\"M 366.42685126423726 297.01122406350703 L 69.59851319063789 367.32614574153\" fill=\"none\" stroke-width=\"2\" stroke=\"black\"><\/path><path d=\"M 366.42685126423726 297.01122406350703 L 69.59851319063789 367.32614574153\" opacity=\"0\" fill=\"none\" stroke-width=\"30\" stroke=\"black\"><\/path><text font-size=\"15px\" dy=\"0.35em\" text-anchor=\"middle\" style=\"user-select: none;\" x=\"203.08299255371094\" y=\"319.824951171875\">inf<\/text><path stroke=\"black\" fill=\"black\" d=\"M -15 7.5 L 0 0 L -15 -7.5 Z\" transform=\"translate (88.18415832519531 362.9234313964844) rotate(166.6733220082538)\"><\/path><\/g><g><path d=\"M 366.42685126423726 297.01122406350703 L 662 359.99965163378397\" fill=\"none\" stroke-width=\"2\" stroke=\"black\"><\/path><path d=\"M 366.42685126423726 297.01122406350703 L 662 359.99965163378397\" opacity=\"0\" fill=\"none\" stroke-width=\"30\" stroke=\"black\"><\/path><text font-size=\"15px\" dy=\"0.35em\" text-anchor=\"middle\" style=\"user-select: none;\" x=\"529.1431274414062\" y=\"316.16168212890625\">inf<\/text><path stroke=\"black\" fill=\"black\" d=\"M -15 7.5 L 0 0 L -15 -7.5 Z\" transform=\"translate (643.3194580078125 356.01873779296875) rotate(12.029297457258082)\"><\/path><\/g><g><path d=\"M 364.74554582466936 69.59851319063789 L 366.42685126423726 297.01122406350703\" fill=\"none\" stroke-width=\"2\" stroke=\"black\"><\/path><path d=\"M 364.74554582466936 69.59851319063789 L 366.42685126423726 297.01122406350703\" opacity=\"0\" fill=\"none\" stroke-width=\"30\" stroke=\"black\"><\/path><text font-size=\"15px\" dy=\"0.35em\" text-anchor=\"middle\" style=\"user-select: none;\" x=\"408.093994140625\" y=\"183.20348001051042\">同时选文科<\/text><path stroke=\"black\" fill=\"black\" d=\"M -15 7.5 L 0 0 L -15 -7.5 Z\" transform=\"translate (366.28564453125 277.9117431640625) rotate(89.57713222549252)\"><\/path><\/g><g><path d=\"M 662 359.99965163378397 L 367.32129017837025 661.8540224083981\" fill=\"none\" stroke-width=\"2\" stroke=\"black\"><\/path><path d=\"M 662 359.99965163378397 L 367.32129017837025 661.8540224083981\" opacity=\"0\" fill=\"none\" stroke-width=\"30\" stroke=\"black\"><\/path><text font-size=\"15px\" dy=\"0.35em\" text-anchor=\"middle\" style=\"user-select: none;\" x=\"487.15283203125\" y=\"498.22804661328314\">选理科<\/text><path stroke=\"black\" fill=\"black\" d=\"M -15 7.5 L 0 0 L -15 -7.5 Z\" transform=\"translate (380.59375 648.2583618164062) rotate(134.3112058351374)\"><\/path><\/g><g><path d=\"M 364.74554582466936 69.59851319063789 L 662 359.99965163378397\" fill=\"none\" stroke-width=\"2\" stroke=\"black\"><\/path><path d=\"M 364.74554582466936 69.59851319063789 L 662 359.99965163378397\" opacity=\"0\" fill=\"none\" stroke-width=\"30\" stroke=\"black\"><\/path><text font-size=\"15px\" dy=\"0.35em\" text-anchor=\"middle\" style=\"user-select: none;\" x=\"540.880615234375\" y=\"201.12721252441406\">选文科<\/text><path stroke=\"black\" fill=\"black\" d=\"M -15 7.5 L 0 0 L -15 -7.5 Z\" transform=\"translate (648.3377075195312 346.65234375) rotate(44.329078091112564)\"><\/path><\/g><g><path d=\"M 366.16238212372537 450.0657305441708 L 367.32129017837025 661.8540224083981\" fill=\"none\" stroke-width=\"2\" stroke=\"black\"><\/path><path d=\"M 366.16238212372537 450.0657305441708 L 367.32129017837025 661.8540224083981\" opacity=\"0\" fill=\"none\" stroke-width=\"30\" stroke=\"black\"><\/path><text font-size=\"15px\" dy=\"0.35em\" text-anchor=\"middle\" style=\"user-select: none;\" x=\"409.2496643066406\" y=\"555.888781785965\">同时选理科<\/text><path stroke=\"black\" fill=\"black\" d=\"M -15 7.5 L 0 0 L -15 -7.5 Z\" transform=\"translate (367.2167663574219 642.7542724609375) rotate(89.68627984680484)\"><\/path><\/g><g><path d=\"M 69.59851319063789 367.32614574153 L 366.16238212372537 450.0657305441708\" fill=\"none\" stroke-width=\"2\" stroke=\"black\"><\/path><path d=\"M 69.59851319063789 367.32614574153 L 366.16238212372537 450.0657305441708\" opacity=\"0\" fill=\"none\" stroke-width=\"30\" stroke=\"black\"><\/path><text font-size=\"15px\" dy=\"0.35em\" text-anchor=\"middle\" style=\"user-select: none;\" x=\"232.81011962890625\" y=\"396.3599853515625\">inf<\/text><path stroke=\"black\" fill=\"black\" d=\"M -15 7.5 L 0 0 L -15 -7.5 Z\" transform=\"translate (347.76495361328125 444.9329528808594) rotate(15.590839129065841)\"><\/path><\/g><g><path d=\"M 662 359.99965163378397 L 366.16238212372537 450.0657305441708\" fill=\"none\" stroke-width=\"2\" stroke=\"black\"><\/path><path d=\"M 662 359.99965163378397 L 366.16238212372537 450.0657305441708\" opacity=\"0\" fill=\"none\" stroke-width=\"30\" stroke=\"black\"><\/path><text font-size=\"15px\" dy=\"0.35em\" text-anchor=\"middle\" style=\"user-select: none;\" x=\"499.1436767578125\" y=\"392.68896484375\">inf<\/text><path stroke=\"black\" fill=\"black\" d=\"M -15 7.5 L 0 0 L -15 -7.5 Z\" transform=\"translate (384.4343566894531 444.5029296875) rotate(163.06625459626565)\"><\/path><\/g><g><path d=\"M 69.59851319063789 367.32614574153 L 367.32129017837025 661.8540224083981\" fill=\"none\" stroke-width=\"2\" stroke=\"black\"><\/path><path d=\"M 69.59851319063789 367.32614574153 L 367.32129017837025 661.8540224083981\" opacity=\"0\" fill=\"none\" stroke-width=\"30\" stroke=\"black\"><\/path><text font-size=\"15px\" dy=\"0.35em\" text-anchor=\"middle\" style=\"user-select: none;\" x=\"245.96771240234375\" y=\"501.582275390625\">选理科<\/text><path stroke=\"black\" fill=\"black\" d=\"M -15 7.5 L 0 0 L -15 -7.5 Z\" transform=\"translate (353.81396484375 648.4916381835938) rotate(44.691477026263726)\"><\/path><\/g><g><path d=\"M 364.74554582466936 69.59851319063789 L 69.59851319063789 367.32614574153\" fill=\"none\" stroke-width=\"2\" stroke=\"black\"><\/path><path d=\"M 364.74554582466936 69.59851319063789 L 69.59851319063789 367.32614574153\" opacity=\"0\" fill=\"none\" stroke-width=\"30\" stroke=\"black\"><\/path><text font-size=\"15px\" dy=\"0.35em\" text-anchor=\"middle\" style=\"user-select: none;\" x=\"189.6642303466797\" y=\"204.90884896565618\">选文科<\/text><path stroke=\"black\" fill=\"black\" d=\"M -15 7.5 L 0 0 L -15 -7.5 Z\" transform=\"translate (82.97493743896484 353.832763671875) rotate(134.74968255229285)\"><\/path><\/g><\/g><g><g fixed=\"false\" style=\"cursor: pointer;\"><circle stroke-width=\"5\" fill=\"white\" stroke=\"black\" r=\"19\" cx=\"364.74554582466936\" cy=\"69.59851319063789\"><\/circle><text font-size=\"14\" dy=\".35em\" text-anchor=\"middle\" stroke-width=\"1\" fill=\"black\" stroke=\"black\" x=\"364.74554582466936\" y=\"69.59851319063789\" style=\"user-select: none;\">ST<\/text><\/g><g fixed=\"false\" style=\"cursor: pointer;\"><circle stroke-width=\"5\" fill=\"white\" stroke=\"black\" r=\"19\" cx=\"69.59851319063789\" cy=\"367.32614574153\"><\/circle><text font-size=\"14\" dy=\".35em\" text-anchor=\"middle\" stroke-width=\"1\" fill=\"black\" stroke=\"black\" x=\"69.59851319063789\" y=\"367.32614574153\" style=\"user-select: none;\">(i,j)<\/text><\/g><g fixed=\"false\" style=\"cursor: pointer;\"><circle stroke-width=\"5\" fill=\"white\" stroke=\"black\" r=\"19\" cx=\"367.32129017837025\" cy=\"661.8540224083981\"><\/circle><text font-size=\"14\" dy=\".35em\" text-anchor=\"middle\" stroke-width=\"1\" fill=\"black\" stroke=\"black\" x=\"367.32129017837025\" y=\"661.8540224083981\" style=\"user-select: none;\">ED<\/text><\/g><g fixed=\"false\" style=\"cursor: pointer;\"><circle stroke-width=\"5\" fill=\"white\" stroke=\"black\" r=\"19\" cx=\"662\" cy=\"359.99965163378397\"><\/circle><text font-size=\"14\" dy=\".35em\" text-anchor=\"middle\" stroke-width=\"1\" fill=\"black\" stroke=\"black\" x=\"662\" y=\"359.99965163378397\" style=\"user-select: none;\">(i+1,j)<\/text><\/g><g fixed=\"false\" style=\"cursor: pointer;\"><circle stroke-width=\"5\" fill=\"white\" stroke=\"black\" r=\"19\" cx=\"366.42685126423726\" cy=\"297.01122406350703\"><\/circle><text font-size=\"14\" dy=\".35em\" text-anchor=\"middle\" stroke-width=\"1\" fill=\"black\" stroke=\"black\" x=\"366.42685126423726\" y=\"297.01122406350703\" style=\"user-select: none;\">new<\/text><\/g><g fixed=\"false\" style=\"cursor: pointer;\"><circle stroke-width=\"5\" fill=\"white\" stroke=\"black\" r=\"19\" cx=\"366.16238212372537\" cy=\"450.0657305441708\"><\/circle><text font-size=\"14\" dy=\".35em\" text-anchor=\"middle\" stroke-width=\"1\" fill=\"black\" stroke=\"black\" x=\"366.16238212372537\" y=\"450.0657305441708\" style=\"user-select: none;\">new'<\/text><\/g><\/g><\/g><\/svg>\n\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf (1<<30)\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?__=1,EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\nconst int N=100011,M=5000011;\nint n,m,cnt=1,head[N],ST,ED,d[N],q[N];\nstruct edge{\n    int to,nxt,w;\n}e[M];\n#define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\nvoid add(int x,int y,int w){\n    e[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;e[cnt].w=w;\n    e[++cnt].to=x;e[cnt].nxt=head[y];head[y]=cnt;e[cnt].w=0;\n}\nbool bfs(){\n    int h=0,t=1,x;\n    memset(d,0,sizeof d);\n    q[h]=ST;d[ST]=1;\n    while(h<t){\n        x=q[h++];\n        if(x==ED)return 1;\n        fl(i,x)if(!d[to]&&e[i].w)\n            d[to]=d[x]+1,q[t++]=to;\n    }\n    return 0;\n}\nint dfs(int x,int mf){\n    if(x==ED)return mf;\n    int us=0,w;\n    fl(i,x)if(e[i].w&&d[to]==d[x]+1){\n        w=dfs(to,min(mf-us,e[i].w));\n        e[i].w-=w;\n        e[i^1].w+=w;\n        us+=w;\n        if(us==mf)return mf;\n    }\n    if(!us)d[x]=-1;\n    return us;\n}\nint id(int x,int y){\n    return (x-1)*m+y;\n}\nint main(){\n    in(n,m);\n    ST=0,ED=n*m+2*(n-1)*m+2*n*(m-1)+1;\n    int ans=0,w,tt=n*m;\n    \/\/选文科ST→(i,j)\n    Fur(i,1,n)Fur(j,1,m)\n        in(w),ans+=w,\n        add(ST,id(i,j),w);\n    \/\/选理科(i,j)→ED\n    Fur(i,1,n)Fur(j,1,m)\n        in(w),ans+=w,\n        add(id(i,j),ED,w);\n    \/\/ST→new,new→(i,j),new→(i+1,j)\n    Fur(i,1,n-1)Fur(j,1,m)\n        in(w),ans+=w,\n        add(ST,++tt,w),\n        add(tt,id(i,j),inf),\n        add(tt,id(i+1,j),inf);\n    \/\/(i,j)→new,(i+1,j)→new,new→ED\n    Fur(i,1,n-1)Fur(j,1,m)\n        in(w),ans+=w,\n        add(++tt,ED,w),\n        add(id(i,j),tt,inf),\n        add(id(i+1,j),tt,inf);\n    \/\/ST→new,new→(i,j),new→(i,j+1)\n    Fur(i,1,n)Fur(j,1,m-1)\n        in(w),ans+=w,\n        add(ST,++tt,w),\n        add(tt,id(i,j),inf),\n        add(tt,id(i,j+1),inf);\n    \/\/(i,j)→new,(i,j+1)→new,new→ED\n    Fur(i,1,n)Fur(j,1,m-1)\n        in(w),ans+=w,\n        add(++tt,ED,w),\n        add(id(i,j),tt,inf),\n        add(id(i,j+1),tt,inf);\n    \n    while(bfs())ans-=dfs(ST,inf);\n    printf(\"%d\\n\",ans);\n}\n```\n","link":null,"tags":["网络流","最小割"],"title":"LG 1646 [国家集训队]happiness"},{"categories":[["刷题记录"]],"content":"\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?__=1,EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\nconst int N=100011;\nint n,q,a[N],blk;\nstruct que{\n    int l,r,bl,br,id;\n}Q[N];\nvoid inc(int x){\n\n}\nvoid dec(int x){\n\n}\nint main(){\n    in(n,q);\n    blk=sqrt(n);\n    Fur(i,1,n)in(a[i]);\n    Fur(i,1,q){\n\n    }\n}\n```\n","link":null,"tags":["带修莫队"],"title":"LG CF940F Machine-Learning"},{"categories":[["刷题记录"]],"content":"\n$f[i][j]$表示前$i$个分$j$个邮局\n\n$f[i][j]=\\min(f[x][j-1]+w[x+1][i])$\n\n满足决策单调性\n\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\n#define N 3011\nint n,m,a[N],k[N][N];\nll w[N][N],f[311][N];\nint main(){\n    in(n,m);\n    Fur(i,1,n)in(a[i]);\n    sort(a+1,a+n+1);\n    Fur(i,1,n)\n        Fur(j,i+1,n)\n            w[i][j]=w[i][j-1]+a[j]-a[(i+j)>>1];\n    Fur(i,1,n)f[1][i]=w[1][i],k[1][i]=0;\n    Fur(i,2,m){\n        k[i][n+1]=n;\n        Fdr(j,n,i+1){\n            f[i][j]=1ll<<60;\n            Fur(x,k[i-1][j],k[i][j+1])\n            if(f[i-1][x]+w[x+1][j]<f[i][j]){\n                f[i][j]=f[i-1][x]+w[x+1][j];\n                k[i][j]=x;\n            }\n        }\n    }\n    cout<<f[m][n]<<endl;\n}\n```\n","link":null,"tags":["动态规划","四边形不等式","数论"],"title":"LG 4767 [IOI2000]邮局"},{"categories":[["刷题记录"]],"content":"\n设$f_i$表示以$i$开头合法子序列方案数\n\n$f_i=\\sum_{j=i+a_i+1}^{n+1} f_j \\times {j-i+1 \\choose a_i}$\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\n#define N 1011\nint n,a[N],c[N][N],mod=998244353;\nll f[N];\nint main(){\n    in(n);\n    Fur(i,0,1000){\n        c[i][0]=c[i][i]=1;\n        Fur(j,1,i-1)\n            c[i][j]=(c[i-1][j]+c[i-1][j-1])%mod;\n    }\n    Fur(i,1,n)in(a[i]);\n    f[n+1]=1;\n    Fdr(i,n,1)if(a[i]>0){\n        Fur(j,i+a[i]+1,n+1)\n            f[i]=(f[i]+f[j]*1ll*c[j-i-1][a[i]]%mod)%mod;\n    }\n    ll ans=0;\n    Fur(i,1,n)ans=(ans+f[i])%mod;\n    cout<<ans<<endl;\n}\n```\n","link":null,"tags":["动态规划"],"title":"LG CF1000D Yet-Another-Problem-On-a-Subsequence"},{"categories":[["刷题记录"]],"content":"\n动态开点线段树模板\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\n#define N 15001000\n#define pu s[x]=s[ls[x]]+s[rs[x]]\nint n,q,s[N],ls[N],rs[N],laz[N],sz=0;\nvoid pd(int x,int ln,int rn){\n    if(laz[x]){\n        if(!ls[x])ls[x]=++sz;\n        if(!rs[x])rs[x]=++sz;\n        laz[ls[x]]=laz[rs[x]]=laz[x];\n        s[ls[x]]=ln*(laz[x]-1);s[rs[x]]=rn*(laz[x]-1);\n        laz[x]=0;\n    }\n}\nvoid upd(int L,int R,int v,int l=1,int r=n,int x=1){\n    if(L<=l&&r<=R){\n        if(v==2)s[x]=r-l+1;\n        else s[x]=0;\n        laz[x]=v;\n        return;\n    }\n    int m=(l+r)>>1;\n    pd(x,m-l+1,r-m);\n    if(L<=m)upd(L,R,v,l,m,ls[x]?ls[x]:ls[x]=++sz);\n    if(R>m)upd(L,R,v,m+1,r,rs[x]?rs[x]:rs[x]=++sz);\n    pu;\n}\nint main(){\n    in(n,q);\n    s[sz=1]=n;laz[1]=2;\n    int k,l,r;\n    while(q--){\n        in(l,r,k);\n        upd(l,r,k);\n        out(s[1],ln);\n    }\n    flush();\n}\n```\n","link":null,"tags":["线段树","动态开点"],"title":"LG CF915E Physical-Education-Lessons"},{"categories":[["刷题记录"]],"content":"\n我们可以第一次修改的时候就用第一个黑点建树,可以预处理出$a_i$表示$i$到根节点路径上点编号的最小值\n\n我们考虑接下来将一个点$x$变为黑点对其他点的影响：\n\n显然$x$变成黑点对它的子树内的点的答案没有影响\n\n对子树外的影响：\n\n子树外的点可以通过根到达$x$,可以记录一个值$t$表示根能到黑点的所有路径上值的点的最小编号\n\n查询时答案就是$\\min(a_x,t)$\n\n自己画个图就懂了\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\n#define N 1000011\nint n,head[N],cnt=0,a[N];\nstruct edge{\n    int to,nxt;\n}e[N*2];\nil void add(int x,int y){\n    e[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;\n}\nvoid dfs(int x,int d){\n    a[x]=d;\n    fl(i,x)if(!a[to])dfs(to,MIN(d,to));\n}\nint main(){\n    int q,opt,x,y,la=0,tt=inf;\n    in(n,q);\n    Fur(i,1,n-1)in(x,y),add(x,y),add(y,x);\n    in(y,x);\n    x=x%n+1;\n    dfs(x,x);\n    while(--q){\n        in(opt,x);\n        x=(la+x)%n+1;\n        if(opt==1)tt=MIN(tt,a[x]);\n        else out(la=MIN(tt,a[x]),ln);\n    }\n    flush();\n}\n```\n","link":null,"tags":["dfs","思维"],"title":"LG CF825G Tree-Queries"},{"categories":[["刷题记录"]],"content":"\n和[\\[国家集训队]happiness](https:\/\/www.luogu.com.cn\/problemnew\/show\/P1646)有点像\n\n而且建图更加简化了\n\n答案为总和减去最小割\n\n$(i+j)\\&1,(i',j')$与$(i,j)$相邻,黑白染色建图\n\n$st\\xrightarrow{A} (i,j)\\xrightarrow{B}ed$\n\n$st\\xrightarrow{B} (i',j')\\xrightarrow{A}ed$\n\n$(i,j) \\xleftrightarrow{c_{i,j}+c_{i',j'}} (i',j')$\n\n<svg width=\"366px\" height=\"366px\"><g><g><g><path d=\"M 179.9565402615114 64.65031742466253 L 110.93085210521868 181.6436746692404\" fill=\"none\" stroke-width=\"2\" stroke=\"black\"><\/path><path d=\"M 179.9565402615114 64.65031742466253 L 110.93085210521868 181.6436746692404\" opacity=\"0\" fill=\"none\" stroke-width=\"30\" stroke=\"black\"><\/path><text font-size=\"15px\" dy=\"0.35em\" text-anchor=\"middle\" style=\"user-select: none;\" x=\"134.43588256835938\" y=\"115.71207236851667\">A<\/text><path stroke=\"black\" fill=\"black\" d=\"M -15 7.5 L 0 0 L -15 -7.5 Z\" transform=\"translate (120.63645935058594 165.1934051513672) rotate(120.54182437911714)\"><\/path><\/g><g><path d=\"M 179.9565402615114 64.65031742466253 L 250.62058333668756 180.66171477618175\" fill=\"none\" stroke-width=\"2\" stroke=\"black\"><\/path><path d=\"M 179.9565402615114 64.65031742466253 L 250.62058333668756 180.66171477618175\" opacity=\"0\" fill=\"none\" stroke-width=\"30\" stroke=\"black\"><\/path><text font-size=\"15px\" dy=\"0.35em\" text-anchor=\"middle\" style=\"user-select: none;\" x=\"225.49951171875\" y=\"114.97562115122257\">B<\/text><path stroke=\"black\" fill=\"black\" d=\"M -15 7.5 L 0 0 L -15 -7.5 Z\" transform=\"translate (240.68463134765625 164.34954833984375) rotate(58.652662037796304)\"><\/path><\/g><g><path d=\"M 110.93085210521868 181.6436746692404 L 181.59447414202378 297.65509303120433\" fill=\"none\" stroke-width=\"2\" stroke=\"black\"><\/path><path d=\"M 110.93085210521868 181.6436746692404 L 181.59447414202378 297.65509303120433\" opacity=\"0\" fill=\"none\" stroke-width=\"30\" stroke=\"black\"><\/path><text font-size=\"15px\" dy=\"0.35em\" text-anchor=\"middle\" style=\"user-select: none;\" x=\"156.46578979492188\" y=\"231.96886161353007\">B<\/text><path stroke=\"black\" fill=\"black\" d=\"M -15 7.5 L 0 0 L -15 -7.5 Z\" transform=\"translate (171.71058654785156 281.42828369140625) rotate(58.65158788133772)\"><\/path><\/g><g><path d=\"M 250.62058333668756 180.66171477618175 L 181.59447414202378 297.65509303120433\" fill=\"none\" stroke-width=\"2\" stroke=\"black\"><\/path><path d=\"M 250.62058333668756 180.66171477618175 L 181.59447414202378 297.65509303120433\" opacity=\"0\" fill=\"none\" stroke-width=\"30\" stroke=\"black\"><\/path><text font-size=\"15px\" dy=\"0.35em\" text-anchor=\"middle\" style=\"user-select: none;\" x=\"205.09970092773438\" y=\"231.71899310498995\">A<\/text><path stroke=\"black\" fill=\"black\" d=\"M -15 7.5 L 0 0 L -15 -7.5 Z\" transform=\"translate (191.30010986328125 281.2048645019531) rotate(120.54043854783976)\"><\/path><\/g><g><path d=\"M 110.93085210521868 181.6436746692404 L 250.62058333668756 180.66171477618175\" fill=\"none\" stroke-width=\"2\" stroke=\"black\"><\/path><path d=\"M 110.93085210521868 181.6436746692404 L 250.62058333668756 180.66171477618175\" opacity=\"0\" fill=\"none\" stroke-width=\"30\" stroke=\"black\"><\/path><text font-size=\"15px\" dy=\"0.35em\" text-anchor=\"middle\" style=\"user-select: none;\" x=\"178.62067289825168\" y=\"168.54331970214844\">c[i][j]+c[i'][j']<\/text><path stroke=\"black\" fill=\"black\" d=\"M -15 7.5 L 0 0 L -15 -7.5 Z\" transform=\"translate (231.52105712890625 180.7959747314453) rotate(359.59944615766557)\"><\/path><\/g><g><path d=\"M 250.62058333668756 180.66171477618175 L 110.93085210521868 181.6436746692404\" fill=\"none\" stroke-width=\"2\" stroke=\"black\"><\/path><path d=\"M 250.62058333668756 180.66171477618175 L 110.93085210521868 181.6436746692404\" opacity=\"0\" fill=\"none\" stroke-width=\"30\" stroke=\"black\"><\/path><text font-size=\"15px\" dy=\"0.35em\" text-anchor=\"middle\" style=\"user-select: none;\" x=\"178.62070578225905\" y=\"168.54331970214844\">c[i][j]+c[i'][j']<\/text><path stroke=\"black\" fill=\"black\" d=\"M -15 7.5 L 0 0 L -15 -7.5 Z\" transform=\"translate (129.93038940429688 181.51011657714844) rotate(179.59944615766557)\"><\/path><\/g><\/g><g><g fixed=\"false\" style=\"cursor: pointer;\"><circle stroke-width=\"2\" fill=\"white\" stroke=\"black\" r=\"19\" cx=\"179.9565402615114\" cy=\"64.65031742466253\"><\/circle><text font-size=\"14\" dy=\".35em\" text-anchor=\"middle\" stroke-width=\"1\" fill=\"black\" stroke=\"black\" x=\"179.9565402615114\" y=\"64.65031742466253\" style=\"user-select: none;\">st<\/text><\/g><g fixed=\"false\" style=\"cursor: pointer;\"><circle stroke-width=\"2\" fill=\"white\" stroke=\"black\" r=\"19\" cx=\"110.93085210521868\" cy=\"181.6436746692404\"><\/circle><text font-size=\"14\" dy=\".35em\" text-anchor=\"middle\" stroke-width=\"1\" fill=\"black\" stroke=\"black\" x=\"110.93085210521868\" y=\"181.6436746692404\" style=\"user-select: none;\">i,j<\/text><\/g><g fixed=\"false\" style=\"cursor: pointer;\"><circle stroke-width=\"2\" fill=\"white\" stroke=\"black\" r=\"19\" cx=\"250.62058333668756\" cy=\"180.66171477618175\"><\/circle><text font-size=\"14\" dy=\".35em\" text-anchor=\"middle\" stroke-width=\"1\" fill=\"black\" stroke=\"black\" x=\"250.62058333668756\" y=\"180.66171477618175\" style=\"user-select: none;\">i',j'<\/text><\/g><g fixed=\"false\" style=\"cursor: pointer;\"><circle stroke-width=\"2\" fill=\"white\" stroke=\"black\" r=\"19\" cx=\"181.59447414202378\" cy=\"297.65509303120433\"><\/circle><text font-size=\"14\" dy=\".35em\" text-anchor=\"middle\" stroke-width=\"1\" fill=\"black\" stroke=\"black\" x=\"181.59447414202378\" y=\"297.65509303120433\" style=\"user-select: none;\">ed<\/text><\/g><\/g><\/g><\/svg>\n\n假设$(i,j)$选择$A$,那么要断开$(i,j)\\rightarrow t,(i,j)\\rightarrow (i',j')$\n\n这些边上的权值会从答案中减去\n\n最小割可以最小化要减去的权值,所以答案最大\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?__=1,EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\nconst int N=100011,M=1000011;\nint n,m,cnt=1,head[N],st,ed,d[N],q[N],c[101][101];\nstruct edge{\n    int to,nxt,w;\n}e[M];\nil void add(int x,int y,int w){\n    e[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;e[cnt].w=w;\n    e[++cnt].to=x;e[cnt].nxt=head[y];head[y]=cnt;e[cnt].w=0;\n}\nbool bfs(){\n    int h=0,t=1,x;\n    clr(d,0);\n    q[0]=st;d[st]=1;\n    while(h<t){\n        x=q[h++];if(x==ed)return 1;\n        fl(i,x)if(e[i].w&&!d[to])\n            d[to]=d[x]+1,q[t++]=to;\n    }\n    return 0;\n}\nint dfs(int x,int mf){\n    if(x==ed)return mf;\n    int us=0,w;\n    fl(i,x)if(e[i].w&&d[to]==d[x]+1){\n        w=dfs(to,MIN(mf-us,e[i].w));\n        e[i].w-=w;\n        us+=w;\n        e[i^1].w+=w;\n        if(us==mf)return mf;\n    }\n    if(!us)d[x]=-1;\n    return us;\n}\nint id(int x,int y){\n    return (x-1)*m+y;\n}\nint main(){\n    in(n,m);\n    st=N-1,ed=N-2;\n    int ans=0,w,tt=n*m,dx[4]={0,1,0,-1},dy[4]={1,0,-1,0},x,y;\n    Fur(i,1,n)Fur(j,1,m){\n        in(w),ans+=w;\n        if((i+j)&1)add(st,id(i,j),w);\n        else add(id(i,j),ed,w);\n    }\n    Fur(i,1,n)Fur(j,1,m){\n        in(w),ans+=w;\n        if((i+j)&1)add(id(i,j),ed,w);\n        else add(st,id(i,j),w);\n    }\n    Fur(i,1,n)Fur(j,1,m)in(c[i][j]);\n    Fur(i,1,n)Fur(j,1,m)\n    if(!((i+j)&1))\n    Fur(t,0,3){\n        x=i+dx[t],y=j+dy[t];\n        if(x<1||x>n||y<1||y>m)continue;\n        ans+=(w=c[i][j]+c[x][y]);\n        add(id(i,j),id(x,y),w);\n        add(id(x,y),id(i,j),w);\n    }\n    while(bfs())ans-=dfs(st,inf);\n    printf(\"%d\\n\",ans);\n}\n```\n","link":null,"tags":["最小割"],"title":"LG 1935 [国家集训队]圈地计划"},{"categories":[["算法","数论"],["算法","技巧"],["note"]],"content":"\n# 四边形不等式\n\n## 定义\n\n对于任意$a_1\\le a_2<b_1\\le b_2$,满足$m[a_1,b_1]+m[a_2,b_2]\\le m[a_1,b_2]+m[a_2,b_1]$\n \n那么$m[i,j]$满足四边形不等式\n\n> 要证明$m[i,j]$满足四边形不等式可以用~~打表~~或数学归纳法\n\n## 区间类2D1D动态规划应用\n\n设$m[i,j]$为动态规划中区间$[i,j]$的答案\n\n一般是$m[i,j]=\\min(m[i,k]+m[k,j])(k\\in [i,j])$,当然$\\max$或其他的也可以\n\n优化的前提是：**m满足四边形不等式**\n\n一般的区间$dp$的复杂度是$\\Theta(n^3)$\n\n我们可以优化为$\\Theta(n^2)$\n\n定义$s[i,j]$为使$m[i,j]$取得最优解的$k$\n\n可以证明:$s[i,j-1]\\le s[i,j]\\le s[i+1,j]$\n\n那么$m[i,j]=\\min(m[i,k]+m[k,j])(k\\in [s[i,j-1],s[i+1,j]])$\n\n### 复杂度分析：\n\n假设我们现在要求$m[i,i+L]$,\n\n那么我们要枚举的次数是：\n\n$(s[2,L+1]-s[1,L])+(s[3,L+2]-s[2,L+1])+…+(s[n-L+1,n]-s[n-L,n-1])=s[n-L+1,n]-s[1,L]\\le n$\n\n所以总复杂度是$\\Theta(n)$\n\n### 证明：\n\n对上述$s[i,j-1]\\le s[i,j]\\le s[i+1,j]$的证明：\n\n\n设$mk[i,j]=m[i,k]+m[k,j],s[i,j]=d$\n\n对于任意$k<d$,有$mk[i,j]\\ge md[i,j]$\n\n(这里以$m[i,j]=\\min(m[i,k]+m[k,j])$为例)\n\n接下来只要证明$mk[i+1,j]\\ge md[i+1,j]$,\n\n那么只有当$s[i+1,j]\\ge s[i,j]$时才有可能有$mk[i+1,j]\\ge md[i+1,j]$\n\n$$\n(mk[i+1,j]-md[i+1,j])-(mk[i,j]-md[i,j])\n\\\\\n=(mk[i+1,j]+md[i,j])-(md[i+1,j]+mk[i,j])\n\\\\\n=(m[i+1,k]+m[k,j]+m[i,d]+m[d,j])\n\\\\\n-(m[i+1,d]+m[d,j]+m[i,k]+m[k,j])\n\\\\\n=(m[i+1,k]+m[i,d])-(m[i+1,d]+m[i,k])\n$$\n\n$\\because m$满足四边形不等式\n\n对于$i<i+1\\le k<d$有$m[i+1,k]+m[i,d]\\ge m[i+1,d]+m[i,k]$\n\n$\\therefore (mk[i+1,j]-md[i+1,j])\\ge(mk[i,j]-md[i,j])\\ge 0$\n\n$\\therefore s[i,j]\\le s[i+1,j]$,同理可证$s[i,j-1]\\le s[i,j]$\n证毕\n\n### 例题：\n\n[[NOI1995]石子合并](https:\/\/www.luogu.com.cn\/problem\/P1880)\n\n\n\n## 1D1D 动态规划中的应用\n\n考虑$f_r=\\min(f_l+w(l+1,r))(l\\in [1,r-1])$\n\n若$w(l,r)$满足四边形不等式,\n\n设$k_r$为$f_r$的最优决策点,则有：\n\n$\\forall r_1\\le r_2 : k_{r_1} \\le k_{r_2}$\n\n~~证明略~~\n\n这些也可以看作具有**决策单调性**\n\n但是我们只能知道枚举的下界,不能知道上界\n\n我们可以采用分治算法来解决\n\n设$work(l,r,k_l,k_r)$表示求解$f_l～f_r$,并知道最优决策点在$[k_l,k_r]$\n\n类似下方代码：\n\n```cpp\nvoid work(int l,int r,int kl,int kr){\n    int m=(l+r)>>1,k=kl;\n    for(int i=kl;i<=min(kr,m-1);++i)\n    if(w(i,m)<w(k,m))i=k;\n    f[m]=w(k,m);\n    if(l<m)work(l,m-1,kl,k);\n    if(r>m)work(m+1,r,k,kr);\n}\n```\n\n复杂度：$\\Theta(n \\log n)$\n\n也可以使用**队列实现决策二分栈**\n\n以[「lG 3515」「loj2157」「POI2011」Lightning Conductor](https:\/\/www.luogu.com.cn\/problem\/P3515)为例：\n\n> 对于每个$j$,把$a_j+\\sqrt{i-j}$看成关于$i$的函数$f_j$。\n> \n> 我们要做的就是在所有$j\\leq i$的函数中找到最值\n> \n> 队列实现决策二分栈,按$j$从小到大依次维护这些函数。\n> \n> 对于其中任意两个相邻的函数$f_t,f_{t+1}$ ,它们都有一个临界> 值$k_{t,t+1}$\n> \n> 显然序列中的$k_{1,2},k_{2,3}...$也要严格递增。\n> \n> 否则,如果$k_{t,t+1}\\ge k_{t+1,t+2}$,$f_{t+1}$根本没有> 用。\n> \n> 每次加入$f_i$的时候：\n> \n> 设队尾为$t$,如果当前$i$比$t$优($calc(k_{t-1},i)\\ge > calc(k_{t-1},t)$),那么弹出$t$\n> \n> 现在来考虑队头$h$\n> \n> 若$k_h\\le i$那么把$h$弹出\n\n### 例题\n\n[「lG 3515」「loj2157」「POI2011」Lightning Conductor](https:\/\/www.luogu.com.cn\/problem\/P3515)\n\n[[JSOI2011]柠檬](https:\/\/www.luogu.com.cn\/problemnew\/show\/P5504)\n\n上述题目可参考我的题解库https:\/\/zt.zcmimi.top\n\n> 参考文献：\n> \n> https:\/\/baike.baidu.com\/item\/四边形不等式\/7556574\n> \n> https:\/\/oi-wiki.org\/dp\/opt\/quadrangle\/\n> \n> https:\/\/www.luogu.com.cn\/blog\/flashblog\/solution-p3515","link":null,"tags":["动态规划","技巧","数论"],"title":"四边形不等式"},{"categories":[["刷题记录"]],"content":"\n先考虑没有换根的操作(设根节点为$1$)\n\n修改点$x$的权值\n\n被影响的只有$1\\rightarrow x$上的点,设$p_1,p_2,...,p_k$为$1\\rightarrow x$上的点\n\n设$s_i$为$i$子树点权和\n\n将修改看成增加$v$\n\n修改后贡献为\n\n$\\sum_{i=1}^k (s_{p_i}+v)^2-\\sum_{i=1}^k s_{p_i}^2= k\\times v^2+2v\\sum_{i=1}^ks_{p_i}$\n\n我们需要预处理出$s_i^2$,维护$s_i$\n\n\n\n考虑换根操作：\n\n设$x$为根,$p_1,p_2,...,p_k$为$1\\rightarrow x$上的点\n\n设$a_i$为在$1$为根时$v_i$的点权和,$b_i$为在$x$为根时$v_i$的点权和\n\n可以发现$a_{i+1}+b_i=a_1=b_k$(因为所有点的点权和总是相同)\n\n设$ans_x$表示$x$为根时的答案\n\n$ans_x=ans_1+\\sum_{i=1}^k b_i^2-a_i^2$\n\n$=ans_1+\\sum_{i=1}^k (a_1-a_{i+1})^2-a_i^2$\n\n$=ans_1+\\sum_{i=2}^k (a_1-a_i)^2-a_i^2$\n\n$=ans_1+ (k-1)a_1^2- 2a_1\\sum_{i=2}^k a_i$\n\n$=ans_1+ s_1[(k+1)s_1-2\\sum_{i=1}^k s_{p_i}]$\n\n\n\n可以使用树链剖分+(树状数组\/线段树)或LCT维护\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\n#define N 200011\nint n,cnt=0,head[N],val[N],pos[N],w[N];\nstruct edge{\n    int to,nxt;\n}e[N<<1];\nil void add(int x,int y){\n    e[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;\n}\nll s[N],S[N],ans=0;\nil void upd(int x,int v){\n    if(x<=n)\n    for(int i=x;i<=n;i+=i&-i)\n        s[i]+=v,\n        S[i]+=1ll*x*v;\n}\nil void upd(int l,int r,int v){upd(l,v);upd(r+1,-v);}\nil ll ask(int x){\n    ll res=0;\n    for(int i=x;i;i-=i&-i)\n        res+=1ll*(x+1)*s[i]-S[i];\n    return res;\n}\nil ll ask(int l,int r){return ask(r)-ask(l-1);}\nint siz[N],top[N],id[N],f[N],d[N],sz=0;\nvoid dfs(int x){\n    siz[x]=1;\n    fl(i,x)if(to!=f[x]){\n        f[to]=x;d[to]=d[x]+1;\n        dfs(to);\n        siz[x]+=siz[to];\n        w[x]+=w[to];\n    }\n}\nvoid bt(int x,int tp){\n    top[x]=tp;pos[id[x]=++sz]=x;\n    ans+=1ll*w[x]*w[x];\n    upd(id[x],w[x]-w[pos[sz-1]]);\n    int k=0;\n    fl(i,x)if(to!=f[x]&&siz[to]>siz[k])k=to;\n    if(!k)return;bt(k,tp);\n    fl(i,x)if(!top[to])bt(to,to);\n}\nil void mdy(int x,int v){\n    int k=0;\n    ll res=0;\n    while(x){\n        k+=id[x]-id[top[x]]+1;\n        res+=ask(id[top[x]],id[x]);\n        upd(id[top[x]],id[x],v);\n        x=f[top[x]];\n    }\n    ans+=1ll*v*(1ll*v*k+(res<<1));\n}\nil ll qry(int x){\n    int k=0,v=ask(1);\n    ll res=0;\n    while(x){\n        k+=id[x]-id[top[x]]+1;\n        res+=ask(id[top[x]],id[x]);\n        x=f[top[x]];\n    }\n    return ans+1ll*v*((k+1)*v-(res<<1));\n}\nint main(){\n    int q,x,y,opt;\n    in(n,q);\n    Fur(i,1,n-1)\n        in(x,y),\n        add(x,y),add(y,x);\n    Fur(i,1,n)in(val[i]),w[i]=val[i];\n    dfs(1);bt(1,1);\n    while(q--){\n        in(opt,x);\n        if(opt==1){\n            in(y);\n            y-=val[x];\n            val[x]+=y;\n            mdy(x,y);\n        }\n        else out(qry(x),ln);\n    }\n    flush();\n}\n```\n","link":null,"tags":["树链剖分","数论"],"title":"LG 3676 小清新数据结构题"},{"categories":[["刷题记录"]],"content":"\n换根树链剖分\n\n前置知识：树链剖分\n\n题意：树链加,子树加,需要支持换根,查询树链和,子树和\n\n树链加、查询树链和 与普通的树链剖分一样\n\n主要讲：\n\n需要支持换根,子树加,查询子树和\n\n设当前查询的点为$x$\n\n情况1: $x$就是根,直接输出整棵树的和\n\n情况2: 根在$x$子树内:\n\n找到根到$x$路径上的$x$的儿子\n\n```cpp\nint child(int rt,int x){\n    while(top[rt]!=top[x]){\n        rt=top[rt];\n        if(f[rt]==x)return rt;\/\/父亲是x,返回当前点\n        rt=f[rt];\n    }\n    return son[x];\/\/根在x所在的重链上\n}\n```\n\n把整棵树除$t$子树外的部分加上$val$即可\n\n> 举个例子\n> \n> <svg width=\"300px\" height=\"300px\" _=\"SVGRoot\"><g _=\"EditableGraph\"><g _=\"SVGGroup\"><g _=\"GraphEdge\"><path d=\"M 148.30985915492957 45.774647887323944 L 96.30985915492957 98.87323943661971\" fill=\"none\" stroke-width=\"2\" stroke=\"black\" _=\"SVGPath\"><\/path><path d=\"M 148.30985915492957 45.774647887323944 L 96.30985915492957 98.87323943661971\" opacity=\"0\" fill=\"none\" stroke-width=\"30\" stroke=\"black\" _=\"SVGPath\"><\/path><\/g><g _=\"GraphEdge\"><path d=\"M 148.30985915492957 45.774647887323944 L 226.30985915492957 98.87323943661971\" fill=\"none\" stroke-width=\"2\" stroke=\"black\" _=\"SVGPath\"><\/path><path d=\"M 148.30985915492957 45.774647887323944 L 226.30985915492957 98.87323943661971\" opacity=\"0\" fill=\"none\" stroke-width=\"30\" stroke=\"black\" _=\"SVGPath\"><\/path><\/g><g _=\"GraphEdge\"><path d=\"M 96.30985915492957 98.87323943661971 L 70.30985915492957 151.9718309859155\" fill=\"none\" stroke-width=\"2\" stroke=\"black\" _=\"SVGPath\"><\/path><path d=\"M 96.30985915492957 98.87323943661971 L 70.30985915492957 151.9718309859155\" opacity=\"0\" fill=\"none\" stroke-width=\"30\" stroke=\"black\" _=\"SVGPath\"><\/path><\/g><g _=\"GraphEdge\"><path d=\"M 96.30985915492957 98.87323943661971 L 148.3098591549295 151.9718309859155\" fill=\"none\" stroke-width=\"2\" stroke=\"black\" _=\"SVGPath\"><\/path><path d=\"M 96.30985915492957 98.87323943661971 L 148.3098591549295 151.9718309859155\" opacity=\"0\" fill=\"none\" stroke-width=\"30\" stroke=\"black\" _=\"SVGPath\"><\/path><\/g><g _=\"GraphEdge\"><path d=\"M 226.30985915492957 98.87323943661971 L 200.30985915492954 151.9718309859155\" fill=\"none\" stroke-width=\"2\" stroke=\"black\" _=\"SVGPath\"><\/path><path d=\"M 226.30985915492957 98.87323943661971 L 200.30985915492954 151.9718309859155\" opacity=\"0\" fill=\"none\" stroke-width=\"30\" stroke=\"black\" _=\"SVGPath\"><\/path><\/g><g _=\"GraphEdge\"><path d=\"M 226.30985915492957 98.87323943661971 L 252.30985915492957 151.9718309859155\" fill=\"none\" stroke-width=\"2\" stroke=\"black\" _=\"SVGPath\"><\/path><path d=\"M 226.30985915492957 98.87323943661971 L 252.30985915492957 151.9718309859155\" opacity=\"0\" fill=\"none\" stroke-width=\"30\" stroke=\"black\" _=\"SVGPath\"><\/path><\/g><g _=\"GraphEdge\"><path d=\"M 70.30985915492957 151.9718309859155 L 44.30985915492957 205.07042253521126\" fill=\"none\" stroke-width=\"2\" stroke=\"black\" _=\"SVGPath\"><\/path><path d=\"M 70.30985915492957 151.9718309859155 L 44.30985915492957 205.07042253521126\" opacity=\"0\" fill=\"none\" stroke-width=\"30\" stroke=\"black\" _=\"SVGPath\"><\/path><\/g><g _=\"GraphEdge\"><path d=\"M 70.30985915492957 151.9718309859155 L 96.30985915492955 205.07042253521126\" fill=\"none\" stroke-width=\"2\" stroke=\"black\" _=\"SVGPath\"><\/path><path d=\"M 70.30985915492957 151.9718309859155 L 96.30985915492955 205.07042253521126\" opacity=\"0\" fill=\"none\" stroke-width=\"30\" stroke=\"black\" _=\"SVGPath\"><\/path><\/g><\/g><g _=\"SVGGroup\"><g fixed=\"false\" style=\"cursor: pointer;\" _=\"GraphNode\"><circle stroke-width=\"5\" fill=\"white\" stroke=\"black\" r=\"19\" cx=\"148.30985915492957\" cy=\"45.774647887323944\" _=\"SVGCircle\"><\/circle><text font-size=\"14\" dy=\".35em\" text-anchor=\"middle\" stroke-width=\"1\" fill=\"black\" stroke=\"black\" x=\"148.30985915492957\" y=\"45.774647887323944\" style=\"user-select: none;\" _=\"SVGText\">1<\/text><\/g><g fixed=\"false\" style=\"cursor: pointer;\" _=\"GraphNode\"><circle stroke-width=\"5\" fill=\"white\" stroke=\"black\" r=\"19\" cx=\"96.30985915492957\" cy=\"98.87323943661971\" _=\"SVGCircle\"><\/circle><text font-size=\"14\" dy=\".35em\" text-anchor=\"middle\" stroke-width=\"1\" fill=\"black\" stroke=\"black\" x=\"96.30985915492957\" y=\"98.87323943661971\" style=\"user-select: none;\" _=\"SVGText\">2<\/text><\/g><g fixed=\"false\" style=\"cursor: pointer;\" _=\"GraphNode\"><circle stroke-width=\"5\" fill=\"white\" stroke=\"black\" r=\"19\" cx=\"226.30985915492957\" cy=\"98.87323943661971\" _=\"SVGCircle\"><\/circle><text font-size=\"14\" dy=\".35em\" text-anchor=\"middle\" stroke-width=\"1\" fill=\"black\" stroke=\"black\" x=\"226.30985915492957\" y=\"98.87323943661971\" style=\"user-select: none;\" _=\"SVGText\">3<\/text><\/g><g fixed=\"false\" _=\"GraphNode\" style=\"cursor: pointer;\"><circle stroke-width=\"5\" fill=\"white\" stroke=\"black\" r=\"19\" cx=\"70.30985915492957\" cy=\"151.9718309859155\" _=\"SVGCircle\"><\/circle><text font-size=\"14\" dy=\".35em\" text-anchor=\"middle\" stroke-width=\"1\" fill=\"black\" stroke=\"black\" x=\"70.30985915492957\" y=\"151.9718309859155\" _=\"SVGText\" style=\"user-select: none;\">4<\/text><\/g><g fixed=\"false\" _=\"GraphNode\" style=\"cursor: pointer;\"><circle stroke-width=\"5\" fill=\"white\" stroke=\"black\" r=\"19\" cx=\"148.3098591549295\" cy=\"151.9718309859155\" _=\"SVGCircle\"><\/circle><text font-size=\"14\" dy=\".35em\" text-anchor=\"middle\" stroke-width=\"1\" fill=\"black\" stroke=\"black\" x=\"148.3098591549295\" y=\"151.9718309859155\" _=\"SVGText\" style=\"user-select: none;\">5<\/text><\/g><g fixed=\"false\" _=\"GraphNode\" style=\"cursor: pointer;\"><circle stroke-width=\"5\" fill=\"white\" stroke=\"black\" r=\"19\" cx=\"200.30985915492954\" cy=\"151.9718309859155\" _=\"SVGCircle\"><\/circle><text font-size=\"14\" dy=\".35em\" text-anchor=\"middle\" stroke-width=\"1\" fill=\"black\" stroke=\"black\" x=\"200.30985915492954\" y=\"151.9718309859155\" _=\"SVGText\" style=\"user-select: none;\">6<\/text><\/g><g fixed=\"false\" _=\"GraphNode\" style=\"cursor: pointer;\"><circle stroke-width=\"5\" fill=\"white\" stroke=\"black\" r=\"19\" cx=\"252.30985915492957\" cy=\"151.9718309859155\" _=\"SVGCircle\"><\/circle><text font-size=\"14\" dy=\".35em\" text-anchor=\"middle\" stroke-width=\"1\" fill=\"black\" stroke=\"black\" x=\"252.30985915492957\" y=\"151.9718309859155\" _=\"SVGText\" style=\"user-select: none;\">7<\/text><\/g><g fixed=\"false\" _=\"GraphNode\" style=\"cursor: pointer;\"><circle stroke-width=\"5\" fill=\"white\" stroke=\"black\" r=\"19\" cx=\"44.30985915492957\" cy=\"205.07042253521126\" _=\"SVGCircle\"><\/circle><text font-size=\"14\" dy=\".35em\" text-anchor=\"middle\" stroke-width=\"1\" fill=\"black\" stroke=\"black\" x=\"44.30985915492957\" y=\"205.07042253521126\" style=\"user-select: none;\" _=\"SVGText\">8<\/text><\/g><g fixed=\"false\" _=\"GraphNode\" style=\"cursor: pointer;\"><circle stroke-width=\"5\" fill=\"white\" stroke=\"black\" r=\"19\" cx=\"96.30985915492955\" cy=\"205.07042253521126\" _=\"SVGCircle\"><\/circle><text font-size=\"14\" dy=\".35em\" text-anchor=\"middle\" stroke-width=\"1\" fill=\"black\" stroke=\"black\" x=\"96.30985915492955\" y=\"205.07042253521126\" style=\"user-select: none;\" _=\"SVGText\">9<\/text><\/g><\/g><\/g><\/svg>\n> \n> 建树时是以1为根\n> \n> 设当前根为9,x为2\n> \n> 找出的child是4\n> \n> <svg width=\"300px\" height=\"300px\" _=\"SVGRoot\"><g _=\"EditableGraph\"><g _=\"SVGGroup\"><g _=\"GraphEdge\"><path d=\"M261,153.39565279298176Q205.162355744426,154.5050546416901,149.32471148885205,155.6144564903984\" fill=\"none\" stroke-width=\"2\" stroke=\"black\" _=\"SVGPath\"><\/path><path d=\"M261,153.39565279298176Q205.162355744426,154.5050546416901,149.32471148885205,155.6144564903984\" opacity=\"0\" fill=\"none\" stroke-width=\"30\" stroke=\"black\" _=\"SVGPath\"><\/path><\/g><g _=\"GraphEdge\"><path d=\"M261,153.39565279298176Q206.91547342716183,207.19782639649088,152.83094685432368,261\" fill=\"none\" stroke-width=\"2\" stroke=\"black\" _=\"SVGPath\"><\/path><path d=\"M261,153.39565279298176Q206.91547342716183,207.19782639649088,152.83094685432368,261\" opacity=\"0\" fill=\"none\" stroke-width=\"30\" stroke=\"black\" _=\"SVGPath\"><\/path><\/g><g _=\"GraphEdge\"><path d=\"M149.32471148885205,155.6144564903984Q151.05132366814587,97.3072282451992,152.7779358474397,39\" fill=\"none\" stroke-width=\"2\" stroke=\"black\" _=\"SVGPath\"><\/path><path d=\"M149.32471148885205,155.6144564903984Q151.05132366814587,97.3072282451992,152.7779358474397,39\" opacity=\"0\" fill=\"none\" stroke-width=\"30\" stroke=\"black\" _=\"SVGPath\"><\/path><\/g><g _=\"GraphEdge\"><path d=\"M 149.32471148885205 155.6144564903984 L 39 148.97409692923225\" fill=\"none\" stroke-width=\"2\" stroke=\"black\" _=\"SVGPath\"><\/path><path d=\"M 149.32471148885205 155.6144564903984 L 39 148.97409692923225\" opacity=\"0\" fill=\"none\" stroke-width=\"30\" stroke=\"black\" _=\"SVGPath\"><\/path><\/g><g _=\"GraphEdge\"><path d=\"M 152.7779358474397 39 L 260.3385416666667 39\" fill=\"none\" stroke-width=\"2\" stroke=\"black\" _=\"SVGPath\"><\/path><path d=\"M 152.7779358474397 39 L 260.3385416666667 39\" opacity=\"0\" fill=\"none\" stroke-width=\"30\" stroke=\"black\" _=\"SVGPath\"><\/path><\/g><g _=\"GraphEdge\"><path d=\"M152.7779358474397,39Q95.88896792371985,39,39,39\" fill=\"none\" stroke-width=\"2\" stroke=\"black\" _=\"SVGPath\"><\/path><path d=\"M152.7779358474397,39Q95.88896792371985,39,39,39\" opacity=\"0\" fill=\"none\" stroke-width=\"30\" stroke=\"black\" _=\"SVGPath\"><\/path><\/g><g _=\"GraphEdge\"><path d=\"M152.83094685432368,261Q95.91547342716184,261,39,261\" fill=\"none\" stroke-width=\"2\" stroke=\"black\" _=\"SVGPath\"><\/path><path d=\"M152.83094685432368,261Q95.91547342716184,261,39,261\" opacity=\"0\" fill=\"none\" stroke-width=\"30\" stroke=\"black\" _=\"SVGPath\"><\/path><\/g><g _=\"GraphEdge\"><path d=\"M 152.83094685432368 261 L 261 261\" fill=\"none\" stroke-width=\"2\" stroke=\"black\" _=\"SVGPath\"><\/path><path d=\"M 152.83094685432368 261 L 261 261\" opacity=\"0\" fill=\"none\" stroke-width=\"30\" stroke=\"black\" _=\"SVGPath\"><\/path><\/g><\/g><g _=\"SVGGroup\"><g fixed=\"false\" style=\"cursor: pointer;\" _=\"GraphNode\"><circle stroke-width=\"2\" fill=\"white\" stroke=\"black\" r=\"19\" cx=\"261\" cy=\"153.39565279298176\" _=\"SVGCircle\"><\/circle><text font-size=\"14\" dy=\".35em\" text-anchor=\"middle\" stroke-width=\"1\" fill=\"black\" stroke=\"black\" x=\"261\" y=\"153.39565279298176\" style=\"user-select: none;\" _=\"SVGText\">1<\/text><\/g><g fixed=\"false\" style=\"cursor: pointer;\" _=\"GraphNode\"><circle stroke-width=\"2\" fill=\"white\" stroke=\"black\" r=\"19\" cx=\"149.32471148885205\" cy=\"155.6144564903984\" _=\"SVGCircle\"><\/circle><text font-size=\"14\" dy=\".35em\" text-anchor=\"middle\" stroke-width=\"1\" fill=\"black\" stroke=\"black\" x=\"149.32471148885205\" y=\"155.6144564903984\" style=\"user-select: none;\" _=\"SVGText\">2<\/text><\/g><g fixed=\"false\" _=\"GraphNode\" style=\"cursor: pointer;\"><circle stroke-width=\"2\" fill=\"white\" stroke=\"black\" r=\"19\" cx=\"152.83094685432368\" cy=\"261\" _=\"SVGCircle\"><\/circle><text font-size=\"14\" dy=\".35em\" text-anchor=\"middle\" stroke-width=\"1\" fill=\"black\" stroke=\"black\" x=\"152.83094685432368\" y=\"261\" _=\"SVGText\" style=\"user-select: none;\">3<\/text><\/g><g fixed=\"false\" _=\"GraphNode\" style=\"cursor: pointer;\"><circle stroke-width=\"5\" fill=\"white\" stroke=\"black\" r=\"19\" cx=\"152.7779358474397\" cy=\"39\" _=\"SVGCircle\"><\/circle><text font-size=\"14\" dy=\".35em\" text-anchor=\"middle\" stroke-width=\"1\" fill=\"black\" stroke=\"black\" x=\"152.7779358474397\" y=\"39\" style=\"user-select: none;\" _=\"SVGText\">4<\/text><\/g><g fixed=\"false\" _=\"GraphNode\" style=\"cursor: pointer;\"><circle stroke-width=\"2\" fill=\"white\" stroke=\"black\" r=\"19\" cx=\"39\" cy=\"148.97409692923225\" _=\"SVGCircle\"><\/circle><text font-size=\"14\" dy=\".35em\" text-anchor=\"middle\" stroke-width=\"1\" fill=\"black\" stroke=\"black\" x=\"39\" y=\"148.97409692923225\" style=\"user-select: none;\" _=\"SVGText\">5<\/text><\/g><g fixed=\"false\" _=\"GraphNode\" style=\"cursor: pointer;\"><circle stroke-width=\"5\" fill=\"white\" stroke=\"black\" r=\"19\" cx=\"260.3385416666667\" cy=\"39\" _=\"SVGCircle\"><\/circle><text font-size=\"14\" dy=\".35em\" text-anchor=\"middle\" stroke-width=\"1\" fill=\"black\" stroke=\"black\" x=\"260.3385416666667\" y=\"39\" style=\"user-select: none;\" _=\"SVGText\">8<\/text><\/g><g fixed=\"false\" _=\"GraphNode\" style=\"cursor: pointer;\"><circle stroke-width=\"5\" fill=\"white\" stroke=\"black\" r=\"19\" cx=\"39\" cy=\"39\" _=\"SVGCircle\"><\/circle><text font-size=\"14\" dy=\".35em\" text-anchor=\"middle\" stroke-width=\"1\" fill=\"black\" stroke=\"black\" x=\"39\" y=\"39\" style=\"user-select: none;\" _=\"SVGText\">9<\/text><\/g><g fixed=\"false\" _=\"GraphNode\" style=\"cursor: pointer;\"><circle stroke-width=\"2\" fill=\"white\" stroke=\"black\" r=\"19\" cx=\"39\" cy=\"261\" _=\"SVGCircle\"><\/circle><text font-size=\"14\" dy=\".35em\" text-anchor=\"middle\" stroke-width=\"1\" fill=\"black\" stroke=\"black\" x=\"39\" y=\"261\" _=\"SVGText\" style=\"user-select: none;\">6<\/text><\/g><g fixed=\"false\" _=\"GraphNode\" style=\"cursor: pointer;\"><circle stroke-width=\"2\" fill=\"white\" stroke=\"black\" r=\"19\" cx=\"261\" cy=\"261\" _=\"SVGCircle\"><\/circle><text font-size=\"14\" dy=\".35em\" text-anchor=\"middle\" stroke-width=\"1\" fill=\"black\" stroke=\"black\" x=\"261\" y=\"261\" _=\"SVGText\" style=\"user-select: none;\">7<\/text><\/g><\/g><\/g><\/svg>\n\n情况3: 根不在$x$子树内: 与普通树链剖分一样\n\n线段树版:\n```cpp\n#include<bits\/stdc++.h>\nusing namespace std;\n#define ll long long\n#define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n#define N 100011\nint n,cnt=0,RT=1,head[N],c[N];\nstruct edge{\n    int to,nxt;\n}e[N];\nvoid add(int x,int y){\n    e[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;\n}\nint a[N];\nll s[N<<2],laz[N<<2];\n#define ls rt<<1\n#define rs rt<<1|1\n#define pu s[rt]=s[ls]+s[rs]\nvoid pd(int rt,int ln,int rn){\n    if(laz[rt]){\n        laz[ls]+=laz[rt];\n        laz[rs]+=laz[rt];\n        s[ls]+=ln*laz[rt];\n        s[rs]+=rn*laz[rt];\n        laz[rt]=0;\n    }\n}\nvoid build(int l,int r,int rt){\n    if(l==r){\n        s[rt]=a[l];\n        return;\n    }\n    int m=(l+r)>>1;\n    build(l,m,ls);build(m+1,r,rs);\n    pu;\n}\nvoid upd(int L,int R,int v,int l,int r,int rt){\n    if(L<=l&&r<=R){\n        s[rt]+=v*(r-l+1);\n        laz[rt]+=v;\n        return;\n    }\n    int m=(l+r)>>1;\n    pd(rt,m-l+1,r-m);\n    if(L<=m)upd(L,R,v,l,m,ls);\n    if(R>m)upd(L,R,v,m+1,r,rs);\n    pu;\n}\nll ask(int L,int R,int l,int r,int rt){\n    if(L<=l&&r<=R)return s[rt];\n    int m=(l+r)>>1;\n    ll ans=0;\n    pd(rt,m-l+1,r-m);\n    if(L<=m)ans=ask(L,R,l,m,ls);\n    if(R>m)ans+=ask(L,R,m+1,r,rs);\n    return ans;\n}\nint son[N],siz[N],top[N],id[N],f[N],d[N],sz=0;\nvoid dfs(int x){\n    siz[x]=1;\n    son[x]=0;\n    fl(i,x){\n        d[to]=d[x]+1;\n        dfs(to);\n        siz[x]+=siz[to];\n        if(siz[to]>siz[son[x]])son[x]=to;\n    }\n}\nvoid bt(int x,int tp){\n    top[x]=tp;id[x]=++sz;a[id[x]]=c[x];\n    if(!son[x])return;\n    bt(son[x],tp);\n    fl(i,x)if(!top[to])bt(to,to);\n}\nll fh(int x,int y){\n    ll ans=0;\n    while(top[x]!=top[y]){\n        if(d[top[x]]<d[top[y]])swap(x,y);\n        ans+=ask(id[top[x]],id[x],1,n,1);x=f[top[x]];\n    }\n    if(id[x]>id[y])swap(x,y);\n    return ans+ask(id[x],id[y],1,n,1);\n}\nvoid ul(int x,int y,int k){\n    while(top[x]!=top[y]){\n        if(d[top[x]]<d[top[y]])swap(x,y);\n        upd(id[top[x]],id[x],k,1,n,1);x=f[top[x]];\n    }\n    if(id[x]>id[y])swap(x,y);\n    upd(id[x],id[y],k,1,n,1);\n}\nint child(int x,int y){\n    while(top[x]!=top[y]){\n        x=top[x];\n        if(f[x]==y)return x;\n        x=f[x];\n    }\n    return son[y];\n}\nint main(){\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;++i)scanf(\"%d\",&c[i]);\n    int q,x,y,opt,k;\n    for(int i=2;i<=n;++i)\n        scanf(\"%d\",&f[i]),add(f[i],i);\n    dfs(1);bt(1,1);\n    build(1,n,1);\n    scanf(\"%d\",&q);\n    while(q--){\n        scanf(\"%d%d\",&opt,&x);\n        if(opt==1)RT=x;\n        if(opt==2)scanf(\"%d%d\",&y,&k),ul(x,y,k);\n        if(opt==3){\n            scanf(\"%d\",&k);\n            if(x==RT)upd(1,n,k,1,n,1);\n            else if(id[x]<=id[RT]&&id[RT]+siz[RT]<=id[x]+siz[x]){\n                int t=child(RT,x);\n                upd(1,n,k,1,n,1);\n                upd(id[t],id[t]+siz[t]-1,-k,1,n,1);\n            }\n            else upd(id[x],id[x]+siz[x]-1,k,1,n,1);\n        }\n        if(opt==4)scanf(\"%d\",&y),printf(\"%lld\\n\",fh(x,y));\n        if(opt==5){\n            if(x==RT)printf(\"%lld\\n\",s[1]);\n            else if(id[x]<=id[RT]&&id[RT]+siz[RT]<=id[x]+siz[x]){\n                int t=child(RT,x);\n                printf(\"%lld\\n\",s[1]-ask(id[t],id[t]+siz[t]-1,1,n,1));\n            }\n            else printf(\"%lld\\n\",ask(id[x],id[x]+siz[x]-1,1,n,1));\n        }\n    }\n}\n```\n\n树状数组版：\n```cpp\n#include<bits\/stdc++.h>\n#pragma GCC optimize(3)\n#pragma GCC optimize(Ofast)\n#define il inline\nil void SWAP(int &x,int &y){int t=x;x=y;y=t;}\nusing namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\n#define N 100011\n#define ll long long\n#define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\nint n,cnt=0,RT=1,head[N],c[N];\nstruct edge{\n    int to,nxt;\n}e[N];\nil void add(int x,int y){\n    e[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;\n}\nll s[N],S[N];\nil void upd(int x,int v){\n    if(x<=n)\n    for(int i=x;i<=n;i+=i&-i)\n        s[i]+=v,\n        S[i]+=1ll*v*(x-1);\n}\nil ll ask(int x){\n    ll ans=0;\n    for(int i=x;i;i-=i&-i)\n        ans+=1ll*x*s[i]-S[i];\n    return ans;\n}\nil void upd(int l,int r,int v){upd(l,v);upd(r+1,-v);}\nil ll ask(int l,int r){return ask(r)-ask(l-1);}\nint son[N],siz[N],top[N],id[N],f[N],d[N],sz=0;\nvoid dfs(int x){\n    siz[x]=1;\n    son[x]=0;\n    fl(i,x){\n        d[to]=d[x]+1;\n        dfs(to);\n        siz[x]+=siz[to];\n        if(siz[to]>siz[son[x]])son[x]=to;\n    }\n}\nvoid bt(int x,int tp){\n    top[x]=tp;id[x]=++sz;\n    if(!son[x])return;\n    bt(son[x],tp);\n    fl(i,x)if(!top[to])bt(to,to);\n}\nll fh(int x,int y){\n    ll ans=0;\n    while(top[x]!=top[y]){\n        if(d[top[x]]<d[top[y]])SWAP(x,y);\n        ans+=ask(id[top[x]],id[x]);x=f[top[x]];\n    }\n    if(id[x]>id[y])SWAP(x,y);\n    return ans+ask(id[x],id[y]);\n}\nvoid ul(int x,int y,int k){\n    while(top[x]!=top[y]){\n        if(d[top[x]]<d[top[y]])SWAP(x,y);\n        upd(id[top[x]],id[x],k);x=f[top[x]];\n    }\n    if(id[x]>id[y])SWAP(x,y);\n    upd(id[x],id[y],k);\n}\nil int child(int x,int y){\n    while(top[x]!=top[y]){\n        x=top[x];\n        if(f[x]==y)return x;\n        x=f[x];\n    }\n    return son[y];\n}\nint main(){\n    in(n);\n    for(int i=1;i<=n;++i)in(c[i]);\n    int q,x,y,opt,k;\n    for(int i=2;i<=n;++i)\n        in(f[i]),add(f[i],i);\n    dfs(1);bt(1,1);\n    for(int i=1;i<=n;++i)upd(id[i],id[i],c[i]);\n    in(q);\n    while(q--){\n        in(opt,x);\n        if(opt==1)RT=x;\n        if(opt==2)in(y,k),ul(x,y,k);\n        if(opt==3){\n            in(k);\n            if(x==RT)upd(1,n,k);\n            else if(id[x]<=id[RT]&&id[RT]+siz[RT]<=id[x]+siz[x]){\n                int t=child(RT,x);\n                upd(1,k);\n                upd(id[t],id[t]+siz[t]-1,-k);\n            }\n            else upd(id[x],id[x]+siz[x]-1,k);\n        }\n        if(opt==4)in(y),out(fh(x,y),ln);\n        if(opt==5){\n            if(x==RT)out(ask(n),ln);\n            else if(id[x]<=id[RT]&&id[RT]+siz[RT]<=id[x]+siz[x]){\n                int t=child(RT,x);\n                out(ask(n)-ask(id[t],id[t]+siz[t]-1),ln);\n            }\n            else out(ask(id[x],id[x]+siz[x]-1),ln);\n        }\n    }\n    flush();\n}\n```\n```cpp\n#include<bits\/stdc++.h>\nusing namespace std;\n#define ll long long\n#define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n#define N 100011\nint n,cnt=0,RT=1,head[N],c[N];\nstruct edge{\n    int to,nxt;\n}e[N];\nvoid add(int x,int y){\n    e[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;\n}\nint a[N];\nll s[N<<2],laz[N<<2];\n#define ls rt<<1\n#define rs rt<<1|1\n#define pu s[rt]=s[ls]+s[rs]\nvoid pd(int rt,int ln,int rn){\n    if(laz[rt]){\n        laz[ls]+=laz[rt];\n        laz[rs]+=laz[rt];\n        s[ls]+=ln*laz[rt];\n        s[rs]+=rn*laz[rt];\n        laz[rt]=0;\n    }\n}\nvoid build(int l,int r,int rt){\n    if(l==r){\n        s[rt]=a[l];\n        return;\n    }\n    int m=(l+r)>>1;\n    build(l,m,ls);build(m+1,r,rs);\n    pu;\n}\nvoid upd(int L,int R,int v,int l,int r,int rt){\n    if(L<=l&&r<=R){\n        s[rt]+=v*(r-l+1);\n        laz[rt]+=v;\n        return;\n    }\n    int m=(l+r)>>1;\n    pd(rt,m-l+1,r-m);\n    if(L<=m)upd(L,R,v,l,m,ls);\n    if(R>m)upd(L,R,v,m+1,r,rs);\n    pu;\n}\nll ask(int L,int R,int l,int r,int rt){\n    if(L<=l&&r<=R)return s[rt];\n    int m=(l+r)>>1;\n    ll ans=0;\n    pd(rt,m-l+1,r-m);\n    if(L<=m)ans=ask(L,R,l,m,ls);\n    if(R>m)ans+=ask(L,R,m+1,r,rs);\n    return ans;\n}\nint son[N],siz[N],top[N],id[N],f[N],d[N],sz=0;\nvoid dfs(int x){\n    siz[x]=1;\n    son[x]=0;\n    fl(i,x){\n        d[to]=d[x]+1;\n        dfs(to);\n        siz[x]+=siz[to];\n        if(siz[to]>siz[son[x]])son[x]=to;\n    }\n}\nvoid bt(int x,int tp){\n    top[x]=tp;id[x]=++sz;a[id[x]]=c[x];\n    if(!son[x])return;\n    bt(son[x],tp);\n    fl(i,x)if(!top[to])bt(to,to);\n}\nll fh(int x,int y){\n    ll ans=0;\n    while(top[x]!=top[y]){\n        if(d[top[x]]<d[top[y]])swap(x,y);\n        ans+=ask(id[top[x]],id[x],1,n,1);x=f[top[x]];\n    }\n    if(id[x]>id[y])swap(x,y);\n    return ans+ask(id[x],id[y],1,n,1);\n}\nvoid ul(int x,int y,int k){\n    while(top[x]!=top[y]){\n        if(d[top[x]]<d[top[y]])swap(x,y);\n        upd(id[top[x]],id[x],k,1,n,1);x=f[top[x]];\n    }\n    if(id[x]>id[y])swap(x,y);\n    upd(id[x],id[y],k,1,n,1);\n}\nint child(int x,int y){\n    while(top[x]!=top[y]){\n        x=top[x];\n        if(f[x]==y)return x;\n        x=f[x];\n    }\n    return son[y];\n}\nint main(){\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;++i)scanf(\"%d\",&c[i]);\n    int q,x,y,opt,k;\n    for(int i=2;i<=n;++i)\n        scanf(\"%d\",&f[i]),add(f[i],i);\n    dfs(1);bt(1,1);\n    build(1,n,1);\n    scanf(\"%d\",&q);\n    while(q--){\n        scanf(\"%d%d\",&opt,&x);\n        if(opt==1)RT=x;\n        if(opt==2)scanf(\"%d%d\",&y,&k),ul(x,y,k);\n        if(opt==3){\n            scanf(\"%d\",&k);\n            if(x==RT)upd(1,n,k,1,n,1);\n            else if(id[x]<=id[RT]&&id[RT]+siz[RT]<=id[x]+siz[x]){\n                int t=child(RT,x);\n                upd(1,n,k,1,n,1);\n                upd(id[t],id[t]+siz[t]-1,-k,1,n,1);\n            }\n            else upd(id[x],id[x]+siz[x]-1,k,1,n,1);\n        }\n        if(opt==4)scanf(\"%d\",&y),printf(\"%lld\\n\",fh(x,y));\n        if(opt==5){\n            if(x==RT)printf(\"%lld\\n\",s[1]);\n            else if(id[x]<=id[RT]&&id[RT]+siz[RT]<=id[x]+siz[x]){\n                int t=child(RT,x);\n                printf(\"%lld\\n\",s[1]-ask(id[t],id[t]+siz[t]-1,1,n,1));\n            }\n            else printf(\"%lld\\n\",ask(id[x],id[x]+siz[x]-1,1,n,1));\n        }\n    }\n}\n```\n","link":null,"tags":["树链剖分","模板"],"title":"LOJ 139 树链剖分"},{"categories":[["刷题记录"]],"content":"\n考虑一种颜色对答案的贡献\n\n把树中这种颜色的点都删掉,那么就会有很多的小树,这些小树中的点互相之间不会产生贡献,而不同树的两个点之间会产生贡献。\n\n可以得到每一种颜色,点的sum值就是**n - 所在小树的size**\n\n一个点的sum就是**n * 颜色数 - 每种颜色节点所在小树的size**\n\n\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\n#define N 100011\nint n,cnt=0,cs=0,head[N],col[N],siz[N],del[N],csz[N],tag[N];\nll ans[N],qwq=0;\nstruct edge{\n    int to,nxt;\n}e[N<<1];\nil void add(int x,int y){\n    e[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;\n}\nbool v[N];\nvoid dfs(int x,int f){\n    siz[x]=1;\n    int tt=del[col[f]];\n    fl(i,x)if(to!=f){\n        dfs(to,x);\n        siz[x]+=siz[to];\n    }\n    ++del[col[x]];\n    if(f){\n        csz[x]=siz[x]-del[col[f]]+tt;\/\/每种颜色节点所在小树的size\n        del[col[f]]+=csz[x];\n    }\n}\nvoid get(int x,int f){\n    int oldtag=tag[col[f]];\n    qwq+=csz[x]-tag[col[f]];\n    tag[col[f]]=csz[x];\n    ans[x]=1ll*n*cs-qwq+tag[col[x]];\n    fl(i,x)if(to!=f)get(to,x);\n    tag[col[f]]=oldtag;\n    qwq-=csz[x]-tag[col[f]];\n}\nint main(){\n    in(n);\n    Fur(i,1,n){\n        in(col[i]);\n        if(!v[col[i]])v[col[i]]=1,++cs;\n    }\n    int x,y;\n    Fur(i,1,n-1)\n        in(x,y),\n        add(x,y),add(y,x);\n    \n    dfs(1,0);\n    Fur(i,1,100000)\n    if(v[i]){\n        qwq+=n-del[i];\n        tag[i]=n-del[i];\n    }\n    get(1,0);\n    Fur(i,1,n)out(ans[i],ln);\n    flush();\n}\n```\n","link":null,"tags":["点分治","树上差分"],"title":"LG 2664 树上游戏"},{"categories":[["刷题记录"]],"content":"\n点分治\n```cpp\n#include<bits\/stdc++.h>\nusing namespace std;\n#define N 500011\n#define inf 1000000000\n#define ll long long\nint n,k,cnt=0,SZ,rt,mxs,head[N],siz[N];\nbool v[N];\nstruct edge{\n    int to,nxt;\n}e[N<<1];\nvoid add(int x,int y){\n    e[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;\n}\n#define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\nvoid frt(int x,int f){\n    siz[x]=1;\n    int res=0;\n    fl(i,x)if(!v[to]&&to!=f){\n        frt(to,x);\n        siz[x]+=siz[to];\n        res=max(res,siz[to]);\n    }\n    res=max(res,SZ-siz[x]);\n    if(res<mxs)rt=x,mxs=res;\n}\nint b[N],tt;\nll ans=0;\nvoid gd(int x,int d,int f){\n    if(d>k)return;\n    b[++tt]=d;\n    fl(i,x)if(!v[to]&&to!=f)gd(to,d+1,x);\n}\nll calc(int x,int d){\n    tt=0;gd(x,d,0);\n    sort(b+1,b+tt+1);\n    int l=0,r=tt;\n    ll res=0;\n    while(l<r){\n        ++l;\n        while(b[l]+b[r]>k&&l<r)--r;\n        if(b[l]+b[r]==k){\n            int t1=1,t2=1;\n            while(l<r&&b[l]==b[l+1])++l,++t1;\n            while(l<r&&b[r]==b[r-1])--r,++t2;\n            if(b[l]!=b[r])res+=1ll*t1*t2;\n            else res+=1ll*(t1+t2)*(t1+t2-1)\/2ll;\n        }\n    }\n    return res;\n}\nvoid sol(int x){\n    v[x]=1;ans+=calc(x,0);\n    fl(i,x)if(!v[to]){\n        ans-=calc(to,1);\n        rt=0,mxs=inf;SZ=siz[to];\n        frt(to,0);\n        sol(rt);\n    }\n}\nint main(){\n    scanf(\"%d%d\",&n,&k);\n    int x,y;\n    for(int i=1;i<=n-1;++i)\n        scanf(\"%d%d\",&x,&y),\n        add(x,y),add(y,x);\n    \n    rt=0,mxs=inf,SZ=n;\n    frt(1,0);\n    sol(rt);\n    printf(\"%lld\\n\",ans);\n}\n```\n","link":null,"tags":["点分治"],"title":"LG CF161D Distance-in-Tree"},{"categories":[["刷题记录"]],"content":"\n点分治\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\n#define N 20011\nint n,cnt=0,head[N];\nstruct edge{\n    int to,nxt,w;\n}e[N<<1];\nvoid add(int x,int y,int w){\n    e[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;e[cnt].w=w;\n}\nint siz[N],SZ,rt,mxs,ans=0,b[3];\nbool v[N];\nvoid frt(int x,int f){\n    siz[x]=1;\n    int res=0;\n    fl(i,x)if(!v[to]&&to!=f){\n        frt(to,x);\n        siz[x]+=siz[to];\n        res=MAX(res,siz[to]);\n    }\n    res=MAX(res,SZ-siz[x]);\n    if(res<mxs)rt=x,mxs=res;\n}\nvoid gd(int x,int d,int f){\n    ++b[d%3];\n    fl(i,x)if(!v[to]&&to!=f)gd(to,d+e[i].w,x);\n}\nint calc(int x,int d){\n    clr(b,0);\n    gd(x,d,0);\n    return b[0]*b[0]+b[1]*(b[2]<<1);\n}\nvoid sol(int x){\n    v[x]=1;\n    ans+=calc(x,0);\n    fl(i,x)if(!v[to]){\n        ans-=calc(to,e[i].w);\n        rt=0,mxs=inf,SZ=siz[to];\n        frt(to,x);\n        sol(rt);\n    }\n}\nint main(){\n    in(n);\n    int x,y,w;\n    Fur(i,1,n-1)\n        in(x,y,w),\n        add(x,y,w),\n        add(y,x,w);\n    \n    rt=0,mxs=inf;SZ=n;\n    frt(1,0);\n    sol(rt);\n    int fm=n*n,gcd=GCD(fm,ans);\n    fm\/=gcd;ans\/=gcd;\n    cout<<ans<<\"\/\"<<fm<<endl;\n}\n```\n","link":null,"tags":["点分治"],"title":"LG 2634 [国家集训队]聪聪可可"},{"categories":[["刷题记录"]],"content":"\n我们先预处理出$L_i,R_i$分别表示与$a_i$相同的数出现在$i$左边和右边的位置\n\n我们可以使用分治来判断一个区间是否合法\n\n我们设当前区间为$[l,r]$\n\n从两边一起找\n\n假设枚举到位置$i$若$L_i＜l$且$R_i>r$,那么左端点在$[l,i]$,右端点在$[i,r]$的区间都是\"non-boring\"\n\n这时我们只需要判断区间$[l,i-1]$和$[i+1,r]$是否合法就可以了\n\n复杂度可以降至$\\Theta(n \\log n)$\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i=x;i<=y;++i)\n    #define Fdr(i,x,y) for(int i=x;i>=y;--i)\n    #define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){clr(ch,0);if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 200011\nint n,a[N],L[N],R[N];\nmap<int,int>mp;\nbool chk(int l,int r){\n    if(l>=r)return 1;\n    int i=l,j=r;\n    while(i<=j){\n        if(L[i]<l&&R[i]>r)return chk(l,i-1)&&chk(i+1,r);\n        if(L[j]<l&&R[j]>r)return chk(l,j-1)&&chk(j+1,r);\n        ++i;--j;\n    }\n    return 0;\n}\nvoid work(){\n    in>>n;\n    Fur(i,1,n)in>>a[i];\n    mp.clear();\n    Fdr(i,n,1){\n        R[i]=mp[a[i]];\n        if(!R[i])R[i]=n+1;\n        mp[a[i]]=i;\n    }\n    mp.clear();\n    Fur(i,1,n){\n        L[i]=mp[a[i]];\n        mp[a[i]]=i;\n    }\n    out<<(chk(1,n)?\"non-boring\":\"boring\")<<ln;\n}\nint main(){\n    fin(\"in\");\n    int T;in>>T;\n    while(T--)work();\n}\n```\n","link":null,"tags":["分治","思维"],"title":"LG UVA1608 不无聊的序列 Non-boring sequences"},{"categories":[["刷题记录"]],"content":"\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\n#define N 100011\nint n;\nint main(){\n    \n}\n```\n","link":null,"tags":["数论","扩展欧几里德"],"title":"LG 1762 偶数"},{"categories":[["算法","树论"],["note"]],"content":"\n形态: 在一棵树上加多一条边\n\n实现:\n\n找出环后一次处理环上每个点的子树,然后再处理环\n\n## [IOI 2008]Island(求基环树直径)\n\n[IOI 2008 Island](https:\/\/www.luogu.com.cn\/problem\/P4381)\n\n先找出环,把环当根节点,找出每棵子树的直径和最大深度$d_x$\n\n接着就要在环上找到两点$x,y$使$d_x+dis(x,y)+d_y$最大\n\n可以破环后用单调队列$\\mathcal O(n)$处理\n\n```cpp\n#include<cstdio>\nconst int N=1000011;\n#define ll long long\n#define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\ninline ll max(ll x,ll y){return x>y?x:y;}\nint n,cnt=0,head[N],dfn[N],sz=0,pre[N],tt[N],tot=0,q[N];\nbool b[N];\nstruct edge{\n    int to,nxt,w;\n}e[N<<1];\nvoid add(int x,int y,int w){\n    e[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;e[cnt].w=w;\n}\nvoid dfs(int x){\n    dfn[x]=++sz;\n    fl(i,x)if(to!=pre[x]){\n        if(dfn[to]){\n            if(dfn[to]<dfn[x])continue;\n            b[tt[++tot]=x]=1;\n            for(int y=to;y!=x;y=pre[y])b[tt[++tot]=y]=1;\n        }\n        else pre[to]=x,dfs(to);\n    }\n}\nll f[N],d[N],s[N],ans=0;\nvoid dp(int x,int fa){\n    fl(i,x)if(to!=fa&&!b[to]){\n        dp(to,x);\n        f[x]=max(f[x],max(f[to],d[x]+d[to]+e[i].w));\n        d[x]=max(d[x],d[to]+e[i].w);\n    }\n}\nvoid work(int x){\n    ll tmp=0;\n    tot=0;\n    dfs(x);\n    tt[tot+1]=tt[1];\n    int p=0;\n    for(int i=1;i<=tot;++i)\n        fl(j,tt[i])if(to==tt[i+1])\n            s[++p]=e[j].w;\n    for(int i=1;i<=tot+1;++i)\n        tt[i+tot]=tt[i],s[i+tot]=s[i];\n    for(int i=2;i<=tot*2;++i)s[i]+=s[i-1];\n    for(int i=1;i<=tot;++i)dp(tt[i],0),tmp=max(tmp,max(f[tt[i]],d[tt[i]]));\n    int h=1,t=0;\n    for(int i=1;i<=tot*2;++i){\n        while(h<=t&&i-q[h]>=tot)++h;\n        if(h<=t)tmp=max(tmp,d[tt[i]]+d[tt[q[h]]]+s[i-1]-s[q[h]-1]);\n        while(h<=t&&d[tt[i]]-s[i-1]>=d[tt[q[t]]]-s[q[t]-1])--t;\n        q[++t]=i;\n    }\n    ans+=tmp;\n}\nint main(){\n    scanf(\"%d\",&n);\n    int y,w;\n    for(int i=1;i<=n;++i)\n        scanf(\"%d%d\",&y,&w),\n        add(i,y,w),add(y,i,w);\n    for(int i=1;i<=n;++i)if(!dfn[i])work(i);\n    printf(\"%lld\\n\",ans);\n}\n```\n\n## 创世纪(基环树dp)\n\n[创世纪](https:\/\/www.acwing.com\/problem\/content\/361\/)\n\n两次dp解决代替基环树dp\n\n所有的$A_i\\rightarrow i$构成了一棵基环树\n\n我们先考虑如果基环树的子树怎么做\n\n也就是树型dp\n\n($f_x$表示不放,$g_x$表示放)\n\n若元素$i$不投放,\n\n$$f_x=\\sum_{A_y=x}\\max(f_y,g_y)$$\n\n否则必须至少有一个元素限制$i$,不能投放\n\n$$g_x=\\max_{A_y=x}\\{f_y+\\sum_{A_z=x,z\\not = y}\\max(f_z,g_z)\\}$$\n\n找到环上的一个点,将它和它限制的那个点断开,先后进行两次树形dp,\n\n第一次是假设环上的这个点对其限制的点不起限制作用\n\n另外一次是强制环上那个点已经限制了其可以限制的点（也就是环上那个点不选）\n\n```cpp\n#include<cstdio>\nint max(int x,int y){return x>y?x:y;}\nint min(int x,int y){return x<y?x:y;}\nconst int N=1000011;\nint n,cnt=0,head[N],A[N],f[N],g[N],RT;\nstruct edge{\n    int to,nxt;\n}e[N<<1];\nvoid add(int x,int y){e[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;}\nbool v[N];\nvoid dp(int x){\n    v[x]=1;f[x]=0;\n    int res=1<<30;\n    fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n    if(to!=RT){\n        dp(to);\n        f[x]+=max(f[to],g[to]);\n        res=min(res,max(g[to]-f[to],0));\n    }\n    g[x]=f[x]+1-res;\n}\nint main(){\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;++i)scanf(\"%d\",A+i),add(A[i],i);\n    int ans=0;\n    for(int i=1;i<=n;++i)\n    if(!v[i]){\n        int res=0;\n        RT=i;\n        while(!v[A[RT]]){\n            v[RT]=1;\n            RT=A[RT];\n        }\n        dp(RT);\n        res=max(f[RT],g[RT]);\n        RT=A[RT];\n        dp(RT);\n        ans+=max(res,max(f[RT],g[RT]));\n    }\n    printf(\"%d\\n\",ans);\n}\n```\n\n## [ZJOI2008]骑士(基环树dp)\n\n将一个骑士与他最痛恨的人连边\n\n先考虑这个如果是树型dp：\n\n$f_x$表示不取$x$,$g_x$表示取$x$\n\n$$\nf_x=\\sum \\max(f_{to},g_{to})\n\\\\\ng_x=\\sum f_{to}\n$$\n\n我们可以用两次树型dp代替基环树dp\n\n第一次： 选择$x$,不选择$x$最痛恨的人\n\n第一次： 选择$x$最痛恨的人,不选择$x$\n\n```cpp\n#include<cstdio>\nint max(int x,int y){return x>y?x:y;}\nconst int N=1000011;\nint n,cnt=0,head[N],val[N],a[N],rt;\nlong long f[N],g[N],ans=0,res,inf=1ll<<60;\nstruct edge{\n    int to,nxt;\n}e[N<<1];\nvoid add(int x,int y){e[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;}\nbool v[N];\nvoid dp(int x){\n    f[x]=0;g[x]=val[x];\n    v[x]=1;\n    for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n    if(to!=rt){\n        dp(to);\n        f[x]+=max(f[to],g[to]);\n        g[x]+=f[to];\n    }\n    else g[to]=-inf;\n}\nint main(){\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;++i)\n        scanf(\"%d%d\",val+i,a+i),add(a[i],i);\n    for(int i=1;i<=n;++i)\n    if(!v[i]){\n        rt=i;\n        res=0;\n        while(!v[a[rt]]){\n            v[rt]=1;\n            rt=a[rt];\n        }\n        dp(rt);\/\/强制选i\n        res=max(f[rt],g[rt]);\n        rt=a[rt];\n        dp(rt);\/\/强制选a[i]\n        ans+=max(res,max(f[rt],g[rt]));\n    }\n    printf(\"%lld\\n\",ans);\n}\n```","link":null,"tags":["算法","技巧","树"],"title":"基环树"},{"categories":[["刷题记录"]],"content":"\n> qwq\n>\n> qwq\n> > > > > > > > > qwq\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\n#define N 2000011\nint n,cnt=0,head[N];\nstruct edge{\n    int to,nxt;\n}e[N];\nil void add(int x,int y){\n    e[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;\n}\nint dfn[N],low[N],sz=0,rt,rs;\nbool cut[N];\nvoid tarjan(int x,int f){\n    low[x]=dfn[x]=++sz;\n    fl(i,x)\n    if(!dfn[to]){\n        tarjan(to,x);\n        low[x]=MIN(low[x],low[to]);\n        if(low[to]>=dfn[x]){\n            if(x!=rt)cut[x]=1;\n            else ++rs;\n        }\n    }\n    else if(to!=f)low[x]=MIN(low[x],dfn[to]);\n}\nbool v[N];\nint st,ed;\nbool bfs(int x){\n    clr(v,0);\n    v[st]=v[x]=1;\n    queue<int>q;\n    q.push(st);\n    while(!q.empty()){\n        x=q.front();q.pop();\n        fl(i,x)\n        if(to==ed)return 0;\n        else if(!v[to])v[to]=1,q.push(to);\n    }\n    return 1;\n}\nint main(){\n    in(n);\n    int x,y;\n    while(1){\n        in(x,y);\n        if(!x||!y)break;\n        add(x,y),add(y,x);\n    }\n    in(st,ed);\n    rt=st;rs=0;\n    tarjan(st,st);\n    if(rs>=2)cut[st]=1;\n    Fur(i,1,n)\n    if(cut[i]&&bfs(i))\n        return cout<<i<<endl,0;\n    cout<<\"No solution\\n\";\n}\n```\n","link":null,"tags":["tarjan","双连通分量","割点"],"title":"LG 5058 [ZJOI2004]嗅探器"},{"categories":[["刷题记录"]],"content":"\n夫妻之间：$girl \\to boy$\n\n情人之间：$boy \\to girl$\n\n$Tarjan$求强连通分量,对于一对夫妻,如果两人在同一个强连通分量里,那么这对婚姻就是不安全的,反之,则是安全的。\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\n#define N 8011\nint n,m,cnt=0,head[N];\nstruct edge{\n    int to,nxt;\n}e[300011];\nvoid add(int x,int y){\n    e[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;\n}\nint low[N],dfn[N],sz=0,q[N],tp=0,bl[N];\nbool v[N];\nvoid tarjan(int x){\n    low[x]=dfn[x]=++sz;\n    v[x]=1;q[++tp]=x;\n    fl(i,x)\n    if(!dfn[to])\n        tarjan(to),low[x]=MIN(low[x],low[to]);\n    else if(v[to])low[x]=MIN(low[x],dfn[to]);\n    \n    if(dfn[x]==low[x])\n    while(int k=q[tp--]){\n        bl[k]=x;v[k]=0;\n        if(k==x)break;\n    }\n}\n#include<bits\/extc++.h>\nusing namespace __gnu_pbds;\ncc_hash_table<string,int>T;\nint main(){\n    in(n);\n    int x,y;\n    string s1,s2;\n    Fur(i,1,n){\n        in(s1,s2);\n        T[s1]=i;\n        T[s2]=i+n;\n        add(i,i+n);\n    }\n    in(m);\n    Fur(i,1,m){\n        in(s1,s2);\n        add(T[s2],T[s1]);\n    }\n    Fur(i,1,n*2)if(!dfn[i])tarjan(i);\n    Fur(i,1,n)\n        out((bl[i]!=bl[i+n])?\"Safe\":\"Unsafe\",ln);\n    flush();\n}\n```\n","link":null,"tags":["tarjan","强连通分量"],"title":"LG 1407 [国家集训队]稳定婚姻"},{"categories":[["刷题记录"]],"content":"\n假设当前被封锁的是$x$\n\n如果$x$不是割点,那么除$x$外的点都连通,答案为$2\\times(n-1)$($x$和其他$n-1$个点配对)\n\n如果$x$是割点,删掉$x$后图会变成若干个连通块,设这些连通块大小为$t_1,t_2,...,t_a$\n\n那么答案为:$\\sum_{i=1}^a t_i\\times(n-t_i)+(1+sum)\\times(n-sum-1)+n-1$\n\n\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\n#define N 100011\nint n,m,cnt=0,head[N],siz[N];\nstruct edge{\n    int to,nxt;\n}e[1000011];\nvoid add(int x,int y){\n    e[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;\n}\nbool cut[N];\nint dfn[N],low[N],sz=0,rt,rs;\nll ans[N];\nvoid tarjan(int x){\n    dfn[x]=low[x]=++sz;\n    siz[x]=1;\n    int sum=1,cc=0;\n    fl(i,x)\n    if(!dfn[to]){\n        tarjan(to);\n        siz[x]+=siz[to];\n        low[x]=MIN(low[x],low[to]);\n        if(low[to]>=dfn[x]){\n            ans[x]+=1ll*siz[to]*(n-siz[to]);\n            sum+=siz[to];\n            ++cc;\n            if(x!=1||cc>=2)cut[x]=1;\n        }\n    }\n    else low[x]=MIN(low[x],dfn[to]);\n    if(!cut[x])ans[x]=2*(n-1);\n    else ans[x]+=1ll*sum*(n-sum)+n-1;\n}\n\nint main(){\n    in(n,m);\n    int x,y;\n    Fur(i,1,m)\n        in(x,y),\n        add(x,y),add(y,x);\n\n    tarjan(1);\n    Fur(i,1,n)out(ans[i],ln);\n    flush();\n}\n```\n","link":null,"tags":["tarjan","割点"],"title":"LG 3469 [POI2008]BLO-Blockade"},{"categories":[["刷题记录"]],"content":"\n分类讨论：\n\n用$Tarjan$跑出割点,然后$DFS$搜索所有的联通快\n\n计算每一个联通快中的割点数目\n\n分类讨论：\n\n1. 没有割点\n   \n   至少需要建立两个出口\n\n   从任意非割点的地方选择两个点建立\n\n2. 这个分组只有一个割点\n\n   只需要在分组内设立一个出口\n\n   可以设立在任意一个非割点的地方\n\n3. 有两个及以上个割点,则无需建立,可以直接到达其他联通块\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\n#define N 50011\nint n,m,cnt=0,head[N];\nstruct edge{\n    int to,nxt;\n}e[100011];\nil void add(int x,int y){\n    e[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;\n}\nint dfn[N],low[N],sz=0,rt,rs,v[N],tt,num,cuts=0;\nbool cut[N];\nvoid tarjan(int x,int f){\n    dfn[x]=low[x]=++sz;\n    fl(i,x)\n    if(!dfn[to]){\n        tarjan(to,x);\n        low[x]=MIN(low[x],low[to]);\n        if(low[to]>=dfn[x]){\n            if(x!=rt)cut[x]=1;\n            else ++rs;\n        }\n    }\n    else if(to!=f)low[x]=MIN(low[x],dfn[to]);\n}\nvoid dfs(int x){\n    v[x]=tt;\n    ++num;\n    fl(i,x){\n        if(cut[to]&&v[to]!=tt){\n            ++cuts;\n            v[to]=tt;\n        }\n        if(!v[to])dfs(to);\n    }\n}\nint CASE=0;\nvoid work(){\n    in(m);\n    if(!m)flush(),exit(0);\n    clr(head,0);sz=cnt=tt=0;\n    clr(cut,0);clr(v,0);\n    clr(dfn,0);clr(low,0);\n\n    int x,y;\n    ll ans1=0,ans2=1;\n    n=0;\n    Fur(i,1,m){\n        in(x,y);\n        add(x,y),add(y,x);\n        n=MAX(n,MAX(x,y));\n    }\n    Fur(i,1,n)\n    if(!dfn[i]){\n        rt=i;rs=0;\n        tarjan(i,i);\n        if(rs>=2)cut[i]=1;\n    }\n    Fur(i,1,n)\n    if(!v[i]&&!cut[i]){\n        ++tt;\n        num=cuts=0;\n        dfs(i);\n        if(!cuts)\n            ans1+=2ll,\n            ans2*=1ll*(num-1)*num\/2;\n        if(cuts==1)\n            ++ans1,\n            ans2*=1ll*num;\n    }\n\n    out(\"Case \",++CASE,\": \",ans1,\" \",ans2,ln);\n}\nint main(){\n    while(1)work();\n}\n```\n","link":null,"tags":["tarjan","组合数"],"title":"LG 3225 [HNOI2012]矿场搭建"},{"categories":[["刷题记录"]],"content":"\nkruskal重构树模板\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{\n    const int str=1<<20;\n    \/\/in\n    static char in_buf[str],*in_s,*in_t;\n    bool __=0;\n    il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}\n    template<typename T>\n    il void in(T &x){\n        if(__)return;\n        char c=gc();\n        bool f=0;\n        while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();\n        if(c==EOF){__=1;return;}\n        x=0;\n        while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();\n        if(c==EOF)__=1;\n        if(f)x=-x;\n    }\n\n    \/\/out\n    const char ln='\\n';\n    static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;\n    il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}\n    il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}\n    template<typename T>\n    il void out(T x){\n        if(!x){pt('0');return;}\n        if(x<0)pt('-'),x=-x;\n        char a[50],t=0;\n        while(x)a[t++]=x%10,x\/= 10;\n        while(t--)pt(a[t]+'0');\n    }\n}using namespace IO;\n#define N 30011\nint n,m,q,cnt=0,head[N],f[N],ne[N];\nstruct edge{\n    int to,nxt;\n}e[N*2];\nil void add(int x,int y){e[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;}\nstruct link{\n    int x,y,w;\n    il bool operator<(link x){return w<x.w;}\n}E[N];\nint gf(int x){return (x==f[x])?x:(f[x]=gf(f[x]));}\nint s[16][N];\nil void st(){\n    int sz=l2(n<<1);\n    Fur(k,1,sz)\n        Fur(i,1,(n<<1)-(1<<k)+1)\n        s[k][i]=MAX(s[k-1][i],s[k-1][i+(1<<(k-1))]);\n}\nil int ask(int l,int r){\n    int k=l2(r-l+1);\n    return MAX(s[k][l],s[k][r-(1<<k)+1]);\n}\nint top[N],d[N],siz[N],id[N],sz=0;\nvoid dfs(int x){\n    siz[x]=1;\n    fl(i,x){\n        d[to]=d[x]+1;\n        f[to]=x;\n        dfs(to);\n        siz[x]+=siz[to];\n    }\n}\nvoid bt(int x,int tp){\n    top[x]=tp;id[x]=++sz;\n    s[0][sz]=ne[x];\n    int k=0;\n    fl(i,x)if(siz[to]>siz[k])k=to;\n    if(!k)return;bt(k,tp);\n    fl(i,x)if(to!=k)bt(to,to);\n}\nil int fh(int x,int y){\n    int ans=0;\n    while(top[x]!=top[y]){\n        if(d[top[x]]<d[top[y]])SWAP(x,y);\n        ans=MAX(ans,ask(id[top[x]],id[x]));x=f[top[x]];\n    }\n    if(id[x]>id[y])SWAP(x,y);\n    return MAX(ans,ask(id[x],id[y]));\n}\nint main(){\n    in(n),in(m),in(q);\n    int x,y,w,t=n;\n    Fur(i,1,m)in(E[i].x),in(E[i].y),in(E[i].w);\n    sort(E+1,E+m+1);\n    Fur(i,1,n)f[i]=i;\n    Fur(i,1,m){\n        x=gf(E[i].x),y=gf(E[i].y);\n        if(x==y)continue;\n        ne[++t]=E[i].w;\n        f[x]=f[y]=f[t]=t;\n        add(t,x),add(t,y);\n    }\n    dfs(t);\n    bt(t,t);\n    st();\n    while(q--)\n        in(x),in(y),\n        out(fh(x,y)),pt(ln);\n    flush();\n}\n```\n","link":null,"tags":["kruskal重构树","rmq","lca"],"title":"BZ 3732 Network"},{"categories":[["刷题记录"]],"content":"\n可以先考虑离散化\n\n离散话后是$1～n$\n\n一般要求中位数可以:\n\n二分中位数$x$\n\n将区间中$<x$的赋值为$-1$,$\\ge x$的赋值为$-1$\n\n若区间和为$0$,那么$x$就是中位数\n\n题目是要求左端点在$[a,b]$,右端点在$[c,d]$的序列的最大中位数\n\n区间$[b+1,c-1]$是必选的\n\n我们可以求$[a,b]$的最大后缀和$[c,d]$的最大前缀\n\n如果这三个部分的和大于零,那么当前二分的值是合法的\n\n~~这个一看就可以用线段树维护~~\n\n\n\n我们再来考虑$x$变成$x+1$会有什么变化：\n\n1. 原来$<x$的还是$-1$\n2. 原来$>x$的还是$1$\n3. 原来$=x$变成$-1$\n\n所以我们只需修改值为$x$的位置(可以先用链表或$vector$存下所有值为$x$的位置)\n\n其实从小到大排序后按顺序更改就完事了\n\n数离散化后的大小不超过$n$\n\n我们可以先预处理出所有$x$(中位数)对应的线段树\n\n可是空间不够啊\n\n这时候主席树就派上用场了\n\n下面是简洁的代码：\n\n```cpp\n#include<bits\/stdc++.h>\nusing namespace std;\n#define N 20011\nint n,la=0;\nstruct node{\n    int v,p;\n    bool operator<(node x){return v<x.v;}\n}b[N];\nint ls[N*15],rs[N*15],rt[N],s[N*15],lm[N*15],rm[N*15],sz=0;\nvoid pu(int x){\n    s[x]=s[ls[x]]+s[rs[x]];\n    lm[x]=max(lm[ls[x]],s[ls[x]]+lm[rs[x]]);\n    rm[x]=max(rm[rs[x]],s[rs[x]]+rm[ls[x]]);\n}\nvoid build(int l,int r,int &x){\n    x=++sz;\n    if(l==r){\n        s[x]=lm[x]=rm[x]=1;\n        return;\n    }\n    int m=(l+r)>>1;\n    build(l,m,ls[x]);build(m+1,r,rs[x]);\n    pu(x);\n}\nvoid upd(int l,int r,int p,int &x,int pre){\n    if(!x)x=++sz;\n    if(l==r){\n        s[x]=lm[x]=rm[x]=-1;\n        return;\n    }\n    int m=(l+r)>>1;\n    if(p<=m)upd(l,m,p,ls[x],ls[pre]),rs[x]=rs[pre];\n    else upd(m+1,r,p,rs[x],rs[pre]),ls[x]=ls[pre];\n    pu(x);\n}\nint qs(int L,int R,int l,int r,int x){\n    if(L<=l&&r<=R)return s[x];\n    int m=(l+r)>>1;\n    if(L<=m&&R>m)return qs(L,R,l,m,ls[x])+qs(L,R,m+1,r,rs[x]);\n    else if(L<=m)return qs(L,R,l,m,ls[x]);\n    else return qs(L,R,m+1,r,rs[x]);\n}\nstruct tr{int s,lm,rm;};\ntr operator+(tr x,tr y){\n    tr ans;\n    ans.s=x.s+y.s;\n    ans.lm=max(x.lm,x.s+y.lm);\n    ans.rm=max(y.rm,y.s+x.rm);\n    return ans;\n}\ntr qm(int L,int R,int l,int r,int x){\n    if(L<=l&&r<=R)return tr{s[x],lm[x],rm[x]};\n    int m=(l+r)>>1;\n    if(L<=m&&R>m)return qm(L,R,l,m,ls[x])+qm(L,R,m+1,r,rs[x]);\n    else if(L<=m)return qm(L,R,l,m,ls[x]);\n    else return qm(L,R,m+1,r,rs[x]);\n}\nvoid work(){\n    int A,B,C,D,q[4];\n    scanf(\"%d%d%d%d\",q+0,q+1,q+2,q+3);\n    q[0]=(q[0]+la)%n+1;\n    q[1]=(q[1]+la)%n+1;\n    q[2]=(q[2]+la)%n+1;\n    q[3]=(q[3]+la)%n+1;\n    sort(q,q+4);\n    A=q[0],B=q[1],C=q[2],D=q[3];\n    int l=1,r=n,ans;\n    while(l<=r){\n        int m=(l+r)>>1,tot=0;\n        if(B+1<=C-1)tot=qs(B+1,C-1,1,n,rt[m]);\n        tot+=qm(A,B,1,n,rt[m]).rm+qm(C,D,1,n,rt[m]).lm;\n        if(tot>=0)ans=m,l=m+1;\n        else r=m-1;\n    }\n    printf(\"%d\\n\",la=b[ans].v);\n}\nint main(){\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;++i)scanf(\"%d\",&b[i]),b[i].p=i;\n    sort(b+1,b+n+1);\n    build(1,n,rt[1]);\n    for(int i=2;i<=n;++i)\n        upd(1,n,b[i-1].p,rt[i],rt[i-1]);\n    int q;scanf(\"%d\",&q);\n    while(q--)work();\n}\n```\n","link":null,"tags":["二分","主席树"],"title":"LG 2839 [国家集训队]middle"},{"categories":[["刷题记录"]],"content":"\n可以算是$kruskal$重构树的模板题\n\n建完$kruskal$重构树,我们可以发现一个节点(新建的带点权的点)能走到的节点一定在它的子树中\n\n那么我们可以用$dfs$序+主席树维护\n\n> ## kruskal重构树\n> \n> 我们回想一下$kruskal$生成最小生成树的过程：\n> \n> 先将边按边权从小到大排序,然后依次加入\n> \n> 如果$x,y$已经联通,则跳过这条边\n> \n> 否则连接$x,y$\n> \n> $kruskal$重构树是在$kruskal$生成最小生成树的,\n> \n> 连接$x,y$时,将边权变成一个新的节点$t$权值为边权,然后连边> $t\\rightarrow x,t\\rightarrow y$\n> \n> 代码：\n> \n> ```cpp\n> void kruskal(){\n>     int x,y,tt=n;\n>     sort(E+1,E+m+1);\/\/将边排序\n>     Fur(i,1,n)fa[i]=i;\n>     Fur(i,1,m){\n>         x=gf(E[i].x),y=gf(E[i].y);\n>         if(x==y)continue;\/\/如果已经联通则跳过\n>         ne[++tt]=E[i].w;\/\/点权赋值为边权\n>         fa[x]=fa[y]=fa[tt]=tt;\n>         f[0][x]=f[0][y]=tt;\n>         \/\/维护并查集\n>         add(tt,x);add(tt,y);\/\/连边t→x,t→y\n>     }\n> }\n> ```\n> \n> $kruskal$重构树还有很多有意思的性质\n> \n> 1. 是一个二叉树\n> 2. **如果是按最小生成树建立的话是一个大根堆**\n> 3. 任意两个点路径上边权的最大值为它们的LCA的点权\n> 4. 重构树中代表原树中的点的节点全是叶子节点,其余节点都代表了一条边的边权。\n\n给出重构后的图(帮助理解)：\n\n![](https:\/\/cdn.luogu.org\/upload\/pic\/67842.png)\n\n(红色的是原来的节点)\n\n可以倍增求出最远的满足要求的祖先\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\n#define N 200011\nint n,m,q,SZ=0,rt[N];\nstruct node{\n    int v,p;\n    il bool operator<(node x){return v<x.v;}\n}b[N];\nint a[N],c[N];\nstruct link{\n    int x,y,w;\n    il bool operator<(link x){return w<x.w;}\n}E[500011];\nvoid init(){\n    in(n,m,q);\n    Fur(i,1,n)in(b[i].v),b[i].p=i;\n    sort(b+1,b+n+1);\n    b[0].v=-inf;\n    sort(b+1,b+n+1);\n    Fur(i,1,n){\n        SZ+=(b[i].v!=b[i-1].v);\n        c[a[b[i].p]=SZ]=b[i].v;\n    }\n    Fur(i,1,m)in(E[i].x,E[i].y,E[i].w);\n}\nint fa[N],f[21][N];\nint gf(int x){return (x==fa[x])?x:(fa[x]=gf(fa[x]));}\nstruct tree{\n    int s[N*20],sz=0,ls[N*20],rs[N*20];\n    void build(int l,int r,int &x){\n        s[x=++sz]=0;\n        if(l==r)return;\n        int m=(l+r)>>1;\n        build(l,m,ls[x]);\n        build(m+1,r,rs[x]);\n    }\n    void ins(int l,int r,int v,int &x,int pre){\n        x=++sz;\n        s[x]=s[pre]+1;\n        ls[x]=ls[pre];\n        rs[x]=rs[pre];\n        if(l==r)return;\n        int m=(l+r)>>1;\n        if(v<=m)ins(l,m,v,ls[x],ls[pre]);\n        else ins(m+1,r,v,rs[x],rs[pre]);\n    }\n    int ask(int l,int r,int k,int x,int y){\n        if(l==r)return l;\n        int m=(l+r)>>1,sum=s[rs[y]]-s[rs[x]];\n        if(k<=sum)return ask(m+1,r,k,rs[x],rs[y]);\n        else return ask(l,m,k-sum,ls[x],ls[y]);\n    }\n}T;\nint cnt=0,head[N];\nstruct edge{\n    int to,nxt;\n}e[N*2];\nil void add(int x,int y){e[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;}\nint L[N],R[N],dfn=0;\nvoid dfs(int x){\n    Fur(i,1,20)f[i][x]=f[i-1][f[i-1][x]];\n    L[x]=dfn;\n    if(!head[x]){\n        L[x]=++dfn;\n        T.ins(1,SZ,a[x],rt[dfn],rt[dfn-1]);\n        R[x]=dfn;\n        return;\n    }\n    fl(i,x)dfs(to);\n    R[x]=dfn;\n}\nint ne[N];\nvoid kruskal(){\n    int x,y,tt=n;\n    sort(E+1,E+m+1);\n    Fur(i,1,n)fa[i]=i;\n    Fur(i,1,m){\n        x=gf(E[i].x),y=gf(E[i].y);\n        if(x==y)continue;\n        ne[++tt]=E[i].w;\n        fa[x]=fa[y]=fa[tt]=tt;\n        f[0][x]=f[0][y]=tt;\n        add(tt,x);add(tt,y);\n    }\n    T.build(1,SZ,rt[0]);\n    dfs(tt);\n}\nvoid solve(){\n    int x,w,k;\n    while(q--){\n        in(x,w,k);\n        Fdr(i,20,0)if(f[i][x]&&ne[f[i][x]]<=w)x=f[i][x];\n        if(R[x]-L[x]<k)out(\"-1\\n\");\n        else out(c[T.ask(1,SZ,k,rt[L[x]],rt[R[x]])],ln);\n    }\n}\nint main(){\n    init();\n    kruskal();\n    solve();\n    flush();\n    return 0;\n}\n```\n","link":null,"tags":["kruskal重构树","倍增","主席树"],"title":"LG 4197 Peaks"},{"categories":[["刷题记录"]],"content":"\n## 解法1\n\n主席树+离散化(深度太大需要离散化)\n\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf (1ll<<60)\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\n#define N 200011\n#define int ll\nint n,len;\nint cnt=0,head[N];\nint d[N],f[N],mxd=0,siz[N],DFN=0,dfn[N];\nint rt[N],ls[N*30],rs[N*30],s[N*30],sz=0,b[N],tt;\nstruct edge{\n    int to,nxt;\n}e[N];\nvoid add(int x,int y){\n    e[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;\n}\nint build(int l,int r){\n    int x=++sz;\n    if(l==r)return x;\n    int m=(l+r)>>1;\n    ls[x]=build(l,m);\n    rs[x]=build(m+1,r);\n    return x;\n}\nvoid ins(int l,int r,int v,int &x,int pre){\n    x=++sz;\n    ls[x]=ls[pre];\n    rs[x]=rs[pre];\n    s[x]=s[pre]+1;\n    if(l==r)return;\n    int m=(l+r)>>1;\n    if(v<=m)ins(l,m,v,ls[x],ls[pre]);\n    else ins(m+1,r,v,rs[x],rs[pre]);\n}\nint ask(int ql,int qr,int l,int r,int x,int y){\n    if(ql<=l&&r<=qr)return s[y]-s[x];\n    int m=(l+r)>>1,ans=0;\n    if(ql<=m)ans=ask(ql,qr,l,m,ls[x],ls[y]);\n    if(qr>m)ans+=ask(ql,qr,m+1,r,rs[x],rs[y]);\n    return ans;\n}\nvoid dfs(int x){\n    siz[x]=1;\n    dfn[x]=++DFN;\n    int k=lower_bound(b+1,b+tt+1,d[x])-b;\n    ins(1,tt,k,rt[DFN],rt[DFN-1]);\n    fl(i,x)dfs(to),siz[x]+=siz[to];\n}\nsigned main(){\n    in(n,len);\n    int x,y;\n    b[1]=0;\n    Fur(i,2,n)\n        in(f[i],y),\n        b[i]=d[i]=y+d[f[i]],\n        add(f[i],i);\n    \n    b[n+1]=inf;\n    sort(b+1,b+n+2);\n    tt=unique(b+1,b+n+2)-b-1;\n\n    rt[0]=build(1,tt);\n    dfs(1);\n\n    Fur(i,1,n){\n        int k=lower_bound(b+1,b+tt+1,d[i])-b-1;\n        if(b[k+1]==d[i])++k;\n        int kk=lower_bound(b+1,b+tt+1,d[i]+len)-b-1;\n        if(b[kk+1]==d[i]+len)++kk;\n        if(kk==tt-1)out(siz[i],ln);\n        else out(ask(k,kk,1,tt,rt[dfn[i]-1],rt[dfn[i]+siz[i]-1]),ln);\n    }\n    flush();\n}\n```\n## 解法2\n\n树上查分+倍增\n\n对于每个点u,找到离他最远的祖先v(满足距离小于len)\n\n那么u到v路径上每个点答案+1\n\n可以使用树上差分维护\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf (1ll<<60)\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\n#define N 200011\nint f[20][N],n,s[N];\nll len,d[N];\nil void gf(int x){Fur(i,1,19)f[i][x]=f[i-1][f[i-1][x]];}\nil void work(int x){\n    ++s[x];\n    ll t=len;\n    Fdr(i,19,0)if(d[x]-d[f[i][x]]<=t)\n        t-=d[x]-d[f[i][x]],x=f[i][x];\n    if(x!=1)--s[f[0][x]];\n}\nint main(){\n    in(n,len);\n    ll x;\n    f[0][1]=1;\n    Fur(i,2,n){\n        in(f[0][i],x);\n        d[i]=d[f[0][i]]+x;\n        gf(i);\n    }\n    Fur(i,1,n)work(i);\n    Fdr(i,n,2)s[f[0][i]]+=s[i];\n    Fur(i,1,n)out(s[i],ln);\n    flush();\n}\n```\n","link":null,"tags":["主席树","dfs序","离散化","差分","倍增"],"title":"LG 3066 [USACO12DEC]逃跑的BarnRunning-Away-From"},{"categories":[["刷题记录"]],"content":"\n先想想暴力做法：\n\nbfs出不涉水可以到达的点,然后在这些点中找出与点$1$的最小距离\n\n优化：\n\n我们可以使用kruskal重构树来快速求出这些点\n\n先按海拔从高到低排序,这样见出来的kruskal重构树的是海拔的小根堆\n\n我们可以倍增找出最远可以到达的祖先,然后求出这段区间中的点与点$1$的最小距离\n\n可以在dfs的时候预处理\n\n详见代码\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\n#define N 200011\nint n,m,cnt=0,d[N<<1],head[N];\nstruct link{\n    int x,y,l,a;\n    il bool operator<(link b){return a>b.a;}\n}E[N<<1];\nstruct edge{int to,nxt,w;}e[N<<2];\nil void add(int x,int y,int w){e[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;e[cnt].w=w;}\nbool v[N];\nil void dij(){\n    struct cmp{il bool operator()(int x,int y){return d[x]>d[y];}};\n    priority_queue<int,vector<int>,cmp>q;\n    Fur(i,1,n)d[i]=inf;\n    d[1]=0;\n    q.push(1);\n    while(!q.empty()){\n        int x=q.top();v[x]=0;q.pop();\n        fl(i,x)if(d[x]+e[i].w<d[to]){\n            d[to]=d[x]+e[i].w;\n            if(!v[to])v[to]=1,q.push(to);\n        }\n    }\n}\nint fa[N<<1],ne[N<<1],f[21][N<<1];\nint gf(int x){return (x==fa[x])?x:(fa[x]=gf(fa[x]));}\nint ls[N<<1],rs[N<<1];\nvoid dfs(int x){\n    Fur(i,1,20)f[i][x]=f[i-1][f[i-1][x]];\n    if(!ls[x])return;\n    dfs(ls[x]),dfs(rs[x]);\n    d[x]=MIN(d[ls[x]],d[rs[x]]);\n}\nil void work(){\n    clr(head,0);cnt=0;\n    clr(ls,0);clr(rs,0);\n    in(n,m);\n    int x,y,l,a,t=n;\n    Fur(i,1,m){\n        in(x,y,l,a);\n        E[i]=link{x,y,l,a};\n        add(x,y,l);add(y,x,l);\n    }\n    dij();\n    sort(E+1,E+m+1);\n    Fur(i,1,n*2+1)fa[i]=i;\n    Fur(i,1,m){\n        x=gf(E[i].x),y=gf(E[i].y);\n        if(x==y)continue;\n        ne[++t]=E[i].a;\n        fa[x]=fa[y]=fa[t]=t;\n        f[0][x]=f[0][y]=t;\n        ls[t]=x;rs[t]=y;\n    }\n    dfs(t);\n    int Q,K,S,p,la=0;\n    in(Q,K,S);\n    while(Q--){\n        in(x,p);\n        x=(x+K*la-1)%n+1;\n        p=(p+K*la)%(S+1);\n        Fdr(i,20,0)if(f[i][x]&&ne[f[i][x]]>p)x=f[i][x];\n        out(la=d[x],ln);\n    }\n}\nint main(){\n    int T;in(T);\n    while(T--)work();\n    flush();\n}\n```\n","link":null,"tags":["最短路","kruskal重构树","倍增"],"title":"LG 4768 [NOI2018]归程"},{"categories":[["刷题记录"]],"content":"\n## 扩展欧拉定理\n\n当$b\\ge \\varphi(m)$时,$a^b \\equiv a^{(b \\mod \\varphi(m))+\\varphi(m)} \\pmod m$\n```cpp\n#include<bits\/stdc++.h>\nusing namespace std;\nint a,m,b;\nint main(){\n    scanf(\"%d%d\",&a,&m);\n    \n}\n```\n","link":null,"tags":["数论","欧拉定理"],"title":"LG 5091 【模板】欧拉定理"},{"categories":[["刷题记录"]],"content":"\n这个图是个DAG,我们可以很快地处理出每个点以他为起点($ds_i$)或终点($dt_i$)的最长路\n\n接着我们枚举删掉哪个点\n\n我们可以将拓扑序小于当前点的点称作A集合,大于的称作B集合\n\n删掉这个点后的最长路有三种可能：\n\n$A\\rightarrow A,A\\rightarrow B,B\\rightarrow B$\n\n($to$指x连接的点)\n\n当删除一个点$x$时,我们可以删去所有集合中的$dt_to+1+ds_x$(反向图中的)\n\n求出集合中的最大值就是当前最长路长度\n\n接着将$dt_x+1+ds_to$加入集合,转移到下一个状态(原图中的)\n\n于是我们需要一个数据结构满足以下要求：\n\n1. 插入某个值\n2. 删除某个值\n3. 查找最大值\n\n我们可以用堆(手写堆或者两个stl优先队列)、平衡树、权值线段树等维护\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\n#define N 500111\n#define FL(i,x) for(int i(HEAD[x]),to;to=e[i].to,i;i=e[i].nxt)\nint n,m;\nint cnt=0,head[N],HEAD[N],deg[N];\nstruct edge{\n    int to,nxt;\n}e[N*4];\nil void add(int x,int y){\n    e[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;\n    e[++cnt].to=x;e[cnt].nxt=HEAD[y];HEAD[y]=cnt;\n}\nil void init(){\n    in(n,m);\n    Fur(i,1,m){\n        int x,y;\n        in(x,y);\n        add(x,y);\n        ++deg[y];\n    }\n}\nint ds[N],dt[N],q[N],a[N],dfn=0;\nil void topsort(){\n    int h=0,t=0;\n    Fur(i,1,n)if(!deg[i])q[t++]=i;\n    while(h<t){\n        int x=q[h++];a[++dfn]=x;\n        fl(i,x)if(!--deg[to])q[t++]=to;\n    }\n    Fur(t,1,n){\n        int x=a[t];\n        fl(i,x)dt[to]=MAX(dt[to],dt[x]+1);\n    }\n    Fdr(t,n,1){\n        int x=a[t];\n        FL(i,x)ds[to]=MAX(ds[to],ds[x]+1);\n    }\n}\nstruct ddd{\n    priority_queue<int>p,q;\n    il void ins(int x){q.push(x);}\n    il void del(int x){p.push(x);}\n    il int top(){\n        while(!p.empty()&&q.top()==p.top())\n            q.pop(),p.pop();\n        return q.top();\n    }\n}T;\nil void solve(){\n    Fur(i,1,n)T.ins(ds[i]);\n    int ans=T.top(),as;\n    Fur(t,1,n){\n        int x=a[t];T.del(ds[x]);\n        FL(i,x)T.del(dt[to]+1+ds[x]);\n        int tmp=T.top();\n        if(tmp<=ans)ans=tmp,as=x;\n        fl(i,x)T.ins(dt[x]+1+ds[to]);\n        T.ins(dt[x]);\n    }\n    cout<<as<<\" \"<<ans<<endl;\n}\nint main(){\n    init();\n    topsort();\n    solve();\n}\n```\n","link":null,"tags":["dag","堆","权值线段树","数据结构","平衡树"],"title":"LG 3573 [POI2014]RAJ-Rally"},{"categories":[["刷题记录"]],"content":"\n$\\overbrace{88...88}^{x\\text{个}8}$可以表示成：\n\n$8\\times \\frac{(10^x-1)}9$\n\n那么$8\\times \\frac{(10^x-1)}9=kL$\n\n$8\\times (10^x-1)=9kL$\n\n设$d=\\gcd(9L,8)=\\gcd(8,L)$\n\n$\\frac{8}d\\times (10^x-1)=\\frac{9L}dk$\n\n令$p=\\frac8d,q=\\frac{9L}{d}$\n\n$p\\times (10^x-1)=qk$\n\n$\\because \\gcd(p,q)=1$\n\n$\\therefore q|(10^x-1)$\n\n$\\frac{9L}{d}|(10^x-1)$\n\n$10^x \\equiv 1 \\pmod {\\frac{9L}{d}}$\n\n题目中要求的是最小的解\n\n符合欧拉定理：\n\n> 若$\\gcd(a,p)=1$,那么$a^{\\varphi(p)} \\equiv 1 \\pmod p$\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\n#define N 100011\nint n;\nint main(){\n    \n}\n```\n","link":null,"tags":["欧拉函数","数论"],"title":"POJ 3696 The-Luckiest-number"},{"categories":[["刷题记录"]],"content":"\n设$f_i$表示只经过第$i$个黑点的方案数\n\n$f_i$最初为${x_i+y_i-2}\\choose {x_i-1}$\n\n减去$(1,1)$到$(x_i,y_i)$这个范围内所有$f_j$的方案数就是最终答案了\n\n\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\n#define N 2011\nconst int mod=1000000007;\nint h,w,n,f[N];\nstruct node{\n    int x,y;\n}a[N];\nbool cmp(node p,node q){\n    if(p.x!=q.x)return p.x<q.x;\n    return p.y<q.y;\n}\n#define M 200011\nint fac[200012],inv[200012];\nint pw(int x,int p){\n    int ans=1;\n    while(p){\n        if(p&1)ans=1ll*ans*x%mod;\n        p>>=1;x=1ll*x*x%mod;\n    }\n    return ans;\n}\nvoid init(){\n    fac[0]=1;\n    Fur(i,1,M)fac[i]=1ll*fac[i-1]*i%mod;\n    inv[M]=pw(fac[M],mod-2);\n    Fdr(i,M-1,0)inv[i]=1ll*inv[i+1]*(i+1)%mod;\n}\nint C(int x,int y){\n    if(x<y)return 0;\n    return 1ll*fac[x]*inv[y]%mod*inv[x-y]%mod;\n}\nsigned main(){\n    init();\n    in(h,w,n);\n    Fur(i,1,n)in(a[i].x,a[i].y);\n    sort(a+1,a+n+1,cmp);\n    a[++n]=node{h,w};\n    Fur(i,1,n){\n        f[i]=C(a[i].x+a[i].y-2,a[i].x-1);\n        Fur(j,1,i-1)\n        if(a[j].y<=a[i].y){\n            f[i]-=1ll*f[j]*C(a[i].x-a[j].x+a[i].y-a[j].y,a[i].x-a[j].x)%mod;\n            while(f[i]<0)f[i]+=mod;\n        }\n    }\n    cout<<f[n]<<endl;\n}\n```\n","link":null,"tags":["动态规划","计数dp"],"title":"LG CF559C Gerald-and-Giant-Chess"},{"categories":[["刷题记录"]],"content":"\n可以看成两道题吧\n\n前$50\\%$: 二维前缀和+二分\n\n后$50\\%$: 主席树同时维护区间大于$k$的个数、总和,然后二分即可\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\n#define N 500011\nint n,a[N];\nint R,C,M,p[211][211],w[211][211][1001],W[211][211][1001];\nint getw(int x,int y,int X,int Y,int k){\n    return w[X][Y][k]-w[x-1][Y][k]-w[X][y-1][k]+w[x-1][y-1][k];\n}\nint getW(int x,int y,int X,int Y,int k){\n    return W[X][Y][k]-W[x-1][Y][k]-W[X][y-1][k]+W[x-1][y-1][k];\n}\nvoid sol1(){\n    int mx=0;\n    Fur(i,1,R)\n        Fur(j,1,C)\n            in(p[i][j]),\n            mx=MAX(mx,p[i][j]);\n    \n    Fur(k,0,mx)\n        Fur(i,1,R)\n            Fur(j,1,C)\n                w[i][j][k]=w[i-1][j][k]+w[i][j-1][k]-w[i-1][j-1][k]+(p[i][j]>=k),\n                W[i][j][k]=W[i-1][j][k]+W[i][j-1][k]-W[i-1][j-1][k]+(p[i][j]>=k?p[i][j]:0);\n        \n    while(M--){\n        int x,y,X,Y,h;\n        in(x,y,X,Y,h);\n        if(getW(x,y,X,Y,0)<h)out(\"Poor QLW\\n\");\n        else{\n            int l=0,r=mx+1,ans=-1;\n            while(l+1<r){\n                int m=(l+r)>>1;\n                if(getW(x,y,X,Y,m)>=h)ans=m,l=m;\n                else r=m;\n            }\n            if(ans==-1)out(\"Poor QLW\\n\");\n            else out(getw(x,y,X,Y,ans)-(getW(x,y,X,Y,ans)-h)\/ans,ln);\n        }\n    }\n}\nint rt[N],ls[N*20],rs[N*20],s[N*20],S[N*20],sz=0;\nvoid build(int &x,int l,int r){\n    s[x=++sz]=0;\n    S[x]=0;\n    if(l==r)return;\n    int m=(l+r)>>1;\n    build(ls[x],l,m);build(rs[x],m+1,r);\n}\nvoid ins(int l,int r,int v,int &x,int pre){\n    x=++sz;\n    s[x]=s[pre]+1;\n    S[x]=S[pre]+v;\n    ls[x]=ls[pre];\n    rs[x]=rs[pre];\n    if(l==r)return;\n    int m=(l+r)>>1;\n    if(v<=m)ins(l,m,v,ls[x],ls[pre]);\n    else ins(m+1,r,v,rs[x],rs[pre]);\n}\nint ask(int l,int r,int tt,int x,int y){\n    int ans=0;\n    while(l<r){\n        int m=(l+r)>>1;\n        int sum=S[rs[y]]-S[rs[x]];\n        if(sum<tt)ans+=s[rs[y]]-s[rs[x]],tt-=sum,r=m,x=ls[x],y=ls[y];\n        else l=m+1,x=rs[x],y=rs[y];\n    }\n    ans+=(tt+l-1)\/l;\n    return ans;\n}\nvoid sol2(){\n    n=C;\n    build(rt[0],1,1000);\n    Fur(i,1,n)in(a[i]),ins(1,1000,a[i],rt[i],rt[i-1]);\n    int l,r,h;\n    while(M--){\n        in(l,l,r,r,h);\n        if(S[rt[r]]-S[rt[l-1]]<h)out(\"Poor QLW\\n\");\n        else out(ask(1,1000,h,rt[l-1],rt[r]),ln);\n    }\n}\nint main(){\n    in(R,C,M);\n    if(R!=1)sol1();\n    else sol2();\n    flush();\n}\n```\n","link":null,"tags":["主席树","二分","二维前缀和"],"title":"LG 2468 [SDOI2010]粟粟的书架"},{"categories":[["算法","图论"],["算法","树论"],["算法","技巧"],["note"]],"content":"\n## kruskal重构树\n\n我们回想一下$kruskal$生成最小生成树的过程：\n\n先将边按边权从小到大排序,然后依次加入\n\n如果$x,y$已经联通,则跳过这条边\n\n否则连接$x,y$\n\n$kruskal$重构树是在$kruskal$生成最小生成树的,\n\n连接$x,y$时,将边权变成一个新的节点$t$权值为边权,然后连边$t\\rightarrow x,t\\rightarrow y$\n\n代码：\n\n```cpp\nvoid kruskal(){\n    int x,y,tt=n;\n    sort(E+1,E+m+1);\/\/将边排序\n    Fur(i,1,n)fa[i]=i;\n    Fur(i,1,m){\n        x=gf(E[i].x),y=gf(E[i].y);\n        if(x==y)continue;\/\/如果已经联通则跳过\n        ne[++tt]=E[i].w;\/\/点权赋值为边权\n        fa[x]=fa[y]=fa[tt]=tt;\n        f[0][x]=f[0][y]=tt;\n        \/\/维护并查集\n        add(tt,x);add(tt,y);\/\/连边t→x,t→y\n    }\n}\n```\n\n$kruskal$重构树还有很多有意思的性质\n\n0. ~~原树的节点个数变成2n-1个~~\n1. 是一个二叉树\n2. **如果是按最小生成树建立的话是一个大根堆**\n3. 任意两个点路径上边权的最大值为它们的LCA的点权\n4. 重构树中代表原树中的点的节点全是叶子节点,其余节点都代表了一条边的边权。\n\n## 例题：\n\n### LG 4197 Peaks\n\n[LG 4197 Peaks](https:\/\/www.luogu.com.cn\/problem\/P4197)\n\n题意：\n\n在Bytemountains有$n$座山峰,每座山峰有他的高度$h_i$。有些山峰之间有双向道路相连,共$m$条路径,每条路径有一个困难值,这个值越大表示越难走。\n\n现在有$q$组询问,每组询问询问从点$v$开始只经过困难值小于等于$x$的路径所能到达的山峰中第$k$高的山峰,如果无解输出$-1$\n\n题解：\n\n可以算是$kruskal$重构树的模板题\n\n建完$kruskal$重构树,我们可以发现一个节点(新建的带点权的点)能走到的节点一定在它的子树中\n\n那么我们可以用$dfs$序+主席树维护\n\n给出重构后的图(帮助理解)：\n\n![](tree.png)\n\n(红色的是原来的节点)\n\n可以倍增求出最远的满足要求的祖先\n\n```cpp\n#include<bits\/stdc++.h>\n#define il __inline__ __attribute__ ((always_inline))\n#define Fur(i,x,y) for(int i(x);i<=y;++i)\n#define Fdr(i,x,y) for(int i(x);i>=y;--i)\n#define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n#define clr(x,y) memset(x,y,sizeof(x))\n#define l2(n) ((int)(log2(n)))\n#define inf 2122219134\nil int MIN(int x,int y){return x<y?x:y;}\nusing namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\n#define N 200011\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\n#define N 200011\nint n,m,q,SZ=0,rt[N];\nstruct node{\n    int v,p;\n    il bool operator<(node x){return v<x.v;}\n}b[N];\nint a[N],c[N];\nstruct link{\n    int x,y,w;\n    il bool operator<(link x){return w<x.w;}\n}E[500011];\nvoid init(){\n    in(n,m,q);\n    Fur(i,1,n)in(b[i].v),b[i].p=i;\n    sort(b+1,b+n+1);\n    b[0].v=-inf;\n    sort(b+1,b+n+1);\n    Fur(i,1,n){\n        SZ+=(b[i].v!=b[i-1].v);\n        c[a[b[i].p]=SZ]=b[i].v;\n    }\n    Fur(i,1,m)in(E[i].x,E[i].y,E[i].w);\n}\nint fa[N],f[21][N];\nint gf(int x){return (x==fa[x])?x:(fa[x]=gf(fa[x]));}\nstruct tree{\n    int s[N*20],sz=0,ls[N*20],rs[N*20];\n    void build(int l,int r,int &x){\n        s[x=++sz]=0;\n        if(l==r)return;\n        int m=(l+r)>>1;\n        build(l,m,ls[x]);\n        build(m+1,r,rs[x]);\n    }\n    void ins(int l,int r,int v,int &x,int pre){\n        x=++sz;\n        s[x]=s[pre]+1;\n        ls[x]=ls[pre];\n        rs[x]=rs[pre];\n        if(l==r)return;\n        int m=(l+r)>>1;\n        if(v<=m)ins(l,m,v,ls[x],ls[pre]);\n        else ins(m+1,r,v,rs[x],rs[pre]);\n    }\n    int ask(int l,int r,int k,int x,int y){\n        if(l==r)return l;\n        int m=(l+r)>>1,sum=s[rs[y]]-s[rs[x]];\n        if(k<=sum)return ask(m+1,r,k,rs[x],rs[y]);\n        else return ask(l,m,k-sum,ls[x],ls[y]);\n    }\n}T;\nint cnt=0,head[N];\nstruct edge{\n    int to,nxt;\n}e[N*2];\nil void add(int x,int y){e[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;}\nint L[N],R[N],dfn=0;\nvoid dfs(int x){\n    Fur(i,1,20)f[i][x]=f[i-1][f[i-1][x]];\n    L[x]=dfn;\n    if(!head[x]){\n        L[x]=++dfn;\n        T.ins(1,SZ,a[x],rt[dfn],rt[dfn-1]);\n        R[x]=dfn;\n        return;\n    }\n    fl(i,x)dfs(to);\n    R[x]=dfn;\n}\nint ne[N];\nvoid kruskal(){\n    int x,y,tt=n;\n    sort(E+1,E+m+1);\n    Fur(i,1,n)fa[i]=i;\n    Fur(i,1,m){\n        x=gf(E[i].x),y=gf(E[i].y);\n        if(x==y)continue;\n        ne[++tt]=E[i].w;\n        fa[x]=fa[y]=fa[tt]=tt;\n        f[0][x]=f[0][y]=tt;\n        add(tt,x);add(tt,y);\n    }\n    T.build(1,SZ,rt[0]);\n    dfs(tt);\n}\nvoid solve(){\n    int x,w,k;\n    while(q--){\n        in(x,w,k);\n        Fdr(i,20,0)if(f[i][x]&&ne[f[i][x]]<=w)x=f[i][x];\n        if(R[x]-L[x]<k)out(\"-1\\n\");\n        else out(c[T.ask(1,SZ,k,rt[L[x]],rt[R[x]])],ln);\n    }\n}\nint main(){\n    init();\n    kruskal();\n    solve();\n    flush();\n    return 0;\n}\n```\n\n### BZ 3732 Network\n\n题意：\n\n给你$N$个点的无向图 $(1 <= N <= 15,000)$,记为：$1…N$。\n图中有$M$条边 $(1 <= M <= 30,000)$ ,第$j$条边的长度为： $d_j ( 1 < = d_j < = 1,000,000,000)$.\n\n现在有 $K$个询问 $(1 < = K < = 20,000)$。\n每个询问的格式是：$A$ $B$,表示询问从$A$点走到$B$点的所有路径中,最长的边最小值是多少？\n\n更裸的kruskal重构树模板\n\nkruskal重构树+lca+rmq\n\n```cpp\n#include<bits\/stdc++.h>\n#define il __inline__ __attribute__ ((always_inline))\n#define Fur(i,x,y) for(int i(x);i<=y;++i)\n#define Fdr(i,x,y) for(int i(x);i>=y;--i)\n#define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n#define clr(x,y) memset(x,y,sizeof(x))\n#define l2(n) ((int)(log2(n)))\n#define inf 2122219134\nil int MIN(int x,int y){return x<y?x:y;}\nusing namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\n#define N 200011\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\n#define N 30011\nint n,m,q,cnt=0,head[N],f[N],ne[N];\nstruct edge{\n    int to,nxt;\n}e[N*2];\nil void add(int x,int y){e[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;}\nstruct link{\n    int x,y,w;\n    il bool operator<(link x){return w<x.w;}\n}E[N];\nint gf(int x){return (x==f[x])?x:(f[x]=gf(f[x]));}\nint s[16][N];\nil void st(){\n    int sz=l2(n<<1);\n    Fur(k,1,sz)\n        Fur(i,1,(n<<1)-(1<<k)+1)\n        s[k][i]=MAX(s[k-1][i],s[k-1][i+(1<<(k-1))]);\n}\nil int ask(int l,int r){\n    int k=l2(r-l+1);\n    return MAX(s[k][l],s[k][r-(1<<k)+1]);\n}\nint top[N],d[N],siz[N],id[N],sz=0;\nvoid dfs(int x){\n    siz[x]=1;\n    fl(i,x){\n        d[to]=d[x]+1;\n        f[to]=x;\n        dfs(to);\n        siz[x]+=siz[to];\n    }\n}\nvoid bt(int x,int tp){\n    top[x]=tp;id[x]=++sz;\n    s[0][sz]=ne[x];\n    int k=0;\n    fl(i,x)if(siz[to]>siz[k])k=to;\n    if(!k)return;bt(k,tp);\n    fl(i,x)if(to!=k)bt(to,to);\n}\nil int fh(int x,int y){\n    int ans=0;\n    while(top[x]!=top[y]){\n        if(d[top[x]]<d[top[y]])SWAP(x,y);\n        ans=MAX(ans,ask(id[top[x]],id[x]));x=f[top[x]];\n    }\n    if(id[x]>id[y])SWAP(x,y);\n    return MAX(ans,ask(id[x],id[y]));\n}\nint main(){\n    in(n),in(m),in(q);\n    int x,y,w,t=n;\n    Fur(i,1,m)in(E[i].x),in(E[i].y),in(E[i].w);\n    sort(E+1,E+m+1);\n    Fur(i,1,n)f[i]=i;\n    Fur(i,1,m){\n        x=gf(E[i].x),y=gf(E[i].y);\n        if(x==y)continue;\n        ne[++t]=E[i].w;\n        f[x]=f[y]=f[t]=t;\n        add(t,x),add(t,y);\n    }\n    dfs(t);\n    bt(t,t);\n    st();\n    while(q--)\n        in(x),in(y),\n        out(fh(x,y)),pt(ln);\n    flush();\n}\n```\n\n### NOI 2018 归程\n\n[LG 4768](https:\/\/www.luogu.com.cn\/problemnew\/show\/P4768)\n\n先想想暴力做法：\n\nbfs出不涉水可以到达的点,然后在这些点中找出与点$1$的最小距离\n\n优化：\n\n我们可以使用kruskal重构树来快速求出这些点\n\n先按海拔从高到低排序,这样见出来的kruskal重构树的是海拔的小根堆\n\n我们可以倍增找出最远可以到达的祖先,然后求出这段区间中的点与点$1$的最小距离\n\n可以在dfs的时候预处理\n\n详见代码\n\n```cpp\n#include<bits\/stdc++.h>\n#define il __inline__ __attribute__ ((always_inline))\n#define Fur(i,x,y) for(int i(x);i<=y;++i)\n#define Fdr(i,x,y) for(int i(x);i>=y;--i)\n#define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n#define clr(x,y) memset(x,y,sizeof(x))\n#define l2(n) ((int)(log2(n)))\n#define inf 2122219134\nil int MIN(int x,int y){return x<y?x:y;}\nusing namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\n#define N 200011\nint n,m,cnt=0,d[N<<1],head[N];\nstruct link{\n    int x,y,l,a;\n    il bool operator<(link b){return a>b.a;}\n}E[N<<1];\nstruct edge{int to,nxt,w;}e[N<<2];\nil void add(int x,int y,int w){e[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;e[cnt].w=w;}\nbool v[N];\nil void dij(){\n    struct cmp{il bool operator()(int x,int y){return d[x]>d[y];}};\n    priority_queue<int,vector<int>,cmp>q;\n    Fur(i,1,n)d[i]=inf;\n    d[1]=0;\n    q.push(1);\n    while(!q.empty()){\n        int x=q.top();v[x]=0;q.pop();\n        fl(i,x)if(d[x]+e[i].w<d[to]){\n            d[to]=d[x]+e[i].w;\n            if(!v[to])v[to]=1,q.push(to);\n        }\n    }\n}\nint fa[N<<1],ne[N<<1],f[21][N<<1];\nint gf(int x){return (x==fa[x])?x:(fa[x]=gf(fa[x]));}\nint ls[N<<1],rs[N<<1];\nvoid dfs(int x){\n    Fur(i,1,20)f[i][x]=f[i-1][f[i-1][x]];\n    if(!ls[x])return;\n    dfs(ls[x]),dfs(rs[x]);\n    d[x]=MIN(d[ls[x]],d[rs[x]]);\n}\nil void work(){\n    clr(head,0);cnt=0;\n    clr(ls,0);clr(rs,0);\n    in(n,m);\n    int x,y,l,a,t=n;\n    Fur(i,1,m){\n        in(x,y,l,a);\n        E[i]=link{x,y,l,a};\n        add(x,y,l);add(y,x,l);\n    }\n    dij();\n    sort(E+1,E+m+1);\n    Fur(i,1,n*2+1)fa[i]=i;\n    Fur(i,1,m){\n        x=gf(E[i].x),y=gf(E[i].y);\n        if(x==y)continue;\n        ne[++t]=E[i].a;\n        fa[x]=fa[y]=fa[t]=t;\n        f[0][x]=f[0][y]=t;\n        ls[t]=x;rs[t]=y;\n    }\n    dfs(t);\n    int Q,K,S,p,la=0;\n    in(Q,K,S);\n    while(Q--){\n        in(x,p);\n        x=(x+K*la-1)%n+1;\n        p=(p+K*la)%(S+1);\n        Fdr(i,20,0)if(f[i][x]&&ne[f[i][x]]>p)x=f[i][x];\n        out(la=d[x],ln);\n    }\n}\nint main(){\n    int T;in(T);\n    while(T--)work();\n    flush();\n}\n```\n\n### NOIP2013 货车运输\n\n$A$国有$n $座城市,编号从 $1 $到$ n$,城市之间有 $m$ 条双向道路。每一条道路对车辆都有重量限制,简称限重。现在有 $q$ 辆货车在运输货物, 司机们想知道每辆车在不超过车辆限重的情况下,最多能运多重的货物。\n\n### 输入格式\n\n第一行有两个用一个空格隔开的整数$ n,m$,表示 $A$ 国有$ n$ 座城市和 $m$ 条道路。\n\n接下来 $m$行每行$ 3 $个整数 $x, y, z$,每两个整数之间用一个空格隔开,表示从 $x $号城市到$ y $号城市有一条限重为 $z$ 的道路。注意： **$x$ 不等于 $y$,两座城市之间可能有多条道路** 。\n\n接下来一行有一个整数 q,表示有 q 辆货车需要运货。\n\n接下来 q 行,每行两个整数 x、y,之间用一个空格隔开,表示一辆货车需要从 x 城市运输货物到 y 城市,注意： **x 不等于 y** 。\n\n题解：\n\n~~可以很明显地看出这就是模板~~\n\nkruskal重构树+lca","link":null,"tags":["算法","技巧","树","图论"],"title":"kruskal重构树"},{"categories":[["刷题记录"]],"content":"\n此题卡常,需要使用二维树状数组\n\n联想一维的树状数组：\n\n> 差分数组：$d_0=a_0,d_i=a_i-a_{i-1}(i>0)$\n> \n> 令差分数组的前缀和$sd_i=\\sum_{j=0}^id_j$,那么$sd_i=a_i$\n\n我们现在来看看二维前缀和\n\n$s(i,j)=s(i-1,j)+s(i,j-1)-s(i-1,j-1)+a(i,j)$\n\n查询$(x_1,y_1)$到$(x_2,y_2)$的和则为：\n\n$s(x_2,y_2)-s(x_1-1,y_2)-s(x_2,y_1-1)+s(x_1-1,y_1-1)$\n\n我们可以使用差分数组:\n\n$d(i,j)=a(i,j)-(a(i-1,j)+a(i,j-1)-a(i-1,j-1))$\n\n## 修改\n\n$d(x_1,y_1)+=v$\n\n$d(x_1,y_2+1)-=v$\n\n$d(x_2+1,y_1)-=v$\n\n$d(x_2+1,y_2+1)+=v$\n\n举个例子：\n\n```\n0 0 0 0 0\n0 1 1 1 0\n0 1 1 1 0 \n0 0 0 0 0\n```\n将$1$部分加上$v$,那么\n```\n0  0 0 0 0\n0 +v 0 0 -v\n0  0 0 0 0 \n0 -v 0 0 +v\n```\n\n## 查询\n\n对于点$(x,y)$它的值应该是：$\\sum\\limits_{i=1}^x\\sum\\limits_{j=1}^y d(i,j)$\n\n那么$(1,1)$到$(x,y)$的和就是:\n\n$$\n\n\\sum_{i=1}^x\\sum_{j=1}^y\\sum_{p=1}^i\\sum_{q=1}^j d(p,q)\n\\\\\n=\\sum_{i=1}^x\\sum_{j=1}^yd(i,j)\\times(x-i+1)\\times(y-j+1)\n\\\\\n=\\sum_{i=1}^x\\sum_{j=1}^yd(i,j)\\times[(xy-xj+x)+(-yi+ij-i)+(y-j+1)]\n\\\\\n=\\sum_{i=1}^x\\sum_{j=1}^yd(i,j)\\times (xy+x+y+1)-d(i,j)\\times i(y+1)-d(i,j)\\times j(x+1) + d(i,j)\\times i \\times j\n$$\n\n我们需要维护$d(i,j),d(i,j)\\times i,d(i,j) \\times j, d(i,j)\\times i \\times j$\n\n\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\n#define N 2049\n#define lb(x) (x&-x)\nint n,m;\nstruct bit{\n    int s[N][N];\n    void add(int x,int y,int v){\n        for(int i=x;i<=n;i+=lb(i))\n            for(int j=y;j<=m;j+=lb(j))\n                s[i][j]+=v;\n    }\n    int ask(int x,int y){\n        int ans=0;\n        for(int i=x;i;i-=lb(i))\n            for(int j=y;j;j-=lb(j))\n                ans+=s[i][j];\n        return ans;\n    }\n}d,di,dj,dij;\nvoid upd(int x,int y,int v){\n    d.add(x,y,v);\n    di.add(x,y,v*x);\n    dj.add(x,y,v*y);\n    dij.add(x,y,v*x*y);\n}\nint ask(int x,int y){\n    return\n    d.ask(x,y)*(x*y+x+y+1)\n    -di.ask(x,y)*(y+1)\n    -dj.ask(x,y)*(x+1)\n    +dij.ask(x,y);\n}\nint main(){\n    in(n,m);\n    char opt;\n    int x,y,X,Y,v;\n    while(!__){\n        in(opt,x,y,X,Y);\n        if(__)break;\n        if(opt=='L')\n            in(v),\n            upd(x,y,v),\n            upd(x,Y+1,-v),\n            upd(X+1,y,-v),\n            upd(X+1,Y+1,v);\n        else out(ask(X,Y)-ask(x-1,Y)-ask(X,y-1)+ask(x-1,y-1),ln);\n    }\n    flush();\n}\n```\n","link":null,"tags":["二维树状数组","二维线段树"],"title":"LG 4514 上帝造题的七分钟"},{"categories":[["刷题记录"]],"content":"\n## 区间加,单点查询\n\n设差分数组$d_i=a_i-a_{i-1}$\n\n\n修改：$d_l+=v,d_{r+1}-=v$\n\n查询:$a_i=\\sum\\limits_{j=1}^id_j$\n\n## 区间加,区间查询\n\n$$\n\\sum_{i=1}^na_i=\\sum_{i=1}^n\\sum_{j=1}^id_i\n\\\\\n=\\sum_{i=1}^nd_i\\times(n-i+1)\n\\\\\n=n\\sum_{i=1}^nd_i-\\sum_{i=1}^n d_i\\times(i-1)\n$$\n\n维护两个树状数组,一个记录$d_i$,另一个记录$d_i\\times(i-1)$\n\n修改：\n\n$d_l+=v,d_{r+1}-=v$\n\n$d'_l+=v\\times(l-1),d'_{r+1}-=v\\times(l-1)$\n\n查询:如上述\n\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\n#define N 100011\nint n;\nll s[N],S[N];\nvoid upd(int x,int v){\n    for(int i=x;i<=n;i+=i&-i)\n        s[i]+=v,\n        S[i]+=v*(x-1);\n}\nll ask(int x){\n    ll ans=0;\n    for(int i=x;i;i-=i&-i)\n        ans+=x*s[i]-S[i];\n    return ans;\n}\nint main(){\n    int q,opt,x,y=0,v;\n    in(n,q);\n    Fur(i,1,n)in(x),upd(i,x-y),y=x;\n    while(q--){\n        in(opt,x,y);\n        if(opt==1)in(v),upd(x,v),upd(y+1,-v);\n        else out(ask(y)-ask(x-1),ln);\n    }\n    flush();\n}\n```\n","link":null,"tags":["树状数组","线段树"],"title":"LG 3372 【模板】线段树-1"},{"categories":[["刷题记录"]],"content":"\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\n#define N 100011\nint n,q,tot,sz,a[N],c[N<<1],RT[N],s[N*400],ls[N*400],rs[N*400];\nstruct que{bool opt;int l,r,k;}Q[N];\nstruct node{int v,id,typ;bool operator<(node t)const{return v<t.v;}}b[N<<1];\nvoid upd(int x,int v,int l,int r,int &rt){\n    if(!rt)rt=++sz;\n    s[rt]+=v;\n    if(l==r){return;}\n    int m=l+r>>1;\n    if(x<=m)upd(x,v,l,m,ls[rt]);\n    else upd(x,v,m+1,r,rs[rt]);\n}\nil void UPD(int x,int v){for(int i=x;i<=n;i+=i&-i)upd(a[x],v,1,tot,RT[i]);}\nint tl[20],tr[20];\nil int ask(int l,int r,int k){\n    int cl=0,cr=0,cnt,m;\n    for(int i=l-1;i;i^=i&-i)tl[++cl]=RT[i];\n    for(int i=r;i;i^=i&-i)tr[++cr]=RT[i];\n    l=1,r=tot;\n    while(l<r){\n        m=l+r>>1;cnt=0;\n        Fur(i,1,cl)cnt-=s[ls[tl[i]]];\n        Fur(i,1,cr)cnt+=s[ls[tr[i]]];\n        if(k<=cnt){\n            Fur(i,1,cl)tl[i]=ls[tl[i]];\n            Fur(i,1,cr)tr[i]=ls[tr[i]];\n            r=m;\n        }\n        else{\n            Fur(i,1,cl)tl[i]=rs[tl[i]];\n            Fur(i,1,cr)tr[i]=rs[tr[i]];\n            k-=cnt,l=m+1;\n        }\n    }\n    return l;\n}\nint main(){\n    in(n,q);\n    char ch;bool opt;int l,r,k,d=n,t=0,x;\n    Fur(i,1,n)in(x),b[i]={x,i,0};\n    Fur(i,1,q){\n        in(ch,l,r);\n        opt=ch=='Q';\n        if(opt)in(k);\n        else b[++d]={r,i,1};\n        Q[i]=que{opt,l,r,k};\n    }\n    sort(b+1,b+d+1);b[0].v=-(1<<30);\n    Fur(i,1,d)c[(b[i].typ?Q[b[i].id].r:a[b[i].id])=tot+=b[i].v!=b[i-1].v]=b[i].v;\n    Fur(i,1,n)UPD(i,1);\n    Fur(i,1,q)\n    if(Q[i].opt)out(c[ask(Q[i].l,Q[i].r,Q[i].k)],ln);\n    else UPD(Q[i].l,-1),a[Q[i].l]=Q[i].r,UPD(Q[i].l,1);\n    flush();\n}\n```\n","link":null,"tags":["树状数组","主席树"],"title":"LG 2617 Dynamic-Rankings"},{"categories":[["刷题记录"]],"content":"\n记录每个单词的hash值\n\n然后按照题目所说操作\n\n```cpp\n#include<bits\/stdc++.h>\n#define il inline\n#define ull unsigned long long \nusing namespace std;\nconst int N=1e5+5;const ull B=233;\null h[N],H[25],S[N],b[25];\nint n,m;char s[25]; \nil int find(ull x){\n    int l=1,r=n,mid;\n    while(l<=r) (h[mid=l+r>>1]<=x)?l=mid+1:r=mid-1;\n    return h[l-1]==x&&x;\n}\nint main(){\n    ios::sync_with_stdio(0);\n    b[0]=1;for(int i=1;i<=21;++i) b[i]=b[i-1]*B;\n    cin>>n>>m;\n    for(int i=1;i<=n;++i){\n        cin>>s+1;\n        for(int j=1,lg=strlen(s+1);j<=lg;++j) h[i]=h[i]*B+s[j]-96;\n    }\n    sort(h+1,h+n+1);\n    while(m--){\n        cin>>s+1;int lg=strlen(s+1),ct=0;S[lg+1]=0;\n        for(int i=1;i<=lg;++i) H[i]=H[i-1]*B+s[i]-96;\n        for(int i=lg;i>=1;--i) S[i]=S[i+1]+(s[i]-96)*b[lg-i];\n        if(find(H[lg])){printf(\"-1\\n\");continue;}\n        for(int i=0;i<lg;++i) if(s[i]^s[i+1])\n        if(find(H[i]*b[lg-i-1]+S[i+2])) ++ct;\n        for(int i=0;i<=lg;++i) for(int j=1;j<=26;++j) if(j!=s[i]-96)\n        if(find(H[i]*b[lg-i+1]+j*b[lg-i]+S[i+1])) ++ct;\n        for(int i=1;i<=lg;++i) for(int j=1;j<=26;++j)\n        if(find(H[lg]+(j-s[i]+96)*b[lg-i])) ++ct;\n        printf(\"%d\\n\",ct);\n    }\n}\n```\n","link":null,"tags":["hash"],"title":"LG 4407 [JSOI2009]电子字典"},{"categories":[["刷题记录"]],"content":"\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n\t#pragma GCC optimize(3)\n\t#define il __inline__ __attribute__ ((always_inline))\n\t#define rg register\n\t#define ll long long\n\t#define ull unsigned long long\n\t#define db double\n\t#define sht short\n\t#define MB template <class T>il\n\t#define Fur(i,x,y) for(int i=x;i<=y;i++)\n\t#define Fdr(i,x,y) for(int i=x;i>=y;i--)\n\t#define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n\t#define clr(x,y) memset(x,y,sizeof(x))\n\t#define cpy(x,y) memcpy(x,y,sizeof(x))\n\t#define fin(s) freopen(s\".in\",\"r\",stdin)\n\t#define fout(s) freopen(s\".out\",\"w\",stdout)\n\t#define fcin ios::sync_with_stdio(false)\n\t#define l2(n) (int(log2(n)))\n\t#define inf 0x3f3f3f3f\n\tMB T ABS(T x){return x>0?x:-x;}\n\tMB T MAX(T x,T y){return x>y?x:y;}\n\tMB T MIN(T x,T y){return x<y?x:y;}\n\tMB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n\tMB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 10000011\n#define int ll\nint n,a[N];\nvoid init(){\n\tint A,B,C;\n\tin>>n>>A>>B>>C>>a[1];\n\tFur(i,2,n)a[i]=(1ll*a[i-1]*A+B)%100000001;\n\tFur(i,1,n)a[i]%=C,a[i]++;\n}\nsigned main(){\n\tinit();\n\tdb ans=(db)(MIN(a[n],a[1])*1.0\/a[n]\/a[1]);\n\tFur(i,2,n)ans+=(db)(MIN(a[i-1],a[i])*1.0\/a[i]\/a[i-1]);\n\tprintf(\"%.3f\\n\",ans);\n}\n```\n","link":null,"tags":[],"title":"LG 1297 [国家集训队]单选错位"},{"categories":[["刷题记录"]],"content":"\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i=x;i<=y;i++)\n    #define Fdr(i,x,y) for(int i=x;i>=y;i--)\n    #define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) (int(log2(n)))\n    #define inf 0x3f3f3f3f\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 100011\nstruct edge{\n\tint to,nxt,w;\n}e[N*2];\nint head[N],cnt=0,f[N][31],dis[N],d[N],n;\nvoid add(int x,int y,int w){\n\te[++cnt].to=y;e[cnt].w=w;e[cnt].nxt=head[x];head[x]=cnt;\n}\nvoid dfs(int x){\n\tfor(int i=1;(1<<i)<=d[x];i++)\n\tif(f[x][i-1])f[x][i]=f[f[x][i-1]][i-1];\n\tfl(i,x)if(to!=f[x][0]){\n\t\td[to]=d[x]+1;f[to][0]=x;\n\t\tdis[to]=dis[x]+e[i].w;\n\t\tdfs(to);\n\t}\n}\nint lca(int a,int b){\n\tif(d[a]<d[b])SWAP(a,b);\n\tFdr(i,30,0)\n\t\tif(d[b]<=d[a]-(1<<i))a=f[a][i];\n\tif(a==b)return a;\n\tFdr(i,30,0)\n\t\tif(f[a][i]!=f[b][i])a=f[a][i],b=f[b][i];\n\treturn f[a][0];\n}\nint ask(int a,int b,int k){\n\tint tp=lca(a,b);\n\tif(d[a]-d[tp]+1>=k){\n\t\tint res=d[a]-k+1;\n\t\tFdr(i,30,0)if((1<<i)<=d[a]-res)a=f[a][i];\n\t\treturn a;\n\t}\n\telse{\n\t\tint res=d[tp]*2+k-d[a]-1;\n\t\tFdr(i,30,0)\n\t\tif(d[b]-(1<<i)>=res)b=f[b][i];\n\t\treturn b;\n\t}\n}\nint main(){\n\tfin(\"in\");\n\tint T;\n\tin>>T;\n\twhile(T--){\n\t\tclr(head,0);cnt=0;\n\t\tclr(f,0);\n\t\tclr(dis,0);\n\t\tclr(d,0);\n\t\tin>>n;\n\t\tint x,y,w;\n\t\tFur(i,1,n-1)in>>x>>y>>w,add(x,y,w),add(y,x,w);\n\t\tdfs(1);\n\t\tchar ch[20];\n\t\twhile(1){\n\t\t\tin>>ch;if(ch[1]=='O')break;\n\t\t\tif(ch[0]=='D')in>>x>>y,out<<dis[x]+dis[y]-dis[lca(x,y)]*2<<ln;\n\t\t\telse in>>x>>y>>w,out<<ask(x,y,w)<<ln;\n\t\t}\n\t}\n}\n\n```\n","link":null,"tags":[],"title":"LG SP913 Query on a tree II"},{"categories":[["刷题记录"]],"content":"\nFake-tournament\ntop: 0\n\n\ntarjan强连通分量缩点一下\n\n最多只有一个入度为0的点,\n\n否则就是没有符合条件的点\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;rg char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\n#define N 1011\nint n,dfn[N],bl[N],low[N],sz=0,z[N],tp=0,cnt=0,head[N],siz[N];\nbool v[N];\nstruct edge{\n    int x,to,nxt;\n}e[N*N*2];\nvoid add(int x,int y){e[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;e[cnt].x=x;}\nvoid tarjan(int x){\n    dfn[x]=low[x]=++sz;\n    z[++tp]=x;\n    fl(i,x)\n    if(!dfn[to])tarjan(to),low[x]=MIN(low[x],low[to]);\n    else if(v[to])low[x]=MIN(low[x],dfn[to]);\n\n    if(low[x]==dfn[x]){\n        while(int k=z[tp--]){\n            bl[k]=x;++siz[x];v[k]=0;\n            if(k==x)break;\n        }\n    }\n}\nint deg[N];\nvoid work(){\n    clr(head,0);cnt=0;clr(low,0);clr(z,0);clr(dfn,0);\n    in(n);\n    int x,y;\n    Fur(i,1,n){\n        in(y);\n        while(y--)in(x),add(i,x);\n        deg[i]=siz[i]=0;\n    }\n    Fur(i,1,n)if(!dfn[i])tarjan(i);\n    Fur(i,1,cnt){\n        x=e[i].x,y=e[i].to;\n        if(bl[x]!=bl[y])++deg[bl[y]];\n    }\n    bool f=0;\n    int ans=0;\n    Fur(i,1,n)if(i==bl[i]&&!deg[i])ans=siz[i],f^=1;\n    if(f)out(ans,ln);\n    else out(\"0\\n\");\n}\nint main(){\n    int T;in(T);\n    while(T--)work();\n    flush();\n}\n```\n","link":null,"tags":["tarjan"],"title":"LG SP51 TOUR"},{"categories":[["刷题记录"]],"content":"\n斜率优化入门题\n\n设$f_i$表示前$i$件玩具的制作费用\n\n$$\nf_i=\\min_{j=1}^{i-1}(f[j]+(i-j-1+s_i-s_j-L)^2)\n$$\n\n显然$\\Theta(n^2)$不能满足要求\n\n令$a_i=s_i+i,b[i]=s_i+i+L+1$\n\n(都只与$i$有关)\n\n那么\n$$\nf_i=\\min_{j=1}^{i-1}(f_j+(a_i-b_j)^2)\n\\\\\\text{展开得}\\\\\nf_i=f_j+{a_i}^2-2a_ib_j+{b_j}^2\n\\\\\\text{移项得}\\\\\n2a_ib_j+f_i-{a_i}^2=f_j+{b_j}^2\n$$\n\n设$x=b_j,y=f_j+{b_j}^2$\n$$\ny=2a_ix+(f_i-{a_i}^2)\n$$\n\n可以看成一条斜率为$2a_i$的直线\n\n$f_i$含义转化为当上述直线经过点$(x,y)$即$(b_j,f_j+{b_j}^2)$时,直线在$y$轴的截距上加上${a_i}^2$\n\n题目就是要找这个最小的截距\n\n我们可以将这条直线从下往上平移,直到经过第一个点\n\n这样的话我们可以维护一个下凸壳\n\n求的过程大概是这样：\n\nhttps:\/\/www.desmos.com\/calculator\/mqsdvzuaee\n\n![](data:image\/png;base64,iVBORw0KGgoAAAANSUhEUgAAAyAAAAMgCAYAAADbcAZoAAAgAElEQVR4Xuy9C5Bc1XU2umZGr4GRBMZjAWIQLxs0xhBmhIMv5VjzB+OAwfKoiuubSDd2TXyJbyhVyaMLTpHfkSs3UZIfJ3Ip\/p041xX5IaeSEJOHb8UPIFfEFYNtWYCDrcQ8bGQEAo9AQiNpNHrMrdNSj7pnuvvsc\/Zaa6+9+2vXlG3N3uvxrW+v3t\/s07s7pqampqjB6\/vf\/37lXwcHBxv9Otp\/SzWvP\/mTP6HsJ3tt2LCh8pPCK9V6Ia+42Jlqvf7yL\/+yUog777wzroLkRJtqvapph8xv+\/\/7DD3x6J66Csyd10Uf\/tgNNH\/BHC8ehczLK\/A25SP6hyRreG0\/8MAD9KlPfapidPHixdPGe3p6aMuWLdTb28vr0MFaBwSIA0oRDIEAiaBINSHijRb1soAANhAWqlA8hlD9Y\/z1o7T1k9+hEyfq\/255\/bsuphtvvrR4IjNmhMrLO3AIEGkIVe2nxsOdO3fSxo0b6cCBA3UCpKurizZt2kT9\/f2q+FadQYAEgZ3fKQQIP6aSFlNrcFWskJcka\/htQ4DwY6phMdQ6kzz9yHALlZd0zVLNC\/1Dmjn+9nfv3l15ImZiYmKWABkdHaWhoSF\/JyUtQICUBM7aNAgQaxVpHU+qb0jIKy4eYgMRV71CCn3p0w8IkPi4iP5hu2bZicf69etpbGysEmjtCcjw8DCNjIwETQACJCj8fM4hQPiw1LCEjboGynw+Uq0XNhB8HNG0FIKP0qcfECCaDOLxhf7Bg6OElePHj9M999xDTz\/99LT5qgDJTj2yR7I6OzslXDvbhABxhsr2QAgQ2\/WZGV2IDYQGQshLA2U+H9hA8GGpaUl7nWmcfkCAaDKIxxf6Bw+OElayPeH27dvrTGcCZMmSJfTFL36Ruru7JdwWsgkBUgguu4MhQOzWplFk2hsILXSQlxbSPH6wgeDBUduK9jrTOP2AANFmkb8\/9A9\/DCUsZDdebd26dZbpyclJuvvuu+mmm26ScFvYJgRIYchsToAAsVmXZlFpbyC00EFeWkjz+MEGggdHbSua60zr9AMCRJtF\/v7QP\/wx5LZQvfFqpt3sxqs1a9bQZZddZubrNSBAuKsfyB4ESCDgS7rV3ECUDLHUNORVCrZgk7CBCAa9l2PNdaZ1+gEB4kWJIJPRP4LA3tRp7Y1XMwdlN14tWrSo8s9Wvt8PAsQWf0pHAwFSGrogEzU3EJoJIi9NtP19YQPhj2EIC1rrTPP0AwIkBJP8fKJ\/+OHHOXvmjVe1tqs3Xmn1Dde8IEBckTI+DgLEeIFmhGetEXChh7y4kNSxgw2EDs7cXrTWmebpBwQIN0vk7aF\/yGPs4qHRjVfVeQMDA9M3Xmn1DZeYszEQIK5IGR8HAWK8QBAgcRWoTeqFDUSctNTYSGiffkCAxMdF9A8bNWt041UWWV9fH2W\/q954pdE3iiACAVIELcNjIUAMF6dBaNYaARd6yIsLSR072EDo4MztRWOdaZ9+QIBws0TeHvqHPMZ5HprdeNXT00Nbtmyh3t7eaRMafSMv3trfQ4AUQcvwWAgQw8WBAImrOG1UL2wg4qSm9EYixOkHBEh8XET\/CFuzVjdebdq0ifr7++sClO4bRdHo2LFjx1SjSbt27ar88\/Lly4vaND0+1by2bdtG2U\/2Wrt2beUnhVeq9UJecbEz1Xplfz3LXqtXr46rIDnRplqvatrS+T312H766a5DdSh3zemgmz5wPs2dJ\/ftydJ5hSJ5qnmhf4RiFNHevXtp8+bNlH23x8xXdt3uihUrZv27NR5CgITjD6tnCBBWOMWNWWsEXAkjLy4kdexgA6GDM7cXyXU2cfgEPXz\/Xpo6WR\/1FdcspKsGT13jKfWSzEsqZhe7qeaF\/uFSff4x4+Pjlc927N+\/f5bxlStX0qpVqxo6tcZDPILFz40gFvEIVhDYSzu1dhRaOpEZE5EXF5I6dvAIhQ7O3F4k11mIz35U8ZHMi7sGReylmhf6RxEW8Ix1vfGqkTdrPIQA4eFEcCsQIMFLUCgAa42gUPAtBiMvLiR17GADoYMztxepdRbqsx8QINwM0bGH\/qGDc60X1xuvIED0a5PrUapx5zoWHgABIgwws\/lUeYi8mIkibA4bCGGAhcxLrbOQpx8ZVFJ5CZXB2WyqeaF\/OFOAZWCRG68gQFgg5zWSaiOAAOHlibS1VHmIvKSZw2sfGwhePLWsSayz0KcfECBa7OHzg\/7Bh2WepaI3XkGA5CEa4PcSjTtAGrNcQoBYqIJ7DKnyEHm5c8DCSGwgLFSheAwS6yz06QcESHEehJ6B\/qFTgd27d9OGDRtoYmJilsPR0VEaGhpyCkSibzg5bjIInwHxQc\/QXAgQQ8VwCMVaI3AI2WkI8nKCycwgbCDMlKJQINzrzMLpBwRIIQqYGIz+IV+GAwcO0Pr162lsbGyWs+HhYRoZGXEOgrtvODuGADmFgLUC+BawOh8ChAtJHTup8hB56fCHyws2EFxI6trhXmcWTj9Sfn\/mrpcu25p7Q\/+QrYTPjVeNIrPGQ5yAyPJHzToEiBrULI6sNQKWpBIW+KnWCxsILubr2uHko5XTDwgQXQ5xeEP\/4ECxuQ2fG68gQGRrU8o6Z+MuFYDQJAgQIWCFzKbKQ+QlRBghs9hACAErbJZznVk5\/YAAESaNgHn0DwFQT5v0vfEKAkSuNqUtczbu0kEITIQAEQBV0GSqPERegqQRMI0NhACoCia51pml0w8IEAXiMLtA\/2AG9LQ5jhuvIEBkauNllatxewUhMBkCRABUQZOp8hB5CZJGwDQ2EAKgKpjkWmeWTj8gQBSIw+wC\/YMZUCLiuvEKAoS\/Nt4WuRq3dyDMBiBAmAEVNpcqD5GXMHGYzWMDwQyokjmOdWbt9AMCRIk8jG7QPxjBJCLOG68gQHhrw2KNo3GzBMJsBAKEGVBhc6nyEHkJE4fZPDYQzIAqmeNYZ9ZOPyBAlMjD6Ab9gw9M7huvIED4asNmiaNxswXDaAgChBFMBVOp8hB5KZCH0QU2EIxgKpryXWcWTz8gQBQJxOQK\/YMJSCLivvEKAoSvNmyWfBs3WyDMhiBAmAEVNpcqD5GXMHGYzWMDwQyokjnfdWbx9AMCRIk8jG7QP3jAlLjxCgKEpzasVnwbN2swjMYgQBjBVDCVKg+RlwJ5GF1gA8EIpqIpn3Vm9fQDAkSRQEyu0D\/8gZS68QoCxL827BZ8Gjd7MIwGIUAYwVQwlSoPkZcCeRhdYAPBCKaiKZ91ZvX0AwJEkUBMrtA\/\/ICUvPEKAsSvNiKzfRq3SEBMRiFAmIBUMpMqD5GXEoGY3GADwQSkspmy68zy6QcEiDKJGNyhf5QHUfrGKwiQ8rURm1m2cYsFxGQYAoQJSCUzqfIQeSkRiMkNNhBMQCqbKbvOLJ9+QIAok4jBHfpHORA1bryCAClXG9FZZRu3aFAMxiFAGEBUNJEqD5GXIokYXGEDwQBiABNl1pn10w8IkABE8nSJ\/lEOQI0bryBAytVGdFaZxi0aEJNxCBAmIJXMpMpD5KVEICY32EAwAalspsw6s376AQGiTCIGd+gfxUHUuvEKAqR4bcRnlGnc4kExOIAAYQBR0USqPEReiiRicIUNBAOIAUwUXWcxnH5AgAQgkqdL9I9iAGreeAUBUqw2KqOLNm6VoBicQIAwgKhoIlUeIi9FEjG4wgaCAcQAJoqusxhOPyBAAhDJ0yX6hzuA2jdeQYC410ZtZNHGrRaYpyMIEE8AlaenykPkpUwkT3fYQHgCGGh6kXUWy+kHBEggMnm4Rf9wAy\/EjVcQIG61UR1VpHGrBubpDALEE0Dl6anyEHkpE8nTHTYQngAGml5kncVy+gEBEohMHm7RP\/LBC3XjFQRIfm3URxRp3OrBeTiEAPEAL8DUVHmIvAKQycMlNhAe4AWc6rrOYjr9gAAJSKiSrtE\/8oELdeMVBEh+bdRHuDZu9cA8HUKAeAKoPD1VHiIvZSJ5usMGwhPAQNNd11lMpx8QIIHI5OEW\/aM1eCFvvIIA8SC21FTXxi3lX8ouBIgUsjJ2U+Uh8pLhi5RVbCCkkJW167LOYjv9gACR5YyEdfSP5qiGvvEKAkSC8Z42XRq3p4sg0yFAgsBe2mmqPERepSkRZCI2EEFg93bqss5iO\/2AAPGmhboB9I\/GkFu48QoCRH055Dt0adz5VuyNgACxV5NWEaXKQ+QVFw+xgYirXtVo89ZZjKcfECDxcRH9Y3bNrNx4BQFicD3lNW6DITuFBAHiBJOZQanyEHmZoZhTINhAOMFkblDeOovx9AMCxBzNcgNC\/6iHyNKNVxAgufTVH5DXuPUj4vEIAcKDo5aVVHmIvLQYxOMHGwgeHLWttFpnsZ5+QIBos8jfH\/pHPYaWbryCAPHnN7uFVDdIECDsVBE1mCoPkZcobdiNYwPBDqmKwVbrLNbTDwgQFeqwOkH\/OAOntRuvIEBYqc5jLNUNEgQIDz+0rKTKQ+SlxSAeP9hA8OCobaXZOov59AMCRJtF\/v7QP05haPHGKwgQf36zW0h1gwQBwk4VUYOp8hB5idKG3Tg2EOyQqhhsts5iPv2AAFGhDqsT9A8iqzdeQYCwUp3HWKobJAgQHn5oWUmVh8hLi0E8frCB4MFR20qjdRb76QcEiDaL\/P21e\/+wfOMVBIg\/v9ktpLpBggBhp4qowVR5iLxEacNuvN03EOyAKhlstM5iP\/2AAFEiD6Obdu4f1m+8ggBhJDqXqVQ3SBAgXAzRsZMqD5GXDn+4vLTzBoILwxB2Zq6zFE4\/IEBCMMnPZzv3D+s3XkGA+HFbZHaqGyQIEBG6iBlNlYfIS4wyIobbeQMhAqiS0ZnrLIXTDwgQJfIwumnX\/hHDjVcQIIxE5zKV6gYJAoSLITp2UuUh8tLhD5eXdt1AcOEXyk7tOkvl9AMCJBSbyvttx\/4Ry41XECDleS02M9UNEgSIGGVEDKfKQ+QlQhcxo+24gRADU9Fw7TpL5fQDAkSRQEyu2q1\/xHTjFQQIE8k5zaS6QYIA4WSJvK1UeYi85LnD6aHdNhCc2IW0VV1nV775atr6ye\/QiRNTdeFc\/66L6cabLw0ZYinf6B+lYAs2qZ36R2w3XkGABFsWzR2n2uAgQAySrUVIqfIQecXFw3baQMRVmdbRVtfZwZcW0xOP7qkbPHdeF334YzfQ\/AVzoksZ\/SOukrVL\/4jxxisIEINrKdUGBwFikGwQIHEVpQ3r1S4biGSIeDqR7H1s4vAJ2vngRDKnH1lqqb4\/p5pXu\/SPGG+8ggAx2PVTbQQQIAbJ1oYb2lTXV6p5tcsGIq7ukB9txsenHttPr71Yf8oR8+kHBEh+3a2NaIf+EeuNVxAg1lZLwn9hgQAxSDYIkLiK0ob1aocNRDIkrEnk37\/1XXr4\/r20aOHiuvRi\/exHNYlUhX6qeaXePzo6Omjjxo2zWkhXVxdt2rSJ+vv7o2ov1njYMTU1Vf\/ptZoj3ux\/Dg4ORgVwXrDWCpAXr+vvIUBckbIxLlUeIi8b\/HKNIvUNRGrvX9W6fuF\/Pkw\/3XWIFi8+I0BiP\/3ACYjrqrUzLuX+sXfvXvr85z9PExMTswAfHR2loaEhO4VwjMTa+zMEiGPhrA+DALFeofr4rDUCLvSQFxeSOnZS3kCk+Ae0LKfsez\/+9L9\/g6ZOUp0Aif30AwJEZ81zekm1fzzyyCOU7aka\/X1+eHiYRkZGOGFUs2Xt\/RkCRK30so4gQGTx5bZurRFw5Ye8uJDUsZPqBiJVHmasyL7345Gv\/6hCkOoJSAqnHxAgOmue00uK\/SO78eqDH\/wg\/exnP6sT+BluAwMDlUeyOjs7OWFUs2WtL0KAqJVe1hEEiCy+3NatNQKu\/JAXF5I6dlLcQKS8ka1+6\/mrr+6vEyApnH6kXLdU+2KK\/SPbS\/3TP\/1T3frK\/k9fX1\/lVKS7u1unOQt4scZDCBCBIocwCQESAvXyPq01gvKZ1M9EXlxI6thJcQOR8ka2+q3n2ZeiVU9AUjn9SLluqfbF1PpH9car2vWV8bKnp4e2bNlCvb29Oo1ZyIs1HkKACBVa2ywEiDbifv6sNQK\/bM7MRl5cSOrYSW0DUUUtRR5WTz+ybz2v3SClcvoBAaKz5jm9pNQ\/du7cOX3jVe36ivXGq0Z1ttYXO3bs2NHwFqxdu3ZV4l++fDknX4PbSjWvbdu2UfaTvdauXVv5SeGVar2QV1zsTLVe2V\/8stfq1avjKkhOtCnWK\/vej+zmq+x18ODByn+fc+4iuukD59PceXE+kz6zjCnWLcsx1bxS6R\/ZjVebN2+mycnJuvW1cOFCWrNmDa1YsSKJ\/miNhxAgSdCKKuIDAiSeYlprBFzIIS8uJHXspLKBSH0jm33refa9H9nNV7UC5LobL6SrBhfpkEXBC\/qHAsiMLlLoH+Pj45XPduzff+pzVbXr6\/bbb6dVq1YxIhbWlLX1hUewwvKBzTsewWKDUsWQtaNQrqSRFxeSOnZSeoSiFrHUeFj97Ec1x+wRka45HXT3H91C8xfUfxu6DnNkvKRWtypKqeYVe\/\/Ibry655576Omnn64jdLa+rrrqKvqLv\/iLaG+8arRCrfEQAkSmj6pbhQBRh9zLobVG4JVMzWTkxYWkjp3YNxDNUEqJh7Wf\/agVIFdcs5DW3Bnfl6G1YnZKdUtZEFdzi71\/ZPum7du3z6LkggULaP369XTjjTfqNGIlL9bWFwSIUuGl3UCASCPMa99aI+DKDnlxIaljJ\/YNRDsIkJmnH1nO44der3z244Z3XK9DFCUv6B9KQDO5ibl\/VG+8mglFduPVb\/zGb9C5555Lg4ODTEjZMGNtfUGA2OCFdxQQIN4Qqhqw1gi4kkdeXEjq2Il5A9EOf0lvdPqR5d277GTlsx\/YIOmsE18vqfbFWPtH7Y1XtbWt3nh15MiRyj9jffkyv\/V8CBBZfNWsQ4CoQc3iKNU3JOTFQg81I7FuIPIASoWHjU4\/su\/9GLx5fuXmK2yQ8phg4\/ep8HEmmjH2j927d9OGDRtoYmJiFjlGR0dpaGiIUq2XtbwgQGz0J+8oIEC8IVQ1YK0RcCWPvLiQ1LET4wbCBZkUeNjs9CP73o8F572Kv9C6EMHImBT42AjK2PpH9uHy7LMdY2Njs9IZHh6mkZGRyr+nWi9reUGAGGlQvmFAgPgiqDvfWiPgyh55cSGpYye2DYQrKinwsNnpx4c\/dgM99cMnIUBcyWBgXAp8jF2ANLvxKstrYGCg8iWEnZ2nvk8n1XpZywsCxEBz4ggBAoQDRT0b1hoBV+bIiwtJHTsQIDo4F\/XS6vTjxpsvxQapKKCBx6faF2PqH81uvOrr66t8D0h3d\/c0S1Ktl7W8IEACNyYu9xAgXEjq2LHWCLiyRl5cSOrYiWkDUQSR2HnY6vQj+96P2PNrVkvkVYTl4cfG0j9a3Xi1ZcsW6u3trQMTPNThFgSIDs7iXiBAxCFmdYAGxwqnuLFU6xXLBqJogWOuV97pR4ZFzPm1qiXyKsr0sONj6B95N1719\/fPAhE81OEVBIgOzuJeIEDEIWZ1gAbHCqe4sVTrFcMGokxxY65X3ukHBEgZRoSdEzMfWyFnvX+43HjVKL9U62UtLwiQsH2JzTsECBuUKoasNQKupJEXF5I6dqxvIMqiECsPXU4\/IEDKsiLcvFj5mIeY5f7heuMVBEheleV+DwEih62qZQgQVbi9naX6hoS8vKmhasDyBsIHiFh56HL6AQHiw4wwc2PlYx5aVvtHkRuvIEDyqiz3ewgQOWxVLUOAqMLt7SzVNyTk5U0NVQNWNxC+IMTIQ9fTDwgQX3boz4+Rjy4oWe0fRW68ggBxqbTMGAgQGVzVrUKAqEPu5TDVNyTk5UUL9clWNxC+QMTIQ9fTDwgQX3boz4+Rjy4oWewfRW+8ggBxqbTMGAgQGVzVrUKAqEPu5TDVNyTk5UUL9ckWNxAcIMTGwyKnHxAgHAzRtREbH13RsdY\/ytx4BQHiWm3+cRAg\/JgGsQgBEgT20k5TfUNCXqUpEWSitQ0EFwix8bDI6QcECBdL9OzExkdXZCz1j7I3XkGAuFabfxwECD+mQSxCgASBvbTTVN+QkFdpSgSZaGkDwQlATDwsevoBAcLJFB1bMfGxCCJW+ofPjVcQIEUqzjsWAoQXz2DWIECCQV\/KcapvSMirFB2CTbKygeAGICYeFj39gADhZou8vZj4WAQNC\/3D98YrCJAiFecdCwHCi2cwaxAgwaAv5TjVNyTkVYoOwSZZ2EBIJB8LD8ucfkCASDBG1mYsfCyKgoX+4XvjFQRI0arzjYcA4cMyqCUIkKDwF3ae6hsS8ipMhaATLGwgJACIhYdlTj8gQCQYI2szFj4WRSF0\/+C48QoCpGjV+cZDgPBhGdQSBEhQ+As7T\/UNCXkVpkLQCaE3EFLJx8DDsqcfECBSrJGzGwMfy2Qfsn9w3XgFAVKm8jxzIEB4cAxuBQIkeAkKBZDqGxLyKkSD4INDbiAkk4+Bh2VPPyBAJJkjYzsGPpbJPFT\/4LzxCgKkTOV55kCA8OAY3AoESPASFAog1Tck5FWIBsEHh9pASCdunYc+px8QINLs4bdvnY9lMw7RP7hvvIIAKVt9\/3kQIP4YmrAAAWKiDM5BpPqGhLycKWBiYIgNhEbi1nnoc\/oBAaLBIF4f1vlYNlvt\/iFx4xUESNnq+8+DAPHH0IQFCBATZXAOItU3JOTlTAETA7U3EFpJW+ah7+kHBIgWi\/j8WOajT5ba\/UPixisIEB8G+M2FAPHDz8xsCBAzpXAKJNU3JOTlVH4zg7Q3EFqJW+ah7+kHBIgWi\/j8WOajT5aa\/UPqxisIEB8G+M2FAPHDz8xsCBAzpXAKJNU3JOTlVH4zgzQ3EJpJW+Uhx+kHBIgmk3h8WeWjb3Za\/UPyxisIEF8WlJ8PAVIeO1MzIUBMlSM3mFTfkJBXbulNDdDaQGgnbZWHHKcfECDabPL3Z5WPvplp9A\/pG68gQHxZUH4+BEh57EzNhAAxVY7cYFJ9Q0JeuaU3NUBjAxEiYYs85Dr9gAAJwSg\/nxb56JfRqdnS\/UPjxisIEA4mlLMBAVION3OzIEDMlaRlQKm+ISGvuHgovYEIhYZFHnKdfkCAhGJVeb8W+Vg+mzMzJfuH1o1XECAcTChnAwKkHG7mZkGAmCsJBEhcJWnLekluIEKW39qGj\/P0AwIkJLPK+bbGx3JZzJ4l2T+0bryCAOFiQ3E7ECDFMTM5AwLEZFmaBpXqGxLyiouHkhuIkEhY4yHn6QcESEhmlfNtjY\/lstATIJo3XkGAcLGhuB0IkOKYmZwBAWKyLBAgcZWl7eoFASJPUO7TDwgQ+Zpxe4AAcUdU+8YrCBD32nCPhADhRjSQPQiQQMCXdJvqGxLyKkmIQNMgQOSB5z79gACRrxm3h1T7Inf\/CHHjFQQIN9vd7UGAuGNleiQEiOnyzAou1Tck5BUXD7k3EFayt8JDidMPCBArLHOPwwof3SN2G8nZP0LdeAUB4lZriVEQIBKoBrAJARIAdA+Xqb4hIS8PUgSYyrmBCBB+U5dWeChx+gEBYolpbrFY4aNbtO6juPpHyBuvIEDc6809EgKEG9FA9iBAAgFf0m2qb0jIqyQhAk3j2kAECt+0AJE6\/YAAsca2\/HhS7Ytc\/SPkjVcQIPn8lRoBASKFrLJdCBBlwD3dpfqGhLw8iaE8nWsDoRx2rjsLPJQ6\/YAAyS2\/uQEW+CgBCkf\/CH3jFQSIBDPcbEKAuOFkfhQEiPkS1QWY6hsS8oqLhxwbCIsZh+ah5OkHBIhFxrWOKTQfpRDz7R8WbryCAJFiR75dCJB8jKIYAQESRZmmg0z1DQl5xcVD3w2E1WxD81Dy9AMCxCrrmscVmo9SiPn0Dys3XkGASLEj3y4ESD5GUYyAAImiTBAgcZUp+Xr5bCAslzLkhk\/69AMCxDLzGscWko+SaJXtH5ZuvIIAkWRIa9sQIOGwZ\/UMAcIKp7ixVN+QkJc4dVgdlN1AsAYhYCwkD6VPPyBABAgjbDIkHyVTK9M\/rN14BQEiyRAIkDoEUm0EECDhFlEZz6nyEHmVYUO4OWU2EOGidfcciocapx8QIO48sDIyFB+l8y\/TP6zdeAUBIs2S5vZxAhIOe1bPECCscIobS\/UNCXmJU4fVQZkNBGsAQsZC8VDj9AMCRIg0gmZD8VEwpYrpov3D4o1XECDSLIEAmUYg1UYAARJuEZXxnCoPkVcZNoSbU3QDES7SYp5D8FDr9AMCpBgXLIwOwUeNvIv0D6s3XkGAaDClsQ+cgITDntUzBAgrnOLGUn1DQl7i1GF1UGQDwepY2FgIHmqdfkCACJNHwHwIPgqkMcuka\/+wfOMVBIgGUyBAKgik2gggQMItojKeU+Uh8irDhnBzXDcQ4SIs51mbh5qnHym\/j2nXrRy7is9KNS+X\/mH9xisIkOJ85pqBExAuJAPbgQAJXICC7lN9Q0JeBYkQeLjLBiJwiKXca\/NQ8\/QDAqQUJYJO0uajVrJ5\/SOGG68gQLTYMtsPBEg47Fk9Q4CwwiluLNU3JOQlTh1WB3kbCFZnisY0eah9+gEBokgkJleafGQK2clMXv+I4cYrCBCnUosMggARgVXfKASIPuY+HlN9Q0JePqzQn5u3gdCPiMejJg+1Tz8gQHg4omlFk4+aebXqH7HceAUBosmYel8QIOGwZ\/UMAcIKp7ixVN+QkJc4dVgdQID4wRni9AMCxK9mIWan2heb9Y+YbryCAAmxIk757NixY8dUI\/e7du2q\/PPy5cvDRSfgOdW8tm3bRtlP9lq7dm3lJ4VXqvVCXnGxM9V6ZX+lzF6rV6+OqyA50WrV66nH9tNPdx2qi6ZrTgfd9IHzae68TjFMtfITS6CJYeSljbifv0b9Y+\/evbR582aanJycZXzNmjW0YsUKP6cKs8FDBZAhQHRA1vACAaKBMp8PNDg+LDUspVovCHfPJ3QAACAASURBVJDy7Jk4fIIevn8vTZ2st3HFNQvpqsFF5Q07zEyVj8jLofiGhszsH+Pj45Q9jbF\/\/\/5ZUa5cuZJWrVplKPrmoYCHOmXCI1g6OIt7wSNY4hCzOkj1SB55sdJE3BgewSoPcYjPflSjxTorX7cQM1OtV23\/iPXGq0Z8SLVe1vKCAAnRjQR8QoAIgCpo0loj4EoVeXEhqWMHAqQczqE++wEBUq5eoWel2hdr+0esN15BgIRbHRAg4bBn9QwBwgqnuLFU35CQlzh1WB1AgJSDM+TpRxYx1lm5uoWalWq9qv3jjW98I23dunUWvD09PbRlyxbq7e0NBX0pv6nWy1peECCl6GlvEgSIvZq0ishaI+BCD3lxIaljBwKkOM6hTz8gQIrXLPSMVPti1j92795NTz755CyIu7q6aNOmTdTf3x8a\/sL+U62XtbwgQApT0+YECBCbdWkWlbVGwIUe8uJCUscOBEhxnEOffkCAFK9Z6Bmp9sU\/+qM\/ovvvv58uvPDCWRCPjo7S0NBQaOhL+U+1XtbyggApRU97kyBA7NUEJyBx1aQd6wUBUoyjFk4\/IECK1czCaGsbPw5MDhw4QLfccgtlN18tW7aszuTw8DCNjIxwuAliI8V6WewbECBB6M3vFAKEH1NJi2hwkujy2061XhAgxbhi4fTD4kaiGIrNR6e6zlLLq3rj1UMPPVQpZq0AGRgYoI0bN1Jnp9z34HDxrZmd1OpVzdNaXhAg0kxWsg8BogQ0kxtrjYApLXw4lgtIJTsQIO5AWzn9gABxr5mVkan1++qNV88\/\/3ydAOnr66t8D0h3d7cV6EvFkVq9IEBK0YB\/UqrEggDh54qkxVR5iLwkWcNvGwLEHVMrpx8QIO41szIypb6Yfflg9carWgES641XjTiSUr1q87OWF05ArHQozzggQDwBVJ5urRFwpY+8uJDUsQMB4oazpdMPCBC3mlkalUpf3LlzZ+XxquqrKkAuu+yyaG+8ggAJt1IgQMJhz+oZAoQVTnFjqbwhzQQKeYlTh9UBBIgbnJZOPyBA3GpmaVQKfTG7bnfDhg00MTFRJ0A6OjroU5\/6VLQ3XkGAhFspECDhsGf1DAHCCqe4sRTekNC4xWki7gACJB9ia6cfECD5NbM2IvZ+n914tX79ehobG6uDNjsBue666+gLX\/iCNci94om9Xs2St5YXBIgXTe1MhgCxUwuXSKw1ApeYXcYgLxeU7IyBAMmvhbXTDwiQ\/JpZGxFzX6zeePX000\/PgnVqaopuu+02+shHPmINcq94Yq5Xq8St5QUB4kVTO5MhQOzUwiUSa43AJWaXMcjLBSU7YyBAWtfC4ukHBIid9eMaScx9sXrj1cxcsxuvsm85nzdvHt15552uUEQxLuZ6QYAYpliqxIIAMUy6BqGlykPkFRcPIUBa18vi6QcESFxrLOZ61d54VYt69carf\/iHf6j8MwRIHJy09v6ME5A4eJMbJQRILkSmBlhrBFzgIC8uJHXsQIA0x9nq6UfMG9o8VqN\/5CGk9\/uZN15VPXd1dU3feIX+oVcPDk\/W1hcECEdVDdiAADFQhAIhWGsEBUJvORR5cSGpYwcbiOY4Wz39gADRWRucXmLri41uvKriMTo6On3jFfoHJ0vkbVnjIQSIfM1VPECAqMDM5sRaI+BKDHlxIaljBxuIxjhbPv2AANFZG5xeYuqLzW68yvAYHh6mkZGRaWjQPzhZIm\/LGg8hQORrruIBAkQFZjYn1hoBV2LIiwtJHTvYQDTG2fLpBwSIztrg9BJLX2x149XAwEDlSwg7OzshQDjJoWjLGg8hQBSLL+kKAkQSXX7b1hoBV4bIiwtJHTsQILNxtn76AQGiszY4vcTSF1vdeJX9rru7uw4W9A9OlsjbssZDCBD5mqt4gABRgZnNibVGwJUY8uJCUscONhCzcbZ++gEBorM2OL3E0Bfzbrzq7e2dBQn6BydL5G1Z4yEEiHzNVTxAgKjAzObEWiPgSgx5cSGpYwcbiHqcYzj9gADRWRucXqz3RZcbrxrhgf7ByRJ5W9Z4CAEiX3MVDxAgKjCzObHWCLgSQ15cSOrYwQaiHucYTj8gQHTWBqcXy33R9cYrCBBORoSxZY2HECBheMDuFQKEHVJRg9YaAVeyyIsLSR07ECBncI7l9AMCRGdtcHqx2heL3HgFAcLJiDC2rPEQAiQMD9i9QoCwQypq0Foj4EoWeXEhqWMHAuQMzrGcfkCA6KwNTi8W+2LRG68gQDgZEcaWNR5CgIThAbtXCBB2SEUNWmsEXMkiLy4kdexAgJzCOabTDwgQnbXB6cViXyx64xUECCcjwtiyxkMIkDA8YPcKAcIOqahBa42AK1nkxYWkjh0IkFM4x3T6AQGiszY4vVjri2VuvIIA4WREGFvWeAgBEoYH7F4hQNghFTVorRFwJYu8uJDUsQMBEt\/pBwSIztrg9GKpL5a98QoChJMRYWxZ4mGGAARIGB6we4UAYYdU1KC1RsCVLPLiQlLHDgRIfKcfECA6a4PTi5W+6HPjFQQIJyPC2LLCw2r2ECBheMDuFQKEHVJRg9YaAVeyyIsLSR077S5AYvvsR5UVWGc664PLi4V6+d54BQHCxYZwdizwsDZ7CJBwXGD1DAHCCqe4MWuNgCth5MWFpI6ddhcgsX32AwJEZ11wewndFzluvIIA4WaFvr3QPJyZMQSIPgdEPEKAiMAqZtRaI+BKFHlxIaljp50FSKynHxkzsM501geXl9D14rjxCgKEiw3h7ITmIQTI979fwWBwcDAcCwQ8Q4AIgCpo0loj4EoVeXEhqWOnnQVIrKcfECA6a4PTS8i+yHXjFQQIJyPC2ArJw0YZ4wQkDA\/YvUKAsEMqatBaI+BKFnlxIaljp10FSMynHxAgOmuD00uovsh54xUECCcjwtgKxcNm2UKAhOEBu1cIEHZIRQ1aawRcySIvLiR17LSrAIn59AMCRGdtcHoJ0Re5b7yCAOFkRBhbIXjYKlMIkDA8YPcKAcIOqahBa42AK1nkxYWkjp12FCCxn35AgOisDU4v2n1R4sYrCBBORoSxpc3DvCwhQPIQiuT3ECCRFOp0mNYaARd6yIsLSR077ShAYj\/9gADRWRucXjT7otSNVxAgnIwIY0uThy4ZQoC4oBTBGAiQCIpUE6K1RsCFHvLiQlLHTrsJkBROPyBAdNYGpxfNvih14xUECCcjwtjS5KFLhhAgLihFMAYCJIIiQYDEVaQ2qFe7CZAUTj8gQOJrI1obP8kbryBA4uPdzIi1eOiKFASIK1LGx0GAGC\/QjPCsNQIu9JAXF5I6dtpJgKRy+gEBorM2OL1o9EXpG68gQDgZEcaWBg+LZAYBUgQtw2MhQAwXp0Fo1hoBF3rIiwtJHTvtJEBSOf2AANFZG5xepPuixo1XECCcjAhjS5qHRbOCACmKmNHxECBGC9MkLGuNgAs95MWFpI6ddhEgKZ1+QIDorA1OL5J9UevGKwgQTkaEsSXJwzIZQYCUQc1zzrp16+jTn\/50SytLliyhvXv3OnuCAHGGysRAa42ACxTkxYWkjp12ESApnX5AgOisDU4vUn1R88YrCBBORoSxJcXDstlAgJRFzmPer\/7qr9Lf\/M3fQIA4YGhtwTiE7DQEeTnBZGZQqvVqBwGS2ukHBIiZtuAciFT\/0LzxCgLEudxmB0rxsGzCECBlkfOY9+53v5seeughev\/7308bNmxoaGnevHn09re\/3dkLTkCcoTIx0Foj4AIFeXEhqWOnHQRIaqcfECA6a4PTi0Rf1L7xCgKEkxFhbEnw0CcTCBAf9ErOve666+iJJ56gj3\/84\/R7v\/d7Ja3UT4MAYYFRzYi1RsCVOPLiQlLHTuoC5Mo3X01bP\/kdOnFiqg7Q6991Md1486U6IAt4wToTAFXQJHe9Qtx4BQEiSBAl09w89A0bAsQXwRLz+\/r66IUXXqh8DuSuu+4qYWH2FAgQFhjVjFhrBFyJIy8uJHXspC5ADr60mJ54dE8dmHPnddGHP3YDzV8wRwdkAS9YZwKgCprkrFeoG68gQAQJomSak4ccIUOAcKBY0MZZZ51FR44cob\/7u7+jO+64o+DsxsMhQFhgVDNirRFwJY68uJDUsZOyAJk4fIJ2PjiR3OlHxgysM531weWFq14hb7yCAOFiQzg7XDzkygAChAtJRzuHDh2inp6eyuhHHnmEfumXfslxZuthECAsMKoZsdYIuBJHXlxI6thJWYA89dh+eu3F+lOOFE4\/IEB01ganF46+GPrGKwgQTkaEscXBQ87IIUA40XSw9fzzz9Mll1xSGfmf\/\/mf9Ja3vIUyUZJ96Dz7KfuCACmLXJh51hoBFwrIiwtJHTupCpB\/\/9Z36eH799KihYvrgIz9sx\/VZLDOdNYHlxeOeoW+8QoChIsN4exw8JAzeggQTjQdbGUEWLFiRWXkxRdfTC+++CJlf9nIXm9605sqJyK\/9Vu\/RUNDQw7WzgyBACkEV\/DB1hoBFyDIiwtJHTupCpAv\/M+H6ae7DtHixWcESCqnHxkzsM501geXF996WbjxCgKEiw3h7PjykDtyCBBuRHPsPfXUU\/SOd7yDxsfHW47MPpz+Z3\/2Z9TR0eEUIQSIE0xmBllrBFzAIC8uJHXspChAsu\/9+NP\/\/g2aOkl1AiSV0w8IEJ21wenFpy9aufEKAoSTEWFs+fBQIuKOz372s\/X3E572kj0qlL2WLVsm4TeYzRB5ZY9ZrVy5cjrn7AasH\/\/4x3T55ZfT+eefXxEZ2UnIww8\/TL\/\/+79PP\/3pTytj\/\/AP\/5B++7d\/u\/K\/9+3bR1\/5ylea4vbggw9S9pO9su8ZyX5SeIWolwZuyEsDZT4fqdbrW9\/6VgWkd77znXxgBbb08rNzac8zk5Uouru7K\/\/d2UV0xS8epa45Dd\/uAkdc3H2qfERe9Vx49dVX6f7776djx47V\/SLbM9x000105ZVXFicP44wU+0cGD3jISJIWpiBAFHDOPnSePVJ1wQUX5HrLhEb2BYTPPfccLVq0iF5++WVasGBBZd5f\/\/VfNz05gQDJhdbUADQ4U+XIDSbVeqW2gTh+tIOe+d58OnzoSJ0AOa\/vOL3p0lOPuqbwSpWPyOsMO7ObMv\/2b\/+24Xt+9l1iN954Y3Aqp9Y\/qoCChzrUwiNYOjgX8vLZz36WPvKRj1TmbN++nd71rnflzscjWLkQmRpg7SiUCxzkxYWkjp3UHsGqfut5dl1p9so+A5LSZz+qrMA601kfXF6K1svijVeNsEitf2B9cTHezQ4EiBtOqqMee+yxyudEspfrd4VAgKiWyNtZ0Tckb4dKBpCXEtBMblLaQGSf\/ah+63mtAEnpsx\/YIDERX9lM0b5o8cYrCBBl0gi4K8pDgRDqTEKASCNcwn72\/SDVz4x8\/etfp\/e85z25ViBAciEyNcBaI+ACB3lxIaljJyUBUj39yJCrCpA39r4h+m89b8QErDOd9cHlpUi9rN54BQHCxYZwdorwUCNKCBANlAv6yD6I\/vGPf7wya8+ePXThhRfmWoAAyYXI1ABrjYALHOTFhaSOnVQESO3pR60Auel9b6Mbb75UB0xFL1hnimAzuHKtl+UbryBAGIgQ2IQrD7XChADRQvq0n0xQLF26tKnX7Aas7HtCsg+jZzfT\/Nu\/\/ZtThBAgTjCZGWStEXABg7y4kNSxk4oAqT39qAqQrjkddPcf3ULzF9R\/G7oOsrJesM5k8eW27lKv3bt304YNG2hiYmKW+9HR0cLfDcadAwSIBqKyPlx4KBtBvXUIEE20iej222+vPB6watUquv766yvXHHd2dlLWfB599FH64z\/+YxobG6P58+dXxEd2I5bLCwLEBSU7Y6w1Ai5kkBcXkjp2UhAgM08\/qgLkimsW0po7i32hqw7q\/l6wzvwx1LSQV69sT7B+\/frKe\/\/M1\/DwMI2MjGiG6+wrhf7RKNm8ejkDZGygtbwgQJQJ8r73vY+++tWvtvR63nnn0Ze+9CW65ZZbnKODAHGGysRAa42ACxTkxYWkjp0UNhAzTz8y5MYPvU43feB8uuEd1+sAqewF60wZcE93reoVy41XjSBIoX9AgHiS22M6BIgHeGWmZn\/h+NznPkcPPfQQ7dq1q\/IXj6mpKXrDG95AV199dUV0ZH\/tOPfccwuZhwApBFfwwdhABC9BoQBSrVfsG4hGpx9ZYXuXnaSrBhfR4OBgoTrHMjhVPrZjXrHceAUBEkt3aB6ntfUFARI\/pyoZQIDEVUhrjYALPeTFhaSOndgFSKPTj+x7PwZvnk9z53VCgOjQiM1Lu\/WPmG68ggBho3kwQ9bWFwRIMCrwOoYA4cVT2pq1RsCVL\/LiQlLHTswCpNnpR\/a9HwvOe7UCIE5AdHjE5aWd+kdsN15BgHCxPJwda+sLAiQcF1g9Q4CwwiluzFoj4EoYeXEhqWMnZgHS7PTjwx+7gZ764ZMQIDoUYvXSLv0jxhuvIEBYqR7EmLX1BQEShAb8TiFA+DGVtGitEXDliry4kNSxE6sAaXX6kX3vR6o8rLIi1fzaIa9Yb7yCANHpyZJerK0vCBDJaivahgBRBJvBlbVGwJBSxQTy4kJSx06sAqTV6Uf2vR+p8hACRGddcHup8vHaa6+le+65h55++ulZLgYGBmjjxo2Va\/ljecXaP\/LwTbV\/WMsLAiSPiZH8HgIkkkKdDtNaI+BCD3lxIaljJ8YNRN7pR8pCGAJEZ11we6n2xe3bt1P2M\/PV19dXuUimu7ub27WovRj7hwsgeB9zQcl\/DASIP4YmLECAmCiDcxBocM5QmRiYar1i3EDknX5AgJhYMqWCSHWdZXn967\/+a+XLhWe+enp6aMuWLdTb21sKs5CTYuwfLnilzMMsfyuXc0CAuLAxgjEQIBEUqSZENDjUywICsW0gXE4\/IEAsMKtcDKn2xS9\/+cv02c9+lhYvXlwHTFdXF23atIn6+\/vLARZ4Vmz9wxWuVHloLS8IEFdGGh8HAWK8QDPCs9YIuNBDXlxI6tiJbQPhcvoBAaLDHQkvKfaP7Mar7MuFJycnZwmQ0dFRGhoakoBSxWZs\/cMVlBR5aLEvQoC4MtL4OAgQ4wWCAImrQG1Sr5g2EK6nHxbfaLnJjw0SN6Iy9qo3Xj377LMVB7UnIMPDwxVhEvMrpv5RBGesryJolR8LAVIeO1MzIUBMlSM3GDS4XIhMDUi1XjFtIFxPPyBATC2dQsGktM6OHz8+feNVJkRqBUiMN141KmRM\/aMIEVPiYW3e1vKCACnCSsNjIUAMF6dBaNYaARd6yIsLSR07sWwgipx+QIDocEfCS0r9I3tPrt54VStAYr3xCgJEgvG6Nq2tLwgQ3fqLeYMAEYNWxLC1RsCVJPLiQlLHTiwCpMjpBwSIDnckvKTSPx544AHaunXrNERVAbJ06dJob7yCAJFgvK5Na+sLAkS3\/mLeIEDEoBUxbK0RcCWJvLiQ1LETgwApevoBAaLDHQkvKfSPnTt3Vr5QsPaVCZDsCwY\/85nPRHvjFQSIBON1bVpbXxAguvUX8wYBIgatiGFrjYArSeTFhaSOnRgESNHTDwgQHe5IeIm9f2Q3Xm3YsIEmJiZmCZA1a9bQb\/7mb0rAFsxmDP2jDDix87BZztbyggApw06DcyBADBalRUjWGgEXesiLC0kdO9Y3EGVOPyBAdLgj4SXm\/lG98WpsbGwWNNdddx2tWrXKzBfAcdXOev8om2fMPGyVs7W8IEDKMtTYPAgQYwXJCcdaI+BCD3lxIaljx\/oGoszpBwSIDnckvMTaP2pvvJqJS3bj1W233VZ5BMvKN1Bz1c56\/yibZ6w8zMvXWl4QIHkVi+T3ECCRFOp0mNYaARd6yIsLSR07ljcQZU8\/IEB0uCPhJdb+UXvjVS0u1RuvfvSjH1X+GQJEgjX8NmPlYR4S1vKCAMmrWCS\/hwCJpFAQIHEVKvF6WRYgZU8\/IECiXGKVoK1tkFyQnHnjVXVOT0\/P9I1XMeblkrvl\/uESf7MxqdbLWl4QID4sNTQXAsRQMRxCsdYIHEJ2GoK8nGAyM8jqBsLn9CPWjWwRUmCdFUFLbmyjG68yb11dXbRp06bpG69SrZfV\/uFb8VTrZS0vCBBfphqZDwFipBCOYVhrBI5h5w5DXrkQmRpgdQPhc\/oBAWKKYoWCial\/NLvxKkt4dHSUhoaGpnOPKa8iBbPaP4rk0GhsqvWylhcEiC9TjcyHADFSCMcwrDUCx7BzhyGvXIhMDbC4gfA9\/YAAMUWxQsHE0j9a3Xg1PDxMIyMjdXnHklehYhGRxf5RNAcIEA7EytmAACmHm7lZECDmStIyoFTfkJBXXDy0uIHwPf2AAImLg7XRxtA\/8m68yr6EMLvxKra8yrDGYv8ok8fMOTHwsEye1vKCAClTRYNzIEAMFqVFSNYaARd6yIsLSR071jYQHKcfECA63JHwEkP\/yLvxqru7exY0MeRVpp7W+keZHHACwoVacTsQIMUxMzkDAsRkWZoGleobEvKKi4fWNhAcpx8QIHFxMKaTApcbr9ppQ2utf3AxH+9jXEi2tgMBooOzuBcIEHGIWR2gwbHCKW4s1XpZ2kBwnX5AgIgvBzEHlteZ641XECBi9FAzbJmHPiBYywsCxKeahuZCgBgqhkMo1hqBQ8hOQ5CXE0xmBlkSIFynHxAgZuhVOBCr\/aPIjVcQIIXLbm6CVR76AmUtLwgQ34oamQ8BYqQQjmFYawSOYecOQ165EJkaYEWAcJ5+QICYolihYCz2j6I3XkGAFCq5ycEWecgBlLW8IEA4qmrABgSIgSIUCMFaIygQesuhyIsLSR07VgQI5+kHBIgOdyS8WOsfZW68ggCRYIauTWs85MreWl4QIFyVDWwHAiRwAQq6t9YICobfdDjy4kJSx44FAcJ9+gEBosMdCS\/W+keZG68gQCSYoWvTGg+5sreWFwQIV2UD24EACVyAgu6tNYKC4UOAcAEW2I4FAcJ9+gEBEphUHu4t9cWyN15BgHgQwMhUSzzkhMRaXhAgnNUNaAsCJCD4JVxbawQlUmg4BXlxIaljJ7QAkTj9gADR4Y6EFyv9w+fGKwgQCWbo2rTCQ+6sreUFAcJd4UD2IEACAV\/SrbVGUDKNWdOQFxeSOnZCCxCJ0w8IEB3uSHix0D98b7yCAJFghq5NCzyUyNhaXhAgElUOYBMCJADoHi6tNQKPVOqmIi8uJHXshBQgUqcfECA63JHwErp\/cNx4BQEiwQxdm6F5KJWttbwgQKQqrWwXAkQZcE931hqBZzrT05EXF5I6dkIKEKnTDwgQHe5IeAnZP7huvIIAkWCGrs2QPJTM1FpeECCS1Va0DQGiCDaDK2uNgCGlignkxYWkjp1QAkTy9CNlHlZZgXXGvz64bryCAOGvjbZFrC8dxCFAdHAW9wIBIg4xqwM0OFY4xY2lWq9QAkTy9AMCRHw5iDkItc44b7yCABGjh5rhUDyUTtBaXhAg0hVXsg8BogQ0kxtrjYApLZyAcAGpZCeEAJE+\/YAAUSKPgJsQfZH7xisIEAFiKJsMwUONFK3lBQGiUXUFHxAgCiAzurDWCLhSQ15cSOrYCSFApE8\/IEB0uCPhRbt\/SNx4BQEiwQxdm9o81MrOWl4QIFqVF\/YDASIMMLN5a42AKz3kxYWkjh1tAaJx+gEBosMdCS+a\/UPqxisIEAlm6NrU5KFmZtbyggDRrL6gLwgQQXAFTFtrBFwpIi8uJHXsaAsQjdMPCBAd7kh40eofkjdeQYBIMEPXphYPdbOyd0kMBIg2A4T8QYAIAStkFg1OCFghs6nWS1OAaJ1+QIAILQIFs1rrTPLGKwgQBaIIu9DioXAas8xbywsCRJsBQv4gQISAFTJrrRFwpYm8uJDUsaMpQLROPyBAdLgj4UWjf0jfeAUBIsEMXZsaPNTN6JQ3a3lBgIRggYBPCBABUAVNWmsEXKkiLy4kdexoCRDN0w+Lb7Tc1cQ6K4eoxo1XECDlamNpFtaXTjU6duzYMdXI1a5duyr\/vHz5cp1IlLykmte2bdso+8lea9eurfyk8Eq1XsgrLnamWq\/sr8HZa\/Xq1aIFeeqx\/fTTXYfqfHTN6aCbPnA+zZ3Xye471XpVgUo1P8m89u7dS5s3b6bJyclZfFuzZg2tWLGCnYep10urf4gVpolhSR5q51Lrz1peECAh2cDoGwKEEUwFU9YaAVfKyIsLSR07GhuIicMn6OH799LUyfqcrrhmIV01uEgk0VR5mPqGVqpu4+PjlD0lsH\/\/\/ll8W7lyJa1atUqEh6nXS6N\/iBYGAiQEvNM+8QhWUPj5nOMRLD4sNSzhiFcDZT4fqdZL4xEszc9+VCuear1Sz0+ibto3XjXqOhJ58XW38pY0+kf56MrPTLVe1vKCACnPUVMzIUBMlSM3GGuNIDdgxwHIyxEoI8OkNxDan\/1IfYOeen4S\/UP7xisIECPNzSMMCR56hMM21VpeECBspQ1rCAIkLP5FvVtrBEXjbzYeeXEhqWNHWoCEOP3IkEuVhxAgxdZFiBuvIECK1cji6FT7h7W8IEAssr9ETBAgJUALOMVaI+CCAnlxIaljR1KAhDr9gADR4Y6EF87+EerGKwgQCWbo2uTkoW7krb1ZywsCxBI7PGKBAPEAL8BUa42ACwLkxYWkjh1JARLq9AMCRIc7El64+sfu3btpw4YNNDExMSvM0dFRGhoakgi\/qU2uvFSDdnAm2T8c3IsNSbVe1vKCABGjsK5hCBBdvH29WWsEvvlU5yMvLiR17EhtIEKefkCA6HBHwgtH\/zhw4ACtX7+exsbGZoU4PDxMIyMjEqG3tMmRl3rQDg6l+oeDa9EhqdbLWl4QIKI01jMOAaKHNYcna42AI6eUN36p1ktqAxHy9CNlHkLot+5UFm68ahQh+gfXO4yOnVTrZS0vCBAdPot7gQARh5jVgbVGwJUc8uJCUseOhAAJffoB4P6GOQAAIABJREFUAaLDHQkvvv3Dwo1XECASzNC16ctD3WjdvVnLCwLEvXamR0KAmC7PrOCsNQIu9JAXF5I6diQESOjTDwgQHe5IePHpH1ZuvIIAkWCGrk0fHupGWsybtbwgQIrVz+xoCBCzpWkYmLVGwIUe8uJCUscOtwCxcPoBAaLDHQkvZfuHpRuvIEAkmKFrsywPdaMs7s1aXhAgxWtocgYEiMmyNA3KWiPgQg95cSGpY4dbgFg4\/YAA0eGOhJcy\/cPajVcQIBLM0LVZhoe6EZbzZi0vCJBydTQ3CwLEXElaBmStEXChh7y4kNSxwylArJx+QIDocEfCS9H+YfHGKwgQCWbo2izKQ93oynuzlhcESPlampoJAWKqHLnBWGsEuQE7DkBejkAZGcYpQKycfkCAGCFXiTCK9A+rN15BgJQovLEpRXhoLPSo\/vAJARITe1rECgESVyHR4FAvCwhwCRBLpx8QIBaYVS6GIn3R6o1XECDlam9pVhEeWoo7LxZreUGA5FUskt9DgERSqNNhWmsEXOghLy4kdexwCRBLpx8QIDrckfDi2j8s33gFASLBDF2brjzUjcrfm7W8IED8a2rCAgSIiTI4B2GtETgHnjMQeXEhqWOHQ4BYO\/2AANHhjoQXl\/5h\/cYrCBAJZujadOGhbkQ83qzlBQHCU9fgViBAgpegUADWGkGh4FsMRl5cSOrY4RAg1k4\/IEB0uCPhJa9\/xHDjFQSIBDN0bebxUDcaPm\/W8oIA4attUEsQIEHhL+zcWiMonECTCciLC0kdO74CxOLpBwSIDnckvLTqH7HceAUBIsEMXZt4H9PBGwJEB2dxLxAg4hCzOkCDY4VT3Fiq9fIVIBZPPyBAxJeDmINm6yymG68gQMTooWY41X5vLS8IEDVKyzqCAJHFl9u6tUbAlR\/y4kJSx46PALF6+gEBosMdCS\/N+kdMN15BgEgwQ9cm3sd08IYA0cFZ3AsEiDjErA7Q4FjhFDeWar18BIjV0w8IEPHlIOag0TqL7cYrCBAxeqgZTrXfW8sLAkSN0rKOIEBk8eW2bq0RcOWHvLiQ1LFTVoBYPv2AANHhjoSXmf0jxhuvIEAkmKFrE+9jOnhDgOjgLO4FAkQcYlYHaHCscIobS7VeZQWI5dMPCBDx5SDmoHadxXrjFQSIGD3UDKfa763lBQGiRmlZRxAgsvhyW7fWCLjyQ15cSOrYKSNArJ9+QIDocEfCS7V\/XHHFFbR+\/XoaGxub5WZ4eJhGRkYk3IvZTLUvlukfYiAzGk61XtbyggBhJG1IUxAgIdEv7ttaIyieQeMZyIsLSR07ZTYQ1k8\/IEB0uCPhJesf2Y1XX\/nKV2jXrl2zXAwMDNDGjRups7NTwr2YzVT7Ypn+IQYyo+FU62UtLwgQRtKGNAUBEhL94r6tNYLiGUCAcGEW0k7RDUQMpx8QICEZ5ec764vbtm2jZ555Zpahvr4+yt7nuru7\/ZwEmJ1qvy\/aPwJAX8plqvWylhcESCl62psEAWKvJq0istYIuNBDXlxI6tgpuoGI4fQDAkSHOxJe7rvvPvrqV79KixcvrjPf09NDW7Zsod7eXgm34jZT7YtF+4c40EwOUq2XtbwgQJgIG9oMBEjoChTzb60RFIu++WjkxYWkjp0iG4hYTj8gQHS4w+0lu\/Hqox\/9KE1NTdUJkK6uLtq0aRP19\/dzu1Szl2pfLNI\/1MBmcJRqvazlBQHCQFYLJiBALFTBPQZrjcA98tYjkRcXkjp2imwgYjn9gADR4Q6nl+qNVy+\/\/HLFbO0JyOjoKA0NDXG6U7eVal8s0j\/UQfdwmGq9rOUFAeJBUktTIUAsVSM\/FmuNID9itxHIyw0nK6NcNxAxnX5AgFhhl1sc4+PjtG7dusqNVwcOHKgTIDHeeNUo61T7omv\/cGOCnVGp1staXhAgdjjvFQkEiBd86pOtNQIuAJAXF5I6dlw3EDGdfkCA6HCHw0t249W99947feNVrQCJ9cYrCBAOZoS1gfcxHfwhQHRwFvcCASIOMasDNDhWOMWNpVovFwES2+kHBIj4cmBzkL1vbd++fdpeVYBcffXV0d54BQHCRo9ghlLt99byggAJRnFexxAgvHhKW7PWCLjyRV5cSOrYcREgsZ1+QIDocMfXywMPPEBbt26tM5MJkOya3ewq3lhvvIIA8WVG+Pl4H9OpAQSIDs7iXiBAxCFmdYAGxwqnuLFU65UnQGI8\/YAAEV8O3g6yG68+8YlPVG68qn0dPHiQ7rrrLrrjjju8fVgy0K79w1INisSSar2s5QUBUoSVhsdCgBguToPQrDUCLvSQFxeSOnbyBEiMpx8QIDrcKeuleuPVxMTELBO33XYbrVixggYHB8uaNzkv1b6Y1z9MFsMhqFTrZS0vCBAHMsYwBAIkhiqdidFaI+BCD3lxIaljp9UGItbTDwgQHe6U8VJ749XM+dmNV9dee23lnyFAyqCrPwcCRB9zH4\/W3p8hQHyqaWguBIihYjiEYq0ROITsNAR5OcFkZlCrDUSspx8QIGboVRfIzBuvan9ZvfHq8ccfhwCxWb6GUUGARFQsIrL2\/gwBEhd\/mkYLARJXIa01Ai70kBcXkjp2mm0gYj79gADR4U5RLzNvvKrO7+vrm77xCv2jKKphx0OAhMW\/qHdr6wsCpGgFjY6HADFamCZhWWsEXOghLy4kdew020DEfPoBAaLDnSJeGt14lc3v6emhLVu2TN94hf5RBNXwYyFAwtegSATW1hcESJHqGR4LAWK4OA1Cs9YIuNBDXlxI6thptIGI\/fQDAkSHO65emt141dXVRZs2baL+\/v5pU+gfrqjaGAcBYqMOrlFYW18QIK6VMz4OAsR4gWaEZ60RcKGHvLiQ1LHTaAMR++kHBIgOd1y8tLrxanR0lIaGhurMoH+4oGpnDASInVq4RGJtfUGAuFQtgjEQIBEUqSZEa42ACz3kxYWkjp2ZG4gUTj8gQHS4k+cl78arkZGRWSbQP\/JQtfV7CBBb9ciLxtr6ggDJq1gkv4cAiaRQp8O01gi40ENeXEjq2Jm5gUjh9AMCRIc7rby43HjV2dkJARK+VF4RQIB4wac+2dr7MwSIOgVkHEKAyOAqZdVaI+DKE3lxIaljp3YDkcrpBwSIDndaeXG58arRfPSP8LUrEgEESBG0wo+1tr4gQMJzgiUCCBAWGNWMWGsEXIkjLy4kdezUbiBSOf2AANHhTjMvrjdeQYCErROHdwgQDhT1bFh7f4YA0au9qCcIEFF42Y1bawRcCSIvLiR17FQ3EL\/2v32Qtn7yO3TixFSd4+vfdTHdePOlOsEwekmVh1WIrOZX5MYrCBBGwgcyBQESCPiSbq31DQiQkoW0Ng0CxFpFWsdjrRFwoYe8uJDUsVPdQLzlwv9GTzy6p87p3Hld9OGP3UDzF8zRCYbRS6o8tCxAit54BQHCSPhApiBAAgFf0q21vggBUrKQ1qZBgFirCARIXBVpz3plG4jjRzvoxM+vTOb0I6uktTda7rVgLb8yN15BgHCzQt8eBIg+5j4erfUNCBCfahqaCwFiqBgOoVhrBA4hOw1BXk4wmRmUbSBefnYuLZxzWTKnHxAguvQqe+MVBIhunSS8QYBIoCpn09r7MwSIXK1VLUOAqMLt7cxaI\/BO6LQB5MWFpI6dz\/zZ\/0PPfG8+Xdy3rM5hrJ\/9qCaRKg8t5lf2xisIEJ01LukFAkQSXX7b1voiBAh\/jYNYhAAJAntpp9YaQelEZkxEXlxI6tj5vz+2lV7d00XLlp0RIDF\/9sPiBl2iklbWmc+NVxAgEszQtQkBoou3rzcrfaOaBwSIb0WNzIcAMVIIxzCsNQLHsHOHIa9ciMwMODh2kP7gN7dR59FJWviGN9C8Ny2hrvnzKfbTjwzgVHloSWD53ngFAWKmFZQOBAKkNHRBJlrrix07duyov3fxNCy7du2q\/K\/ly5cHAUrKaap5bdu2jbKf7LV27drKTwqvVOuFvOJiZ2r1mjp2jH74xcdo13MnKoWYP38+dcybR3OWXkA3\/a8X0Nz5HXEVaEa0qdVrZjFC57d3717avHkzTU5OzuLJmjVraMWKFaX4EzqvUkE7TEo1r+wELHutXr3aAYV4hqRaL2t5QYDEsyZaRgoBElchrTUCLvSQFxeSgnaOHaPjD36Dtj++kF47fOrvT5kAyV5vWbmMrvqlCwWd65hOlYdV9ELmd\/jwYbrvvvto\/\/79s4q5cuVKWrVqVekih8yrdNAOE1PNCwLEofiGhljjIR7BMkQOn1DwCJYPevpzrR2FciGAvLiQlLFz8uhR+tkXP09Hnn+evvviG+m\/9nZWHHWf1U3zu+fRur\/832lBd3zf+zETrVR5WM0zVH6cN141YniovGRW2xmrqeaFR7CkmcNr3xoPIUB46xvMGgRIMOhLObbWCEol0WAS8uJCkt9OrfjIrJ842UEP7ppDPz96Li08ewG9\/\/+4nq66eZDfcQCLqfIwtADhvPEKAiTAwmB2CQHCDKiwOWt9EQJEuOBa5iFAtJDm8WOtEfBkle6Hf2Ov10zxUa33888\/TxMdC2jlx++lxW++nIsGwe3EXq88AEPkx33jFQRIXpXt\/x4CxH6NaiMM0TdaIQQBEhd\/mkYLARJXIa01Ai70kBcXknx2momPzMNPX3iBXrn6bfTr\/9fdfA4NWEqVh6FOQCRuvIIAMbBQPEOAAPEEUHm6tb4IAaJMACl3ECBSyMrYtdYIuLJEXlxI8thpJT46582jx846myYWLaY777yTx6ERK6nyMIQA2b17N23YsIEmJiZmVXd0dJSGhobYqp5q3VLNCwKEjfoqhqzxEAJEpezyTiBA5DHm9GCtEXDlhry4kPS3kyc++j74IfrSN75ZcQQB4o+3pgWtdTY+Pk7r1q2jsbGxWekNDw\/TyMgIa9paebEG7WAs1bwgQByKb2iINR5CgBgih08oECA+6OnPtdYIuBBAXlxI+tlxER\/dyy4hbCD8cA41W2OdSd941Qg7jbxC1CzVvNA\/QrCpvE9rPIQAKV9LUzMhQEyVIzcYa40gN2DHAcjLESjBYa7iIwsBGwjBQgia1lhn0jdeQYAIEkTJNPqHEtBMbjT6RpFQIUCKoGV4LASI4eI0CM1aI+BCD3lxIVnOThHxAQFSDmMLs6TXmcaNVxAgFpjkFwMEiB9+2rOl+0bRfCBAiiJmdDwEiNHCNAnLWiPgQg95cSFZ3E5R8QEBUhxjKzMk15nWjVcQIFbYVD4OCJDy2IWYKdk3yuQDAVIGNYNzIEAMFqVFSNYaARd6yIsLyWJ2yogPCJBiGFsaLbXONG+8ggCxxKhysUCAlMMt1CypvlE2HwiQssgZmwcBYqwgOeFYawRc6CEvLiTd7ZQVHxAg7hhbGymxzrRvvIIAscaq4vFAgBTHLOQMib7hkw8EiA96huZCgBgqhkMo1hqBQ8hOQ5CXE0xsg3zEBwQIWxnUDXGvsxA3XkGAqNOG3SEECDukoga5+4ZvsBAgvggamQ8BYqQQjmFYawSOYecOQ165ELEN8BUfECBspVA3xL3OQtx4BQGiTht2hxAg7JCKGuTuG77BQoD4ImhkPgSIkUI4hmGtETiGnTsMeeVCxDKAQ3xAgLCUIogRznUW6sYrCJAg1GF1CgHCCqe4Mc6+wREsBAgHigZsQIAYKEKBEKw1ggKhtxyKvLiQbG6HS3xAgMjXSsoD1zoLeeMVBIgUO\/TsQoDoYc3hiatvcMSS2YAA4UIysB0IkMAFKOjeWiMoGH7T4ciLC8nGdjjFBwSIbK0krXOss9A3XkGASDJExzYEiA7OXF44+gZXLBAgnEgGtgUBErgABd1bawQFw4cA4QKsgB1u8QEBUgB8Y0N9+4eFG68gQIyRqkQ4ECAlQAs4xbdvcIeOExBuRAPZgwAJBHxJt9YaQck0Zk1DXlxI1tuREB8QIDK10rDqs86s3HgFAaLBFFkfECCy+HJb9+kb3LFk9iBAJFANYBMCJADoHi6tNQKPVOqmIi8uJM\/YkRIfECD8tdKy6LPOrNx4BQGixRY5PxAgcthKWPbpGxLxQIBIoBrAJgRIANA9XFprBB6pQIBwgdfAjqT4gAARLJyw6bL9w9KNVxAgwiRRMA8BogAyo4uyfYMxhDpTECBSyCrbhQBRBtzTnbVG4JnO9HTkxYUkkbT4gADhq5W2pTLrzNqNVxAg2qzh9wcBwo+ppMUyfUMyHggQSXQVbUOAKILN4MpaI2BIqWICefEgqSE+IEB4ahXCStF1ZvHGKwiQEMzh9QkBwountLWifUM6HggQaYSV7EOAKAHN5MZaI2BKCwKEAUgt8QEBwlCsQCaK9A+rN15BgAQiD6NbCBBGMBVMFekbCuHgQ+gaIGv4gADRQJnPh7VGwJUZ8vJDUlN8QID41SrkbNd1ZvnGKwiQkAzi8Q0BwoOjlhXXvqEVD05AtJAW9gMBIgwws3lrjYArPeRVHklt8QEBUr5WoWe6rjPLN15BgIRmkb9\/CBB\/DDUtuPYNrZggQLSQFvYDASIMMLN5a42AKz3kVQ7JEOIDAqRcrSzMclln1m+8ggCxwCS\/GCBA\/PDTnu3SNzRjggDRRFvQFwSIILgCpq01Aq4UkVdxJEOJDwiQ4rWyMiNvncVw4xUEiBU2lY8DAqQ8diFm5vUN7ZggQLQRF\/IHASIErJBZa42AK03kVQzJkOIDAqRYrSyNbrXOYrnxCgLEEqPKxQIBUg63ULOsvT9DgIRiArNfCBBmQIXNWWsEXOkiL3ckQ4sPCBD3Wlkb2WydxXTjFQSINVYVjwcCpDhmIWdYe3+GAAnJBkbfECCMYCqYstYIuFJGXm5IWhAfECButbI4qtE6i+3GKwgQi8wqFhMESDG8Qo+29v4MARKaEUz+IUCYgFQyY60RcKWNvPKRtCI+IEDya2V1RKN1FtuNVxAgVtnlHhcEiDtWFkZae3+GALHACoYYIEAYQFQ0Ya0RcKWOvFojaUl8QIBwsV7fzsx1FuONVxAg+rzh9ggBwo2orD1r788QILL1VrMOAaIGNYsja42AJSkifBN6CyCtiQ8IEC7W69up7R+x3ngFAaLPG26PECDciMras7bvgACRrbeadQgQNahZHFlrBCxJQYA0hdGi+IAA4WK9vp1q\/+jt7aUNGzbQxMTErCBGR0dpaGhIPzgPj+iLHuAFmAoBEgB0D5fW1hcEiEcxLU2FALFUjfxYrDWC\/IjdRiCv2ThZFR8QIG6ctjgqW2eHDx+mv\/qrv6KxsbFZIQ4PD9PIyIjF0FvGhP4RV8kgQOKql7X1BQESF3+aRgsBElchrTUCLvSQVz2SlsUHBAgX6\/XtfOc736HPfOYz9Oqrr85yPjAwQBs3bqTOzk79wDw9on94Aqg8HQJEGXBPd9bWFwSIZ0GtTIcAsVIJtzisNQK3qPNHIa8zGFkXHxAg+Xy2OuKjH\/1o5fNWixcvrguxr6+PsveC7u5uq6HjBCTKyjQOGgIkrmJae3+GAImLPzgBSaRe1hoBF6zI6xSSMYgPCBAu1uvayW68+tSnPlVxWitAenp6aMuWLZR9LiTWF\/pHXJWDAImrXtbWFwRIXPyBAEmkXtYaAResyCse8QEBwsV6PTvVG6\/2799fJ0C6urpo06ZN1N\/frxeMgCf0DwFQBU1CgAiCK2Da2vqCABEocgiTeAQrBOrlfVprBOUzqZ\/Z7nnFcvJRrRo2EFzMl7eze\/fu6RuvDhw4UCdAYrzxqhFi7d4\/5FnE6wH9gxdPaWvW1hcEiHTFlexDgCgBzeTGWiNgSqutvwckNvGBExAu1svbGR8fp3Xr1k3feFUrQGK98QoCRJ430h4gQKQR5rVvbd8BAcJb32DWIECCQV\/KsbVGUCqJBpPaNa8YxQcECBfrZe0cP36c7r33Xtq1a9e0o6oAyb7nI9YbryBAZHmjYR0CRANlPh\/W3p8hQPhqG9QSBEhQ+As7t9YICifQZEI75hWr+IAA4WK9rJ2st2\/fvr3OSSZAlixZQl\/84hejvfEKAkSWNxrWIUA0UObzYe39GQKEr7ZBLUGABIW\/sHNrjaBwAhAgFQRiFh8QIFysl7OT3Xi1devWWQ4mJyfp7rvvpptuuknOeQDL6IsBQPdwCQHiAV6AqdbWFwRIABJIuIQAkUBVzqa1RsCVaTvlFbv4gADhYr2MneqNV1NTU3UOshuv1qxZQ5dddhkNDg7KOA9ktZ36RyCIWd1CgLDCKW7M2vqCABEvuY4DCBAdnLm8WGsEyKs1AjPrlYL4gADhYj2\/ndobr2Zaz268WrRoUeWfIUD4sZewmGq\/hwCRYIucTWs8hACRq7WqZQgQVbi9nVlrBN4JnTbQDnmlIj4gQLhYz2tn5o1XtdarN161wzrjRTWstVTrBQESlldFvVvjIQRI0QoaHQ8BYrQwTcKy1gi40Es9r+uuvpp+9sXP05Hnn58FWee8edT3wQ9R97JLuOAUt4MNhDjEhRw0uvGqamBgYGD6xqvU1xlOdgrRJthg9I9g0JdybK1vQICUKqO9SRAg9mrSKiJrjYALvZTzmjp2jHr\/48lkxAdOQLhYz2en0Y1XmfW+vj7Kftfd3V1xlvI6y\/KDAOHjlKQlCBBJdPltW+sbECD8NQ5iEQIkCOylnVprBKUTmTEx1bx2PPYYnXzwm7To6EQSJx\/VJLCB4GK+v51mN1719PTQli1bqLe3d9pJqusMefnzSNMC+ocm2v6+rK0vCBD\/mpqwAAFiogzOQVhrBM6B5wxMMa\/sMx87\/scf09QrL9PixYvrEIjxsavaBLCB4GK+n51WN15t2rSJ+vv76xykuM5wsuPHoRCz0T9CoF7ep7W+0bFjx476O\/5O51b91tXly5eXz9bgzFTz2rZtG2U\/2Wvt2rWVnxReqdYLecXBzuyxq+zk4\/Vnn6kEvHDhwjOBz5lDXe9+D3UsWRJHMg2izP7qnr1Wr14dbQ6NAo9pfe3du5c2b95M2Xd7zHxl1+2uWLFi1r\/HlF8RYiGvImiFH4v+Eb4GRSKwtr4gQIpUz\/BYCBDDxWkQmrVGwIVeSnlVxUd28nHw4MF6AZKA+MgSwgaCi\/nl7Bw+fJjuu+8+2r9\/\/ywDK1eupFWrVjU0nNI6q00QeZXjUahZ6B+hkC\/n19r6wiNY5epobhYewTJXkpYBWTsK5UIvlbxmXrV74MCBCkTZI1ixP3ZVW2s8QsHF\/OJ2XG+8amQ5lXU2MzfkVZxHIWegf4REv7hva+sLAqR4DU3OgAAxWZamQVlrBFzopZBXo+\/5qAqQc3t7o7tqt1VtsYHgYn5xO643XkGAFMfW2owU+mIjTNE\/rDGtdTzWeAgBEhd\/mkYLARJXIa01Ai70Ys+r2ZcMVgTInDl0zfqPRvU9H3l1xQYiDyGZ3xe58QoCRKYGmlZj74vNsEL\/0GSRvy9rPIQA8a+pCQsQICbK4ByEtUbgHHjOwJjzavUN5wcOHap84HzFrbdyQWXCDjYQ+mUoeuMVBIh+jbg9xtwXW2GB\/sHNFFl71ngIASJbbzXrECBqULM4stYIWJKK+AvSWomP7DMfr694e+W2q9S+IA0bCC7mu9nZvXs3bdiwgSYmZn+fzOjoKA0NDTkZQv9wgsnMoFTrhf5hhmJOgVjjIQSIU9nsD4IAsV+j2gitNQIu9GLMK0989H3wQ\/SjsX0ViCBAuJgia8ciD8fHx2ndunU0NjY2K\/nh4WEaGRlxBsVifs7BtxiIvDhQ1LMBAaKHNYcna+sLAoSjqgZsQIAYKEKBEKw1ggKhtxwaW14u4qN72SUUW16u9cQGwhUpv3E+N1418pwqH5GXH8+0Z6N\/aCPu58\/a+oIA8aunmdkQIGZK4RSItUbgFLTDoJjychUfWdox5eVQpukh2EAUQav8WJ8bryBAyuNuZSb6h5VKuMWRar2s5QUB4sZH86MgQMyXqC5Aa42AC71Y8ioiPiBAuNihZ8cSD31vvIIA0eONlCdLfOTMEX\/A4ERT3pY1HkKAyNdcxQMEiArMbE6sNQKuxGLIq6j4gADhYoeeHSs85LjxCgJEjzdSnqzwkTs\/CBBuRGXtWeMhBIhsvdWsQ4CoQc3iyFojYEkqgkeVyogPCBAudujZsbC+uG68ggDR442UJwt8lMgNAkQCVTmb1ngIASJXa1XLECCqcHs7s9YIvBM6bcByXmXFBwQIFzv07ITmIeeNVxAgeryR8hSaj1J5QYBIIStj1xoPIUBk6qxuFQJEHXIvh9YagVcyNZOt5uUjPiBAuNihZyckD7lvvIIA0eONlKeQfJTKKbMLASKJLr9tazyEAOGvcRCLECBBYC\/t1FojKJ3IjIkW8\/IVHxAgXOzQsxOSh9w3XkGA6PFGylNIPkrlBAEiiayMbWs8hACRqbO6VQgQdci9HFprBF7JGD4B4RAfECBc7NCzE2p9Sdx4BQGixxspT6H4KJVP1S5OQKQR5rVvjYcQILz1DWYNAiQY9KUcW2sEpZJoMMlSXlziAwKEix16dkLwUOrGKwgQPd5IeQrBR6lcau1CgGigzOfDGg8hQPhqG9QSBEhQ+As7t9YICifQZIKVvDjFBwQIFzv07GjzUPLGKwgQPd5IedLmo1QeM+1CgGghzePHGg8hQHjqGtwKBEjwEhQKwFojKBR8i8EW8uIWHxAgXOzQs6PJQ+kbryBA9Hgj5UmTj1I5NLILAaKJtr8vazyEAPGvqQkLECAmyuAchLVG4Bx4zsDQeUmIDwgQLnbo2dHiocaNVxAgeryR8qTFR6n4m9mFANFG3M+fNR5CgPjV08xsCBAzpXAKxFojcAraYVDIvKTEBwSIQ+GNDdHiocaNVxAgxshVIhwtPpYIzWsKBIgXfOqTrfEQAkSdAjIOIUBkcJWyaq0RcOUZKi9J8QEBwsUOPTsaPNS68QoCRI83Up40+CgVeyu7ECAhUC\/v0xoPIUDK19LUTAgQU+XIDcZaI8j12BL\/AAAgAElEQVQN2HFAiLykxQcEiGPxDQ2T5qHmjVcQIIaIVTIUaT6WDMt7GgSIN4SqBqzxEAJEtfxyziBA5LCVsGytEXDlqJ2XhviAAOFih54dSR5q33gFAaLHGylPknyUitnFLgSIC0p2xljjIQSIHW54RQIB4gWf+mRrjYALAM28tMQHBAgXO\/TsSPEwxI1XECB6vJHyJMVHqXhd7UKAuCJlY5w1HkKA2OCFdxQQIN4Qqhqw1gi4ktfKS1N8QIBwsUPPjgQPQ914BQGixxspTxJ8lIq1iF0IkCJohR9rjYcQIOE5wRIBBAgLjGpGrDUCrsQ18tIWHxAgXOzQsyPBw1A3XkGA6PFGypMEH6ViLWIXAqQIWuHHWuMhBEh4TrBEAAHCAqOaEWuNgCtx6bxCiA8IEC526Nnh5mHIG68gQPR4I+WJm49ScRa1CwFSFLGw463xEAIkLB\/YvEOAsEGpYshaI+BKWjKvUOIDAoSLHXp2OHkY+sYrCBA93kh54uSjVIxl7EKAlEEt3BxrPIQACccFVs8QIKxwihuz1gi4EpbKK6T4gADhYoeeHS4eWrjxCgJEjzdSnrj4KBVfWbsQIGWRCzPPGg8hQMLwgN0rBAg7pKIGrTUCrmQl8gotPiBAuNihZ4eDh1ZuvIIA0eONlCcOPkrF5mMXAsQHPf251ngIAaLPARGPECAisIoZtdYIuBLlzsuC+IAA4WKHnh1fHlq68QoCRI83Up58+SgVl69dCBBfBHXnW+MhBIhu\/cW8QYCIQSti2Foj4EqSMy8r4gMChIsdenZ8eWjpxisIED3eSHny5aNUXL52IUB8EdSdb42HECC69RfzBgEiBq2IYWuNgCtJrrwsiQ8IEC526Nnx4aG1G68gQPR4I+XJh49SMXHYhQDhQFHPhjUeQoDo1V7UEwSIKLzsxq01Aq4EOfKyJj4gQLjYoWenLA8t3ngFAaLHGylPZfkoFQ+XXQgQLiR17FjjIQSITt3FvUCAiEPM6sBaI+BKzjcvi+IDAoSLHXp2yvDQ6o1XECB6vJHyVIaPUrFw2oUA4URT3pY1HkKAyNdcxQMEiArMbE6sNQKuxHzysio+IEC42KFnpygPLd94BQGixxspT0X5KBUHt10IEG5EZe1Z4yEEiGy91axDgKhBzeLIWiNgSYqIyuZlWXxAgHCxQ89OER5av\/EKAkSPN1KeivBRKgYJuxAgEqjK2bTGQwgQuVqrWoYAUYXb25m1RuCd0GkDZfKyLj4gQLjYoWenCA+t33gFAaLHGylPRfgoFYOEXQgQCVTlbFrjIQSIXK1VLUOAqMLt7cxaI\/BOqKQAiUF8QIBwsUPPjuv6iuHGKwgQPd5IeXLlo5R\/KbsQIFLIyti1xkMIEJk6q1uFAFGH3MuhtUbglUzN5CJ5xSI+IEC42KFnx4WHsdx4BQGixxspTy58lPItaRcCRBJdftvWeAgBwl\/jIBYhQILAXtqptUZQOpEZE13zmjh0hLZ\/7m\/o5Zf20SWdh2hJ59FpS53z5lHfBz9E3csu4QrL245rXt6OlA206wYiphuvIECUF4WAO\/QPAVAFTaZaL2t5QYAIkljTNASIJtr+vqw1Av+MTlnIy2vy+Ena\/uQe+ud\/+jaNHz4lOubTSfqN+T+hRR3HyKL4cMmLCz9tO+0oQGK78QoCRHtV8PvL64v8HnUstmP\/0EFWxos1HkKAyNRZ3SoEiDrkXg6tNQKvZGomN8srEx6P\/PBleujJl+j1116nIz\/bXefyF7peo1vPfs3cyUc1yFTr1W4biBhvvIIA4epO4eygf4TDvoznVOtlLS8IkDLsNDgHAsRgUVqEZK0RcKE3M6+q8Hj4By\/R+MTxipsThw\/PEiCXzjlC9\/yf7zH12FUtJqnWq90ESIw3XkGAcHWncHbQP8JhX8ZzqvWylhcESBl2GpwDAWKwKG0sQN527XX0rR+9Qg8++eK08KiF48gLP6MThw6d+qfOTvrN4QF6xzv6zRbRWuPmAqqdBEisN15BgHCxPZwd9I9w2JfxnGq9rOUFAVKGnQbnQIAYLEobCpDHvruDntxzlH4y3t1QeFQhmTp5kib3jdHbFhyl4fe9nfqu6DNdQGuNmwusdhEgMd94BQHCxfZwdtA\/wmFfxnOq9bKWFwRIGXYanAMBYrAobSRAjp04Sf\/2w5fpb\/+\/H9KRY1O0ePHiptl3dHTQwGVvoFsHl9KSxQuiKJy1xs0FWjsIkNhvvIIA4WJ7ODvoH+GwL+M51XpZywsCpAw7Dc6BADFYlDYQIFXh8dAP9tLBI8fowIEDlawbCZBMeFx36bn03hUXRSM8qiW01ri52J66ALnyyitp3bp1NDY2Nguy4eFhGhkZ4YJS1U6qfEReqjTydpZ6\/xgcHPTGyJIBa+sLAsQSOzxigQDxAC\/AVGuNoCgEFeHxo1fo4exWqyPHpqc3EiBV4XHLwIV0wblnFXVlYnzs9WoGYsobiOzGq6985Su0a9euWekPDAzQxo0bqbOz0wS\/igaRKh+RV1EmhB2fcv\/IkIUAkeUXBIgsvmrWIUDUoGZxFOsbbSY8sg+XV67TrREeVVBmCpCBy86jWwYuiFZ44ASEhe7qRrL1tW3bNnrmmWdm+e7r66OsX3Z3d6vHxeUw1v6Rlz\/yykPI1u8hQGzVIy8aa+sLAiSvYpH8HgIkkkKdDtNaI8hDL0941AqQqakpGhq4jG6N+MRjJh6x1SuvntXfp7qBuO++++irX\/3qrEcBe3p6aMuWLdTb2+sKkclxqfIReZmkW9OgUu0f4KEODyFAdHAW9wIBIg4xq4NYGpyr8KiC0zvvML3j0m66+Zd+kRWv0MZiqVdRnFLcQGQ3Xn30ox+lTAjXfhapq6uLNm3aRP39dq97dq1fqnxEXq4MsDEuxf6RIQse6vCrY8eOHVONXFWfm12+fLlOJEpeUs0re9wg+8lea9eurfyk8Eq1XtbzOn5yiv7jxaP0veeP0OHJhi1iml7ZRu\/Nb5pXER6v7H668u\/oG3Gsvuy7MbLX6tWr4wg4J8q9e\/fS5s2bad++fZWRCxcunJ6xZs0aWrFiRRJ5Wu8fZUFGXmWRCzMvtf5RRRE81OETBIgOzuJeIEDEIWZ1YLXBZcLjqRcn6bvPH3YUHvPpHZcuoPPOnlPBx2pevsVLNa+UNhCHDx+m7NGr\/fv308GDB+sEyMqVK2nVqlW+NDAzP1U+Ii8zFHMKJKX+UZsweOhUfu9BeATLG0IbBvAIlo06uEZh7Yg3e9Tq33f9nL755Iv0+uEzt1o1y+cXLj2XbhlYSkvfUH+rlbW8XOuRNy7VvFJ5hCK78eree++dFsC1lyHEfuNVI26mykfkldeJbP0+lf4xE1XwUIdnECA6OIt7gQARh5jVgZUGlwmPb\/9nJjxeogOHJnNzbCY8qhOt5JWbSMEBqeaVygYi63\/bt2+frmpVgFx99dXR33gFAVJwsRocjv5hsCgtQkq1XtbyggCJa100jRYCJK5Chm4ERYXHtZecW\/nm8pknHvjLUVy8mxltCgIkewxk69atdallAiS7Zjd7NDX2G68gQOJeY1n0ofu9FIIp9A+sLyl25NuFAMnHKIoRECBRlGk6yFBvSNlnPP591yv0zSdepAMOj1pds+ycyjeX5wkPnIDExb9qtLFvILIbrz7xiU9UbryqfWWfAbnrrrvojjvuiLMwOVGH6h\/SYCIvaYR57cfeP5qhAR7y8qSZNQgQHZzFvUCAiEPM6kC7wWXC49u7XqFvCAkPCBBWeqgZi3kDsXv3btqwYQNNTEzMwuu2226r3HiV2jcZY52pLQ1WR9r9njX4FsZi7h+tMEq1XtbyggDRWqnCfiBAhAFmNq\/VCCrCI\/uMxxMv0n6Hz3hcs+zUo1YXnVf\/4XLX9LXyco2Ha1yqecW6gRgfH6d169bR2NjYrBIPDw\/TtddeW\/l3CBCuFaBjJ9V1lmpesfaPPDanWi9reUGA5DExkt9DgERSqNNhSjeCosLjbdmjVoMXlRYe+MtsXPyrRhvjBmLmjVe1yFdvvHr88cchQCKkpHRfDAVJqnnF2D9cOJBqvazlBQHiwsYIxkCARFCkmhClGsEp4fEKPfjkS\/TaeP6tVldffA7dtsJfeECAxMW\/mAXIzBuvqrn09fVN33gltb6sVDnV\/JCXFYa5xQEB4oaTlVHW1hcEiBVmeMYBAeIJoPJ07kaQCY9HK9fpvhhEeECAKBOIyV1sG4hGN15lUPT09NCWLVumb7ziXl9McLOZSTU\/5MVGERVDsfUPV1DAQ1ek\/MZBgPjhZ2Y2BIiZUjgFwtXgjp84SY\/9eIy+8fiL9JrDZzy4TzxmJsuVlxOIioNSzSumDUSzG6+6urpo06ZN1N\/fP82IVOsFoa+46BldpcrHmPpHkXKmWi9reUGAFGGl4bEQIIaL0yA030ZQVHi89eJz6HbGR62aoe2bl9UqpppXLBuIVjdejY6O0tDQUB11Uq0XBIjVDtE6rlT5GEv\/KMqaVOtlLS8IkKLMNDoeAsRoYZqEVbYRVIVHdqvVqw6f8ciEx60DF9Ky3h4VgMrmpRKch5NU84phA5F349XIyMisyqZaLwgQj0UccGqqfIyhf5Qpe6r1spYXBEgZdhqcAwFisCgtQiraCDLh8Z2nTz1q5SQ8+hZXrtPVEh7YGMXFv2q01jcQLjdedXZ2QoDESb+2qVvRfh9LOa33j7I4plova3lBgJRlqLF5ECDGCpITjmsjqAqPbz7xEu07eDQ3ybf2nUO3DuqdeMwMyDWv3ESMDUg1L+sbCJcbrxpRJdV6QegbawyO4aTKR+v9w7E8EMJlgfKcBwHiCaCV6RAgVirhFkfeG1ImPL779L7KN5fHIDywMXKru7VRljcQrjdeQYBYY1X5ePL6YnnLYWemmpfl\/uFT8VTrZS0vCBAflhqaCwFiqBgOoTRrBCdOTtF3Tz9qNeZw4tHft5jeG+BRq2YpWmtwDqVwGpJqXlY3EEVuvIIAcaJwFINSXWep5mW1f\/iSPdV6WcsLAsSXqUbmQ4AYKYRjGDMbQVHhsfyixXTbCv3PeOSlZ63B5cXr+vtU87K4gSh64xUEiCuL7Y9LdZ2lmpfF\/sHB8lTrZS0vCBAOthqwAQFioAgFQqg2gl+4bmD6w+Uuj1pdtXQRvXfFRXTpm3RutSqQUmWotQZXNP52O9mxtoEoc+MVBAgXy8PbQf8IX4MiEVjrH0VibzUWPORCsrUdCBAdnMW9QICIQ8zq4Hs7vk+79h6lZ8fPdvqMh3XhUQUHjZuVJuLGLG0gyt54BQEiThM1B+gfalCzOLLUP1gSOm0EPOREs7ktCBAdnMW9QICIQ8ziIHvU6nvP7KMvffMJen1iihYvXtzS7lVLF9N7Vyw1e+IxM3g0bhaaqBmxtIEoe+MVBIgaXcQdoX+IQ8zqwFL\/4EwMPOREEwJkGoFUiQUBorNgyno5OZV9uHwfff3xPTT2+lE6cOBAxVQzAXLl0kV0m+FHrZrhkOr6SjUvKxsInxuvIEDKdiV781JdZ6nmZaV\/cDM51XpZywsnINzMDWQPAiQQ8DluTwmPMfrGEy\/Rzw9MTI9uJkBiFR7VxKw1OC5WpJqXhQ2E741XECBcLA9vJ9V1lmpeFvqHBGtTrZe1vCBAJNgbwCYESADQW7jMhMf3shOPJ16sEx7VKTMFyFsuXFS5Tvfy8xfaSqRgNNYaXMHwmw5PNa\/QGwiOG68gQLhYHt5Oquss1bxC9w8pxqZaL2t5QYBIMVjZLgSIMuBN3E0Lj8f30M9fb\/7N5VUB8vblfXRrAsIDJyA2+Fc0ipAbCK4bryBAilbd7nhrGyQupFLNK2T\/4KpNO\/UPazyEAJFksaJtCBBFsBu4yoTHjmf20dd2thYe1akLOw7R\/3LZWXT7f\/vFsIEze7fW4LjSSzWvUBsIzhuv2mkDAaHPtaJ17aB\/6OLt6y3VelnLCwLEl6lG5kOAhClEVXh8\/fEX6ZWaz3g0i6b6qNX+PT+uDBkcHAwTuJBXaw2OK81U8wolQDhvvIIA4WJ5eDuprrNU8wrVP6SZmmq9rOUFASLNZCX7ECBKQJ92c\/LkFH3\/uezEw014vPmChZVbraqf8bDWCLjQQ15cSOrYCbGB4L7xCgJEhysaXtA\/NFDm8xGif\/BF39wSeKiBMhEEiA7O4l4gQMQhrjioCo\/sxOPl\/WdutWrmPRMc77v+jPCojkOD06kXl5dU66W9gZC48QoChIvl4e2kus5SzUu7f2gxNNV6WcsLAkSL0cJ+IEBkAc6Ex87nXqWvPb7HSXi8+YJFdMvAhZQ9ctVOGyRrDY6LFanmpbmBkLrxqp3WF\/6AwbWide2gf+ji7est1XpZywsCxJepRuZDgMgUoiI8fvIqfe37e+hlh894XHHBQrplYCld2UR4YAMhUydpq9YaN1e+WgJE8sYrCBAuNoS3k+o6SzUvrf6hzcxU62UtLwgQbWYL+YMA4QW2Kjy+vnMP7XV81Cq7TjdPeECA8NZJy5q1xs2Vt8YGQvrGKwgQLjaEt5PqOks1L43+EYKVqdbLWl4QICHYLeATAoQH1DLCI\/sCwWaPWjWLyloj4EGPCHlxIaljR2MDIX3jFQSIDlc0vKB\/aKDM50Ojf\/BF624JPHTHymckBIgPeobmQoD4FWNqqvoZjxdp72tHco1dtqSH3jt4EV25tPFnPPIMoMHlIWTr96nWS3oDoXHjFQSIrbXiE02q6yzVvKT7hw+XfOamWi9reUGA+LDU0FwIkHLFKCw8zl9Itw5cSFctXVzO4elZ1hqBVzI1k5EXF5I6diQ3EFo3XkGA6HBFwwv6hwbKfD4k+wdflMUtgYfFMSszAwKkDGoG50CAFCtKJjwe\/8lrle\/xeOm1w7mTL2MSHlVHaHC5kJsakGq9pDYQmjdeQYCYWipewaS6zlLNS6p\/eJGIYXKq9bKWFwQIA1ktmIAAcavCKeHxKn1t50tOwuPS049aXVXyUatmUVlrBG7o5Y9CXvkYWRohsYHQvvEKAsQSo\/xiQf\/ww097tkT\/0M6hnfqHtfUFAWKB7QwxQIC0BjETHk\/85DX6l5176CWHz3hc+qYeym61Wn6R36NWECAM5DZgwlrj5oKEewMR4sardtpA4ASVi\/m6dtA\/dPH29ZZqvazlBQHiy1Qj8yFAGheiKjy+9viL9OKr+Y9aSQsPbCCMLJiCYVhr3AXDbzqcW4CEuPEKAoSLDeHtpLrOUs2Lu3+EZ+CpCFKtl7W8IECsMN4zDgiQegAz4fHkT\/dXTjxchUf2BYL9fTInHjPLa60ReNJvejry4kJSxw7nBiLUjVcQIDpc0fCC\/qGBMp8Pzv7BF5W\/JfDQH0MXCxAgLihFMAYC5FSRTgmPUx8u3+Nw4nHJm3roloEL6a1956hWGQ1OFW5vZ6nWi2sDEfLGKwgQb3qbMZDqOks1L67+YYaApwNJtV7W8oIAscb8kvG0uwCJRXhUy2utEZSk3axpyIsLSR07HBuI0DdeQYDocEXDC\/qHBsp8Pjj6B180fJbAQz4sW1mCANHBWdxLuwqQ6qNWX9u5x+nEY1nv2XTr4EX0VqVHrZoVHg1OfEmwOki1Xr4bCAs3XkGAsFI9qLFU11mqefn2j6Bka+E81XpZywsCxOoKKBhXuwmQTHj84Pn9lAmPF\/blf7h8WW9P5QsE33qx7qNWECAFiWx0uLXGzQWTzwbCyo1XECBcbAhvJ9V1lmpePv0jPNuaR5BqvazlBQFieRUUiK2dBEgmPP7l+y84C4\/sMx5XGxEe1ZJaawQFqNZyKPLiQlLHjs8GwsqNVxAgOlzR8IL+oYEynw+f\/sEXBb8l8JAf00YWIUB0cBb30g4CpHri8bOxQ7l4Xpw9ajWw1JzwgADJLZ3JAam+IZXdQFi68QoCxOSSKRVUquss1bzK9o9S5FCclGq9rOUFAaJIaklXKQuQZ8cm6SeHF5GL8Oh749n03kG7wgMCRHIVyNm21ri5Mi2zgbB24xUECBcbwttJdZ2lmleZ\/hGeZfkRpFova3lBgORzMYoRMQuQyRPH6MCR1+ngxEE6eHScXj9ykF4\/Ok679+2jh5\/4T5qYnEO9Pf10dtdFTWtx0XlnVT5cfs0yG5\/xyCONtUaQF6\/r75GXK1I2xhXdQFi88QoCxAaXOKJA\/+BAUc9G0f6hF5mfJ\/DQDz\/X2RAgrkgZH2dRgByePEwHMlExMV4RF69nP6cFRiY0qoJj4tjRWegemTxBz+49SMeOHav8bu6cuXTJWatpTsdZdWMz4fHewYvobZEID5yAGF9ITcJL9Q2pyAbC6o1XECBxrql2qhv6R1wcTbVe1vKCAIlrXTSNVlOA7D9yoCIqKoLi9KlF3f+fGKdsjM\/r5f1H6OevHz0jQObOpTfOG6Rz5iyvmM0etco+4xGb8IAA8WFFuLnWGjcXEq4CxPKNV+20kUX\/4GK+rp127x+6aPt7S7Ve1vKCAPHnqgkLvgLkWPYYVCYoKo9CjVdOKqZPLSoi41Dld4cm86+85QDk4JFj9PzPD80QIL9Ibzv\/F6IWHthAcLBD34a1xs2FgKsAsXzjFQQIFxvC20l1naWal2v\/CM+sYhGkWi9reUGAFOOl2dHNBIjPY1Chk927\/wi9tG+8EsYbF\/bShl\/+CL39igtDh8Xi31ojYEmKiJAXF5I6dlw2ENZvvIIA0eGKhhf0Dw2U+Xy49A8+b3qWwEMdrCFAdHAW9fLigb103+f+lP7l4a9Rx\/xOevuNv0hvufpK78egRIOeYXzhgh7qmd9DixcspIXZf3cvop75Z9OPn36B5tHZtPZXbtEMR9wXGpw4xKwOUq1X3gYihhuvIEBYqR7UWKrrLNW88vpHUDJ5OE+1XtbyggDxIKmFqT9+5Vn6y3\/\/Aj333HP07LPPVkK6\/PLL6bLLLrMQHp3TvZgWZaJiwWlxMf2\/TwmMTGhkv2\/2srZguEBFXlxI6thJtV6tNhCx3HgFAaKzBjS8pLrOUs0LAkRjVfD5sMZDCBC+2gax9JUnvkqP\/uR7qgJk\/pz5tGhBz2lhsXBaYCya30OLuhdVTjAywXH2vPobq8oAZG3BlMmhnTZIqBcXQ3TsNNtAxHTjVTutr2quWGc664PLS6r1ggDhYoiOHWs87PjkJz851Sj1F154ofLPF13U\/LsXdCDj9ZJaXrvpJfoZ7aV9+\/ZVfrLXeeedV\/kp+poz1UXzOubRvKk5NK9jLs2juZX\/VP\/\/3Kk5NL9jHnVSZ1HTpcenVq8qEMirNCWCTEy1Xo899lgFzxtuuGEa1xMnTtDXvvY1euWVV2ZhvXTpUnr3u99NnZ16PaBMwVOtF\/pHGTaEn5MqHxv1j\/Bo+0eQar2s5dVxwQUXNBQg09+\/MHeufzUNWUgtr86zuui8my+ibNOQ\/WSvrq6uyk\/ldXKKTkycoJPZz9ETNDVx4tT\/P3rq304cOU5TR09W\/j81ZELY4qVWryqayCssr4p6T7Vehw+futXurLPOnFZmpx+Tk5OzIMp6yqJFi6ijo6MofOrjU60X+oc6lVgcpsrHRv2DBbDARlKtl7W8IEACE53DfdfZc2jq3E6aODpBx48cr5xczO+cVxEbJydPcrgIZsPaguECAnlxIaljJ9V6zdxAHDlyhLKfma9MdGTiY\/oPGzqwl\/aSar0gQEpTIujEVPkIARKUVoWdW+MhHsEqXEKbEx555BHKfrLXu971rspPCi9rR4ZcmCIvLiR17KRar9pHKLIcv\/nNbzYUH7feeistWbJEB2wGL6nWqwpNqvkhLwbyK5rAI1iKYDO4sra+8CF0hqJaMOH7RYQWcmgUg7UPTXHhhLy4kNSxk2q9qh8i\/ZVf+RXasGEDTUxMzAJ0dHSUhoaGdIBm8pJqvarwpJof8mJaAEpm8CF0JaCZ3FhbXxAgTIUNbQYCJHQFivm31giKRd98NPLiQlLHTraByETH448\/TmNjY7OcDg8P08jIiE4wjF5S5SEECCNJFE2lykcIEEUSMbiyxkMIEIaiWjABAWKhCu4xWGsE7pG3Hom8uJDUsfPnf\/7n9I\/\/+I80b968WQ4HBgZo48aN5m+8aoRUqjyEANFZF9xeUuUjBAg3U2TtWeMhBIhsvdWsQ4CoQc3iyFojYEmKiJAXF5I6du644w76r\/\/6L1q2bFmdw76+Psp6Snd3t04gzF5S5SEECDNRlMylykcIECUCMbmxxkMIEKbChjYDARK6AsX8W2sExaJvPhp5cSEpb+eBBx6gT3ziExVHtQKkp6eHtmzZQr29vfJBCHlIlYcQIEKEETabKh8hQISJw2zeGg8hQJgLHMocBEgo5Mv5tdYIymUxexby4kJS1s7OnTsr4mNqqv7Lf7Jrdjdt2kT9\/f2yAQhbT5WHECDCxBEynyofIUCECCNk1hoPIUCECq1tFgJEG3E\/f9YagV82Z2YjLy4k5ezs3r07qRuvGiGVKg8hQOTWhaTlVPkIASLJGn7b1ngIAcJf4yAWIUCCwF7aqbVGUDqRGRORFxeSMnaybzlft25dUjdeQYDIcCWEVfSPEKiX9wkBUh67EDOtrS8IkBAsIKKTJ0\/S5z73OfrCF75Q+RBo9o2iF198Mb3\/\/e+v\/HWy6PPXECCBClnSrbVGUDKNWdOQFxeS\/HaOHz9O9957Lz355JMNv3BwpsfshqyPfOQj\/IEoWEyVhzgBUSCPgItY+fjMM8\/Q6tWr6T\/+4z\/oPe95D33961+vQ6eRAOHe2wiUI9dkrPXKS8xaXhAgeRUT+P3Ro0fp9ttvpwcffLCh9QsvvJC+8Y1v0NVXX+3sHQLEGSoTA601Ai5QkBcXkvx2sh6xfft2yk5Bsv\/Oe0GA5CEU7vdYZ+GwL+M5xnr98z\/\/M\/36r\/86HThwoJJyMwEyODhI2U\/2ktjblMHbd06M9XLJ2VpeECAuVWMekz0C8elPf7pi9a677qIPf\/jDtHDhQvr2t79Nd999N74CPCIAACAASURBVL388st0xRVXVP5SedZZZzl5hwBxgsnMIGuNgAsY5MWFJK+d7MarrVu3Voy++uqrlV6Tvd75znfSPffcQ+ecc84sh1kPOv\/883kDUbKWKg+r8KWaH\/JSWiAt3GQnGL\/7u79buYwiu6Qiexrj5z\/\/eVMB8qEPfWj6e4Qk9jYhEAEPdVCHANHBedpL9gHQyy+\/nLLHIbLFml13Wft66qmnKn9NmJycpM2bN9P69eudIoQAcYLJzCA0ODOlcAok5nrNvPFq7969tGPHjkre2R85rrnmGicMYhoUc71ccE41P+TlUn25Mfv27aNf+7Vfqzyi2dHRQX\/wB39Azz33XOVx8UYnINm4m2++uRKQ1N5GLtvmlsFDHdQhQHRwnvaS\/VXhd37ndyi77nLPnj20ZMmSWRFkx55f+tKXaPny5fSjH\/3IKUIIECeYzAxCgzNTCqdAYq1Xoxuvsn\/7wQ9+QIsWLZp+vMIJhIgGxVovV4hTzQ95uTJAZtwjjzxCv\/zLv0zz58+nz3\/+85R9UenatWvpy1\/+ckMBkn025G1ve1slGKm9jUymra2ChzqoQ4Do4Dzt5aabbqKHH36YbrjhBnr00Ucbev\/7v\/\/7ysL\/\/9v7Hhg7s7L8s1PFDjbb7Got7GZWkLC2lUSYuiZq0K2JURKEsS5RodG4k4pimpQpRmzAqaup8idxU7Gy\/mlIqIoku11EE0WQQWIksb\/VRNdZDEtXAsua1D+FJduopL+cb7nD\/Ll37vd953nf83zvPDdpCDvfed\/zPO9z3p6n99538uuJJ57Y8luKxy2SAXEuZGE6NbhCAp2XD7FekyZe5S+WPvbYY83v+nj00UedmfRJN8R6dWEmKj7h6qICm2d\/7\/d+L911113ppS99aZPgnnvuSQ8++OBYA\/L5z38+Pf\/5z2+es7rb2KCUAanB6+acMiDOVcifqc7f8Xj961+f3v3ud4\/Nni8IL37xi5ufXbp0qZmMNe0lAzKNIa6f6y9arnpM283Q6jWaeLW6uroFWv6YRf7HjyNHjqS\/\/uu\/ngZ9kD8fWr26khwVn3B1VYL98z\/yIz+SHn744bEGZH12q7uNPcKtGaRDH9ZlQHx4brI888wza18q\/9Vf\/dX0lre8ZWz2PEli9+7dzc9+4zd+I\/3iL\/7i1F3KgEyliOoBNTiqckzdzNDqNZp4tRnY3Nxc+uIXv5guXryYfvzHfzz98R\/\/cTO55n\/\/93\/T13\/91zef+47wGlq9unIeFZ9wdVWC\/fP5H0A\/8IEPbGtALO829ghlQGpwnHPKgDgy\/+STT6bbb7+9yfjbv\/3b6Q1veMPE7HkqVv4IRZ6K9fa3v33qLmVAplJE9YD+oqUqx9TNDKle6yderQe2Z8+eZujFvffem\/7sz\/4s3XLLLc2P\/+u\/\/qv536\/5mq9pPs\/9oz\/6o810vnGTsaYSRfLAkOrVh7Ko+ISrjxps17QxIJZ3G1t046NLhz6sy4D48Nxkefzxx5vxuvn1B3\/wB81FYNIrj767evVq+rmf+7l0\/vz5qbuUAZlKEdUDanBU5Zi6maHUa\/PEqxGwPPQif0k0f+8jj83MvwB1u1f+h5JsUkafA59KENkDQ6lXX9qi4hOuvoqwW9fGgFjebeyQTY4sHfqwLgPiw3OTJY+zyyN48yuPtVtcXJyY\/Ru\/8RtT\/qy2DMj\/azga\/aIjx3KZplKDM6UXHnwI9Ro38WpExNLSUvOdj9Hrox\/9aLr11lvTHXfc0UzDyu+25hHg+R9G8vSbPP8\/T+j75Cc\/mfbu3Qvn0zrgEOpVwkFUfMJVogqbtW0MiOXdxgbV9lGlQx\/WZUB8eG6y5C+fj36xV9uPYJ06dSq9853vnLpLvQMylSKqB9TgqMoxdTPs9Zo08SoDy18i3e7d1s3g77\/\/\/vTGN76x+c\/5XZNf+qVfmsoP2wPs9SrlKyo+4SpVBn59GwNiebfBI5oeUTqczhHiCRkQBIstY+RfLjg7O5vybxpt+yX0\/IuATp8+PTWDDMhUiqgeUIOjKsfUzTDXa7uJV\/Pz82l5eTnNzMxMxTh6IPen\/GX1\/Lnuu+++O+V3S4b2Yq4Xgsuo+IQLoQ5sjDYGxPJug0XTLpp02I6n0qdkQEoZ7Lj+hS98YfO7PdqO4c1TavK0mmkvGZBpDHH9XA2Oqx7TdsNcr+0mXuWf5X\/0mPT63d\/93eZHP\/MzP7PhkR\/6oR9Kf\/mXfznY3xXCXK9pWmvz86j4hKtN9X2f2c6AZOPxnOc8p9mQ1d3GF+2z2aRDH9ZlQHx4Xsty9OjR5nd7tP1FhPlz2d\/2bd82dZcyIFMponpADY6qHFM3w1qvaROv8jCL7V4f\/OAHU\/5lYpsNSP6+yMrKyrZ9aippFR9grReKkqj4hAulEFyc7QzI+l9EaHW3wSFpH0k6bM9VyZMyICXs9Vibf8to\/ss+T6X53Oc+13zRc\/PrJ3\/yJ9N73\/ve5mdPPfVUqywyIK1oonlIDY6mFK02wlivNhOvWoHb9FCe6Z97T\/59IblXPfDAA33CVF3DWC8kIVHxCRdSJZhY2xmQXK\/RgBiruw0GRbco0mE3vvo+LQPSl7me665du9ZMnvnCF76QTpw40czlX\/969NFHU\/7cdn5rM\/8CwvyLCNu8ZEDasMTzjBocTy3a7IStXl0mXq3Hl\/tO\/j5I\/p0gk15vetObUu4n+fWRj3wkff\/3f38biqieYasXmpyo+IQLrZTyeNsZkAcffLD5vUH5ZXW3KUfQPYJ02J2zPitkQPqwVrjmbW97W3rzm9\/cRDl58mQzjjePwvzbv\/3blKde5bc18xje\/PGrce+QjEsvA1JYFOflanDOhBemY6pXycSry5cvp\/z9jnvuuacxFi95yUuaX0j4n\/\/5n+lTn\/pUM4Y3fywrv\/L0rPwRryG+mOplwV9UfMJloZaymNsZkPwdste+9rVr\/6Bhcbcp232\/1dJhP966rpIB6coY4Pk8Yz9\/zOrixYtjo+W5+w8\/\/HAzgabtSwakLVMcz6nBcdSh7S5Y6lU68Sp\/bKvN79R5zWte0\/w+kOc+97ltKaJ6jqVeVqRExSdcVorpH3eaAbnzzjvX7ioWd5v+O++\/Ujrsz12XlTIgXdgCP5snXOV\/Qfinf\/qn9KUvfSnl3z78ile8onkX5AUveEGnbDIgneiq\/rAaXPUSdNoAS71KJl6NAH\/oQx9K73vf+9Lf\/\/3fp\/xRrtx7stHI\/ee7v\/u7m9+U\/vKXv7wTP2wPs9TLipeo+ITLSjH9404zIDny5iEWyLtN\/533Xykd9ueuy0oZkC5sET8rA0JcnDFbU4NTvboyUDrxqmu+IT8f9XyNahIVn3AN69RNGuM9LBRbdysd+lRQBsSHZ\/MsMiDmFEMTqMFB6TQPVrteVhOvzImrlKB2vaxhR8UnXNbKwcaXAcHyaR2N7XzJgFhX3Cm+DIgT0aA0bI0ABEu\/wAlF5Lo4fSdeGWxlMCGjni+9AzIYCW7YaFQ9yoAMS49sOpQBGZZ+Ju5WBmRYhWRrBCj2hAvF5LNxSiZetdmJLhBtWOJ7RueMrybb7ShqvdQ\/pMMSBmRAStgjWisDQlSMFluJ+heScLUofstHSidetUmjC0Qblvie0Tnjq4kMyLBqshPrxdY3ZECCnBkZkGEVkq0RoNgTLhSTqfllgCsrK1sCzs3NNT+bnZ0tTiYDUkxhlQA6Z1Vo7500ar3UP3pLospCNh3KgFSRAT6pDAieU8uIbI0AhVW4MEx6TbzSBQJTL+8oOmfejJfli1ov9Y8yXXivZtOhDIi3AozyyYAYEWsUlq0RoGAKVzmTnhOvdIEor1eNCDpnNVjvnzNqvdQ\/+muixko2HcqA1FCBQU4ZEANSDUOyNQIUVOEqY9J74pUuEGX1qrVa56wW8\/3yRq2X+kc\/PdRaxaZDGZBaSgDnlQEBE2ocjq0RoOAKV38mrSdejduZLhD961Vzpc5ZTfa7545aL\/WP7lqouYJNhzIgNdUAzC0DAiTTIRRbI0BBFq5+THpMvJIB6VcbxlU6Z4xVmbynqPWSAZEOSxiQASlhj2itDAhRMVpsJepfSMLVovhjHvGYeCUD0q82jKt0zhirIgMyrKrsvHqx9Q0ZkCAnRgZkWIVkawQo9oSrO5NeE69kQLrXhnWFzhlrZcbvK2q99A6IdFjCgAxICXtEa2VAiIrRYitR\/0ISrhbFX\/eI58QrGZButWF+WueMuTpb9xa1XjIg0mEJAzIgJewRrZUBISpGi61E\/QtJuFoU\/yuPeE+8kgFpXxv2J3XO2Cu0cX9R6yUDIh2WMCADUsIe0VoZEKJitNhK1L+QhKtF8VNKNSZeyYC0q80QntI5G0KVvrrHqPWSAZEOSxiQASlhj2itDAhRMVpsJepfSMI1vfi1Jl7JgEyvzVCe0DkbSqWe3WfUesmASIclDMiAlLBHtFYGhKgYLbYS9S8k4Zpe\/FoTr2RAptdmKE\/onA2lUjIgw6pU7Hqx9Q0ZkCGejjF7lgEZViHZGgGKPeHansmaE69kQFAqrx9H56x+DbrsIGq99A5IFxXUf5ZNhzIg9TUB2YEMCIRGtyBsjQAFXLgmM1l74pUMCErl9ePonNWvQZcdRK2XDEgXFdR\/lk2HMiD1NQHZgQwIhEa3IGyNAAVcuMYzyTDxSgYEpfL6cXTO6tegyw6i1ksGpIsK6j\/LpkMZkPqagOxABgRCo1sQtkaAAi5cW5lkmXglA4JSef04Omf1a9BlB1HrJQPSRQX1n2XT4U2XL1++MY6W1dXV5j8fPHiwPmvAHUTFdfHixZT\/5NexY8eaPxFeUeslXMNSZ9965YlX58+fT1euXNkC+MCBA+n48eNpZmamGhn5Oyn5dfTo0Wp7sEjct14We7GIGRWfcFmoxS6m+ocdtxaR2c6XDIhFlSvElAGpQHpBSrZGUABlw1Lh2shkPpejf3Va\/5P9+\/enkydPpt27d6Oo7xVHF4hetFVfpHNWvQSdNhC1XuofnWRQ\/WE2HeojWNUlgdmAPoKF4dErCttboSjcwvVVJtkmXo2rsT5CgVK+bxydM1++S7NFrZf6R6kyfNez6VAGxLf+ZtlkQMyoNQnM1ghQIIXrWSYZJ17JgKBUXj+Ozln9GnTZQdR6yYB0UUH9Z9l0KANSXxOQHciAQGh0C8LWCFDAhSsl1olXMiAoldePo3NWvwZddhC1XjIgXVRQ\/1k2HcqA1NcEZAcyIBAa3YKwNQIU8J2Oi3nilQwISuX14+z0c1a\/At12ELVeMiDddFD7aTYdyoDUVgQovwwIiEinMGyNAAV7J+PKE69Onz6dRl\/0W8\/p\/Px8Wl5erjrxSgYEpfL6cXbyOavPfvcdRK2XDEh3LdRcwaZDGZCaagDmlgEBkukQiq0RoCDvZFz5DK6srGyhcm5uLuWfzc7OomiGxdEFAkala6CdfM5ciQYli1ov9Q+QQJzCsOlQBsSp8NZpZECsGcbGZ2sEKHQ7FdcQJl7pHRCUyuvH2annrD7z\/XYQtV4yIP30UGsVmw5lQGopAZxXBgRMqHE4tkaAgrsTcQ1l4pUMCErl9ePsxHNWn\/X+O4haLxmQ\/pqosZJNhzIgNVRgkFMGxIBUw5BsjQAFdafhGtLEKxkQlMrrx9lp56w+42U7iFovGZAyXXivZtOhDIi3AozyyYAYEWsUlq0RoGDuJFzbTbxaWFhIi4uLKFrN4ugCYUataeCddM5MiXQKHrVe6h9OAgKlYdOhDAiosLXDyIDUrkC3\/GyNoNvuJz+9U3ANceKV3gFBqbx+nJ1yzuozjdlB1HrJgGD04RWFTYcyIF6VN84jA2JMMDg8WyNAwdspuIY48UoGBKXy+nF2yjmrzzRmB1HrJQOC0YdXFDYdyoB4Vd44jwyIMcHg8GyNAAVvJ+C6dOlSunDhwhbK9uzZk86dO5f27duHotM8ji4Q5hSbJNgJ58yEuEpBo9ZL\/aOSoHqmZdOhDEjPQrItkwFhq8j2+2FrBCj2ouO66aab0pkzZ9KNGzc2ULZr16509uzZdOjQIRSVLnF0gXChGZ4k+jk7fPgwnLOaAaPWS\/2jpqq652bToQxI9xpSrpABoSzLxE2xNQIUe5FxPfXUU+k973lPun79+ha6lpaW0pEjR1A0usXRBcKNamiiyOcsEyUDApWLWTD1DzNqTQKz9Q0ZEJMy+weVAfHnvCQjWyMowbJ+bVRcH\/\/4x9M73vGOLe98ZOxDmXg1rsa6QKCU7xsn6jkTLl8dlWZT\/yhl0Hc92\/mSAfGtv1k2GRAzak0CszUCFMiIuPLEqzxS98qVK2nv3r0bqJqfn0\/Ly8tpZmYGRaFrHF0gXOmGJYt4zjI5wgWTiEsg9Q8XmmFJ2M6XDAistHUDyYDU5b9rdrZG0HX\/k56PiCufrQ984AMN5PUGZG5uLuWfzc7Oouhzj6MLhDvlkIQRz5kMCEQarkHUP1zpLk7G1jdkQIpLyhFABoSjDm13wdYI2u572nPRcI0mXl27dm2DARnixKtxtdMFYpqiOX8e7ZyNWBYuTr1N2pX6x7DqxXa+ZECGpZ+Ju5UBGVYh2RoBir1IuB555JG1iVfrDchQJ17JgKBUXj9OpHO2nk3hqq+tLjuQAenCVv1n2c6XDEh9TUB2IAMCodEtCFsjQAGPguszn\/lMOnXq1NrEq\/UGZKgTr2RAUCqvHyfKOdvMpHDV11aXHciAdGGr\/rNs50sGpL4mIDuQAYHQ6BaErRGggEfA9fTTT6cTJ06kq1evrtEyMiA\/9VM\/1XwhPcpLF4hhVjLCORvHvHANS4\/qH8OqF9v5kgEZln4m7lYGZFiFZGsEKPaGjitPvDp9+nRaXV3dQEk2IAcOHEjvfve7BzvxSu+AoFReP87Qz9kkBoWrvra67EAGpAtb9Z9lO18yIPU1AdmBDAiERrcgbI0ABXzouPI5WllZ2ULH7t2708mTJ9P3fM\/3oKiiiKMLBEUZOm9i6OdMBqRzySkXqH9QlmXiptj6hgzIsPSjd0CC1IutEaBoHTKu0cSrzVzkiVf5Y1e33HJLuN\/QrAsESvm+cYZ8zrZjSrh8dVSaTf2jlEHf9WznSwbEt\/5m2fQOiBm1JoHZGgEK5FBxrZ94tZ6L0cSrZ555pvnPhw8fRlFFEUcXCIoydN7EUM\/ZNKDCNY0hrp+rf3DVY9pu2M6XDMi0ig3k5zIgAynUV7bJ1ghQ7A0R1+aJV+u5GE28GiKuNjXVBaINS3zPRNWjcPFpbbsdqX8Mq15s50sGZFj6mbhbGZBhFZKtEaDYGxqucROvRlwsLCysTbwaGq629dQFoi1TXM9F1aNwcels2m7UP6YxxPVztvMlA8Klj967kQHpTV2VhWyNAEXCkHBNmniVuZifn0\/Ly8trE6+GhKtLLXWB6MIWz7NR9ShcPBprsxP1jzYs8TzDdr5kQHi0UbQTGZAi+twXszUCFAFDwjVp4tXc3FzKP5udnV2jZUi4utRSF4gubPE8G1WPwsWjsTY7Uf9owxLPM2znSwaERxtFO5EBKaLPfTFbI0ARMBRc2028OnfuXNq3b98GSoaCq2sddYHoyhjH81H1KFwc+mq7C\/WPtkxxPMd2vmRAOHRRvAsZkGIKXQOwNQIU+CHgmjbx6tChQ1voGAKuPjXUBaIPa\/XXRNWjcNXXVpcdqH90Yav+s2znSwakviYgO5ABgdDoFoStEaCAs+NqM\/FqHBfsuPrWTxeIvszVXRdVj8JVV1dds6t\/dGWs7vNs50sGpK4eYNllQGBUugRiawQo0My42k68kgFBqaFeHGYdIliJik+4EOrwiyED4sc1IhPb+ZIBQVSVIIYMCEEROmyBrRF02Pq2j7Li6jLxSgYEpYZ6cVh1iGIkKj7hQinEJ44MiA\/PqCxs50sGBFXZynFkQCoXoGN6tkbQcfsTH2fF1WXilQwISg314rDqEMVIVHzChVKITxwZEB+eUVnYzpcMCKqylePIgFQuQMf0bI2g4\/YHZUC6TrySAUGpoV6cqOdrxGhUfMJV78z0ySwD0oe1emvYzpcMSD0tQDPLgEDpNA\/G1ghQgNlw9Zl4JQOCUkO9OGw6RDMRFZ9woZViG08GxJZfdHS28yUDgq5wpXgyIJWI75mWrRH0hLFlGROuvhOvZEBQaqgXh0mHFixExSdcFmqxiykDYsetRWS28yUDYlHlCjFlQCqQXpCSrREUQNmwlAVXycQrGRCUGurFYdGhFQNR8QmXlWJs4sqA2PBqFZXtfMmAWFXaOa4MiDPhhenYGkEhnLXlDLhKJ17JgKDUUC8Ogw4t0UfFJ1yWqsHHlgHBc2oZke18yYBYVtsxtgyII9mAVGyNAACpCcGAq3TilQwISg314jDo0BJ9VHzCZakafGwZEDynlhHZzpcMiGW1HWPLgDiSDUjF1ggAkCgMCGLilQwISg314kQ9XyNGo+ITrnpnpk9mGZA+rNVbw3a+ZEDqaQGaWQYESqd5MLZGgAJcExdq4pUMCEoN9eLU1KEH6qj4hMtDPbgcMiA4Lj0isZ0vGRCPqjvkkAFxIBmYgq0RoKDVwoWceCUDglJDvTi1dOiFOCo+4fJSECaPDAiGR68obOdLBsSr8sZ5ZECMCQaHZ2sEKHg1cKEnXsmAoNRQL04NHXqijYpPuDxVVJ5LBqScQ88IbOdLBsSz+oa5ZEAMyTUIzdYIUBC9cVlMvJIBQamhXhxvHXojjYpPuLyVVJZPBqSMP+\/VbOdLBsRbAUb5ZECMiDUKy9YIUDC9cVlMvJIBQamhXhxvHXojjYpPuLyVVJZPBqSMP+\/VbOdLBsRbAUb5ZECMiDUKy9YIUDA9cVlNvJIBQamhXhxPHdZAGRWfcNVQU\/+cMiD9uauxku18yYDUUIFBThkQA1INQ7I1AhRUL1yWE69kQFBqqBfHS4e1EEbFJ1y1FNUvrwxIP95qrWI7XzIgtZQAzisDAibUOBxbI0DB9cBlPfFKBgSlhnpxPHRYDx3HL\/y0wB+1blFxyYBYnAK7mGw6lAGxq7VrZBkQV7qLk7E1gmJAXwlgjctj4pUMCEoN9eJY67AesmczR8UnXLWV1S2\/DEg3vmo\/zXa+brp8+fKNcaSsrq42\/\/ngwYO1OYPmj4rr4sWLKf\/Jr2PHjjV\/Iryi1ku4uqszT7w6f\/58unLlypbFBw4cSMePH08zMzPdA7dYEbVeDz30UIP+6NGjLVgYziNR6zWqQFR8wjWcM5Z3qv4xrHqxnS8ZkGHpZ+JuZUCGVUi2RoBizxJX1vjoX3DW73f\/\/v3p5MmTaffu3SgYW+JY4jLbdIvAukC0IInwkah6FC5CsW2zJfWPYdWL7XzpI1jD0s\/E3eojWMMqJNtboSj2rHB5Trwax4UVLhTvfePoIxR9mau7LqoehauurrpmV\/\/oyljd59nOlwxIXT3AssuAwKh0CcTWCFCgLXB5T7ySAUGpoV4cCx3WQ7M1c1R8wsWksul7kQGZzhHTE2znSwaESR0Fe5EBKSCvwlK2RoCiAI2rxsQrGRCUGurFQeuwHpLxmaPiEy42pW2\/HxmQYdWL7XzJgAxLPxN3KwMyrEKyNQIUe0hctSZeyYCg1FAvDlKH9VBMzhwVn3Axqm3ynmRAhlUvtvMlAzIs\/ciABKkXWyNA0YrClSdenT59Oo2+NLd+f\/Pz82l5edls4pUMCEoN9eKgdFgPwfaZo+ITLlbFjd+XDMiw6sV2vmRAhqUfGZAg9WJrBChaUbjyO3orKytbtjU3N5fyz2ZnZ1FbbhUHhatVMseHdIFwJBuYKqoehQsoEodQ6h8OJANTsJ0vGRBgcWuG0kewarLfPTdbI+iOYPwKBK7aE6\/0DghKDfXiIHRYb\/fTM0fFJ1zTa8\/0hAwIUzWm74XtfMmATK\/ZIJ6QARlEmdY2ydYIUOyV4mKYeCUDglJDvTilOqy383aZo+ITrnb1Z3lKBoSlEu32wXa+ZEDa1Y3+KRkQ+hJt2CBbI0CxV4KLZeKVDAhKDfXilOiw3q7bZ46KT7jaa4DhSRkQhiq03wPb+ZIBaV876idlQKjLs2VzbI0AxV5fXEwTr2RAUGqoF6evDuvtuFvmqPiEq5sOaj8tA1K7At3ys50vGZBu9aN9WgaEtjRjN8bWCFDs9cHFNvFKBgSlhnpx+uiw3m67Z46KT7i6a6HmChmQmux3z812vmRAuteQcoUMCGVZJm6KrRGg2OuDi23ilQwISg314vTRYb3dds8cFZ9wdddCzRUyIDXZ756b7XzJgHSvIeUKGRDKssiATCkL48QrGZBhnaWdVK8RVraLBEoxwoVi0ieODIgPz6gsbOdLBgRV2cpxZEAqF6BjerZG0HH7EGPFOvFqJ11odYFAKd83jvqHL9+l2aLWS\/2jVBm+69l0KAPiW3+zbDIgZtSaBGZrBCiQbXExT7ySAUGpoV6ctjqst8OyzFHxCVeZLrxXy4B4M16Wj+18yYCU1ZNmtQwITSlabYStEbTadIuH2uBin3glA9Ki0OSPtNEhOYRttxcVn3ANS5UyIMOqF9v5kgEZln4m7lYGZFiFZGsEKPam4RrCxCsZEJQa6sWZpsN6O8NkjopPuDD68IoiA+LFNCYP2\/mSAcHUtXoUGZDqJei0AbZG0Gnz2zw8DdcQJl7JgKDUUC\/ONB3W2xkmc1R8woXRh1cUGRAvpjF52M6XDAimrtWjyIBUL0GnDbA1gk6b72lAhjLxSgYEpYZ6caKerxGjUfEJV70z0yezDEgf1uqtYTtfMiD1tADNLAMCpdM8GFsjQAGehGtIE69kQFBqqBcn6vmSAamnqZLMUfUoA1KiCv+1bDqUAfHXgElGGRATWs2CsjUCFNBxuIY28UoGBKWGenGini8ZkHqaKskcVY8yICWq8F\/LpkMZEH8NmGSUATGh1SwoWyNAAd2Ma4gTr2RAUGqoFyfq+ZIBqaepksxR9SgDUqIK\/7VsOpQB8deASUYZEBNazYKyNQIU0PW4tkA4awAAIABJREFUhjrxSgYEpYZ6caKeLxmQepoqyRxVjzIgJarwX8umQxkQfw2YZJQBMaHVLChbI0ABXY9rqBOvZEBQaqgXJ+r5kgGpp6mSzFH1KANSogr\/tWw6lAHx14BJRhkQE1rNgrI1AhTQEa78vY8LFy5sCbtnz5507ty5tG\/fPlRKlzhR66ULhIt84Emi6lG44FIxDaj+YUovPDjb+ZIBgZe4TkAZkDq8983K1gj64ti8LuN67LHH0p\/8yZ+kGzdubPjxrl270tmzZ9OhQ4dQ6dziRK2XLhBuEoImiqpH4YLKxDyY+oc5xdAEbOdLBgRa3nrBZEDqcd8nM1sj6INh3Jo\/\/\/M\/T7\/5m7+ZZmdnt\/x4aWkpHTlyBJXKNU7UeukC4SojWLKoehQumERcAql\/uNAMS8J2vmRAYKWtG0gGpC7\/XbOzNYKu+x\/3fJ549drXvjb993\/\/d9q7d++GRxYWFtLi4iIiTZUYEeuVidQFooqcipNG1aNwFUvDNYD6hyvdxcnYzpcMSHFJOQLIgHDUoe0u2BpB231Pem408eoTn\/hE88h6AzI\/P5+Wl5fTzMxMaZpq66PVa0SkLhDVJFWUOKoehatIFu6L1T\/cKS9KyHa+ZECKysmzWAaEpxZtdsLWCNrsebtnRhOvrl27tsGAzM3NpfyzcR\/JKs3puT5avWRAPNWDzxVVj8KF14plRBkQS3bxsdnOlwwIvsZVIsqAVKG9d1K2RtAbSErp0qVLaxOv1huQoU68GsdFpHqtx6cLRIny662NqkfhqqepPpnVP\/qwVm8N2\/mSAamnBWhmGRAonebB2BpBX8CPPPJIOnPmzNrEq5EBufXWWwc78UoGpK8aeNZFOV+TGI2KT7h4zlCbnciAtGGJ5xm28yUDwqONop3IgBTR576YrRH0ISD\/ro9Tp06l69evry0fGZBf+ZVfGezEKxmQPmrgWhPhfG3HaFR8wsV1jqbtRgZkGkNcP2c7XzIgXProvRsZkN7UVVnI1gi6kpAnXp04cSJdvXp1w9JsQO6+++503333dQ1J\/fzQ6zWJXF0gqGU3cXNR9Shcw9Kj+sew6sV2vmRAhqWfibuVARlWIdkaQRf2RhOvVldXtyx7\/vOfn44fP57uuuuuLiHpnx1yvbYjVxcIeumN3WBUPQrXsPSo\/jGserGdLxmQYelHBiRIvdgaQRdaRxOvNq\/JE69e97rXpd27d6fDhw93CUn\/7JDrJQNCL6\/OG4yqR+HqLIWqC2RAqtLfOTnb+ZIB6VxCzgV6B4SzLpN2xdYI2rK3fuLV+jWjiVf5eyH5JQPSltG6z+kCUZf\/vtmH2j+m4RWuaQxx\/Vz9g6se03bDdr5kQKZVbCA\/lwEZSKG+sk22RtCGvc0Tr0Zrdu3atTbxaoi42mCPiksXiDbV53smqh6Fi09r2+1I\/WNY9WI7XzIgw9LPxN3KgAyrkGyNYBp74yZejdYsLS2tTbwaGq5puEc\/j4pLF4i2CuB6LqoehYtLZ9N2o\/4xjSGun7OdLxkQLn303o0MSG\/qqixkawTbkTBp4lVes7CwkBYXF9eWDwlXl8JHxaULRBcV8DwbVY\/CxaOxNjtR\/2jDEs8zbOdLBoRHG0U7kQEpos99MVsjmETAdhOv5ufn0\/LycpqZmZEBcVcQJqEuEBgevaMMpX905UW4ujJW93n1j7r8d83Odr5kQLpWkPR5GRDSwkzYFlsjmMTedhOv8s9mZ2c3LB0Krq5qiYpLF4iuSuB4PqoehYtDX213of7RlimO59jOlwwIhy6KdyEDUkyhawC2RjAO\/LSJV\/v27duybAi4+hQ6Ki5dIPqoof6aqHoUrvra6rID9Y8ubNV\/lu18yYDU1wRkBzIgEBrdgrA1gs3A20y8GkcWO66+BY6KSxeIvoqouy6qHoWrrq66Zlf\/6MpY3efZzpcMSF09wLLLgMCodAnE1gjWg2478UoGxEUqpkl0gTCl1yw4c\/8oAS1cJez5r1X\/8Oe8JCPb+ZIBKakm0VoZEKJitNgKWyMYbbnLxCsZkBaFJn9EFwjyAk3YHmv\/KGVTuEoZ9F2v\/uHLd2k2tvMlA1JaUZL1MiAkhWi5DbZGkLfddeKVDEjLYhM\/pgsEcXG22Rpj\/0AwKVwIFv1iqH\/4cY3IxHa+ZEAQVSWIIQNCUIQOW2BrBHnrXSdeyYB0KDjpo7pAkBZmyrYY+weCSeFCsOgXQ\/3Dj2tEJrbzJQOCqCpBDBkQgiJ02AJbI+gz8UoGpEPBSR\/VBYK0MDIgwyzMhF2z9XsUueofKCZ94rDpUAbEp+7mWWRAzCmGJmBqBH0nXsmAQCVRJZguEFVoL07K1D+KwawLIFxINu1jqX\/Yc4zMwHa+ZECQ1a0YSwakIvk9UrM0gpKJVzIgPQpPtkQXCLKCtNwOS\/9oud3WjwlXa6ooHlT\/oChD602wnS8ZkNal435QBoS7Ppt3x9AISideyYAMS3PjdqsLxDBryNA\/LJgTLgtW7WKqf9hxaxGZ7XzddPny5RvjgK6urjb\/+eDBgxY8VIsZFdfFixdT\/pNfx44da\/5EeEWtV21ceeLV+fPn05UrV7bI5MCBA+n48eNpZmams4Rq4+q84ZYLouJ66KGHGgaOHj3akolhPBa1XiP2o+ITrmGcr9Eu1T+GVS+28yUDMiz9TNytDMiwClm7EWS9jP41ZD1z+\/fvTydPnky7d+\/uRWhtXL023WJRVFy6QLQoPuEjUfUoXIRi22ZL6h\/Dqhfb+dJHsIaln4m71UewhlXImm+FoiZejWO8Ji5LBUTFpY9QWKrGLnZUPQqXnWYsIqt\/WLBqF5PtfMmA2NXaNbIMiCvdxclqNQLkxCsZkGIZVA+gC0T1EvTaQK3+0WuzHRYJVweyCB5V\/yAoQoctsJ0vGZAOxWN+VAaEuTpb91ajEaAnXsmADEtz43arC8Qwa1ijf3gwJVweLONyqH\/guPSIxHa+ZEA8qu6QQwbEgWRgCu9GYDHxSgYEKIhKoXSBqER8YVrv\/lG43dbLhas1VRQPqn9QlKH1JtjOlwxI69JxPygDwl2fzbvzbAR54tXp06fT6Ato6\/cyPz+flpeXe028kgEZlub0Dsjw6zVC4Nk\/PFkTLk+2y3PJgJRz6BmB7XzJgHhW3zCXDIghuQahPRtB1sbKysoWFHNzcyn\/bHZ2FobQExds0y0CRcWlC0SL4hM+ElWPwkUotm22pP4xrHqxnS8ZkGHpZ+JuZUCGVUivRmA58UrvgAxLc3oHZPj10jsgw6yhV7\/3ZkcGxJvxsnxsOpQBKasnzWoZEJpStNqIRyOwnnglA9Kq1NQP6QJBXZ6Jm\/PoHzWYEa4arPfPqf7Rn7saK9nOlwxIDRUY5JQBMSDVMKR1I\/CYeCUDYigQp9C6QDgRDU5j3T\/A220dTrhaU0XxoPoHRRlab4LtfMmAtC4d94MyINz12bw7y0bgNfFKBmRYmhu3W10ghllDy\/5RkxHhqsl+99zqH905q7mC7XzJgNRUAzC3DAiQTIdQVo3Ac+KVDIiDUIxT6AJhTLBReKv+YbTd1mGFqzVVFA+qf1CUofUm2M6XDEjr0nE\/KAPCXR+vd0A8J17JgAxLc3oHZPj1GiFgu0igmBUuFJM+cWRAfHhGZWE7XzIgqMpWjiMDUrkAHdNbNALviVcyIB2LTvi4LhCERWmxJYv+0SKt+SPCZU4xNIH6B5RO82Bs50sGxLzkPglkQHx4RmVBN4IaE69kQFBqqBdHF4h63JdkRvePkr0g1woXkk37WOof9hwjM7CdLxkQZHUrxpIBqUh+j9TIRlBr4pUMSI\/Cky3RBYKsIC23g+wfLVO6PCZcLjTDkqh\/wKh0CcR2vmRAXMpun0QGxJ5jZAZUI6g58UoGBKmIOrF0gajDe2lWVP8o3Qd6vXChGbWNp\/5hyy86Otv5kgFBV7hSPBmQSsT3TItoBLUnXsmA9Cw+0TJdIIiK0WEriP7RIZ3bo8LlRjUkkfoHhEa3IGznSwbErfS2iWRAbPlFR0c0gtoTr2RA0Krwj6cLhD\/niIyI\/oHYBzqGcKEZtY2n\/mHLLzo62\/mSAUFXuFI8GZBKxPdMW9oIGCZeyYD0LD7RMl0giIrRYSul\/aNDKtdHhcuV7uJk6h\/FFLoGYDtfMiCu5bdLJgNix61F5JJGwDLxSgbEQhm+MXWB8OUbla2kf6D2YBFHuCxYtYup\/mHHrUVktvMlA2JR5QoxZUAqkF6Qsm8jYJp4JQNSIACSpbpAkBSi4zb69o+OadwfFy53yosSqn8U0ee+mO18yYC4S8AmoQyIDa9WUfs0AraJVzIgVurwi6sLhB\/XyEx9+gcyv1Us4bJi1iau+ocNr1ZR2c6XDIhVpZ3jyoA4E16YrmsjYJx4JQNSKAKC5bpAEBShxxa69o8eKaosEa4qtPdOqv7Rm7oqC9nOlwxIFRngk8qA4Dm1jNi1ETBOvJIBsVSIT2xdIHx4Rmfp2j\/Q+a3iCZcVszZx1T9seLWKyna+ZECsKu0cVwbEmfDCdF0aAevEKxmQQhEQLNcFgqAIPbbQpX\/0CF9tiXBVo75XYvWPXrRVW8R2vmRAqkkBm1gGBMundbS2jYB54pUMiLVK7OPrAmHPsUWGtv3DIrdlTOGyZBcfW\/0Dz6llRLbzJQNiWW3H2DIgjmQDUrVpBOwTr2RAAEKoHEIXiMoF6Jm+Tf\/oGbrqMuGqSn\/n5OofnSmruoDtfMmAVJUDLrkMCI5Lj0jTGsEQJl7JgHgoxTaHLhC2\/FpFn9Y\/rPJaxxUua4ax8dU\/sHxaR2M7XzIg1hV3ii8D4kQ0KM12jWAoE69kQEBiqBhGF4iK5BekZrtIFEDZsFS4UEz6xFH\/8OEZlYXtfMmAoCpbOY4MSOUCdEy\/XSMYysQrGZCORSd8XBcIwqK02BLbRaLFlls9IlytaKJ5SP2DphStNsJ2vmRAWpWN\/yEZEP4ard\/hpEYwpIlXMiDD0ty43eoCMcwasl0kUCwKF4pJnzjqHz48o7KwnS8ZEFRlK8eRAalcgI7pxzWCoU28kgHpWHTCx3WBICxKiy2xXSRabLnVI8LViiaah9Q\/aErRaiNs50sGpFXZ+B+SAeGv0XbvgAxx4pUMyLA0p3dAhl+vEQK2iwSKWeFCMekTRwbEh2dUFrbzJQOCqmzlODIglQvQMf36RjDUiVcyIB2LTvi4LhCERWmxJbaLRIstt3pEuFrRRPOQ+gdNKVpthO18yYC0Khv\/QzIg\/DUa9w7It3\/7t6fTp0+n1dXVLQDm5+fT8vJympmZGQw4tgaHIi4qLl0gUArxjRNVj8Llq6PSbOofpQz6rmc7XzIgvvU3yyYDYkatSeBRI1hZWUn5z+bX3NxcyjWdnZ01yW8VlK3BoXBGxaULBEohvnGi6lG4fHVUmk39o5RB3\/Vs50sGxLf+ZtlkQMyoNQmcG8FHP\/rR9LGPfWxL\/D179qRz586lffv2meS2DMrW4FBYo+LSBQKlEN84UfUoXL46Ks2m\/lHKoO96tvMlA+Jbf7NsMiBm1JoE\/sM\/\/MOUm\/fNN9+8If6uXbvS2bNn06FDh0zyWgdla3AovFFx6QKBUohvnKh6FC5fHZVmU\/8oZdB3Pdv5kgHxrb9ZNhkQM2rhgfPEq3vvvTf9z\/\/8T9q7d++G+EtLS+nIkSPwnF4B2RocCndUXLpAoBTiGyeqHoXLV0el2dQ\/Shn0Xc92vmRAfOtvlk0GxIxaaODRxKvHH3+8ibvegCwsLKTFxUVoPu9gbA0OhT8qLl0gUArxjRNVj8Llq6PSbOofpQz6rmc7XzIgvvU3yyYDYkYtLPD\/\/d\/\/rU28unbt2gYDMsSJV+OIYWtwqOJFxaULBEohvnGi6lG4fHVUmk39o5RB3\/Vs50sGxLf+ZtlkQMyohQXONRpNvFpvQIY68UoGBCaNaoF0gahGfVFitotEEZh1i4ULxaRPHPUPH55RWdjOlwwIqrKV48iAVC7AlPSXLl1KFy5cWHtqZEBuv\/32wU68kgHh1lyb3ekC0YYlvmfYLhIohoQLxaRPHPUPH55RWdjOlwwIqrKV48iAVC7ANukfeeSRdObMmXTjxo0NBiT\/gsHz588PduKVDAiv5truTBeItkxxPcd2kUCxI1woJn3iqH\/48IzKwna+ZEBQla0cRwakcgEmpM8Tr06dOpWuX7++4Yn8DsjrXve69PrXv55z4z13xdbgesLYsiwqLl0gUArxjRNVj8Llq6PSbOofpQz6rmc7XzIgvvU3yyYDYkZt78CjiVdXr17dEuNlL3tZevWrX50OHz7cOz7jQrYGh+IoKi5dIFAK8Y0TVY\/C5auj0mzqH6UM+q5nO18yIL71N8smA2JGba\/A6ydebQ6QJ1698pWvTPkjWDIgveh1X8TWuFEE6AKBYtI3TlQ9CpevjkqzqX+UMui7nu18yYD41t8smwyIGbW9Aq+feLU+wGji1b\/8y780\/1kGpBe97ovYGjeKAF0gUEz6xomqR+Hy1VFpNvWPUgZ917OdLxkQ3\/qbZZMBMaO2c+DNE69GAfbs2bM28YqtEXQGOWGBcKGY9ImjC4QPz+gsOmdoRm3jRa2X+oetbtDR2XQoA4KucKV4MiCViN+UdtzEq\/zIrl270tmzZ9cmXrE1AhR7woVi0ieOLhA+PKOz6JyhGbWNF7Ve6h+2ukFHZ9OhDAi6wpXiyYBUIn5d2kkTr\/IjS0tL6ciRI2tPszUCFHvChWLSJ44uED48o7PonKEZtY0XtV7qH7a6QUdn06EMCLrCleLJgFQi\/itpt5t4tbCwkBYXFzdskK0RoNgTLhSTPnF0gfDhGZ1F5wzNqG28qPVS\/7DVDTo6mw5vunz58ld\/O9o6tKurq83\/O3jwIJqDqvGi4rp48WLKf\/Lr2LFjzZ8IryHUK0+8yr9Q8MqVK1soP3DgQDp+\/Hgz8Wr9awi4+uhHuPqwVm\/NQw891CQ\/evRovU0YZI6qwxFVUfEJl8FhMAyp\/mFIrkFotvMlA2JQ5BohZUBqsP5szsz96F8W1u9i\/\/796eTJk2n37t1bNsfWCFDsCReKSZ84ukD48IzOonOGZtQ2XtR6qX\/Y6gYdnU2H+ggWusKV4ukjWHWIbzPxatzO2N4KRbEnXCgmfeLoIxQ+PKOz6JyhGbWNF7Ve6h+2ukFHZ9OhDAi6wpXiyYD4E9924pUMiH9t0BnZGjcKny4QKCZ940TVo3D56qg0m\/pHKYO+69nOlwyIb\/3NssmAmFE7NnCXiVcyIL61scjG1rhRGHWBQDHpGyeqHoXLV0el2dQ\/Shn0Xc92vmRAfOtvlk0GxIzaLYG7TrySAfGrjVUmtsaNwqkLBIpJ3zhR9Shcvjoqzab+Ucqg73q28yUD4lt\/s2wyIGbUbgicJ16dPn06jb7Mtf6H8\/PzaXl5ecvEKxkQn9pYZmFr3CisukCgmPSNE1WPwuWro9Js6h+lDPquZztfMiC+9TfLJgNiRu2GwJnnlZWVLcnm5uZS\/tns7GyrjbA1glabbvGQcLUgiegRXSCIitFhKzpnHcgieDRqvdQ\/CMTVYQtsOpQB6VA85kdlQOyr03fild4Bsa+NdQa2xo3CqwsEiknfOFH1KFy+OirNpv5RyqDverbzJQPiW3+zbDIgZtQ2gUsmXsmA2NbGIzpb40Zh1gUCxaRvnKh6FC5fHZVmU\/8oZdB3Pdv5kgHxrb9ZNhkQM2pT6cQrGRC72nhFZmvcKNy6QKCY9I0TVY\/C5auj0mzqH6UM+q5nO18yIL71N8smA2JDLWLilQyITW08o7I1bhR2XSBQTPrGiapH4fLVUWk29Y9SBn3Xs50vGRDf+ptlkwHBU4uaeCUDgq+Nd0S2xo3CrwsEiknfOFH1KFy+OirNpv5RyqDverbzJQPiW3+zbDIgeGpRE69kQPC18Y7I1rhR+HWBQDHpGyeqHoXLV0el2dQ\/Shn0Xc92vmRAfOtvlk0GBEstcuKVDAi2NjWisTVuFAe6QKCY9I0TVY\/C5auj0mzqH6UM+q5nO18yIL71N8smA4KjFj3xSgYEV5takdgaN4oHXSBQTPrGiapH4fLVUWk29Y9SBn3Xs50vGRDf+ptlkwHBUGsx8UoGBFObmlHYGjeKC10gUEz6xomqR+Hy1VFpNvWPUgZ917OdLxkQ3\/qbZZMBKafWauKVDEh5bWpHYGvcKD50gUAx6Rsnqh6Fy1dHpdnUP0oZ9F3Pdr5kQHzrb5ZNBqSMWsuJVzIgZbVhWM3WuFGc6AKBYtI3TlQ9CpevjkqzqX+UMui7nu18yYD41t8smwxIGbWWE69kQMpqw7CarXGjONEFAsWkb5yoehQuXx2VZlP\/KGXQdz3b+ZIB8a2\/WTYZkP7UWk+8kgHpXxuWlWyNG8WLLhAoJn3jRNWjcPnqqDSb+kcpg77r2c6XDIhv\/c2yyYD0o9Zj4pUMSL\/aMK1ia9wobnSBQDHpGyeqHoXLV0el2dQ\/Shn0Xc92vmRAfOtvlk0GpDu1XhOvZEC614ZtBVvjRvGjCwSKSd84UfUoXL46Ks2m\/lHKoO96tvMlA+Jbf7NsMiDdqPWceCUD0q02jE+zNW4UR7pAoJj0jRNVj8Llq6PSbOofpQz6rmc7XzIgvvU3yyYD0p5a74lXMiDta8P6JFvjRvGkCwSKSd84UfUoXL46Ks2m\/lHKoO96tvMlA+Jbf7NsMiDtqfWeeCUD0r42rE+yNW4UT7pAoJj0jRNVj8Llq6PSbOofpQz6rmc7XzIgvvU3yyYD0o7aGhOvZEDa1Yb5KbbGjeJKFwgUk75xoupRuHx1VJpN\/aOUQd\/1bOdLBsS3\/mbZZECmU1tr4pUMyPTasD\/B1rhRfOkCgWLSN05UPQqXr45Ks6l\/lDLou57tfMmA+NbfLJsMyPbU1px4JQNiJnu3wGyNGwVcFwgUk75xoupRuHx1VJpN\/aOUQd\/1bOdLBsS3\/mbZZEAmU1t74pUMiJns3QKzNW4UcF0gUEz6xomqR+Hy1VFpNvWPUgZ917OdLxkQ3\/qbZZMBGU8tw8QrGRAz2bsFZmvcKOC6QKCY9I0TVY\/C5auj0mzqH6UM+q5nO18yIL71N8smAzKeWoaJVzIgZrJ3C8zWuFHAdYFAMekbJ6oehctXR6XZ1D9KGfRdz3a+ZEB862+WTQZkK7UsE69kQMxk7xaYrXGjgOsCgWLSN05UPQqXr45Ks6l\/lDLou57tfMmA+NbfLJsMyEZqmSZeyYCYyd4tMFvjRgHXBQLFpG+cqHoULl8dlWZT\/yhl0Hc92\/mSAfGtv1k2GZCvUss28UoGxEz2boHZGjcKuC4QKCZ940TVo3D56qg0m\/pHKYO+69nOlwyIb\/3NssmAPEst48QrGRAz2bsFZmvcKOC6QKCY9I0TVY\/C5auj0mzqH6UM+q5nO18yIL71N8smA5IS68QrGRAz2bsFZmvcKOC6QKCY9I0TVY\/C5auj0mzqH6UM+q5nO18yIL71N8smA5IS68QrGRAz2bsFZmvcKOC6QKCY9I0TVY\/C5auj0mzqH6UM+q5nO18yIL71N8u20w0I88QrGRAz2bsFZmvcKOC6QKCY9I0TVY\/C5auj0mzqH6UM+q5nO18yIL71N8u2kw0I+8QrGRAz2bsFZmvcKOC6QKCY9I0TVY\/C5auj0mzqH6UM+q5nO18yIL71N8u2Uw3IECZeyYCYyd4tMFvjRgHXBQLFpG+cqHoULl8dlWZT\/yhl0Hc92\/mSAfGtv1m2nWhAhjLxSgbETPZugdkaNwq4LhAoJn3jRNWjcPnqqDSb+kcpg77r2c6XDIhv\/c2y7TQDMqSJVzIgZrJ3C8zWuFHAdYFAMekbJ6oehctXR6XZ1D9KGfRdz3a+ZEB8699kO3HiRHrXu961beb9+\/enp556qvXudpoBGdLEKxmQ1jKmfZCtcaOI0gUCxaRvnKh6FC5fHZVmU\/8oZdB3Pdv5kgHxrX+T7Sd+4ifS+973PhmQFtyPOzBDm3glA9Ki0OSPsDVuFF26QKCY9I0TVY\/C5auj0mzqH6UM+q5nO18yIL71b7L9wA\/8QPrwhz+cFhYW0qlTp8bu4DnPeU76zu\/8zta72ynvgAxx4pUMSGsZ0z7I1rhRROkCgWLSN05UPQqXr45Ks6l\/lDLou57tfMmA+Na\/yfayl70s\/eM\/\/mN661vfmu677z7IDnaCARnqxCsZEIjEqwZha9woMnSBQDHpGyeqHoXLV0el2dQ\/Shn0Xc92vmRAfOvfZJubm0uf\/exnm++B\/PzP\/zxkB9ENyLd+67c23525evXqFr7yO0mLi4sQHr2CsDUCFG7hQjHpE0cXCB+e0Vl0ztCM2saLWi\/1D1vdoKOz6VAGBF3hFvGe+9znpmeeeSa9\/\/3vT695zWtarJj+SGQDkidePfjgg2l1dXULEfPz82l5eTnNzMxMJ4noCbZGgKJGuFBM+sTRBcKHZ3QWnTM0o7bxotZL\/cNWN+jobDqUAUFXeEq8L33pS2nPnj3NUx\/72MfS937v90J2ENmAXLx4MX3qU5\/awlN+Jynjnp2dhXDoGYStEaCwCxeKSZ84ukD48IzOonOGZtQ2XtR6qX\/Y6gYdnU2HMiDoCk+J92\/\/9m\/pBS94QfPUY489lu68886UTUn+0nn+0\/cV1YC8853vTH\/6p3+a9u7du4GabOLOnTuX9u3b15eyquvYGgGKDOFCMekTRxcIH57RWXTO0IzaxotaL\/UPW92go7PpUAYEXeEp8bIAvuM7vqN56o477khPPvlkyh8xyq9v+qZvat4RecMb3pCOHDnSaWcRDUieePXGN74x3bhxY4MB2bVrVzp79mw6dOhQJ46YHmZrBChuhAvFpE8cXSB8eEZn0TlDM2obL2q91D9sdYOOzqZDGRB0hafE++d\/\/uf0Xd\/1Xenpp5\/e9sn85fTf+q3fSjfddFOrHUYzIKOJV\/\/+7\/\/e4F\/\/DsjS0lJng9aKRMeH2BoBCrpwoZj0iaNQlS94AAAUsklEQVQLhA\/P6Cw6Z2hGbeNFrZf6h61u0NHZdCgDgq5wi3h5Ata\/\/uu\/phe96EXpec97XmMy8jshH\/nIR9Kv\/dqvpSeeeKKJ8uu\/\/uvpzW9+c4uIqfkuRP6TX\/l3i0z6\/SKtglV+KJuz0cSra9eubTAgQ5x4NY5OtkaAKrlwoZj0iaMLhA\/P6Cw6Z2hGbeNFrZf6h61u0NHZdHjTAw88cGMcyPxdhfz65m\/+ZjQHVeMhceXvb9x9990Nns9\/\/vPp0UcfHYvt4MGD6fbbb2+F+z\/+4z+aX0D46U9\/Ot18880pvwOwe\/fuZu0f\/dEfTXzn5K\/+6q9S\/pNf+Rcd5j9DfH35y19ODz\/8cMNnfuVpYfmVv2ieP7L2yle+cnATr3S+hqjEjXtG9g0mNj7+8Y8323n5y1\/OtK3ivUSt14iYqPiEq1j6rgHUP1zpLk7Gdr5kQApKut6AvOc970k\/\/dM\/PTba7\/zO76Sf\/dmfbX6WL9j5OwzbvR544IG151dWVtL3fd\/3NY9\/8IMfXLuYb14fxYBkHJ\/85CfX4I0MSDZw99xzT9EX9QtKDV\/K1ghQAIULxaRPHF0gfHhGZ9E5QzNqGy9qvdQ\/bHWDjs6mQ30EC1ThtgakTbpPfOITzfdE8qvt7wqJ8BGsS5cupQsXLmygKH8EK7\/7kUfxDnXi1bias70V2kaXbZ4RrjYs8Tyjj1Dw1KLLTnTOurBV\/9mo9VL\/qK+tLjtg06EMSJfqOT2bfz\/I6KNdf\/EXf5F+8Ad\/cGrmoRuQPPHqzJkzzcSr9a8vfvGLzW+LR\/3CxqlEOj3A1ghQsIULxaRPHF0gfHhGZ9E5QzNqGy9qvdQ\/bHWDjs6mQxkQdIUB8fIX0d\/61rc2kT73uc+l2267bWrUIRuQ0cSr69evb8GZv\/ORxxYfPnx4KgdDeoCtEaC4Ey4Ukz5xdIHw4RmdRecMzahtvKj1Uv+w1Q06OpsOZUDQFZ4SLxuK7b6Qnidg5Qt3\/jJ6\/mLo3\/zN37Ta4VANyPqJV5uB5olXL33pS5v\/LAPSSgbVH2JrcChCouLSBQKlEN84UfUoXL46Ks2m\/lHKoO96tvMlA+Jb\/\/TDP\/zDKX+v4dWvfnW66667miljMzMzKb8L8Hd\/93fpbW97W7p69Wr6uq\/7usZ85IlYbV5DNCD5FzCePn06ra6uboE4Pz+flpeX0z\/8wz\/IgLQRAMkzbA0ORUtUXLpAoBTiGyeqHoXLV0el2dQ\/Shn0Xc92vmRAfOufXvWqVzXTrLZ7fcM3fEN673vfm17xile03t0QDUjec57ytfk1NzfX\/E6T\/OVztgPTuiBTHhQuFJM+caLWSxcIH\/2gs0TVo3ChlWIbT\/3Dll90dLbzJQOCrvCUePndjd\/\/\/d9PH\/7wh5t\/+c\/\/P3\/x+tZbb00veclLGtNx7733pltuuaXTzoZmQMZNvMqA9+zZk86dO7c28YrtwHQqyjYPCxeKSZ84UeulC4SPftBZoupRuNBKsY2n\/mHLLzo62\/mSAUFXuFK8IRmQSROv8u9HOXv2bDp06NAai2wHBlVe4UIx6RMnar10gfDRDzpLVD0KF1optvHUP2z5RUdnO18yIOgKV4o3FAOy3cSrpaWldOTIkQ0Msh0YVHmFC8WkT5yo9dIFwkc\/6CxR9ShcaKXYxlP\/sOUXHZ3tfMmAoCtcKd4QDMi0iVeLi4tb2GM7MKjyCheKSZ84UeulC4SPftBZoupRuNBKsY2n\/mHLLzo62\/mSAUFXuFI8dgPSZuJVnga2+cV2YFDlFS4Ukz5xotZLFwgf\/aCzRNWjcKGVYhtP\/cOWX3R0tvMlA4KucKV47AakzcSrcdSxHRhUeYULxaRPnKj10gXCRz\/oLFH1KFxopdjGU\/+w5Rcdne18yYCgK1wpHrMBaTvxSgakkniAadkaHApaVFy6QKAU4hsnqh6Fy1dHpdnUP0oZ9F3Pdr5kQHzrb5aN1YB0mXglA2ImD7fAbA0OBTwqLl0gUArxjRNVj8Llq6PSbOofpQz6rmc7XzIgvvU3y8ZoQLpOvJIBMZOHW2C2BocCHhWXLhAohfjGiapH4fLVUWk29Y9SBn3Xs50vGRDf+ptlYzMgfSZeyYCYycMtMFuDQwGPiksXCJRCfONE1aNw+eqoNJv6RymDvuvZzpcMiG\/9zbIxGZC+E69kQMzk4RaYrcGhgEfFpQsESiG+caLqUbh8dVSaTf2jlEHf9WznSwbEt\/5m2ZgMSN+JVzIgZvJwC8zW4FDAo+LSBQKlEN84UfUoXL46Ks2m\/lHKoO96tvMlA+Jbf7NsLAakZOKVDIiZPNwCszU4FPCouHSBQCnEN05UPQqXr45Ks6l\/lDLou57tfMmA+NbfLBuDASmdeCUDYiYPt8BsDQ4FPCouXSBQCvGNE1WPwuWro9Js6h+lDPquZztfMiC+9TfLVtuAICZeyYCYycMtMFuDQwGPiksXCJRCfONE1aNw+eqoNJv6RymDvuvZzpcMiG\/9zbLVNCCoiVcyIGbycAvM1uBQwKPi0gUCpRDfOFH1KFy+OirNpv5RyqDverbzJQPiW3+zbLUMCHLilQyImTzcArM1OBTwqLh0gUApxDdOVD0Kl6+OSrOpf5Qy6Lue7XzJgPjW3yxbLQOCnHglA2ImD7fAbA0OBTwqLl0gUArxjRNVj8Llq6PSbOofpQz6rmc7XzIgvvU3y1bDgKAnXsmAmMnDLTBbg0MBj4pLFwiUQnzjRNWjcPnqqDSb+kcpg77r2c6XDIhv\/c2yeRsQi4lXMiBm8nALzNbgUMCj4tIFAqUQ3zhR9Shcvjoqzab+Ucqg73q28yUD4lt\/s2yeBsRq4pUMiJk83AKzNTgU8Ki4dIFAKcQ3TlQ9CpevjkqzqX+UMui7nu18yYD41t8sm5cBsZx4JQNiJg+3wGwNDgU8Ki5dIFAK8Y0TVY\/C5auj0mzqH6UM+q5nO18yIL71N8vmYUCsJ17JgJjJwy0wW4NDAY+KSxcIlEJ840TVo3D56qg0m\/pHKYO+69nOlwyIb\/3NsnkYEOuJVzIgZvJwC8zW4FDAo+LSBQKlEN84UfUoXL46Ks2m\/lHKoO96tvMlA+Jbf7Ns1gbEY+KVDIiZPNwCszU4FPCouHSBQCnEN05UPQqXr45Ks6l\/lDLou57tfMmA+NbfLJulAfGaeCUDYiYPt8BsDQ4FPCouXSBQCvGNE1WPwuWro9Js6h+lDPquZztfMiC+9TfLZmVAPCdeyYCYycMtMFuDQwGPiksXCJRCfONE1aNw+eqoNJv6RymDvuvZzpcMiG\/9zbJZGBDviVcyIGbycAvM1uBQwKPi0gUCpRDfOFH1KFy+OirNpv5RyqDverbzJQPiW3+zbGgDUmPilQyImTzcArM1OBTwqLh0gUApxDdOVD0Kl6+OSrOpf5Qy6Lue7XzJgPjW3ywb2oDUmHglA2ImD7fAbA0OBTwqLl0gUArxjRNVj8Llq6PSbOofpQz6rmc7XzIgvvU3y4Y0ILUmXsmAmMnDLTBbg0MBj4pLFwiUQnzjRNWjcPnqqDSb+kcpg77r2c6XDIhv\/c2yoQxIzYlXMiBm8nALzNbgUMCj4tIFAqUQ3zhR9Shcvjoqzab+Ucqg73q28yUD4lt\/s2wIA1J74pUMiJk83AKzNTgU8Ki4dIFAKcQ3TlQ9CpevjkqzqX+UMui7nu18yYD41t8sW6kBYZh4JQNiJg+3wGwNDgU8Ki5dIFAK8Y0TVY\/C5auj0mzqH6UM+q5nO18yIL71N8tWYkBYJl7JgJjJwy0wW4NDAY+KSxcIlEJ840TVo3D56qg0m\/pHKYO+69nOlwyIb\/3NspUYEJaJVzIgZvJwC8zW4FDAo+LSBQKlEN84UfUoXL46Ks2m\/lHKoO96tvMlA+Jbf7NsfQ0I08QrGRAzebgFZmtwKOBRcekCgVKIb5yoehQuXx2VZlP\/KGXQdz3b+ZIB8a2\/WbY+BoRt4pUMiJk83AKzNTgU8Ki4dIFAKcQ3TlQ9CpevjkqzqX+UMui7nu18yYD41t8sW1cDwjjxSgbETB5ugdkaHAp4VFy6QKAU4hsnqh6Fy1dHpdnUP0oZ9F3Pdr5kQHzrb5atiwFhnXglA2ImD7fAbA0OBTwqLl0gUArxjRNVj8Llq6PSbOofpQz6rmc7XzIgvvU3y9bWgDBPvJIBMZOHW2C2BocCHhWXLhAohfjGiapH4fLVUWk29Y9SBn3Xs50vGRDf+ptla2tAmCdeyYCYycMtMFuDQwGPiksXCJRCfONE1aNw+eqoNJv6RymDvuvZzpcMiG\/9zbK1MSDbTby6\/\/770\/79+8321zcw24Hpi2PzOuFCMekTJ2q9dIHw0Q86S1Q9ChdaKbbx1D9s+UVHZztfMiDoCleKN82ADGHild4BqSQeYFq2BoeCFhWXLhAohfjGiapH4fLVUWk29Y9SBn3Xs50vGRDf+ptl286ADGXilQyImTzcArM1OBTwqLh0gUApxDdOVD0Kl6+OSrOpf5Qy6Lue7XzJgPjW3yzbJAMypIlXMiBm8nALzNbgUMCj4tIFAqUQ3zhR9Shcvjoqzab+Ucqg73q283XT5cuXb4yjYHV1tfnPBw8e9GXIOFtUXBcvXkz5T34dO3as+ZMnXp0\/fz5duXJlC6sHDhxIx48fTzMzM8aMl4WPWi\/hKtOF9+qo9XrooYcaKo8ePepNqWm+qPUakRYVn3CZHgt4cPUPOKWmAdnOlwyIabn9go8zIPm\/jRzv+p3s27cvLS0tpd27d\/ttsGcmtgPTE8aWZcKFYtInTtR66QLhox90lqh6FC60UmzjqX\/Y8ouOzna+9BEsdIUrxdv8Eaxv+ZZvSRcuXNiymz179iTWiVfjqGN7yxBVXuFCMekTJ2q99BEKH\/2gs0TVo3ChlWIbT\/3Dll90dLbzJQOCrnCleOsNyI\/92I+lxx9\/PN24sfHTdbt27Upnz55Nhw4dqrTL7mnZDkx3BONXCBeKSZ84UeulC4SPftBZoupRuNBKsY2n\/mHLLzo62\/mSAUFXuFK8kQH58pe\/nJ73vOelO+64Y8tO8seujhw5UmmH\/dKyHZh+KLauEi4Ukz5xotZLFwgf\/aCzRNWjcKGVYhtP\/cOWX3R0tvMlA4KucKV42YC84x3vSF\/4whfSC1\/4wpQ\/grX+tbCwkBYXFyvtrn9atgPTH8nGlcKFYtInTtR66QLhox90lqh6FC60UmzjqX\/Y8ouOzna+ZEDQFa4U7+1vf3u67777mslXL3rRizYYkPn5+bS8vEw\/8WocdWwHBlVe4UIx6RMnar10gfDRDzpLVD0KF1optvHUP2z5RUdnO18yIOgKV4r3qle9Kn3oQx9qsq83ILfddlvzpfPZ2dlKOytLy3ZgytB8dbVwoZj0iRO1XrpA+OgHnSWqHoULrRTbeOoftvyio7OdLxkQdIUrxLt06VJ6y1ve0nzxfL0BGdrEK70DUkE84JRsDQ4FLyouXSBQCvGNE1WPwuWro9Js6h+lDPquZztfMiC+9Ydne+SRR9KZM2ca87HegLz4xS8e3MQrGRC4PNwDsjU4FAFRcekCgVKIb5yoehQuXx2VZlP\/KGXQdz3b+ZIB8a0\/NNtnPvOZdOrUqXT9+vX06U9\/eoMBede73jW4iVcyIFB5VAnG1uBQJETFpQsESiG+caLqUbh8dVSaTf2jlEHf9WznSwbEt\/6wbE8\/\/XQ6ceJEunr1ahNzvQHJ3wd5\/\/vfD8tVMxDbgUFxIVwoJn3iRK2XLhA++kFniapH4UIrxTae+octv+jobOdLBgRdYYd4edLV6dOn0+rq6lq2kQH52q\/92vTLv\/zL6Rd+4RccdmKfgu3AoBALF4pJnzhR66ULhI9+0Fmi6lG40Eqxjaf+YcsvOjrb+ZIBQVfYIV7+nR8rKysbMmUD8sQTT6Sbb745velNb2o+mhXhxXZgUJwKF4pJnzhR66ULhI9+0Fmi6lG40Eqxjaf+YcsvOjrb+ZIBQVfYOF6eeHXhwoUtWT772c+mJ598Mu3atasxHzIgxoUoDM\/WCArhrC0XLhSTPnF0gfDhGZ1F5wzNqG28qPVS\/7DVDTo6mw5lQNAVNow3mnh148aNDVmy6bjzzjvTxYsXm\/8uA2JYBFBotkYAgpWEC8WkTxxdIHx4RmfROUMzahsvar3UP2x1g47OpkMZEHSFjeKtn3i1OcXS0lLK5iR\/NEsGxKgA4LBsjQAFT7hQTPrE0QXCh2d0Fp0zNKO28aLWS\/3DVjfo6Gw6lAFBV9gg3uaJV+tTLCwspMXFxcZ8yIAYkG8Ukq0RoGAKF4pJnzi6QPjwjM6ic4Zm1DZe1Hqpf9jqBh2dTYcyIOgKg+ONm3g1SjE\/P5+Wl5fTzMyMDAiYd+twbI0AhVe4UEz6xNEFwodndBadMzSjtvGi1kv9w1Y36OhsOpQBQVcYHG\/cxKuc4rbbbkv3339\/mp2dbTLqHRAw8cbh2BoBCq5woZj0iaMLhA\/P6Cw6Z2hGbeNFrZf6h61u0NHZdCgDgq4wMN6kiVd79uxpzMf+\/fvXssmAAIl3CMXWCFCQhQvFpE8cXSB8eEZn0TlDM2obL2q91D9sdYOOzqZDGRB0hUHxtpt4dfbs2XTo0KENmWRAQMQ7hWFrBCjYwoVi0ieOLhA+PKOz6JyhGbWNF7Ve6h+2ukFHZ9OhDAi6woB40yZeHTlyZEsWGRAA8Y4h2BoBCrpwoZj0iaMLhA\/P6Cw6Z2hGbeNFrZf6h61u0NHZdCgDgq5wYbw2E6\/GpZABKSTeeTlbI0DBFy4Ukz5xdIHw4RmdRecMzahtvKj1Uv+w1Q06OpsOZUDQFS6I13bilQxIAckkS9kaAYoW4UIx6RNHFwgfntFZdM7QjNrGi1ov9Q9b3aCjs+lQBgRd4YJ4bSdeyYAUkEyylK0RoGgRLhSTPnF0gfDhGZ1F5wzNqG28qPVS\/7DVDTo6mw5lQNAV7hmvy8QrGZCeJBMtY2sEKGqEC8WkTxxdIHx4RmfROUMzahsvar3UP2x1g47OpkMZEHSFe8TrOvFKBqQHyWRL2BoBih7hQjHpE0cXCB+e0Vl0ztCM2saLWi\/1D1vdoKOz6fD\/A+4Uam6j4vLwAAAAAElFTkSuQmCC)\n\n到\n\n![](data:image\/png;base64,iVBORw0KGgoAAAANSUhEUgAAAyAAAAMgCAYAAADbcAZoAAAgAElEQVR4Xuy9DbSdVXUuPE+Sc5JgyAnhID8hQaJHTUUrBA1e01qqpRf\/6uXyc3uNcGut7ecd1S+Sn34316\/ejgzbAG1S1Drsp1djQ6DVMlq91UShaI2FaMBgwVgUECX8CSEJCcnJ3\/nGu5N92P\/vet93rrmetfazOzKsyXrnnM8z55p7Pa695x4YHx8flw6vu+++u\/a3Cxcu7PTP0f5dqrj+\/M\/\/XLI\/2evaa6+t\/UnhlWq+iCuu6kw1X3\/9139dS8T73\/\/+uBKSE22q+arDDonvm\/\/nJ7L9zp1NGRgcmizvW3mRTJ02pVIdhcRVKXCDety1a5csXbpUsv9sfV111VWyZMkSnxA62mb\/MKe8kkO0\/TVAAVIpnzAPU4DApMIpELRG4BS0wyLiciAJaAkPEEDJKBBKqH22b++YfO6GrXL0aPP\/bvm6N82TN15ybgEEnZeGwlU5cM8C5PDhw7Js2TJ56KGH2jwtWrRIVq1aJQMDA75htNln\/zCnvJJDtP1FAVIpnTgPU4Dg5MIlErRG4BKzyxricmEJZw0PEDi5KBJJqH3m8\/Yjwx8KVxHuy6ytimvNmjWyZcuWNtfz58+X66+\/XoaGhsqEVfkZ9o\/KFJoaqFqH2sFSgGgzGsgeBUgg4ku6RWsEJWG0PUZcWkza2OEBwoZnbS8h9pnv2w8KkM5Vcsstt8hNN93U9o\/Dw8Ny4403yuzZs7XLy9ke+4czVRALQ\/SNXsApQCDKonoQFCDVObS0gNYItLATlxaTNnZ4gLDhWdtLiH3m+\/aDAqS9SrZu3SqrV69u+4fBwUHJbkVGR0e1S6uQPfaPQnQFXxyib1CANDCAlgCtiqQA0WLSxk6qdUhcNvWj5YUHCC0mbe1Y7zOL2w8KkOYayr7vsWLFChkbG2srrpUrV8rixYtti66DN\/aP4CkoFIB138gLjjcgeQxF8u8UIJEk6kSYaI1Aiz3i0mLSxg4PEDY8a3ux3mcWtx8UIC9UCeLEq041zP6hvbP92rPuG3loKEDyGIrk3ylAIkkUBUhciUo8XzxARFmOpl\/Wtrr9oAA5XouoE68oQOLsFY1RU4AEziFaArTooADRYtLGTqp1SFw29aPlhQJEi0lbO5b7zOr2gwLkeA2hTryiALHd4z68WfYNl\/h5A+LCUgRrKEAiSFJDiGiNQIs94tJi0sYOBYgNz9perPaZ5e0HBYgI8sQrChDtXWxvz6pvuCKjAHFlCnwdBQh4glrCQ2sEWuwRlxaTNnYoQGx41vZitc8sbz\/6XYCgT7yiANHexfb2rPqGKzIKEFemwNdRgIAniAIkrgT1Sb4oQOIsS4uDhPXtRz8LkBgmXlGAxNkrGqO26BtFWKIAKcIW8FoKEODkdAgNrRFosUdcWkza2KEAseFZ24vFPrO+\/ehXARLLxCsKEO1dbG\/Pom8UQUUBUoQt4LUUIMDJoQCJKzl9lC8KkDhL0\/dBIsTtRz8KkJgmXlGAxNkroG9Atm3bNt6J1h07dtT+esGCBfGz3oAgVVwbNmyQ7E\/2WrJkSe1PCq9U80VccVVnqvm69dZba4m47LLL4kpITrSp5qsO2ze+++7aLT\/dsb+J5clTBuQtV50hg0OTvNWKb1zeAi9Zj+vXr5ft27e3PT1nzhz50Ic+JNkvniO\/2D+Qs9MeG9r+GqAAiauAukVLARJXHtEagRZ7xKXFpI0dHiBseNb24nOfHXz+qNz+xSdk\/Fhz1C97zcnyyoUztaE02fOJy2vgJQTI5s2bZdOmTW1PzpgxQ5YvXy4zZ\/rlWoMP9g8NFu1soO0vfgTLLvdePfEjWF7pVTfu+yMU6gE7GiQuR6JAlvEjWCCJKBiGz30W4rsfdfg+cRWkWHV5K64YJ151IoT9Q7VMvBtD218UIN5TbuOAAsSGZy0vaI2AuHozkGq+eIDQqnxbO77qMdR3P\/pJgMQ68YoCxHaP+\/Dmq2+UjZUCpCxzYM9RgIAlJCcctEagxR5xaTFpY4cCxIZnbS++9lnI24+MI1+4tPkvaq+O69xzz5WlS5dKNvmq9XXVVVdF991N9o+ilRB2Pdr+ogAJWw9q3ilA1Kg0MYTWCLRAE5cWkzZ2eICw4Vnbi499Fvr2I3UBcuTIEdm4caNkNyCtr0WLFsmqVatkYGBAu1S82mP\/8EqvunEffaNKkBQgVdgDepYCBCgZDqGgNQKHkJ2WEJcTTTCLeICASUWhQHzss9C3H6kLkGzi1cMPP9yW5\/nz58v1118vQ0NDhWoAYTH7B0IW3GPw0TfcvbevpACpwh7QsxQgQMlwCAWtETiE7LSEuJxoglnEAwRMKgoFor3PEG4\/UhYgH\/vYx2oTr4aHh5vynP33G2+8UWbPnl0o\/yiL2T9QMuEWh3bfcPPafRUFSFUGQZ6nAAFJhGMYaI3AMezcZcSVSxHUAh4goNLhHIz2PkO4\/UhVgGQTr7KxutmrUYBkv\/GxZs0aGR0ddc472kL2D7SM9I5Hu29URU8BUpVBkOcpQEAS4RgGWiNwDDt3GXHlUgS1gAcIqHQ4B6O5z1BuP1IUIPWJV0899VSbAFm5cqUsXrzYOeeIC9k\/ELPSPSbNvqGBnAJEg0UAGxQgAEkoEAJaIygQes+lxKXFpI0dHiBseNb2ornPUG4\/UhMg2aSr+sSrPXv2NAmQGCdedaph9g\/tne3Xnmbf0IiUAkSDRQAbFCAASSgQAlojKBA6BYgWWQB2eIAASEKJELT6B9LtR0oC5PDhw7Js2bKJiVeNAiTWiVcUICU2KtgjWn1DCxYFiBaTge1QgAROQEH3aI2gYPhdlxOXFpM2dihAbHjW9qK1z5BuP1ISINl3O7Zs2TKR9roAOf\/886OdeEUBor2L7e1p9Q2tyClAtJgMbIcCJHACCrpHawQFw6cA0SIssB0KkMAJKOleo3+g3X6kIkBuueUWuemmm5oymwmQGTNmyIYNG6KdeEUBUnKzAj2m0Tc04VCAaLIZ0BYFSEDyS7hGawQlIHR8hLi0mLSxQwFiw7O2F419hnb7kYIAySZerV69ui3d+\/fvlw9+8IPyrne9S7sUgtpj\/whKf2HnGn2jsNMeD1CAaLIZ0BYFSEDyS7hGawQlIFCAaJEW0A4PEAHJr+C6av9AvP2IXYDUJ16NjY21ZTYTHq997Wtl4cKFFbKO9yj7B15OekVUtW9oo6UA0WY0kD0KkEDEl3SL1ghKwmh7jLi0mLSxwwOEDc\/aXqruM8Tbj5gFSOPEq9ZcZxOvFixYUPtrChDtneDHXtX95Seq6lbRcFGAVM8phAUKEIg0OAeB1gicA89ZSFxaTNrYoQCx4VnbS5V9hnr7EasAaZ141Zjr+sSre+65hwJEexN4tFdlf3kMq7JpNFwUIJVTimGAAgQjD65RoDUC17jz1hFXHkNY\/04BgpUP12iq7DPU249YBUjrxKt6DufPnz8x8apKvlxrIsQ69o8QrJf3iVaHFCDlcwn1JAUIVDpyg0FrBLkBOy4gLkeiQJbxAAGSiIJhlN1nyLcfMQqQThOvMhzDw8Ny4403Tky8KpuvgmVhvpz9w5zySg7R6pACpFI6cR6mAMHJhUskaI3AJWaXNcTlwhLOGh4gcHJRJJKy+wz59iM2AdJt4tXg4KBktyKjo6MTKS2bryI1EWIt+0cI1sv7RKtDCpDyuYR6kgIEKh25waA1gtyAHRcQlyNRIMt4gABJRMEwyuwz9NuPmARIr4lXK1eulMWLFzdltEy+CpZEkOXsH0FoL+0UrQ4pQEqnEutBChCsfORFg9YI8uJ1\/XficmUKYx0PEBh5KBpFmX2GfvsRiwDJm3i1ZMmStnSWyVfRmgixnv0jBOvlfaLVIQVI+VxCPUkBApWO3GDQGkFuwI4LiMuRKJBlPECAJKJgGEX3WQy3HzEIEJeJVwMDAxQgBesZbXnR\/YUWf7d40HBRgMRSOTlxUoDElUi0RqDFHnFpMWljhwLEhmdtL0X3WQy3HzEIEJeJV51yXTRf2vXiyx77hy9m\/dhFq0MKED95NrdKAWJOeSWHaI2gEpiGh4lLi0kbOzxA2PCs7aXIPovl9gNdgLhOvKIA0a52e3tF9pd9dOU9ouGiACmfS6gnKUCg0pEbDFojyA3YcQFxORIFsowCBCQRBcMoss9iuf1AFiBFJl5RgBQsZsDlRfYXYPhdQ0LDRQESU\/X0iJUCJK5EojUCLfaIS4tJGzsUIDY8a3tx3Wcx3X6gCpCiE68oQLSr3d6e6\/6yj6yaRzRcFCDV8gnzNAUITCqcAkFrBE5BOywiLgeSgJZQgAAlo0AorvssptsPRAFSZuIVBUiBQgZd6rq\/QMPnDQhqYlItLAoQ1IrrHFeqdUhccdUhBUhc+apH67LPYrv9QBMgZSdeUYDEuacao3bZXzGiRMPFG5AYq6hDzBQgcSUSrRFosUdcWkza2KEAseFZ24vLPovt9gNNgJSdeEUBol3t9vZc9pd9VNU9ouGiAKmeUwgLFCAQaXAOAq0ROAees5C4tJi0sUMBYsOztpe8fRbj7QeSAKky8YoCRLva7e3l7S\/7iHQ8ouGiANHJa3ArFCDBU1AoALRGUCj4HouJS4tJGzsUIDY8a3vJ22cx3n6gCJCqE68oQLSr3d5e3v6yj0jHIxouChCdvAa3QgESPAWFAkBrBIWCpwDRoiu4HQqQ4CkoFUCv\/hHr7QeCANGYeEUBUqqkoR7i+7NNOihAbHj27oUCxDvFqg7Y4FTp9G4s1XxRgHgvHS8OetVjrLcfoQWI1sQrChAvJW9qNNV+j4aLAsS0rP05owDxx60Py2iNQAsjcWkxaWOHAsSGZ20v3fZZzLcfIQWI5sQrChDtare3x\/cxG84pQGx49u6FAsQ7xaoO2OBU6fRuLNV8UYB4Lx0vDrrVY8y3HyEFiObEKwoQLyVvajTVfo+GiwLEtKz9OaMA8cetD8tojUALI3FpMWljhwLEhmdtL532Wey3H6EEiPbEKwoQ7Wq3t8f3MRvOKUBsePbuhQLEO8WqDtjgVOn0bizVfFGAeC8dLw461WPstx8hBIiPiVcUIF5K3tRoqv0eDRcFiGlZ+3NGAeKPWx+W0RqBFkbi0mLSxg4FiA3P2l5a91kKtx\/WAsTXxCsKEO1qt7fH9zEbzilAbHj27oUCxDvFqg7Y4FTp9G4s1XxRgHgvHS8OWusxhdsPSwHic+IVBYiXkjc1mmq\/R8NFAWJa1v6cUYD449aHZbRGoIWRuLSYtLFDAWLDs7aXxn2Wyu2HlQDxPfGKAkS72u3t8X3MhnMKEBuevXuhAPFOsaoDNjhVOr0bSzVfFCDeS8eLg8Z6TOX2w0qA+J54RQHipeRNjaba79FwUYCYlrU\/ZxQg\/rj1YRmtEWhhJC4tJm3sUIDY8Kztpb7PXjF6nnzuhq1y9Oh4k4vXvWmevPGSc7Xderfnu39YTLyiAPFeJt4d+K5D7wC6OEDDRQESqhKU\/VKAKBPq2RxaI9CCS1xaTNrYoQCx4VnbS32fPff4sGy\/c2eT+cGhyfK+lRfJ1GlTtN16t+ezf1hNvKIA8V4m3h34rEPvwfdwgIaLAiRkNSj6pgBRJNPAFFoj0IJMXFpM2tihALHhWdtLts8OPn9U7vnGwWRuPzKOfPUPy4lXFCDa1W5vz1cd2iNp9oiGiwIkdEUo+acAUSLSyAxaI9CCTVxaTNrYoQCx4VnbS7bP7rtrtzz7WPMtR8y3H74EiPXEKwoQ7Wq3t8f3MRvOKUBsePbuhQLEO8WqDtjgVOn0bizVfFGAeC8dLw6+8+3vyu1ffEJmnjzcZD\/W737UQWjvsxATryhAvJS8qVHtOjQNvoczNFwUICiVUTEOCpCKBBo\/jtYItOATlxaTNnYoQGx41vay\/pO3y0937Jfh4RcESOy3Hz5uQEJMvKIA0a52e3t8H7PhnALEhmfvXihAvFOs6oANTpVO78ZSzRcFiPfSUXeQ\/e7HX\/zPzTJ+TJoESOy3H9oCJNTEKwoQ9ZI3N5hqv0fDRQFiXtp+HFKA+OHVl1W0RqCFk7i0mLSxQwFiw7Oml+x3P7616Yc1k\/UbkBRuPzQFSMiJVxQgmtUexhbfx2x4pwCx4dm7FwoQ7xSrOmCDU6XTu7FU80UB4r10VB3Uf\/V8167dTQIkhdsPLQESeuIVBYhqyQcxlmq\/R8NFARKkvPWdUoDoc+rTIloj0MJKXFpM2tihALHhWctL\/VfP9+zZMyFAUrn90BAgCBOvKEC0qj2cHb6P2XBPAWLDs3cvFCDeKVZ1wAanSqd3Y6nmiwLEe+moOajffmS\/et4oQFK5\/agqQFAmXlGAqJV8MEOp9ns0XAPbtm0b75TlHTt21P56wYIFwYrAh+NUcW3YsEGyP9lryZIltT8pvFLNF3HFVZ2p5uvWW2+tJeKyyy6LKyE50aaYr+x3P7LJV9nrueeeq\/3nrFNmyluuOkMGhyYlkb8qeVu\/fr1s3769jYc5c+bIhz70IRkcHAzGURVcwYJ2cMz+4UAS0BK0OqQAASqOKqFQgFRhz\/5ZtEagxQBxaTFpY4cHCBueq3rJfvU8+92PbPJVowA5\/41nySsXzqxqHub5sv1j8+bNsmnTpjYcM2bMkOXLl8vMmWE5KosLJjFdAmH\/QM9Qc3xodciPYMVVP12j5Uew4kok2lWoFnvEpcWkjR1+BMuG56pe6t\/9qNvJPoI1ecqALP+zS2XqtOZfQ6\/qK+TzZfoH2sSrTvyVwRUyD66+2T9cmcJYh1aHFCAYdVE5CgqQyhSaGkBrBFrgiUuLSRs7PEDY8FzFS+N3PxoFyMtec7K8+\/0XVzEN92zR\/oE48YoCBK6sCgdUtA4LOwj0ABouCpBAhaDtlgJEm1G\/9tAagRZa4tJi0sYOBYgNz1W8tN5+ZLb27d9b++7HRW94XRXTcM8W6R+oE68oQODKqnBAReqwsPGAD6DhogAJWAyarilANNn0bwutEWghJi4tJm3sUIDY8FzWS6fbj8zWaeccq333Y+HChWVNQz7n2j+QJ15RgECWVqGgXOuwkFGAxWi4KEAAikIjBAoQDRbtbKA1Ai3kxKXFpI0dChAbnst66XT7kf3ux8JLptYmX\/WrAFmzZo1s2bKljdb58+fL9ddfL0NDQ2Up9\/Jcqn2R\/cNLuXgzilaHFCDeUm1rmALElu+q3tAaQVU89eeJS4tJGzs8QNjwXMZLt9uP7Hc\/pp26q2ayHwXILbfcIjfddFMbpcPDw3LjjTfK7Nmzy9Dt9ZlU+yL7h9eyUTeOVocUIOopDmOQAiQM72W9ojWCsjhanyMuLSZt7PAAYcNzGS\/dbj\/et\/Iiue\/+e\/tSgMQw8apTrlPti+wfZXZ2uGfQ6pACJFwtqHqmAFGl07sxtEagBZi4tJi0scMDhA3PRb30uv144yXnSj\/us1gmXlGAFK12vPX9uL9CZIECJATrHnxSgHgg1aNJNjiP5HownWq+KEA8FIuCyV63H9nvfqRaj91w9Zp4deWVV8p73vMeBdb9mUg1X+wf\/mrGh2W0OqQA8ZHlADYpQAKQXsElWiOoAKXpUeLSYtLGDg8QNjwX8ZJ3+5HZ6qd9FtvEK96AFKl2zLX9tL9CZoACJCT7ir4pQBTJNDDFBmdAsqKLVPNFAaJYJEqm8m4\/+k2AxDbxigJEaSMENJNqv0fDRQESsMg1XVOAaLLp3xZaI9BCTFxaTNrYoQCx4dnVi8vtRz8JkBgnXlGAuFY77jq+j9nkhgLEhmfvXihAvFOs6oANTpVO78ZSzRcFiPfSKeTA5fajXwRIrBOvKEAKlTzk4lT7PRouChDI8i8eFAVIcc5CPoHWCLS4IC4tJm3sUIDY8OzixfX2ox8EyCmnnCIrVqyQsbGxNupWrlwpixcvdqEUZk2qfZH9A6bEnAJBq0MKEKe04S+iAMHPUWOEaI1Aiz3i0mLSxg4PEDY8u3hxvf1IXYDs3btXPv\/5z0s2+ar1FcPEK96AuFQ79hq+j9nkhwLEhmfvXihAvFOs6oANTpVO78ZSzRcFiPfScXJQ5PYjZQGSfexq3bp1sm\/fvjbeFi1aJKtWrZKBgQEnTpEWsX8gZSM\/llTzhYaLAiS\/FqNYQQESRZomgkRrBFrsEZcWkzZ2KEBseM7zUuT2I2UB8sEPflC2b98uw8PDTZTNnz9frr\/+ehkaGsqjEvLfU+2L7B+Q5dY1KLQ6pACJq366RksBElci0RqBFnvEpcWkjR0eIGx47uWl6O1HqgIkm3j1V3\/1VzWqGgVI9v\/feOONMnv27PDJKhlBqn2R\/aNkQQR6DK0OKUACFYK2WwoQbUb92kNrBFpoiUuLSRs7PEDY8NzLS9HbjxQFSH3i1Z49e5oEyODgoGS\/AzI6Oho+URUiSLUvsn9UKIoAj6LVIQVIgCLw4ZICxAer\/myiNQItpMSlxaSNHR4gbHju5qXM7UdqAuShhx6amHjVKkBinHjVKdep9kX2j7D9o6h3tDqkACmaQdD1FCCgiekSFloj0GKPuLSYtLHDA4QNz928lLn9SEmAZJOuli5dOjHxqlGAxDrxigIk7J7S8M73MQ0W821QgORzFMUKCpAo0jQRJBsc84XAAAVIuCyUvf1IRYAcPnxYli1bJtkNSP1VFyCXXHJJtBOvKEDC7Sktz3x\/1mKytx0KEBuevXuhAPFOsaoDNjhVOr0bSzVfFCDeS6erg7K3H6kIkOy7HVu2bGniJxMgc+bMkfXr10c78YoCJNye0vKcar9Hw0UBolWxge1QgAROQEH3aI2gYPhdlxOXFpM2dihAbHhu9VLl9iMFAZJNvLrpppvayD969KgsX75cLr744jCJ8eQ11b7I\/uGpYDyZRatDChBPibY2SwFizXg1f2iNoBqaF54mLi0mbezwAGHDc6uXKrcfsQuQ+sSrVk6yiVdXX321zJ07VxYuXBgmMZ68ptoX2T88FYwns2h1SAHiKdHWZilArBmv5g+tEVRDQwGixZ+1HR4grBkXqXr7EbMAaZx41cp8NvFq+vTptb+mALGvyzIe2T\/KsBbuGbRzBwVIuFpQ9UwBokqnd2NojUALMHFpMWljhwcIG54bvVS9\/YhVgLROvGrkpD7xiv3Dvh6reGT\/qMKe\/bNo+4sCxL4GvHikAPFCqzejaI1ACyhxaTFpY4cHCBue6140bj9iFCCdJl7VOVm0aNHExCv2D9t6rOqN\/aMqg7bPo+0vChDb\/HvzRgHijVovhtEagRZI4tJi0sYODxA2PNe9aNx+xChAOk28ynDMnz9frr\/++omJV+wftvVY1Rv7R1UGbZ9H218UILb59+aNAsQbtV4MozUCLZDEpcWkjR0eIGx4zrxo3X7EJkC6TbwaHh6WG2+8UWbPnj2RBPYPu3rU8MT+ocGinQ20\/UUBYpd7r54oQLzSq24crRFoASQuLSZt7PAAYcNz5kXr9iMmAdJr4lV2KzI6OtqUAPYPu3rU8MT+ocGinQ20\/UUBYpd7r54oQLzSq24crRFoASQuLSZt7PAAYcOz5u1HLAIkb+LV4sWL28hn\/7CpRy0v7B9aTNrYQdtfFCA2effuhQLEO8WqDtAagRY44tJi0sYODxA2PGvefsQgQFwmXnVinv3Dph61vLB\/aDFpYwdtf1GA2OTduxcKEO8UqzpAawRa4IhLi0kbOzxA+OdZ+\/YDXYC4TryiAPFfe749sH\/4ZljXPtr7MwWIbn6DWaMACUZ9KcdojaAUiA4PEZcWkzZ2eIDwz7P27Qe6AHGdeEUB4r\/2fHtg\/\/DNsK59tPdnChDd\/AazRgESjPpSjtEaQSkQFCBatAWzwwOEX+p93H4gC5AiE68oQPzWnoV19g8LlvV8oJ07KED0chvUEgVIUPoLO0drBIUBdHmAuLSYtLHDA4Rfnn3cfqAKkKITryhA\/NaehXX2DwuW9XygvT9TgOjlNqglCpCg9Bd2jtYICgOgANGiLKgdHiD80e\/r9gNRgJSZeEUB4q\/2rCyzf1gxreMH7dxBAaKT1+BWKECCp6BQAGiNoFDwPRYTlxaTNnZ4gPDHs6\/bDzQBUnbiFQWIv9qzssz+YcW0jh+092cKEJ28BrdCARI8BYUCQGsEhYKnANGiK7gdHiD8pMDn7QeSAKky8YoCxE\/tWVpl\/7Bku7ovtHMHBUj1nEJYoACBSINzEGiNwDnwnIXEpcWkjR0eIPzw7PP2A0mAdJt4NW\/ePFm7dq0MDQ0VIpj9oxBdwRezfwRPQaEA0PYXBUih9OEupgDBzQ3\/l764ctNP+eIBQr82fd9+oAiQXhOv1q1bJyMjI4XJRTsgFQbQ5YFUcbF\/aFWIjR20OqQAscm7dy8UIN4pVnWA1gi0wBGXFpM2dniA0OfZ9+0HggDRmHjVT0I\/1b7I\/qHfP3xaRKtDChCf2Ta0TQFiSLaCK7RGoACpZoK4tJi0scMDhC7PFrcfofeZ1sQrChDd2gthjf0jBOvlfaK9P1OAlM8l1JMUIFDpyA0GrRHkBuy4gLgciQJZxgOEbiIsbj9CChDNiVcUILq1F8Ia+0cI1sv7RHt\/pgApn0uoJylAoNKRGwxaI8gN2HEBcTkSBbKMBwi9RFjdfoQSINoTryhA9GovlCX2j1DMl\/OL9v5MAVIuj3BPUYDApaRnQGiNQIs94tJi0sYODxB6PFvdfoQSINoTryhA9GovlCX2j1DMl\/OL9v5MAVIuj3BPUYDApYQCJK6U9GW+eIDQKVLL248QAsTHxCsKEJ3aC2mF\/SMk+8V9U4AU50z1CbQEaIGjANFi0sZOqnVIXDb1o+WFBwgdJi1vP6wFiK+JVxQgOrUX0gr7R0j2i\/tGe3\/mDUjxHEI+QQECmZauQaE1Ai32iEuLSRs7PEBU59n69sNSgPiceEUBUr32Qltg\/widgWL+0d6fKUCK5Q92NQUIbGo6BobWCLTYIy4tJm3s8ABRnWfr2w8rAeJ74hUFSPXaC22B\/SN0Bor5R3t\/pgAplj\/Y1ciNnAQAACAASURBVBQgsKmhAIkrNX2VLx4gqhVniNsPCwFiMfGKAqRa7SE8zf6BkAX3GOAEyLZt28Y7hb9jx47aXy9YsMAdXQQrU8W1YcMGyf5kryVLltT+pPBKNV\/EFVd1ppqvW2+9tZaIyy67LK6E5ERrla\/77totP92xvymayVMG5C1XnSGDQ5O8ceob3\/r162X79u1t8Z9++uly7bXXyuDgoBdsvnF5CdrBaKq42D8ckg+0BK0OByhAgKqjQigUIBXIC\/AoWiPQooC4tJi0scMDRHmeDz5\/VG7\/4hMyfqzZxstec7K8cuHM8oYdnvS5zzZv3iybNm1qi2LGjBk18TFr1iyHCMst8YmrXEQ6T6WKi\/1Dpz6srKDVIT+CZZV5z374ESzPBCubR7sK1YJHXFpM2tjhRyjK8xziux\/1aH3tM8uJV52Y94WrfJZ1nkwVF\/uHTn1YWUGrQwoQq8x79kMB4plgZfNojUALHnFpMWljhweIcjyH+u6HTwFiPfGKAqRc7SE9xf6BlI38WNDenylA8nMWxQoKkCjSNBEkWiPQYo+4tJi0scMDRDmeQ95+ZBFr77MQE68oQMrVHtJT7B9I2ciPRbtv5HvsvYICpCqDIM9TgIAkwjEMtEbgGHbuMuLKpQhqAQ8QxdMR+vZDW4CEmnhFAVK89tCeYP9Ay0jveNDenylA4qqfrtFSgMSVSLRGoMUecWkxaWOHB4jiPIe+\/dAWIGvWrJEtW7a0ETFv3jxZu3atDA0NFSep5BPsHyWJC\/QY+0cg4ku6RdtfFCAlE4n2GAUIWkbi+l8itNhDa3DE1ZsBHiCKVQjC7YemALnlllvkpptuaiNheHhY1q1bJyMjI8UIqria\/aMigcaPs38YE17RHdr+ogCpmFCUxylAUDLhFgdaI3CLOn8VceVzhLSCB4hi2UC4\/dASIKEnXnVinv2jWD2GXs3+EToDxfyj7S8KkGL5g11NAQKbmo6BoTUCLfaIS4tJGzs8QLjzjHL7oSFAECZeUYC41x7qSvYP1Mx0jgvt\/ZkCJK766RotBUhciURrBFrsEZcWkzZ2eIBw5xnl9qOqAEGZeEUB4l57qCvZP1AzQwECmZlUD0gUIJDl1jWoVOuQuOKqQx4g3PKFdPtRRYAgTbyiAHGrPeRV7B\/I2WmPDe39mTcgcdUPb0ASyRdaI9Cilbi0mLSxwwOEG89Itx9VBAjSxCsKELfaQ17F\/oGcHQoQuOykekDiDQhcqfUMKNU6JK646pAHiPx8od1+lBUgaBOvKEDyaw99BfsHeoaa40N7f+YNSFz1wxuQRPKF1gi0aCUuLSZt7PAAkc8z2u1HGQGCOPGKAiS\/9tBXsH+gZ4gCBCpDqR6QeAMCVWa5waRah8SVm3qoBTxA9E4H4u1HUQGCOvGKAgSqFZQKhv2jFG3BHkJ7f+YNSLBS0HVMAaLLp29raI1ACy9xaTFpY4cHiN48I95+FBEgyBOvKEBs9rhPL+wfPtnVt432\/kwBop\/jIBYpQILQXtopWiMoDaTlQeLSYtLGDg8Q3XlGvf1wFSDoE68oQGz2uE8v7B8+2dW3jfb+TAGin+MgFilAgtBe2ilaIygNhAJEi7ogdniA6E476u2HqwBBn3hFARJky6s6Zf9QpdO7MbRzBwWI95TbOKAAseFZywtaIyCu3gykmi8eIDrnHfn2w0WAxDDxigJEq+uGs8P+EY77Mp7R3scoQMpkEfAZChDApPQICa0RaLFHXFpM2tjhAaIzz8i3H3kCJJaJVxQgNnvcpxf2D5\/s6ttGe3+mANHPcRCLFCBBaC\/tFK0RlAbS8iBxaTFpY4cHiHae0W8\/egmQmCZeUYDY7HGfXtg\/fLKrbxvt\/ZkCRD\/HQSxSgAShvbRTtEZQGggFiBZ1QezwANFOO\/rtRzcBEtvEKwqQIFte1Sn7hyqd3o2hnTsoQLyn3MYBBYgNz1pe0BoBcfVmINV88QDRnPcYbj86CZAYJ15RgGh13XB22D\/CcV\/GM9r7GAVImSwCPkMBApiUHiGhNQIt9ohLi0kbOzxANPMcw+1HJwES48QrChCbPe7TC\/uHT3b1baO9P1OA6Oc4iEUKkCC0l3aK1ghKA2l5kLi0mLSxwwPECzzHcvvRKkBinXhFAWKzx316Yf\/wya6+bbT3ZwoQ\/RwHsUgBEoT20k7RGkFpIBQgWtQFscMDxAu0x3L70ShAjhw5IqtXr26rncHBQcluRUZHR4PUVVmn7ItlmQvzHPtHGN7LekXbXxQgZTMJ9hwFCFhCcsJBawRa7BGXFpM2dniAOM5zTLcfdQGyc+dO+cIXviBjY2NtxbJy5UpZvHixTREpemH\/UCTTwBT7hwHJii7Q9hcFiGJyQ5qiAAnJfnHfaI2gOILOTxCXFpM2dniAOM5zTLcfWbx33HGHZD1\/YGCgrVCuvPJKec973mNTQMpe2D+UCfVsjv3DM8HK5tH2FwWIcoJDmaMACcV8Ob9ojaAcivaniEuLSRs7PEDEd\/uRTby6+uqrJbsBGR4ebiqURYsWyapVqzoKE5uKquaF\/aMaf9ZPs39YM17NH9r+ogCplk+YpylAYFLhFAhaI3AK2mERcTmQBLSEB4j4bj+y73b80z\/9U62KGgXIvHnzZO3atTI0NARUYcVCYf8oxlfo1ewfoTNQzD\/a\/qIAKZY\/2NUUILCp6RgYWiPQYo+4tJi0sdPvB4jYvvtRn3i1Z8+eJgGSCZF169bJyMiITeF48sL+4YlYT2b7vX94otWbWbT9RQHiLdW2hilAbPmu6g2tEVTFU3+euLSYtLHT7weImL77sXXr1omJV40CJNaJV50qnP3DZt9reen3\/qHFo5UdtP1FAWKVec9+KEA8E6xsHq0RaMEjLi0mbez08wEiptuPhx56SFasWDEx8apRgMQ68YoCxGaP+\/TSz\/3DJ6++bKO9P1OA+Mq0sV0KEGPCK7pDawQV4Uw8TlxaTNrY6ecDRCy3H7t27ZKlS5dK9p\/1V12A\/N7v\/V60E68oQGz2uE8v\/dw\/fPLqyzba+zMFiK9MG9ulADEmvKI7tEZQEQ4FiBaBxnb69QARy+1HNvFq2bJlkt2ANL4yAXLeeefJJz\/5yWgnXlGAGG92D+76tX94oNLEJNq5gwLEJO3+nVCA+OdY0wNaI9DCRlxaTNrY6dcDRCy3H9nEqy1btrQVw7Rp0+Taa6+Viy66yKZQjLywfxgRreSmX\/uHEn3mZtD2FwWIeQn4cUgB4odXX1bRGoEWTuLSYtLGTj8eIGK5\/ahPvGqthGzi1e\/8zu\/IrFmzZOHChTaFYuSF\/cOIaCU3\/dg\/lKgLYgZtf1GABCkDfacUIPqc+rSI1gi0sBKXFpM2dvrxABHD7UfjxKvGSqhPvNq7d2\/trylAbPZJVS+p9sV+7B9VayHk82h1SAESshoUfVOAKJJpYAqtEWhBJi4tJm3s9NsBIobbj9aJV42VUJ94xX1msz+0vKSar37rH1r1EMoOWh1SgISqBGW\/FCDKhHo2h9YItOASlxaTNnb67QCBfvvRaeJVvRKuvPLKiYlX3Gc2+0PLS6r56rf+oVUPoeyg1SEFSKhKUPZLAaJMqGdzaI1ACy5xaTFpY6efDhDotx\/dJl5llbBo0SJZtWrVxMQr7jOb\/aHlJdV89VP\/0KqFkHbQ6pACJGQ1KPqmAFEk08AUWiPQgkxcWkza2OmnAwT67Ue3iVfz5s2TtWvXytDQ0ERRcJ\/Z7A8tL6nmq5\/6h1YthLSDVocUICGrQdE3BYgimQam0BqBFmTi0mLSxk6\/HCDQbz96Tbxat26djIyMNBUE95nN\/tDykmq++qV\/aNVBaDtodUgBEqAi\/vAP\/1A+8YlP9PR8+umnyxNPPOEcHQWIM1UQC9EagRYpxKXFpI2dfjlAIN9+5E28Gh0dbSsG7jOb\/aHlJdV89Uv\/0KqD0HbQ6pACJEBF\/PZv\/7Zk\/4tXrxcFyHF20DaMVrkQlxaTNnZSzVc\/HCCQbz9cJl51qvBU65G4bPqZlpd+6B9aXCHYQdtfFCABquI3fuM35LbbbpN3vetdtV+z7fTKPu\/7+te\/3jk63oA4UwWxEK0RaJFCXFpM2tjphwME6u2H68QrChCbveDTS6p9sR\/6h8+6sLaNVocUINYVICLnn3++bN++XT7ykY\/In\/zJn6hEQAGiQqOZEbRGoAWcuLSYtLGT+gHiFaPnyedu2CpHj443Efq6N82TN15yrg3JHbwUmXhFARIsTWqOU+2LqfcP\/tCn2hboaIgCxC+\/Ha3PnTtXHn300dr3QP77f\/\/vKhFQgKjQaGYk1Tck4jIrIRVHqR8gnnt8WLbfubOJq8GhyfK+lRfJ1GlTVDgsY6TIxCsKkDIMYz2Tal9MvX9QgPjdRxQgfvntaP2kk06SAwcOyN\/93d\/JFVdcoRIBBYgKjWZGUn1DIi6zElJxlPIB4uDzR+WebxyEu\/0oOvGKAkSl1IMaSbUvptw\/soKhAPG7bShA\/PLbZn3\/\/v0yY8aM2t9\/61vfkl\/91V9ViYACRIVGMyOpviERl1kJqThK+QBx31275dnHmm85Qt9+lJl4RQGiUupBjaTaF1PuHxQg\/rcMBYh\/jps8PPLII\/KSl7yk9nc\/+tGP5OUvf7lkoiT70nnjD00VDYsCpChjYden+oZEXGHrqqj3VA8Q3\/n2d+X2Lz4hM08ebqIk5Hc\/yk68ogApWtV461Pti6n2j1TzhYaLAsS4V2UFcOGFF9a8Zr9w+9hjj8mRI0dq\/\/3FL35x7UbkAx\/4gFx88cWFIqMAKURX8MVojUCLEOLSYtLGTqoHiPWfvF1+umO\/DA+\/IEBC3n5UmXhFAWKzF3x6SbUvpto\/Us0XGi4KEJ9dp4Pt++67T97whjfIvn37enrOvpz+8Y9\/XAYGBpwipABxoglmEVoj0CKGuLSYtLGT4gEi+92Pv\/ifm2X8mDQJkFC3H1UnXlGA2OwFn15S7Ysp9o+sDlLNFxqugU9\/+tPN8wlP7MLso0LZ65xzzvG5L81th8CVfczq137t1yawZhOwHnjgAXnpS18qZ5xxRk1kZDcht99+u6xevVp++tOf1tb+6Z\/+qfzRH\/1R7f9\/5pln5O\/\/\/u+78vWNb3xDsj\/ZK\/udkexPCq8Q+bLgjbgsWNbzkWq+vv3tb9dI+pVf+RU9sgJbevLBQdn5k0O1KKZPn177z0mTRV62aEwmT+n4duc14s2bN8uPf\/zjNh+zZ8+WK6+8UqZMKT6NK9V6JC6vpahuPMX+kZHEOlQvlY4GKUAMeM6+dJ59pOrMM8\/M9ZYJjewHCLPPC8+cOVOefPJJmTZtWu25jRs3dr05oQDJpRZqARscVDpyg0k1X6kdII6MDchPvjdVnt9\/oEmAnDr3iLz43OMfdbV8fe9735Psi+etr0wYXXXVVRMDSYrGlGo9ElfRSgi7PrX+UWeTdWhTV\/wIlg3Phbx8+tOflj\/4gz+oPfPNb35T3vSmN+U+z49g5VIEtQDtKlSLHOLSYtLGTmofoaj\/6vmePXtqBGbfAQn13Q+tiVedKoH7zGZ\/aHlJNV+p9Y96vlPNFxouChCtDqNo56677qp9TyR7uf5WCAWIYgIMTKE1Ai3IxKXFpI2dlA4Q2Xc\/6r963ihAQnz3Q3PiFQWIzV7w6SXVvphS\/2jMf6r5QsNFAeKz65S0nf0+SP07I5s2bZLf\/M3fzLVEAZJLEdQCtEagRQ5xaTFpYyelA0T99iNjri5ARk6bbf6r59oTryhAbPaCTy+p9sWU+gcFiM8d0Nk2BYg957kesy+if+QjH6mt27lzp5x11lm5z1CA5FIEtSDVNyTigiqz3GBSOUA03n40CpC3vPPV8sZLzs3lQWuBj4lXFCBa2QlnJ9W+mEr\/aK2MVPOFhosCxLgnZYJizpw5Xb1mE7Cy3wnJvoyeTab5l3\/5F6cIKUCcaIJZhNYItIghLi0mbeykcoBovP2oC5DJUwZk+Z9dKlOnFZ8yVZb9NWvWyJYtW9oez37zae3atZV+bJb\/C23ZrIR\/LtW+mEr\/oAAJs0coQIx5f8c73lH7eMBv\/dZvyete97ramONJkybJz372M7nzzjslewN7+umnZerUqTXxkU3EcnlRgLiwhLMm1Tck4sKpMZdIUjhAtN5+1AXIy15zsrz7\/cV+0NWFs25rbrnlFrnpppva\/jn7Ivy6detkZGSkivmmZ7nP1Kg0MZRqvlLoH50KINV8oeGiADFpPy84eec73ylf+cpXeno99dRT5W\/+5m\/k0ksvdY6OAsSZKoiFaI1AixTi0mLSxk4KB4jW24+MuX3798pbrjpDLnrD60yI9DnxigckkxR6dZJqX0yhf3B\/eS39nsYpQIy5z243PvOZz8htt90mO3bsqN12jI+PS\/ajVOedd15NdLz3ve+VU045pVBkFCCF6Aq+ONU3JOIKXlqFAoj9ANHp9iMj4LRzjskrF86UhQsXFuKjzGLfE694QCqTFaxnUu2LsfePblWSar7QcFGAYPWp0tFQgJSmLsiDaI1AiwTi0mLSxk7sB4hOtx\/Z734svGSqDA5N8i5Aek28uuKKK+Tqq6\/2kkjuMy+0ejOaar5i7x8UIN5K3skwBYgTTfiLKEDwc9QYYapvSMQVVx3GfIDodvuR\/e7HtFN31RLh8wbEauIVb0Di2lP9lK+Y+0evquL7mM2eowCx4dm7FwoQ7xSrOmCDU6XTu7FU8xXzAaLb7cf7Vl4k991\/r3cBYjXxqp8OtKnus1Rxxdw\/KEC8v23mOqAAyaUojgUUIHHkqR5lqm9IxBVXHcZ6gOh1+5H97ofvOrSceEUBEtee6qd8xdo\/8irKd\/\/I8+\/r39FwUYD4yrSxXQoQY8IrukNrBBXhTDxOXFpM2tiJ9QDR6\/Yj+90Pn3VoPfGqnw60PvNms6M6e0kVV6z9I68WUs0XGi4KkLxKjOTfKUAiSdSJMNEagRZ7xKXFpI2dGA8QebcfGXO+6jDExCsKEJu94NOLr3r0GbOL7Rj7hwuuVPOFhosCxKUaI1hDARJBkhpCRGsEWuwRlxaTNnZiPEDk3X74EiChJl5RgNjsBZ9eUu2LMfYPlzynmi80XBQgLtUYwRoKkAiSRAESV5L6IF+xHSBcbj98CJCQE68oQKJtGxOBox38tBiNrX+44k41X2i4KEBcKxJ8HQUIeIJawkNrBFrsEZcWkzZ2YjtAuNx++BAgISdeUYDY7AWfXlLti7H1D9ccp5ovNFwUIK4VCb6OAgQ8QRQgcSWoT\/IV0wHC9fZDW4CEnnhFARJ166gFj3bw02I0pv5RBHOq+ULDRQFSpCqB11KAACenQ2hojUCLPeLSYtLGTkwHCNfbD80DH8LEKwoQm73g00uqfTGm\/lEkv6nmCw0XBUiRqgReSwECnBwKkLiS00f5iuUAUeT2Q0uAoEy8ogCJvn3wBiSyFKId1LXoQ8NFAaKV2cB2KEACJ6Cge7RGUDD8rsuJS4tJGzuxCJAitx8aAgRp4hUFiM1e8Okl1b4YS\/8omttU84WGiwKkaGWCrqcAAU1Ml7DQGoEWe8SlxaSNnRgOEEVvP6oKELSJVxQgNnvBp5dU+2IM\/aNMXlPNFxouCpAy1Qn4DAUIYFJ6hITWCLTYIy4tJm3sxHCAKHr7UVWAoE28ogCx2Qs+vaTaF2PoH2Xymmq+0HBRgJSpTsBnKEAAk0IBEldS+jBf6AeIMrcfVQQI4sQrCpD42wjawU+LUfT+URZnqvlCw0UBUrZCwZ6jAAFLSE44aI1Aiz3i0mLSxg76AaLM7UdZAYI68YoCxGYv+PSSal9E7x9lc5pqvtBwUYCUrVCw5yhAwBJCARJXQvo0X8gHiLK3H2UECPLEKwqQ+FsJ2sFPi1Hk\/lEFY6r5QsNFAVKlSoGepQABSoZDKGiNwCFkpyXE5UQTzCLkA0TZ24+iAgR94hUFCMx2KR1Iqn0RuX+UTlbCPxyJVocUIFWqFOhZChCgZDiEgtYIHEJ2WkJcTjTBLEI9QFS5\/SgiQGKYeEUBArNdSgeSal9E7R+lE3XiwVTzhYaLAqRqpYI8TwECkgjHMNAagWPYucuIK5ciqAWoB4gqtx9FBEgME68oQKC2TKlgUu2LqP2jVJIaHko1X2i4KECqVirI8xQgIIlwDAOtETiGnbuMuHIpglqAeICoevvhKkBuvvlm2bhxY1s+hoeHZd26dTIyMgKVq8ZguM9gU9MxsFTzhdg\/NCoj1Xyh4aIA0ahWABsUIABJKBACWiMoEHrPpcSlxaSNHcQDRNXbDxcBEtPEK96A2OwFn15S7YuI\/UMjj6nmCw0XBYhGtQLYoAABSEKBENAaQYHQKUC0yAKwg3aA0Lj9yBMgsU28ogAB2CgVQ0i136P1j4ppmng81Xyh4aIA0arYwHYoQAInoKB7tEZQMPyuy4lLi0kbO2gHCI3bj14CJMaJVxQgNnvBp5dU+yJa\/9DKYar5QsNFAaJVsYHtUIAETkBB92iNoGD4FCBahAW2g3SA0Lr96CZAYp14RQESeJMouE+13yP1D4U08QZEk0QHWxQgDiTFsIQCJIYsvRBjqm9IxBVXHSIdILRuP7oJkFgnXlGAxLWn+ilfSP1Ds0r4PqbJZndbFCA2PHv3QgHinWJVB2xwqnR6N5ZqvlAOEJq3H50ESMwTr\/rpQJvqPksVF0r\/0H4DSDVfaLgoQLQrN5A9CpBAxJd0i9YISsJoe4y4tJi0sYNygNC8\/WgVILFPvKIAsdkLPr2k2hdR+od27lLNFxouChDtyg1kjwIkEPEl3aI1gpIwKEC0iAtkB+EAoX370ShATjnlFFmxYoWMjY21Mbxy5UpZvHhxIOaruWX\/qMaf9dOp5guhf\/jIZar5QsNFAeKjegPYpAAJQHoFl2iNoAKUpkeJS4tJGzsIBwjt24+6ANm7d698\/vOfl2zyVevriiuukKuvvtqGZA9euM88kOrRZKr5QugfPtKWar7QcFGA+KjeADYpQAKQXsElWiOoAIUCRIu8AHZCHyB83H5kNGYfu8p+zXzfvn1trC5atEhWrVolAwMDARjXccn+ocOjlZVU8xW6f\/jKX6r5QsNFAeKrgo3tUoAYE17RHVojqAhn4nHi0mLSxk7oA4SP24+MuQ9+8IOyfft2GR4ebiJy3rx5snbtWhkaGrIh2JMX7jNPxHoym2q+QvcPT+mSVPOFhosCxFcFG9ulADEmvKI7tEZQEQ4FiBaBxnZCHiB83X5kE68+9alP1ZhsFCDZ\/5\/dioyMjBizrO+O\/UOfU58WU81XyP7BfBVnAK0OKUCK5xDyCQoQyLR0DQqtEWixR1xaTNrYCXmA8HH7UZ94tWfPniYBMjg4KNnvgIyOjtoQ69kL95lngpXNp5qvkP1DOUVN5lLNFxouChCfVWxomwLEkGwFV2iNQAFSzQRxaTFpYyfUAcLH7cdDDz00MfGqVYDEPPGqUyVwn9nsDy0vqeYrVP\/Qyks3O6nmCw0XBYjvSjayTwFiRLSSG7RGoASLAkSLSCM7oQ4Q2rcf2aSrpUuXTky8ahQgsU+8ogAx2gwe3aTa70P1D4+p4v+Q5pvcBvsUIIZk+3RFAeKTXX3bqb4hEZd+rfi0GOIAoX37cfjwYVm2bJlkNyD1V12AXHLJJdFPvKIA8bkDbGyn2hdD9A+LjKWaLzRcFCAW1WzggwLEgGRFF2iNQAsacWkxaWMnxAFC+\/Yj+27Hli1bmgjLBMjpp58uN910U\/QTryhAbPaCTy+p9sUQ\/cNnnuq2U80XGi4KEItqNvBBAWJAsqILtEagBY24tJi0sWN9gNC+\/cgmXm3cuLGNrKNHj8q1114rb37zm22INPbCfWZMeEV3qebLun9UTIPz46nmCw0XBYhzSWIvpADBzk9rdGiNQIs94tJi0saO9QFC8\/ajPvGqlals4lX2K+dz586VhQsX2hBp7IX7zJjwiu5SzZd1\/6iYBufHU80XGi4KEOeSxF5IAYKdHwqQuPLTL\/myPEBo3n40TrxqzVU28Wr69Om1v6YAiWvfoR2QtNhLFZdl\/9DKhYudVPOFhosCxKUaI1hDARJBkhpCRGsEWuwRlxaTNnYsDxBatx+tE68amapPvEq1DutYU8VHXDb7XsuLZf\/QitnFDuvQhaXqayhAqnMIYYECBCINzkGwwTlTBbEw1XxZHSC0bj86TbyqF8iiRYsmJl6lmi8KEIh2UDiIVOvRqn8UJrziA6nmCw3XwLZt28Y75WrHjh21v16wYEHFVGI9niquDRs2SPYney1ZsqT2J4VXqvkirriqM9V83XrrrbVEXHbZZV4Tct9du+WnO\/Y3+Zg8ZUDectUZMjg0ydn3+vXrZfv27W3rs4lX2ZfOs+9\/ZK9U81UHnio+4nLeChALrfqHNVjWoQ3jFCA2PHv3QgHinWJVB2xwqnR6N5ZqviwOEAefPyq3f\/EJGT\/WnKaXveZkeeXCmc6527x5s2zatKlt\/YwZM2riY9asWRP\/lmq+KECcywVqYar1aNE\/QiQy1Xyh4eJHsEJUtwef\/AiWB1I9mkS7CtWCSlxaTNrYsfgIhcZ3P3pNvMp+B2R0dLSJsFTrsA4yVXzEZbPvtbxY9A+tWIvYYR0WYav8WgqQ8txBPUkBApWO3GDY4HIpglqQar58HyA0vvuRN\/Fq8eLFbbWSar4oQKDagnMwqdaj7\/7hTLDywlTzhYaLAkS5cEOZowAJxXw5v2iNoByK9qeIS4tJGzu+DxBVbz9cJl51YirVOqQAsdkX2l5SrUff\/UM7D672Us0XGi4KENeKBF9HAQKeoJbw0BqBFnvEpcWkjR2fB4iqtx+uE68oQGxqxcIL+4cFy3o+fPYPvSiLW2IdFueszBMUIGVYA3yGAgQwKT1CYoNjvhAY8HmAqHr7kX23Y8uWLW00zZs3T9auXStDQ0NdKUx1f\/EGBGHXFI8h1Xr02T+Ks6z3RKr5QsNFAaJXs0EtUYAEpb+wRWub+wAAIABJREFUc7RGUBhAlweIS4tJGzu+DhBVbz9uvvlm2bhxYxsJw8PDsm7dOhkZGelJUKp1SAFisy+0vaRaj776hzb\/Re2lmi80XBQgRSsTdD0FCGhieFCPKzF9li9fB4gqtx9FJ151ShnaG632JkgVH3FpV4pfe776h9+o862zDvM50lhBAaLBIoANChCAJBQIgQ2uAFkAS1PNl48DRJXbjzITryhAADaIUgip7rNUcfnoH0qlVMlMqvlCw0UBUqlMcR6mAMHJhUskaI3AJWaXNcTlwhLOGh8HiLK3H2UnXlGA4NRT1UjYP6oyaPu8j\/5hi6CzN9ahTRYoQGx49u6FAsQ7xaoO2OBU6fRuLNV8aR8gyt5+VJl4RQHivfzNHKS6z1LFpd0\/zAotx1Gq+ULDRQGCUvEV46AAqUig8eNojUALPnFpMWljR\/sAUfb2o8rEKwoQm1qx8ML+YcGyng\/t\/qEXWTVLrMNq\/Lk+TQHiyhT4OgoQ8AS1hMcGx3whMKB5gCh7+1F14hUFCEIl6cTAvqjDo5UVzf5hFbOLH9ahC0vV11CAVOcQwgIFCEQanINgg3OmCmJhqvnSPECUuf3QmHhFAQKxRVSCSHWfpYpLs3+oFJCSkVTzhYaLAkSpYEOboQAJnYFi\/tEaQbHou68mLi0mbexoHSDK3H5oTbyiALGpFQsv7B8WLOv50OofehHpWGId6vCYZ4UCJI+hSP6dAiSSRJ0Ikw2O+UJgQOsAUfT2Q3PiFQUIQiXpxMC+qMOjlRWt\/mEVr6sf1qErU9XWUYBU4w\/maQoQmFQ4BcIG50QTzKJU86VxgCh6+6E98YoCBGabVA4k1X2WKi6N\/lG5aDwYSDVfaLgoQDwUbwiTFCAhWC\/vE60RlEfS\/CRxaTFpY0fjAFH09kN74hUFiE2tWHhh\/7BgWc+HRv\/Qi0bPEutQj8telihAbHj27oUCxDvFqg7Y4FTp9G4s1XxVPUAUvf3wMfGKAsR7+Zs5SHWfpYqrav8wK6yCjlLNFxouCpCChYm6nAIENTOd40JrBFrsEZcWkzZ2qh4gitx++Jp4RQFiUysWXtg\/LFjW81G1f+hFomuJdajLZzdrFCA2PHv3QgHinWJVB2xwqnR6N5ZqvqocIIrcfviceEUB4r38zRykus9SxVWlf5gVVQlHqeYLDRcFSIniRHyEAgQxK91jQmsEWuwRlxaTNnaqHCBcbz98T7yiALGpFQsv7B8WLOv5qNI\/9KLQt8Q61Oe0k0UKEBuevXuhAPFOsaoDNjhVOr0bSzVfZQ8QrrcfFhOvKEC8l7+Zg1T3Waq4yvYPs4Iq6SjVfKHhogApWaBoj1GAoGWkdzxojUCLPeLSYtLGTtkDhOvth8XEKwoQm1qx8ML+YcGyno+y\/UMvAj+WWId+eG21SgFiw7N3LxQg3ilWdcAGp0qnd2Op5qvMAcL19sNq4hUFiPfyN3OQ6j5LFVeZ\/mFWTBUcpZovNFwUIBWKFOlRChCkbOTHgtYI8iN2W0FcbjyhrCpzgHC5\/bCceEUBglJN1eNg\/6jOoaWFMv3DMr6yvliHZZkr9hwFSDG+YFdTgMCmpmNgbHDMFwIDRQ8QLrcf1hOvKEAQKkknBvZFHR6trBTtH1ZxVfXDOqzKoNvzFCBuPMGvogCBT1FTgGxwzBcCA0UPEHm3HyEmXlGAIFSSTgzsizo8Wlkp2j+s4qrqh3VYlUG35ylA3HiCX0UBAp8iCpC4UtQX+SpygMi7\/Qg18YoCJOKN1RI6D35x5bJI\/4gJGevQJlsUIDY8e\/dCAeKdYlUHbHCqdHo3lmq+ihwg8m4\/Qk28ogDxXv5mDlLdZ6niKtI\/zIpIwVGq+ULDRQGiUKwIJihAELLgHgNaI3CPvPdK4tJi0saO6wEi7\/Yj5MQrChCbWrHwwv5hwbKeD9f+oefRxhLr0IZnChAbnr17oQDxTrGqAzY4VTq9G0s1X64HiF63H9vvvVtWr17dloPBwUHJbkVGR0e956fVQar5quNMFR9xmW+VSg5d+0clJwEeZh3akE4BYsOzdy8UIN4pVnXABqdKp3djqebL5QDR6\/bjzJeNy4oVK2RsbKwtBytXrpTFixd7zw1vQIJQ7MVpqvssVVwu\/cNLoXg2mmq+0HBRgHguZCvzFCBWTOv4QWsEOqhEiEuLSRs7LgeIbrcf\/\/n9L5eVf7RcsslXra8rrrhCrr76ahsQHbykWoe8AQlWUpUcp1qPLv2jEnGBHk41X2i4KEACFbi2WwoQbUb92kNrBFpoiUuLSRs7eQeIbrcf57\/xLLl18yck+82P1teiRYtk1apVMjAwYAOCAiQYz9qO2T+0GfVrL69\/+PXuzzrr0B+3jZYpQGx49u6FAsQ7xaoO2OBU6fRuLNV85R0gut1+7Jnybbnzrn9t433evHmydu1aGRoa8p6TXg5SzVcdc6r4iCvotinsPK9\/FDYI8gDr0CYRFCA2PHv3QgHinWJVB2xwqnR6N5ZqvnodILrdfuw+tl3uvu+2Ns6Hh4dl3bp1MjIy4j0feQ5SzRcFSF7mMf891XqkAMGst25RodUhBUhc9dM1WgqQuBKJ1gi02CMuLSZt7PQ6QHS6\/dj5i3+XHz76ZZk0ufnjVSEnXnViKtU6pACx2RfaXlKtRwoQ7Urxaw+tDilA\/ObbzDoFiBnVKo7QGoEKKOGX0LV4tLLT7QDR6fbjmd2Py5YfrJcZs6a0hRdy4hUFiFW1+PfDvuifY00PFCCabPq3hba\/KED859zEAwWICc1qTtAagRYw4tJi0sZOtwNE6+3H8week3\/850\/KyFmT224\/Qk+8ogCxqRULL+wfFizr+aAA0ePSwhLa\/qIAsci6gQ8KEAOSFV2gNQItaMSlxaSNnU4HiNbbj6PHjsg\/3vYpOTr5WZl92klNgSFMvKIAsakVCy\/sHxYs6\/mgANHj0sIS2v6iALHIuoEPChADkhVdoDUCLWjEpcWkjZ1OB4jW249\/vvNmeXjnv8m8l57SdPuBMvGKAsSmViy8sH9YsKzngwJEj0sLS2j7iwLEIusGPihADEhWdIHWCLSgEZcWkzZ2Wg8Qrbcf99x\/u9x9\/20y69TpTbcfSBOvKEBsasXCC\/uHBct6PihA9Li0sIS2vyhALLJu4IMCxIBkRRdojUALGnFpMWljp\/UA0Xj78chjO+TrW74gkyYNNN1+oE28ogCxqRULL+wfFizr+aAA0ePSwhLa\/qIAsci6gQ8KEAOSFV2gNQItaMSlxaSNncYDROPtRzbx6sv\/\/Ck5cuRw2+0H2sQrChCbWrHwwv5hwbKeDwoQPS4tLKHtLwoQi6wb+KAAMSBZ0QVaI9CCRlxaTNrYaTxA1G8\/solX\/3DbJ2T\/gb1ttx+IE68oQGxqxcIL+4cFy3o+KED0uLSwhLa\/KEAssm7ggwLEgGRFF2iNQAsacWkxaWOnfoD4r\/\/lGvncDVvl0OHDtYlXz+x+rBZA43c\/UCdeUYDY1IqFF\/YPC5b1fFCA6HFpYQltf1GAWGTdwAcFiAHJii7QGoEWNOLSYtLGTv0A8fKzfl2237lTsolXD\/78BzXnjd\/9QJ54RQFiUysWXtg\/LFjW80EBoselhSW0\/UUBYpF1Ax8UIAYkK7pAawRa0IhLi0kbO9kB4sjYgBz9xSvkez+4rTbxqv6q336gT7yiALGpFQsv7B8WLOv5oADR49LCEtr+ogCxyLqBDwoQA5IVXaA1Ai1oxKXFpI2d7ADx5IODsuupsdrEq\/qrfvsxddqQrFmzRkZHR20CUvKSah3W6UkVH3EpbQAjMxQgRkQruUHbXxQgSokNbYYCJHQGivlHawTFou++mri0mLSx81cf\/\/\/k7jv2yrYdX65NvKq\/6rcfMUy86sRUqnVIAWKzL7S9pFqPFCDaleLXHlodUoD4zbeZdQoQM6pVHKE1AhVQIkJcWkza2PkfH\/qE\/MNXbpGBycfabj+u+i9XytVXX20TiLKXVOuQAkS5UIzMpVqPFCBGBaTkBq0OKUCUEhvaDAVI6AwU84\/WCIpFzxsQLb5C2tn1+C655Ff+s+x57hcyZWhQJg1Nzb55Xpt8denbL5ZVq1bJwMBAyBBL+051f1GAlC6JoA+mWo8UIEHLqrBztDoc2LZt23gnFDt27Kj99YIFCwqDRH4gVVwbNmyQ7E\/2WrJkSe1PCq9U80VccVVnavkaP3xYrl\/6Mbn7wQdriZg0aZIMTBqQgWnT5FXnnyPLl18r2S+ex\/pKLV+teUgVH3HFteNuvfXWWsCXXXZZXIHnRMs6tEknBYgNz969UIB4p1jVARucKp3ejSWVr8OH5at\/foNs3LJDDh89Tl0mQLLXaXNOlT+57iMya9Ys75z6dJBUvjoQlSo+4vK5K\/RtU4Doc+rTItr+4kewfGbb0DY\/gmVItoIrtKtQBUg1E8SlxaQfO8fGxuQr\/+uPZd2X\/l52HxySfWPH\/UyePFkGpwzKzf90k5z36lf6cW5oNdU6rFOYKj7iMtwkCq74ESwFEg1NoO0vChDD5Pt0RQHik11922iNQAshcWkxqW8nEx\/f+YsbZPUX\/kYOHT0q4+Miv9g3IIeODcqUyZPlI8s\/JP916e\/qOw5gMdU6pAAJUEwKLlOtRwoQheIwNIFWhxQghsn36YoCxCe7+rbRGoEWQuLSYlLXTiY+\/u1Tn5Q\/\/t+fkz0HD04YP\/D8ATk6MEl+9w8\/KH+wYpmu04DWUq1DCpCARVXBdar1SAFSoSgCPIpWhxQgAYrAh0sKEB+s+rOJ1gi0kBKXFpN6djLx8fDnPisf\/d+fk0d3724y\/PyBgzL3vFfJF7\/6tWgnXnViKtU6pADR2xeWllKtRwoQyyqq7gutDilAqucUwgIFCEQanINAawTOgecsJC4tJnXsZOLj51\/4vHz8lr+Vu3\/+82ajA5Nk8sipctm7l8gHPvABHYcgVlKtQwoQkAIrGEaq9UgBUrAQAi9Hq0MKkMAFoeWeAkSLSRs7aI1ACzVxaTFZ3U5dfHzpq1+V\/3P\/D9vEx+m\/tEBe\/yu\/KjNmzJD3v\/\/91R0CWUi1DilAgIqsQCip1iMFSIEiAFiKVocUIABFoRECBYgGi3Y20BqBFnLi0mKymp26+Nh6553yqS3faRMfM889V274+MfljjvuqP0bBUg1vq2f5j6zZryav1TzRQFSrS6sn0arQwoQ6wrw5I8CxBOxnsyiNQItmMSlxWR5O3Xx8cC998oNt\/9zbeLVxGtgkkyfe7b8j4\/+L1m8eLHwAFGe55BPcp+FZL+471Tzxf5RvBZCPoFWhxQgIatB0TcFiCKZBqbQGoEWZOLSYrKcnbr4eOJHP5I\/\/cZtTROv5IT4uOo9V8s111xTc8ADRDmeQz\/FfRY6A8X8p5ov9o9idRB6NVodUoCErggl\/xQgSkQamUFrBFqwiUuLyeJ26uLjuYcfljW33d488eqE+PgPv3axrFq1amLiFQ8QxXlGeIL7DCEL7jGkmi\/2D\/caQFiJVocUIAhVoRADBYgCiYYm0BqBFnTi0mKymJ26+DjwyCPymTvvap54dUJ8nPuKV8ratWtlaGhowjgPEMV4RlnNfYaSCbc4Us0X+4db\/lFWodUhBQhKZVSMgwKkIoHGj6M1Ai34xKXFpLudRvHxT\/ff3zzx6oT4mH3GmbJu3ToZGRlpMswDhDvPSCu5z5CykR9Lqvli\/8jPPdIKtDqkAEGqjgqxUIBUIC\/Ao2iNQIsC4tJi0s1Oo\/j4wWOPNU+8OiE+ps0cljVr1sjo6GibUR4g3HhGW8V9hpaR3vGkmi\/2D9ZhFQYoQKqwB\/QsBQhQMhxCSfUNibgckq+0pFF8\/Hz37uaJVyfEx+TpJ8nKlStrE686vXiAUEqGsRnuM2PCK7pLNV\/sHxULw\/hxtDqkADEuAF\/uKEB8MevHLloj0EJJXFpM9rbTKD72HDjQPPGqQXxcfvnlExOvKEBscmPhhfvMgmU9H6nmiwJEr0YsLKHVIQWIRdYNfFCAGJCs6AKtEWhBIy4tJrvbaRQfR44da5541SA+Fi1a1DTxigLEf26sPHCfWTGt4yfVfFGA6NSHlRW0OqQAscq8Zz8UIJ4JVjaP1gi04BGXFpOd7TSKj2xF08SrBvExb968tolXFCB+c2NpnfvMku3qvlLNFwVI9dqwtIBWhxQgltn36IsCxCO5HkyjNQItiMSlxWS7nVbx0TTxqkF8DA8Pd5x4RQHiLzfWlrnPrBmv5i\/VfFGAVKsL66fR6pACxLoCPPmjAPFErCezaI1ACyZxaTHZbKdVfDRNvGoQH4ODg10nXlGA+MlNCKvcZyFYL+8z1XxRgJSviRBPotUhBUiIKvDgkwLEA6keTaI1Ai2oxKXF5At2WsVH08SrBvGRPdFr4hUFiH5uQlnkPgvFfDm\/qeaLAqRcPYR6Cq0OKUBCVYKyXwoQZUI9m0NrBFpwiUuLyeN2WsVH08SrFvGRN\/GKAkQ3NyGtcZ+FZL+471TzRQFSvBZCPoFWhxQgIatB0TcFiCKZBqbQGoEWZOLSYrJdfDRNvGoRHy4TryhA9HIT2hL3WegMFPOfar4oQIrVQejVaHVIARK6IpT8U4AoEWlkBq0RaMEmLh0mW28+MqsTE69axIfrxCsKEJ3cIFjhPkPIgnsMqeaLAsS9BhBWotUhBQhCVSjEQAGiQKKhCbRGoAWduKoz2Ul8TEy8ahEfRSZeUYBUzw2KBe4zlEy4xZFqvihA3PKPsgqtDilAUCqjYhwUIBUJNH4crRFowSeuakx2Eh8TE69axEfRiVcUINVyg\/Q09xlSNvJjSTVfFCD5uUdagVaHFCBI1VEhFgqQCuQFeBStEWhRQFzlmewkPiYmXh0bl+lzz5bJ00+acFB04hUFSPncoD3JfYaWkd7xpJovChDWYRUGKECqsAf0LAUIUDIcQkn1DYm4HJLfYUkn8TEx8WrsUJv4KDPxigKkXG4Qn+I+Q8xK95hSzRcFCOuwCgMUIFXYA3qWAgQoGQ6hpPqGRFwOyW9Z0kl8TEy82rO3TXyUnXhFAVI8N6hPcJ+hZqZzXKnmiwKEdViFAQqQKuwBPUsBApQMh1BSfUMiLofkNyzpJD6yf65NvHp0Z5v4qDLxigKkWG6QV3OfIWenPbZU80UBwjqswgAFSBX2gJ6lAAFKhkMoqb4hEZdD8k8s6SY+ahOvfvijNvFRdeIVBYh7btBXcp+hZ6g5vlTzRQHCOqzCAAVIFfaAnqUAAUqGQyipviERl0PyO\/zCef2p2sSr79zZJj40Jl5RgLjlJoZV3GcxZOmFGFPNFwUI67AKAxQgVdgDepYCBCgZDqGk+oZEXPnJ73bzUZt4dcc3ZfKZZzZNu8osaky8ogDJz00sK7jPYsnU8ThTzRcFCOuwCgMUIFXYA3qWAgQoGQ6hpPqGRFy9k99NfGQTr\/7s9jtkbOTUNvGhNfGKAsRhY0ayhPsskkSdCDPVfFGAsA6rMEABUoU9oGcpQICS4RBKqm9IxNU9+d3ERzbx6rp\/\/qY8PeNFbeJDc+IVBYjDxoxkCfdZJImiAIkrUYnnC61vUIBEuT3ag6YAiSuRaI1Aiz3i6sxkN\/GRrf7sd78n9x871iY+tCdeUYBoVXl4O9xn4XNQJIJU88UbkCJVEH4tWh1SgISvCZUIKEBUaDQzgtYItIATVzuTvcTHV\/\/93+W2Z3e3iQ8fE68oQLSqPLwd7rPwOSgSQar5ogApUgXh16LVIQVI+JpQiYACRIVGMyNojUALOHE1M9lLfPzbU7+Qzz30UJv48DXxigJEq8rD2+E+C5+DIhGkmi8KkCJVEH4tWh1SgISvCZUIKEBUaDQzgtYItIAT1wtM9hIfO\/fvl0\/8+wNyZPKUNup9TbyiANGq8vB2uM\/C56BIBKnmiwKkSBWEX4tWhxQg4WtCJQIKEBUazYygNQIt4MR1nMle4uO5o0dl3QM\/kb2HDrXR7nPiFQWIVpWHt8N9Fj4HRSJINV8UIEWqIPxatDqkAAlfEyoRUICo0GhmBK0RaAEnrt7i49jkKfLJn\/1cfvb0022U+554RQGiVeXh7XCfhc9BkQhSzRcFSJEqCL8WrQ4pQMLXhEoEFCAqNJoZQWsEWsD7HVevm49JQ0PyxQMH5a777m+j22LiFQWIVpWHt9Pv+yx8BopFkGq+KECK1UHo1Wh1SAESuiKU\/FOAKBFpZAatEWjB7mdceeLjzlNmy5e+\/o02qq0mXlGAaFV5eDv9vM\/Cs188glTzRQFSvBZCPoFWhxQgIatB0TcFiCKZBqbQGoEW5H7FlSc+nvjl18r1n\/lsG82WE68oQLSqPLydft1n4ZkvF0Gq+aIAKVcPoZ5Cq0MKkFCVoOyXAkSZUM\/m0BqBFtx+xJUnPo5c\/Ovy\/\/7ljTI2NtZGs+XEKwoQrSoPb6cf91l41stHkGq+KEDK10SIJ9HqkAIkRBV48EkB4oFUjybRGoEW1H7DlSc+ZvzWu+T\/+Yu1smvXrjaKrSdeUYBoVXl4O\/22z8IzXi2CVPNFAVKtLqyfRqtDChDrCvDkjwLEE7GezKI1Ai2Y\/YQrT3yc8e4l8pEbPy4PPfRQG70hJl5RgGhVeXg7\/bTPwrNdPYJU80UBUr02LC2g1SEFiGX2PfqiAPFIrgfTaI1AC2K\/4MoTH3Ov+W9y4y1\/K1u2bGmjNtTEKwoQrSoPb6df9ll4pnUiSDVfFCA69WFlBa0OKUCsMu\/ZDwWIZ4KVzaM1Ai14\/YDLRXz8w7\/eKRs3bmyjNeTEKwoQrSoPb6cf9ll4lvUiSDVfFCB6NWJhCa0OKUAssm7ggwLEgGRFF2iNQAta6rjOP+88+fkXPi8HHnmkjbLsdz6ym48fPPGkrF69uu3fQ0+8ogDRqvLwdlLfZwsXLgxPsmIEqeaLAkSxSAxModUhBYhB0i1cUIBYsKznA60RaCFLGdf44cNy2r\/d21N8PH70mKxYsQJy4hUFiFaVh7eT8j7L2KUACV9jLhFQgLiwhLMGrW9QgODURqVIKEAq0Wf+MFoj0CIgVVzb7rpLjn3j6zJz7GDXm48DJ8+UpUuXwk68ogDRqvLwdlLdZ8QVvraKREABUoSt8GvR9hcFSPiaUImAAkSFRjMjaI1AC3iKuLLvfGy7bo2MP\/WkZN\/haHzVP3Y15aw5smzZMuiJVxQgWlUe3k6K+yxjlbjC11aRCChAirAVfi3a\/hrYtm3beCdaduzYUfvrBQsWhGdNMYJUcW3YsEGyP9lryZIltT8pvFLNF3HFUZ3Zx66ym4+9D\/6kFvDJJ5\/8QuBTpsjk3\/hNGTj9dFm\/fr1s3769DdTpp58u1157rWTf\/0B83XrrrbWwLrvsMsTwSseU6v6qE5IqPuIqXfJBHmT\/CEJ7aado+4sCpHQqsR6kAMHKR140aI0gL17Xf08JV118ZDcfzz33XLMAaRAfmzdvlk2bNrVRNGPGjJr4mDVrlit95ut4gDCnXMVhSvuskRDiUikPMyPsH2ZUqzhC21\/8CJZKWsMb4UewwuegSARoV6FFYu+1NhVcraN29+zZU4OdfQSr\/rGr6ee8RLZu3RrNxKtOeeNHKLQq39ZOKvuslTXisq2jqt7YP6oyaPs82v6iALHNvzdvFCDeqPViGK0RaIFMAVen3\/moC5BTTjutNmo3Ex\/ZL5zHNPGKAkSrysPbSWGfdWKRuMLXVpEIKECKsBV+Ldr+ogAJXxMqEVCAqNBoZgStEWgBjx1Xtx8ZrAmQKVPkNf\/30pr42LVrV3QTryhAtKo8vJ3Y91k3BokrfG0ViYACpAhb4dei7S8KkPA1oRIBBYgKjWZG0BqBFvCYcfX6hfM9+\/fXvnB+4VvfKocPH45y4hUFiFaVh7cT8z7rxR5xha+tIhFQgBRhK\/xatP1FARK+JlQioABRodHMCFoj0AIeK65e4iP7zsfeC19fm3aV\/UDamjVrZMuWLW2UzZs3T9auXStDQ0NadHq3wwOEd4q9OIh1n+WRQVx5DGH9O\/sHVj7yokHbXxQgeRmL5N8pQCJJ1Ikw0RqBFnsx4soTH9l3Pn749DM1ih544AHZuHFjG13Zl9PXrVsnIyMjWlSa2OEBwoRmdScx7jMXEojLhSWcNewfOLlwiQRtf1GAuGQtgjUUIBEkqSFEtEagxV5suFzER\/adjwzXfffdJ1\/60pfaqMp+4yO7FRkdHdWi0cwODxBmVKs6im2fuYInLlemMNaxf2DkwTUKtP1FAeKaOfB1FCDgCWoJD60RaLEXEy5X8ZFx8+Uvf1n+8i\/\/Uk466aQ2qlauXCmLFy\/WotDUDg8QpnSrOYtpnxUBTVxF2Aq\/lv0jfA6KRIC2vyhAimQPeC0FCHByOoSG1gi02IsFVxHxkU28uvrqq2Xv3r213wFpfF1++eVyzTXXaNFnbocHCHPKVRzGss+KgiWuooyFXc\/+EZb\/ot7R9hcFSNEMgq6nAAFNTJew0BqBFnsx4CoiPuoTr77\/\/e\/XKGoUIIsWLZJVq1bJwMCAFn3mdniAMKdcxWEM+6wMUOIqw1q4Z9g\/wnFfxjPa\/qIAKZNFwGcoQACT0iMktEagxR46riLiI+OkPvGq8ZfQs7+PceJVpxzzAKFV+bZ20PdZWTaIqyxzYZ5j\/wjDe1mvaPuLAqRsJsGeowABS0hOOGiNQIs9ZFxFxcfNN988MfGqUYDEOvGKAkSrysPbQd5nVdghrirs2T9LAWLPeRWPaPuLAqRKNoGepQABSoZDKGiNwCFkpyWouIqKj61bt8rq1asnMNcFSDZmN9aJVxQgTiUcxSLUfVaVPOKqyqDt8xQgtnxX9Ya2vyhAqmYU5HkKEJBEOIaB1ggcw85dhoirqPh46KGHZMWKFTI2NtYmQD72sY9FO\/GKAiS3fKNZgLjPNMgjLg0W7WxQgNhxreEJbX9RgGhkFcAGBQhAEgqEgNYICoTecykarqLiI5t4tXTpUsn+s\/GV3YC8+c1vlj\/+4z\/WogqNtWb6AAAgAElEQVTCDg8QEGkoHATaPisMoMsDxKXFpI0d9g8bnrW8oO0vChCtzAa2QwESOAEF3aM1goLhd12OhKuo+KhPvMpuQFpfc+fOlfe+971y4YUXalEFYYcHCIg0FA4CaZ8VDr7HA8SlyaZ\/W+wf\/jnW9IC2vyhANLMb0BYFSEDyS7hGawQlIHR8BAVXUfGRgalPvGoFlk28es973iPZL54vXLhQiyoIOzxAQKShcBAo+6xw4DkPEJc2o37tsX\/45VfbOtr+ogDRznAgexQggYgv6RatEZSE0fYYAq4y4qNx4lUjqPrEq0ceeaT21xQgWpXi1w5CHfpEmCo+4vJZNfq2KUD0OfVpEW1\/UYD4zLahbQoQQ7IVXKE1AgVINROhcZURH1u2bKndfrS+shuP+sSr0Li08tNqhwcIX8z6tZtqPRKX37rRts7+oc2oX3to+4sCxG++zaxTgJhRreIIrRGogAosQMqIj+z7HsuWLZPs+x+tr5UrV05MvEo1XzxAaFW+rZ1U65G4bOuoqjf2j6oM2j6Ptr8oQGzz780bBYg3ar0YRmsEWiBD4SojPrpNvMq4uPzyy+Waa66ZoCUULq28dLPDA4Rvhv3YT7UeictPvfiyyv7hi1k\/dtH2FwWInzybW6UAMae8kkO0RlAJTMPDIXCVER+HDh2S5cuXS6eJV4sWLZJVq1bJwMAABYhWYRjbCVGHlhBTxUdcllVU3RcFSHUOLS2g7S8KEMvse\/RFAeKRXA+m0RqBFkRrXGXER4Y1+5Xz7NfOW1\/ZxKu1a9fK0NBQ0z9Z49LKR54dHiDyGML891Trkbgw661bVOwfceULbX9RgMRVP12jpQCJK5FojUCLPUtcZcXHxo0bJZt61fqqT7waGRlp+zdLXFq5cLHDA4QLS3hrUq1H4sKrtV4RsX\/ElS+0\/UUBElf9UIAkki+0RqBFqxWusuLDZeJVJy6scGnlwdUODxCuTGGtS7UeiQurzvKiYf\/IYwjr39H2FwUIVn2UjoY3IKWpC\/IgWiPQIsECV1nx4TrxigJEqxrC2bGow3Dowo+79oU91byliosCxNdO8GMXrQ4pQPzk2dwqBYg55ZUcojWCSmAaHvaNq6z4KDLxigJEqxrC2fFdh+GQHfecKj7iCl1ZxfxTgBTjK\/RqtP1FARK6IpT8U4AoEWlkBq0RaMH2iaus+Cg68YoCRKsawtnxWYfhUL3gOVV8xIVQXe4xUIC4c4WwEm1\/UYAgVIVCDBQgCiQamkBrBFrQfeEqKz4yXEUnXlGAaFVDODu+6jAcombPqeIjLpQKc4uDAsSNJ5RVaPuLAgSlMirGQQFSkUDjx9EagRZ8H7iqiI8yE68oQLSqIZwdH3UYDk2751TxERdSleXHQgGSzxHSCrT9RQGCVB0VYqEAqUBegEfRGoEWBdq4qoiPshOvKEC0qiGcHe06DIeks+dU8REXWqX1jocCJK58oe0vCpC46qdrtBQgcSUSrRFosaeJq4r4qDLxigJEqxrC2dGsw3AountOFR9xIVZb95goQOLKF9r+ogCJq34oQBLJF1oj0KJVC1cV8VF14hUFiFY1hLOjVYfhEPT2nCo+4kKtuM5xUYDElS+0\/UUBElf9UIAkki+0RqBFqwauKuJDY+IVBYhWNYSzo1GH4aLP95wqPuLKzz3SCgoQpGzkx4K2vyhA8nMWxQp+BCuKNE0EidYItNiriquK+MgwaEy8ogDRqoZwdqrWYbjI3Tynio+43PKPsooCBCUTbnGg7S8KELe8wa+iAIFPUVOAaI1Ai70quKqKD62JVxQgWtUQzk6VOgwXtbvnVPERl3sNIKykAEHIgnsMaPuLAsQ9d9ArKUCg09MWHFoj0GKvLK6q4kNz4hUFiFY1hLNTtg7DRVzMc6r4iKtYHYReTQESOgPF\/KPtLwqQYvmDXU0BApuajoGhNQIt9srgqio+tCdeUYBoVUM4O2XqMFy0xT2nio+4itdCyCcoQEKyX9w32v6iACmeQ8gnKEAg09I1KLRGoMVeUVxVxYePiVcUIFrVEM5O0ToMF2k5z6niI65y9RDqKQqQUMyX84u2vyhAyuUR7ikKELiU9AwIrRFosVcEV1Xx4WviFQWIVjWEs1OkDsNFWd5zqviIq3xNhHiSAiQE6+V9ou0vCpDyuYR6kgIEKh25waA1gtyAHRe44jq4\/4B88zO3yJOPPyMvmbRfTp80NuFh0tCQzL3mv8n0c17S06uviVcUII7JBl7mWofAEPg\/YMSanA5xp1qPFCBxFSlaHVKAxFU\/XaOlAIkrkWiNQIu9PFyHjhyTb967U778j\/8q+54\/LjqmyjH53akPy8yBw+IqPnxOvKIA0aqGcHby6jBcZDqeU8VHXDr1YWWFAsSKaR0\/aPuLAkQnr8GtUIAET0GhANAaQaHgeyzuhisTHt+6\/0m57d7HZe+ze+XAz3\/WZOW1k5+Vt77oWaebD98TryhAtKohnJ1U91ed0VTxEVe4PVPGMwVIGdbCPYO2vyhAwtWCqmcKEFU6vRtDawRagFtx1YXH7T94XPYdPFJzc\/T559sEyLlTDsiK\/+s3cz92ZTHxigJEqxrC2Ul1f1GAhKupKp5TrUcKkCpVYf8sWh1SgNjXgBePFCBeaPVmFK0RaAGt43r1L58v3\/7hU\/KNex+bEB6NPg48+nM5un\/\/8b+aNEl+\/z9dIG94wy\/1DMNq4hUFiFY1hLOT6v6iAAlXU1U8p1qPFCBVqsL+WbQ6pACxrwEvHilAvNDqzShaI9ACetd3t8m9O8fk4X3TOwqPup\/xY8fk0DNPy6unjcl\/eufrZe7L5vYMwXLiFQWIVjWEs5Pq\/qIACVdTVTynWo8UIFWqwv5ZtDqkALGvAS8eKUC80OrNKFojqAr08NFj8i\/3Pyl\/e8f9cuDwuAwPD3c1OTAwIBfMny1vXThHTh+e5uTacuIVBYhTSqAXpba\/WslOFR9xQW+rtuAoQOLKF9r+ogCJq366RksBElci0RpBWfbqwuO2Hzwhzx04LHv27KmZ6iRAMuFx\/rmnyNsuPNtZeGS2rCdeUYCUrQac51LZX90YTRUfceHsIZdIKEBcWMJZg7a\/KEBwaqNSJBQglegzfxitERQloCY8fviU3J5NtTpweOLxTgKkLjwuveAsOfOUkwq5CjHxigKkUIogF8e+v\/JITRUfceVlHuvfKUCw8pEXDdr+ogDJy1gk\/04BEkmiToSJ1ghc2cuER\/bl8to43QbhUX++VYBcMP9UufSCMwsLj8xeqIlXFCCu1YC7Ltb95cpoqviIy7UCMNZRgGDkwTUKtP1FAeKaOfB1FCDgCWoJD60R5LGXJzwaBcj4+LhcfMF8eWuJG4+6nZATryhA8qoB\/99j219FGU0VH3EVrYSw6ylAwvJf1Dva\/qIAKZpB0PUUIKCJ6RIWWiPoxp6r8Kg\/f9rQ8\/KGc6fLJb+6qHRCQk+8ogApnTqYB2PZX2UJSxUfcZWtiDDPUYCE4b2sV7T9NbBt27bxTmB27NhR++sFCxaUxQr5XKq4NmzYINmf7LVkyZLanxReqeYLHdeRY+Pyb4+NyfceOSDPH+rYIibKK7vxGH3xUE14PPWzH1fuG5\/97Gflvvvuayvf008\/Xa699loZHBw0L230fJUl5NZbb609etlll5U1Aflcqvmqk50qPuKC3E5dg2L\/iCtfaPuLAiSu+ukaLQVIXIlEawR19jLhcd9jh+S7jzzvKDymyhvOnSanvmhKzURVXJs2bZLNmze3JXPGjBk18TFr1qwgia6KK0jQDk55gHAgCXBJqvVIXIDF1iMk9o+48oW2v\/gRrLjqp2u0\/AhWXIlEuwrNPmr1nR2\/kK\/f+5jsff6FqVbdWH3tuafIpRfMkTmzm6daVcGFMvGqE+YquJArkx+hQM5O99hSrUfiiqse2T\/iyhfa\/qIAiat+KEASyRdKI8iEx7\/+KBMej8ue\/Ydy2e0mPOoPlsWFNPGKAiS3DOAXlK1DeGAnAkwVH3HFUoHH46QAiStfaPuLAiSu+qEASSRfoRtBUeHxyy85pfbL5a03Hq3pKIMLbeIVBUj8m6xMHcaEOlV8xBVTFVKAxJUtEbT9RQESWwV1iZcfwYorkaEaQfYdj+\/seEq+vv0x2ePwUavXnDOr9svlecKj7A0I4sQrCpC49lI\/5avsPoslo6H6om9+UsXFGxDflaNrH60OKUB08xvMGgVIMOpLObZuBJnw+NcdT8lmT8Kj7MFo9erVsnXr1jYO582bJ2vXrpWhoaFS\/Go\/ZJ0v7fi72eMBwoppXT+p1iNx6daJb2vsH74Z1rWPtr8oQHTzG8waBUgw6ks5tmoENeGRfcdj+2Oy2+E7Hq855\/hHrc4+tfnL5a4gi+DauHGj3HzzzW2mh4eHZd26dTIyMuLq1vu6Iri8B6PogAcIRTINTaVaj8RlWEQKrtg\/FEg0NIG2vyhADJPv0xUFiE929W37bgRFhcers49aLTy7tPAoegOCPPGqU7Z950u\/wtws8gDhxhPaqlTrkbjQKq13POwfceULbX9RgMRVP12jpQCJK5G+GsFx4fGUfOPex+XZfflTrc6bN0vefmF14VFEgKBPvKIAiWsv9VO+iuyzGLPoqy+G5iJVXBQgoSurmH+0OqQAKZY\/2NUUILCp6RiYdiPIhMedtXG6jwURHq4HoxgmXvXTgZYHiLj6hus+ixMV3pQeLR61+71WXFXtsH9UZdD2ebQ6pACxzb83bxQg3qj1YlirERw5ekzueuBp2fz9x+RZh+94aN94tJLTC1eviVcXXHCBfPSjH5WBgQEvfFc1qpWvqnFoP88DhDajNvZSrUfisqkfLS\/sH1pM2thB218UIDZ59+6FAsQ7xaoOqjaCosLjVfNmyTsUP2rVjYxeuHpNvLrhhhtk+vTpqhxrGquaL81YNG3xAKHJpp2tVOuRuOxqSMMT+4cGi3Y20PYXBYhd7r16ogDxSq+68bKNoC48sqlWuxy+45EJj7decJacc9oMdQydDHbDFdPEqyK4TEj16IQHCI\/kejRdtn94DEnFNHGp0GhmhP3DjGoVR2j7iwJEJa3hjVCAhM9BkQiKNoJMeGz98fGPWjkJj7nDtXG6VsKjjr0Trm4Tr6ZMmSLXXXedjI6OFqEuyNqi+QoSZAmnPECUIA3gkVTrkbgAiqtACOwfBcgCWIq2vyhAAIpCIwQKEA0W7Wy4NoK68Pj69sflmefGcgN81dxZ8taFdjcerQG14uo18erDH\/6wXHzxxbmYEBa45gsh1iIx8ABRhC2ctanWI3Hh1JhLJOwfLizhrEHbXxQgOLVRKRIKkEr0mT+c1wgy4fHdHz9T++XyGIRHpxuQWCdedSqGvHyZF5CSQx4glIg0NpNqPRKXcSFVdMf+UZFA48fR9hcFiHEB+HJHAeKLWT92uzWCo8fG5bsnPmr1tMONxy\/NHZa3BfioVTdW6rhe\/epXy\/LlyyW7AWl9oU+8ogDxU\/OWVtHeaLWxp4qPuLQrxa89ChC\/\/GpbR9tfFCDaGQ5kjwIkEPEl3bY2gqLCY8HZw\/L2C+2\/45EHt47ra1\/7mmzdurVt+bx58wR94hUFSF6W8f8d7Y1Wm7FU8RGXdqX4tUcB4pdfbeto+4sCRDvDgexRgAQivqTbeiN47fkXTHy53OWjVq+cM1PeduHZcu6LbaZaFYWX4dq0aZPcddddbY8ODw\/LunXrZGRkpKjZ4OvRGrcWITxAaDFpayfVeiQu2zqq6o39oyqDts+j7S8KENv8e\/NGAeKNWi+Gv7ftbtnxxJg8uO9FTt\/xQBcedZI++9nPyvr16yUTG42vmCZe8QbES8mbGkV7o9UGnyo+4tKuFL\/2KED88qttHW1\/UYBoZziQPQqQQMQXdJt91Op7P3lG\/ubr22XvwfG2g3qruVfOGZa3XTgH9sajMd7s+x7ve9\/75MiRI224Ypp4RQFSsKgBl6O90WpTlCo+4tKuFL\/2KED88qttHW1\/UYBoZziQPQqQQMQ7uj02nn25\/BnZ9P2d8vTeMdmzZ0\/tydabgrq5V8yZKW8H\/qhVK+z6xKuHH364Ddfll18u11xzjSNTmMvQGrcWSzxAaDFpayfVeiQu2zqq6o39oyqDts+j7S8KENv8e\/NGAeKN2kqGjwuPp2Xz9sflF3sOTtjqJkBiEx4ZoEOHDk1MvGrFFePEK96AVCp5iIfR3mi1SUkVH3FpV4pfexQgfvnVto62vyhAtDMcyB4FSCDiu7jNhMf3shuP7Y81CY\/68taD+svPmlkbp\/vSM07GAuIQzerVqycmXjXiinXiFQWIQ9LBl6C90WrTlSo+4tKuFL\/2KED88qttHW1\/UYBoZziQPQqQQMS3uJ0QHt\/fKb\/Y2\/2Xy+sH9dcvmCtvjVR4ZNA3btwoN998c9vNTiY+Yp14RQGCsZeqRIH2RlsFSz\/VY6p5SxUXBYj2zvZrD60OKUD85tvMOgWIGdUdHWXCY9tPnpGv3dNbeNQfPnlgv\/yH+SfJO359UdjAK3jfsmWLrFmzpslCJqwmT54s2RvT6OhoBetYj6I1bi12eIDQYtLWTqr1SFy2dVTVG\/tHVQZtn0fbXxQgtvn35o0CxBu1PQ3Xhcem7z8mTzV8x6PbQ\/WPWu3e+UBtycKFC8MEXtFrNvFq2bJlcvjw4TYB8u53v1t+\/\/d\/v6IHrMfRGrcWOzxAaDFpayfVeiQu2zqq6o39oyqDts+j7S8KENv8e\/NGAeKN2o6Gjx0bl7sfym483ITH6Jkn16Za1b\/jgdYIirBXn3iV\/Wfr68ILL5S3v\/3t0QqrbjzEnK9eueUBokjl46xNtR6JC6fGXCJh\/3BhCWcN2v6iAMGpjUqRUIBUos\/54brwyG48ntz9wlSrbgYywfHO170gPOrr0BqBKwGNE69an8kmXr3jHe+QgYEBChBXQgOv4wEicAJKuo+1f+TBJa48hrD+nf0DKx950aDtLwqQvIxF8u8UIH4TlQmPex7aJV\/7\/k4n4TF65ky59IKzJPvIVacXWiNwZa9x4lXjM\/WJVz\/84Q9rfx3rR8u68RBrvvLyygNEHkOY\/55qPRIXZr11i4r9I658oe0vCpC46qdrtBQgfhJZEx4P75Kv3b1TnnT4jsfLzjxZLr1gjryii\/CI+QakdeJVHUv2Y4r1iVdoDU6rKlLFxQOEVoXY2km1HonLto6qemP\/qMqg7fNo+4sCxDb\/3rxRgOhSWxcem+7ZKU84ftQqG6ebJzxiFSCdJl5lWKZMmSLXXXfdxMQrtAanVRWp4uIBQqtCbO2kWo\/EZVtHVb2xf1Rl0PZ5tP1FAWKbf2\/eKEB0qC0jPLIfEOz2UatuUaE1gl7sdZt4lT3z4Q9\/WC6++OKJx2PCVaRiUsXFA0SRKsBZm2o9EhdOjblEwv7hwhLOGrT9RQGCUxuVIqEAqUSfjI\/Xv+PxmDzx7IFcY\/NPnyFvW3i2vGJO5+945BlAawTd4u018eryyy+Xa665punRWHDl5af131PFxQNE0UrAWJ9qPRIXRn25RsH+4coUxjq0\/UUBglEXlaOgAClHYWHhccbJ8tYLzpJXzhku5\/DEU2iNoBOYvIlXH\/3oR2sTrxpfMeAqk7hUcfEAUaYawj+Taj0SV\/jaKhIB+0cRtsKvRdtfFCDha0IlAgqQYjRmwuP7Dz9b+x2Px599Pvfh+UrCo+4IrRF0IiBv4tX06dPbHosBV26yOyxIFRcPEGWqIfwzqdYjcYWvrSIRsH8UYSv8WrT9RQESviZUIqAAcaPxuPDYJV+753En4XHuiY9avbLkR626RYXWCFrjdJl41QkbOi63KmlflSouHiDKVkTY51KtR+IKW1dFvbN\/FGUs7Hq0\/UUBErYe1LxTgPSmMhMe2x9+Vr56z0553OE7Hue+eIZkU60WnF3to1YxChDXiVcUIGrbN5ghHiCCUV\/JMdpBohKYhoeJS4tJGzvsHzY8a3lB218UIFqZDWyHAqRzAurC42vff0we25X\/USvfwqMeJVojqMdVZOIVBUjgTa\/gngcIBRIDmEDtH1WpIK6qDNo+z\/5hy3dVb2j7iwKkakZBnqcAaU5EJjzu\/enu2o2Hq\/DIfkDwl+b6ufFoLRO0RpDFV3TiFQUIyOavEAYPEBXIC\/goYv\/QoIO4NFi0s8H+Yce1hie0\/UUBopFVABsUIMeTcFx4HP9y+U6HG4+XvHiGXHrBWfKqubNMs4jWCMpMvKIAMS0ZL854gPBCq3ejaP1DCzBxaTFpY4f9w4ZnLS9o+4sCRCuzge30uwCJRXjUywStEZSZeEUBEnjTK7jnAUKBxAAm0PqHFgXEpcWkjR32Dxuetbyg7S8KEK3MBrbTrwKk\/lGrr92z0+nG45zTXiRvXXi2vMroo1bdygKpEZSdeEUBEnjTK7jnAUKBxAAmkPqHJnzi0mTTvy32D\/8ca3pA218UIJrZDWir3wRIJjx+8MhuyYTHo8\/kf7n8nNNm1H5A8FXzbD9qhS5Aqky8ogAJuOGVXPMAoUSksRm0g4QWfOLSYtLGDvuHDc9aXtD2FwWIVmYD2+knAZIJj6\/e\/aiz8Mi+43EeiPColwlCI6g68YoCJPCmV3DPA4QCiQFMIPQPH7CJywer\/myyf\/jj1odltP1FAeIjywFs9oMAqd94\/Pzp\/bkMz8s+anXBHDjhgSJANCZeUYDkliH8Ah4g4FPUMUC0g4QWi8SlxaSNHfYPG561vKDtLwoQrcwGtpOyAHnw6UPy8PMzxUV4zB15kbxtIa7wQBAgWhOvKEACb3oF9zxAKJAYwATaQUKLAuLSYtLGDvuHDc9aXtD2FwWIVmYD24lZgBw6elj2HNgrzx18Tp4b2yd7Dzwne8f2yc+eeUZu3\/4jOXhoipw245fkRZPP7sry2aeeVPty+WvOwfiOR145hGwEWhOvKEDysoz\/7zxA4OeI+yzOHDVGHbLf+2SP\/cMnu\/q20eqQAkQ\/x0EsIgqQ5w89L3syUXFwX01c7M3+nBAYmdCoC46Dh8faODtw6Kg8+MRzcvjw4dq\/DU4ZlJecdJlMGTipaW0mPN628Gx5dSTCI\/QNiObEKx6Mgmx1Vac8QKjSaWYM7SChBZy4tJi0scP+YcOzlhe0\/UUBopXZwHYsBcjuA3tqoqImKE7cWjT994P7JFtT5fXk7gPyi71jLwiQwUEZGVoos6YsqJnNPmqVfccjNuERUoBoT7yiAKlS4RjP8gCBkYeiUaAdJIrG3209cWkxaWOH\/cOGZy0vaPuLAkQrs4HtVBUgh7OPQWWCovZRqH21m4qJW4uayNhf+7f9h\/JH3mpQ8dyBw\/LIL\/a3CJBF8uozXhu18AglQHxMvKIA0aj0sDZ4gAjLf1nvaAeJsjhanyMuLSZt7LB\/2PCs5QVtf1GAaGU2sJ1uAqTKx6ACQ5Indh+Qx5\/ZVwtj5OTT5No3\/4G8\/mVnhQ5Lxb9lI\/A18YoCRKUUghrhASIo\/aWdW\/aP0kGWeJC4SpAW8BH2j4Dkl3CNtr8oQEokEe2Rx\/Y8Idd\/5i\/kq7d\/TQamTpLXv3GRvPy8V1T+GJQlzpOnzZAZU2fI8LST5eTsP6fPlBlTXyQP\/PhRGZIXyZL\/eKllON59WTUCnxOvKEC8l4l3BzxAeKfYiwOr\/uEl+B5Gicua8Wr+2D+q8Wf9NNr+ogCxrgBlfw889aD89XfWS\/YRmwcffLBm\/aUvfanMnz9f2VM5c7OmD8vMTFRMOyEuJv7\/4wIjExrZv3d7oW2Yciy0P2WFy+fEKwoQrWoIZ4cHiHDcV\/Fs1T+qxFjmWeIqw1q4Z9g\/wnFfxjPa\/qIAKZNFoGf+fvtX5M6Hv2cqQKZOmSozp804ISxOnhAYM6fOkJnTZ9ZuMDLB8aKh5olVZWhD2zBlMIQ6qPueeBUKl1YOithJtQ55gChSBThrU61H4sKpMZdI2D9cWMJZg7a\/Bm644YbxTvQ8+uijtb8+++zuv72AQ6t7JKnh+pk8Lj+XJ+SZZ56p\/clep556au1P0deU8ckyNDAkQ+NTZGhgUIZksPZ\/9f8+OD5Fpg4MySSZVNR06fWp5atOhG9cDz\/8sNxxxx1tvE+aNEne\/va3y8jISOmc9HrQNy4vQTsYTRXXXXfdVUN\/0UUXObAQz5JU82XVP0JlOtW8pYqL\/SPUTinnF60OB84888yOAmTi9xcGB8shBX0qNVyTTposp15ythw9erT2J3tNnjy59qf2OjYuRw8elWPZn7GjMn7w6PH\/Pnb8744eOCLjY8dq\/106VkLYRKaWrzqbPnFldbB3714ZH29P6IwZM2RoaMhbUn3i8ha0g+FUcT3\/\/PGpdiedVP220oFGsyWp5suif5glqYOjVPOWKi72j5C7pbhvtDqkACmeQ7gnJr9oioyfMkkOjh2UIweO1G4upk4aqomNY4eOwcVbJCC0DVMk9l5rfeE6duxYTXxk\/9n6mjZtmveDpi9cWryXtZMqLh4gylZE2OdSrUfiCltXRb2zfxRlLOx6tP3Fj2CFrQc179\/61rck+5O93vSmN9X+pPBCuzLU4tQHruzm4ytf+YpkY3dbX3PmzJFLLrlEBgYGtCB0tOMDl9eAHY2niosfoXAsALBlqdYjcYEVWk447B9x5Qttf\/FL6HHVT9doq\/4QISoNaF+a0uLJBy7riVeduPCBS4vzKnZSxcUvkVapinDPplqPxBWupsp4Zv8ow1q4Z9D2FwVIuFpQ9UwBokqnd2PajSDExCsKEO9l4t0BDxDeKfbiQLt\/eAmyhFHiKkFawEfYPwKSX8I12v6iACmRRMRHKEAQs9I9Js1GsGXLFlmzZk2bsylTpsh1110no6OjZuRo4jIL2sFRqrh4gHBIPuCSVOuRuACLrUdI7B9x5Qttf1GAxFU\/XaOlAIkrkVqNIPsBymXLlkn9y2WNLHz4wx+Wiy++2JQYLVymQTs4SxUXDxAOyQdckmo9EhdgsVGAxJWUHgrJqUEAACAASURBVNGi7S8KkERKiwIkrkRqNILsy+ZLly7t+KXzyy+\/XK655hpzUjRwmQft4DBVXBQgDskHXJJqPRIXYLFRgMSVFAoQ3Hyl2uAoQHBrrlNkVevw0KFDsnz5csluQFpfF1xwgXz0ox\/1PvHKBy7ULFbNFyquVONKPV+p4iOuuHYk\/weMuPKFtr94AxJX\/XSNlgIkrkRWbQQIE68oQOKquX6Ktur+QucqVXzEhV55zfFRgMSVL7T9RQESV\/1QgCSSryqNAGXiFQVIIsX4\/7f3NbB6n2X5z1lPtnWUlcHRDZYekNnp0S2Rthg1ohynIsmGcJolSputReJwZBk7beP8mFSZxdYSK0PYFJKVdR9RqXOYyNcUtAgN\/WsNG0WzTZiUj8g0nSOLtNh\/np+cw\/l4z3l\/7\/tc9\/Xcv\/tcb9IA3e+57ue+7uu+ea697\/u8AdMo6a8u0BE1P+XVBfV9Z48yIN2ql7f+kgGppJ\/8S9Xvfe9708GDB9O\/\/Mu\/pPyLouPj4+m1r31t2rFjR\/qu7\/qugXamd0AGoqv6w8MOAk83XsmAVJfRUBt46qmn0tjYWN+173nPe9Kb3vSmvs95fGDY\/vKYi\/qsK1VZep9d1eNjjz2Wpqam0mc\/+9n0qle9Kn3oQx+al2QvA4I+29Soflfr1Y8rb3nJgPSrmME\/\/5\/\/+Z90zTXXpI9+9KM90V\/0ohelD3\/4w+mKK65oHV0GpDVVLh4cZhB4u\/FKByMXUhp4E\/lfeHz\/939\/33UyIH0pqvbAMPOj2mYHCKy8BiDL+NGHHnooXXfddenUqVNNpKUMyMaNG1P+k18WZxvjNHvCS4cc1mVAODzPi3LTTTeld73rXc3fvfnNb05vfOMb03Of+9z0D\/\/wD80Xi7\/2ta+l7\/3e703\/\/M\/\/nC644IJWO5QBaUWTm4cGHXAeb7ySAXEjp4E28slPfjL9+I\/\/eLMmHzIuuuiinuvzDLrkkksGwvby8KD95WXfbfcRNT\/l1VYBds\/ldzB+67d+K+3ZsyedPXu2+TTGf\/zHfyxpQLZt25bOPffcZkMWZxu7TJdGlg45rMuAcHiejfLkk0+myy67LJ05c6Zp1ne+853zdvDII480\/zYh33L0B3\/wB+ktb3lLqx3KgLSiyc1Dgww4rzdeyYC4kdNAG\/nLv\/zL5qOeIyMjzZzJP1gZ7TVIf3Ux96j5Ka+6aswfz3z961+fPvKRjzTz4Xd\/93ebmxbzx8V7vQOSn\/vZn\/3ZZtNWZ5sajEiHHNZlQDg8z0bJ\/1bhN37jN9KqVavSyZMn08UXX7xoB\/ltz3vuuSdNTEykz33uc612KAPSiiY3Dw0y4LzeeCUD4kZOA23kfe97X\/Oua\/4eSP43mxFfg\/RXF\/OPmp\/yqqvGT3ziE+mqq65K5513Xrr77rvTtddem7Zu3ZruvffengYkfzfkyiuvbDZtdbapwYh0yGFdBoTD82yUn\/7pn04PP\/xw+pEf+ZH0qU99qmf0P\/\/zP28aP7++8IUvpBe\/+MV9dykD0pciVw+0HXCeb7ySAXElqdab2bt3b7r11lvTD\/zAD6RHH3209bouPdi2v7qU09y9Rs1PedVX5J\/8yZ+kl7\/85emHfuiHms3kH7X9wAc+0NOAfOUrX0kvfOELm+eszjY1GJEOOazLgHB4no2SP1Odv+Nxww03pDvvvLNn9HzzxPr165t\/9hd\/8RfNxyX6vWRA+jHk65+3GXDeb7ySAfGlqba7yd8z279\/f5qcnEx\/8zd\/03ZZp55r01+dSmjBZqPmp7z8qfJ1r3tdevDBB3sakLm7tTrb1GBEOuSwLgPC4bmJ8uyzz85+qfxtb3tb+s3f\/M2e0fNNEueff37zz37v934v\/eqv\/mrfXcqA9KXI1QP9BlwXbrySAXElqdab2b59e\/Pxil\/4hV9I999\/f3NzzenTp9NznvOc5nPfEV79+qvrOUbNT3n5U2b+F6D5e2O9vgMys1vLs00NRqRDDusyIByemyhf\/vKX06WXXtr89z\/6oz9KN95445LR861YzzzzTHMr1r59+\/ruUgakL0WuHlhuwHXlxisZEFeSar2ZfAX4X\/3VX83efvVf\/\/Vfzdr8ZfT8ee7Nmzc3t\/M973nPa43p7cGoB4gZnqPmp7y8dVJqPoHRz4BYnm1qMCIdcliXAeHw3ER5\/PHHm+t18yt\/EfQNb3jDktHz1Xdf\/\/rX06\/8yq+kd7\/73X13KQPSlyJXDyw14Lp045UMiCtJtd5MvjYz\/wDqcq\/8L0qySZn5HHhrcCcPRj1AyIA4EdiA2+iyHtsYEMuzzYBUQx7vcr2WI8BbXjIgELm2A8kfq8lX8OZXvtbul37pl5ZcmG+oyVfiyYD8v4ajmR86ase0\/6eWGgRduvFKBsS\/zpba4d\/+7d+m5z\/\/+Wl8fDxdeOGFzbut+Qrw\/C9G8sez8v3\/+Ya+\/KOFa9eu7Vyi3v6PFk1g1PyUF1op5XhtDIjl2aY8g8ERpMPBORtmhQzIMKwNuSZ\/+Xzmh73afgRrx44dzRdG+730Dkg\/hnz9814Drms3XsmA+NIUajcHDhxIt9xySwOXr9b8tV\/7NRQ0DSfqAWKGwKj5KS9ai7QO1MaAWJ5tWm8U+KB0CCRzGSgZEA7PTZT88ZrVq1en\/Eujbb+Enn8I6Nd\/\/df77lIGpC9Frh5YOOC6eOOVDIgrScE2k+fTunXrmu+svfKVr0z53ZKuvaIeIGRAuqbE\/9tvl\/XYxoBYnm1qVLzL9VqOL295yYCQ1f093\/M9zW97tL2GN99Sk2+r6feSAenHkK9\/PncQdPXGKxkQX5oaZjd\/\/Md\/3Cz75V\/+5XnLf+7nfi59+MMf7uxvhXj7P9phatOlgwQqv6h163JeyxmQbDzOPffcpvxWZxuUtgbB6XK9ujQ3ZEAGUSXg2ampqea3Pdr+EGH+XPYP\/uAP9o0sA9KXIlcPzAy4PLTzx13yzVcLX\/kHoK6\/\/npX++63GQ3ufgz5+ucf\/OAHU\/4xsYUGJP9GyMc\/\/vFl55SvTObvJqoOZ7KMmp\/y8tdVyxmQuT9EaHW2qcGIdMhhXQaEw\/NslPwro\/n\/7FetWpVOnjzZfNFz4eu6665L99xzT\/PPvvrVr7baoQxIK5rcPJQHXP7thfwOV34HZOFrw4YNaffu3Z37XQYNbjcSG3oj+U7\/PHv++7\/\/u5lVd91119BYtRZG1aEMSC1FlcXtsh6XMyA5r5kLYqzONmXMD7e6y\/VaLmNvecmADKfPoVedOnWquXnm6aefTjfddFN65zvfOQ\/r0UcfTfnwmd\/azD9AmH+IsM1LBqQNS36eyYMg3zj07\/\/+74s2lfWRLx7I3xfq2svbgEPxFyWvPHfOOeectGbNmiWp2blzZ8rzJL8efvjh9FM\/9VMoGmk4Ueq1FGFR81NetBZpHWg5A\/KBD3yg+d2g\/LI627TeKPBB6RBI5jJQMiAcnudF2bt3b7r11lubv3vLW97SXMebr8L85Cc\/mfKtV\/ltzXwNb\/74Va93SHptWQakQiELQubLBfJn7BdecZr\/d76FKNe\/iy8Nbt9VO3bsWMrf78gf78vG4oorrmh+kDB\/BPCxxx5rTHH+WFZ+ve51r0uHDx\/2ndASu4uqw5l0o+anvPy123IGJH+H7PWvf\/3sv9CwONvUYEQ65LAuA8LheV6UfMd+\/pjVoUOHekbPh9AHH3ywuYGm7UsGpC1T9Z\/LN17N3Gw214DkX6LOv3q\/fv36+psccgca3EMSR1r2j\/\/4j61+U+faa69tfg\/kggsuIO0MGyaqDmVAsDphoXVZj\/0MyOWXXz57VrE427BqNDdOl+u1HF\/e8pIBqaHub8fMn\/\/P\/wbhs5\/9bPrGN76R8q8Pv\/rVr27eBXnJS14y0M5kQAaiq9rDMzde5V+5z6+5BmR6ejrlL\/92+eVtwKG4jJTXRz7ykfTAAw+kz3zmM+nJJ59sZk82Gnn+\/NiP\/VjKv5T+ile8AkVdFZxI9epFYNT8lFeVdlk2aD8DkhcvvMQCebapwYh0yGFdBoTDs3kUGRBziosD5I+5zNx4lT8vO9eAdPHGKx2MiiUhACMGoh4gZuiKmp\/yMmoII9ilrvE2CkeDlQ45VMuAcHg2jyIDYk5xUYB8qcCuXbtmb7yaa0C6euOVDEiRJLTYkIGoBwgZEEPRGEJH1aMMiKFoDKC96VAGxKDINSBlQGqw3j7m7bffno4ePTq7YMaAXHnllZ298UoGpH399SSXAW\/\/R4vOPmp+ygutFFs8GRBbftHo3vpLBgRd4Up4MiCViG8R9r777mt+72PuKxuQfBXq+9\/\/\/s7eeCUD0qL4zh\/RAcJ5gZbYnreDBIpF5YVikoOj+cHhGRXFW3\/JgKAqWxlHBqRyAZYIn2+8ylcTLnw988wz6eabb075C36RXt4GHIrbqHnpAIFSCBcnqh6VF1dHpdE0P0oZ5K731l8yINz6m0WTATGjdmjgmRuv8i+eL3xdffXVadOmTa2uRB16AxUWehtwKAqi5qUDBEohXJyoelReXB2VRtP8KGWQu95bf8mAcOtvFk0GxIzaoYDn3ni1ECDfeJV\/AC6\/Nm7cOBS+10XeBhyKp6h56QCBUggXJ6oelRdXR6XRND9KGeSu99ZfMiDc+ptFkwExo3Zg4IU3Xs0FmLnxKv8gnAzIwNRWW+BtcKOI0AECxSQXJ6oelRdXR6XRND9KGeSu99ZfMiDc+ptFkwExo3Zg4IU3Xs0AjI+Pz9545W0QDJzkEguUF4pJDo4OEBye0VHUZ2hGbfGi1kvzw1Y3aHRvOpQBQVe4Ep4MSCXiF4TtdeNVfiT\/4vmBAwdmb7zyNghQ7CkvFJMcHB0gODyjo6jP0Iza4kWtl+aHrW7Q6N50KAOCrnAlPBmQSsTPCbvUjVejo6Np3759af369bNPexsEKPaUF4pJDo4OEBye0VHUZ2hGbfGi1kvzw1Y3aHRvOpQBQVe4Ep4MSCXivx12uRuvpqen0+Tk5LwNehsEKPaUF4pJDo4OEBye0VHUZ2hGbfGi1kvzw1Y3aHRvOpQBQVe4Ep4MSCXiU0r9bry6\/vrrF23O2yBAsae8UExycHSA4PCMjqI+QzNqixe1XpoftrpBo3vToQwIusKV8GRA6hDf5sarkZERGZA65YFF9Ta4UYnpAIFikosTVY\/Ki6uj0miaH6UMctd76y8ZEG79zaLJgJhRuyxwmxuvegF4GwQo9pQXikkOjg4QHJ7RUdRnaEZt8aLWS\/PDVjdodG86lAFBV7gSngwIn\/i2N17JgPBrg47obXCj8tMBAsUkFyeqHpUXV0el0TQ\/ShnkrvfWXzIg3PqbRZMBMaO2J\/AgN17JgHBrYxHN2+BG5agDBIpJLk5UPSovro5Ko2l+lDLIXe+tv2RAuPU3iyYDYkbtIuBBb7ySAeHVxiqSt8GNylMHCBSTXJyoelReXB2VRtP8KGWQu95bf8mAcOtvFk0GxIzaecDD3HglA8KpjWUUb4MblasOECgmuThR9ai8uDoqjab5Ucogd723\/pIB4dbfLJoMiBm1s8DD3nglA2JfG+sI3gY3Kl8dIFBMcnGi6lF5cXVUGk3zo5RB7npv\/SUDwq2\/WTQZEDNqZ4GHvfFKBsS+NtYRvA1uVL46QKCY5OJE1aPy4uqoNJrmRymD3PXe+ksGhFt\/s2gyIGbUNsAlN17JgNjWhoHubXCjctYBAsUkFyeqHpUXV0el0TQ\/ShnkrvfWXyPHjh0724uCEydONH89MTHBZcg4WtS8Dh06lPKf\/Nq6dWvzJ8LLQ72OHz+eDh48uIjOVatWpZtvvjmtW7duYKo95DXwplssUF4tSHL0yOHDh5vdTE1NOdpV+Vai6nCGmaj5Ka9y7TMRND+YbJfH8tZfMiDlNXWBIANiU4aTJ0+mAwcOpDNnziwKsGXLlrRp06ahAnsbBEMl0WOR8kIxycHRAYLDMzqK+gzNqC1e1HppftjqBo3uTYf6CBa6wpXw9BEsPPGoG6967czbW6Eo9pQXikkOjj5CweEZHUV9hmbUFi9qvTQ\/bHWDRvemQxkQdIUr4cmAYIlH3nglA4KtTQ00b4MbxYEOECgmuThR9ai8uDoqjab5Ucogd723\/pIB4dbfLJoMCJZa5I1XMiDY2tRA8za4URzoAIFikosTVY\/Ki6uj0miaH6UMctd76y8ZEG79zaLJgOCoRd94JQOCq00tJG+DG8WDDhAoJrk4UfWovLg6Ko2m+VHKIHe9t\/6SAeHW3yyaDAiG2iNHjqS9e\/cuAhsdHU379u1L69evhwTyNgggSaWUlBeKSQ6ODhAcntFR1GdoRm3xotZL88NWN2h0bzqUAUFXuBKeDEg58U888UTauXNnOn369CKw6enpNDk5WR7k2wjeBgEqMeWFYpKDowMEh2d0FPUZmlFbvKj10vyw1Q0a3ZsOZUDQFa6EJwNSRrzljVe9duZtEJSx953VygvFJAdHBwgOz+go6jM0o7Z4Ueul+WGrGzS6Nx3KgKArXAlPBmR44q1vvJIBGb42XlZ6G9woXnSAQDHJxYmqR+XF1VFpNM2PUga56731lwwIt\/5m0WRAhqfW+sYrGZDha+NlpbfBjeJFBwgUk1ycqHpUXlwdlUbT\/ChlkLveW3\/JgHDrbxZNBmQ4ahk3XsmADFcbT6u8DW4UNzpAoJjk4kTVo\/Li6qg0muZHKYPc9d76SwaEW3+zaDIgg1PLuvFKBmTw2nhb4W1wo\/jRAQLFJBcnqh6VF1dHpdE0P0oZ5K731l8yINz6m0WTARmMWuaNVzIgg9XG49PeBjeKIx0gUExycaLqUXlxdVQaTfOjlEHuem\/9JQPCrb9ZNBmQ9tQud+PV5s2b07Zt29qDDfmkt0EwZBqLlikvFJMcHB0gODyjo6jP0Iza4kWtl+aHrW7Q6N50KAOCrnAlPBmQdsTXuPFK74C0q43np7wNbhRXOkCgmOTiRNWj8uLqqDSa5kcpg9z13vpLBoRbf7NoMiDtqK1x45UMSLvaeH7K2+BGcaUDBIpJLk5UPSovro5Ko2l+lDLIXe+tv2RAuPU3iyYD0p\/aWjdeyYD0r433J7wNbhRfOkCgmOTiRNWj8uLqqDSa5kcpg9z13vpLBoRbf7NoMiDLU1vzxisZEDPZ04C9DW5U4jpAoJjk4kTVo\/Li6qg0muZHKYPc9d76SwaEW3+zaDIgS1Nb+8YrGRAz2dOAvQ1uVOI6QKCY5OJE1aPy4uqoNJrmRymD3PXe+ksGhFt\/s2gyIL2p9XDjlQyImexpwN4GNypxHSBQTHJxoupReXF1VBpN86OUQe56b\/0lA8Ktv1k0GZDF1Hq58UoGxEz2NGBvgxuVuA4QKCa5OFH1qLy4OiqNpvlRyiB3vbf+kgHh1t8smgzIYmq93HglA2Imexqwt8GNSlwHCBSTXJyoelReXB2VRtP8KGWQu95bf8mAcOtvFk0GZD61nm68kgExkz0N2NvgRiWuAwSKSS5OVD0qL66OSqNpfpQyyF3vrb9kQLj1N4smA\/Idar3deCUDYiZ7GrC3wY1KXAcIFJNcnKh6VF5cHZVG0\/woZZC73lt\/yYBw628WTQbk\/6j1eOOVDIiZ7GnA3gY3KnEdIFBMcnGi6lF5cXVUGk3zo5RB7npv\/SUDwq2\/WTQZkJS83nglA2Imexqwt8GNSlwHCBSTXJyoelReXB2VRtP8KGWQu95bf8mAcOtvFm2lGxDPN17JgJjJngbsbXCjEtcBAsUkFyeqHpUXV0el0TQ\/ShnkrvfWXzIg3PqbRVvpBsTzjVcyIGaypwF7G9yoxHWAQDHJxYmqR+XF1VFpNM2PUga56731lwwIt\/5m0VayAfF+45UMiJnsacDeBjcqcR0gUExycaLqUXlxdVQaTfOjlEHuem\/9JQPCrb9ZtJVqQLpw45UMiJnsacDeBjcqcR0gUExycaLqUXlxdVQaTfOjlEHuem\/9JQPCrb9ZtJVoQLpy45UMiJnsacDeBjcqcR0gUExycaLqUXlxdVQaTfOjlEHuem\/9JQPCrb9ZtJVmQLp045UMiJnsacDeBjcqcR0gUExycaLqUXlxdVQaTfOjlEHuem\/9JQPCrb9ZtJVkQLp245UMiJnsacDeBjcqcR0gUExycaLqUXlxdVQaTfOjlEHuem\/9JQPCrb9ZtJVkQLp245UMiJnsacDeBjcqcR0gUExycaLqUXlxdVQaTfOjlEHuem\/9JQPCrb9ZtJViQLp445UMiJnsacDeBjcqcR0gUExycaLqUXlxdVQaTfOjlEHuem\/9JQPCrb9ZtJVgQLp645UMiJnsacDeBjcqcR0gUExycaLqUXlxdVQaTfOjlEHuem\/9JQPCrb9ZtOgG5KKLLko7d+5Mp0+fXsTh9PR0mpycNOPWAtjbIEDlqLxQTHJwdIDg8IyOoj5DM2qLF7Vemh+2ukGje9OhDAi6wpXwIhuQp59+Ot19990p33y18LV58+a0bdu2SqwPH9bbIBg+k\/krlReKSQ6ODhAcntFR1GdoRm3xotZL88NWN2h0bzqUAUFXuBJeVAPy6U9\/Ov3hH\/5heuaZZxYxu2HDhrR79+40MjJSifXhw3obBMNnIgOC4q4Gjg4QNVgvj6n5Uc4hEyFqvTQ\/mCoqj+VNhzIg5TV1gRDVgNx4443pkUceSWvXrp3H8\/j4eNq\/f39avXq1C\/4H3YS3QTDo\/pd6XnmhmOTg6ADB4RkdRX2GZtQWL2q9ND9sdYNG96ZDGRB0hSvhRTQg+carO++8s2F0rgHJ\/\/3AgQNpbGysEtvlYb0NgvKM\/g9BeaGY5ODoAMHhGR1FfYZm1BYvar00P2x1g0b3pkMZEHSFK+FFMyAzN16dOnVqngEZHR1N+\/btS+vXr6\/ENCast0GAyUoGBMUjC0cHCBbT2DiaH1g+rdGi1kvzw1o5WHxvOpQBwda3GlokA\/LEE0\/M3ni10IB08carXqLwNghQwlVeKCY5ODpAcHhGR1GfoRm1xYtaL80PW92g0b3pUAYEXeFKeFEMSL7p6pZbbpm98WquAenqjVcyIJWaAhjW2+BGpaYDBIpJLk5UPSovro5Ko2l+lDLIXe+tv2RAuPU3ixbBgHzzm99Mu3btSvkdkJnXjAHJv\/PR1RuvZEDMZE8D9ja4UYnrAIFikosTVY\/Ki6uj0miaH6UMctd76y8ZEG79zaJFMCC33357Onr06DyOsgG5+OKL0\/vf\/\/7O3nglA2Imexqwt8GNSlwHCBSTXJyoelReXB2VRtP8KGWQu95bf8mAcOtvFq3rBiTfeHX\/\/fcv4udb3\/pW2rFjR7rqqqvMuKsB7G0QoDhQXigmOTg6QHB4RkdRn6EZtcWLWi\/ND1vdoNG96VAGBF3hSnhdNiAzN14tpC7feHX99dendevWpY0bN1Zi1iast0GAylJ5oZjk4OgAweEZHUV9hmbUFi9qvTQ\/bHWDRvemQxkQdIUr4XXVgMy98WohdfnGqwsvvLD5axmQSsIaMKy3ATfg9pd8PGpeOkCgFMLFiapH5cXVUWk0zY9SBrnrvfWXDAi3\/mbRumhAFt54NZecmRuvvDUMqoDKC8UkBydqvXSA4OgHHSWqHpUXWim2eJoftvyi0b31lwwIusKV8LpmQHrdeDVD3YYNG2ZvvPLWMKjyKi8UkxycqPXSAYKjH3SUqHpUXmil2OJpftjyi0b31l8yIOgKV8LrmgHpdeNVpm58fDzt379\/9sYrbw2DKq\/yQjHJwYlaLx0gOPpBR4mqR+WFVootnuaHLb9odG\/9JQOCrnAlvC4ZkKVuvFq7dm06cOBAGhsbm2XRW8Ogyqu8UExycKLWSwcIjn7QUaLqUXmhlWKLp\/lhyy8a3Vt\/jRw7duxsryRPnDjR\/PXExASag6p4UfM6dOhQyn\/ya+vWrc0fj6\/jx4+ngwcPLtraqlWr0s0339zceDX3FbVeysujOpfeU9R6HT58uEl6amqqWwXps9uo9ZpJO2p+yqtbbaj50a16eesvGZBu6WfJ3XbBgJw8ebJ5h+PMmTOL8tiyZUvatGnTor\/31jAouSgvFJMcnKj10gGCox90lKh6VF5opdjiaX7Y8otG99Zf+ggWusKV8Lx\/BKvNjVe9qPP2liGqvMoLxSQHJ2q99BEKjn7QUaLqUXmhlWKLp\/lhyy8a3Vt\/yYCgK1wJz7MBaXvjlQxIJfEAw3obcKjUoualAwRKIVycqHpUXlwdlUbT\/ChlkLveW3\/JgHDrbxbNswFpe+OVDIiZPGjA3gYcKvGoeekAgVIIFyeqHpUXV0el0TQ\/ShnkrvfWXzIg3PqbRfNqQAa58UoGxEweNGBvAw6VeNS8dIBAKYSLE1WPyouro9Jomh+lDHLXe+svGRBu\/c2ieTQgR44cSXv37l2U8+joaNq3b19av359Xz68NUzfDbd8QHm1JMrJY1HrpQOEE4ENuI2oelReAwqh8uOaH5ULMGB4b\/0lAzJgAb0+7s2APPHEE2nnzp3p9OnTiyibnp5Ok5OTraj01jCtNt3iIeXVgiRHj0Stlw4QjkQ2wFai6lF5DSACB49qfjgowgBb8NZfMiADFM\/zo54MyLA3XvXi11vDoDSgvFBMcnCi1ksHCI5+0FGi6lF5oZVii6f5YcsvGt1bf8mAoCtcCc+LASm58UoGpJJ4gGG9DThUalHz0gECpRAuTlQ9Ki+ujkqjaX6UMshd762\/ZEC49TeL5sWAlNx4JQNiJg8asLcBh0o8al46QKAUwsWJqkflxdVRaTTNj1IGueu99ZcMCLf+ZtE8GJDSG69kQMzkQQP2NuBQiUfNSwcIlEK4OFH1qLy4OiqNpvlRyiB3vbf+kgHh1t8sWm0DgrjxSgbETB40YG8DDpV41Lx0gEAphIsTVY\/Ki6uj0miaH6UMctd76y8ZEG79zaLVNCCoG69kQMzkQQP2NuBQiUfNSwcIlEK4OFH1qLy4OiqNpvlRyiB3vbf+kgHh1t8sWi0D88ejZwAAIABJREFUgrzxSgbETB40YG8DDpV41Lx0gEAphIsTVY\/Ki6uj0miaH6UMctd76y8ZEG79zaLVMCDoG69kQMzkQQP2NuBQiUfNSwcIlEK4OFH1qLy4OiqNpvlRyiB3vbf+kgHh1t8sWg0Dgr7xSgbETB40YG8DDpV41Lx0gEAphIsTVY\/Ki6uj0miaH6UMctd76y8ZEG79zaKxDYjFjVcyIGbyoAF7G3CoxKPmpQMESiFcnKh6VF5cHZVG0\/woZZC73lt\/yYBw628WjWlArG68kgExkwcN2NuAQyUeNS8dIFAK4eJE1aPy4uqoNJrmRymD3PXe+ksGhFt\/s2gsA2J545UMiJk8aMDeBhwq8ah56QCBUggXJ6oelRdXR6XRND9KGeSu99ZfMiDc+ptFYxgQ6xuvZEDM5EED9jbgUIlHzUsHCJRCuDhR9ai8uDoqjab5Ucogd723\/pIB4dbfLJq1AWHceCUDYiYPGrC3AYdKPGpeOkCgFMLFiapH5cXVUWk0zY9SBrnrvfWXDAi3\/mbRrA0I48YrGRAzedCAvQ04VOJR89IBAqUQLk5UPSovro5Ko2l+lDLIXe+tv2RAuPU3i2ZpQFg3XsmAmMmDBuxtwKESj5qXDhAohXBxoupReXF1VBpN86OUQe56b\/0lA8Ktv1k0KwPCvPFKBsRMHjRgbwMOlXjUvHSAQCmEixNVj8qLq6PSaJofpQxy13vrLxkQbv3NolkYEPaNVzIgZvKgAXsbcKjEo+alAwRKIVycqHpUXlwdlUbT\/ChlkLveW3\/JgHDrbxYNbUBq3HglA2ImDxqwtwGHSjxqXjpAoBTCxYmqR+XF1VFpNM2PUga56731lwwIt\/5m0ZAGpNaNVzIgZvKgAXsbcKjEo+alAwRKIVycqHpUXlwdlUbT\/ChlkLveW3\/JgHDrbxYNaUBq3XglA2ImDxqwtwGHSjxqXjpAoBTCxYmqR+XF1VFpNM2PUga56731lwwIt\/5m0VAGpOaNVzIgZvKgAXsbcKjEo+alAwRKIVycqHpUXlwdlUbT\/ChlkLveW3\/JgHDrbxYNYUBq33glA2ImDxqwtwGHSjxqXjpAoBTCxYmqR+XF1VFpNM2PUga56731lwwIt\/5m0UoNiIcbr2RAzORBA\/Y24FCJR81LBwiUQrg4UfWovLg6Ko2m+VHKIHe9t\/6SAeHW3yxaiQHxcuOVDIiZPGjA3gYcKvGoeekAgVIIFyeqHpUXV0el0TQ\/ShnkrvfWXzIg3PqbRRvWgHi68UoGxEweNGBvAw6VeNS8dIBAKYSLE1WPyouro9Jomh+lDHLXe+svGRBu\/c2iDWtAPN14JQNiJg8asLcBh0o8al46QKAUwsWJqkflxdVRaTTNj1IGueu99ZcMCLf+ZtGGMSDebrySATGTBw3Y24BDJR41Lx0gUArh4kTVo\/Li6qg0muZHKYPc9d76SwaEW3+zaIMaEI83XsmAmMmDBuxtwKESj5qXDhAohXBxoupReXF1VBpN86OUQe56b\/0lA8Ktv1m0QQyI1xuvZEDM5EED9jbgUIlHzUsHCJRCuDhR9ai8uDoqjab5Ucogd723\/pIB4dbfLFpbA+L5xisZEDN50IC9DThU4lHz0gECpRAuTlQ9Ki+ujkqjaX6UMshd762\/ZEC49TeL1saAeL\/xSgbETB40YG8DDpV41Lx0gEAphIsTVY\/Ki6uj0miaH6UMctd76y8ZEG79zaK1MSDeb7ySATGTBw3Y24BDJR41Lx0gUArh4kTVo\/Li6qg0muZHKYPc9d76SwaEW3+zaP0MSBduvJIBMZMHDdjbgEMlHjUvHSBQCuHiRNWj8uLqqDSa5kcpg9z13vpLBoRbf7NoyxmQrtx4JQNiJg8asLcBh0o8al46QKAUwsWJqkflxdVRaTTNj1IGueu99ZcMCLf+ZtGWMiBduvFKBsRMHjRgbwMOlXjUvHSAQCmEixNVj8qLq6PSaJofpQxy13vrLxkQbv3NovUyIF278UoGxEweNGBvAw6VeNS8dIBAKYSLE1WPyouro9Jomh+lDHLXe+svGRBu\/c2iLTQgN910U9q1a1fK74AsfG3YsCHt3r07jYyMmO0HBeytYZTX8gyoXiiFcHB0gODwjI6iPkMzaosXtV6aH7a6QaN706EMCLrClfAWGpBnn302HT16dNFuxsfH0\/79+9Pq1asr7XSwsN4aZrDdL\/208kIxycGJWi8dIDj6QUeJqkflhVaKLZ7mhy2\/aHRv\/SUDgq5wJby5BmRycjI9\/fTTi3aydu3adODAgTQ2NlZpl4OH9dYwg2fQe4XyQjHJwYlaLx0gOPpBR4mqR+WFVootnuaHLb9odG\/9JQOCrnAlvBkDkn9s8OKLL04vfelL5+1kdHQ07du3L61fv77SDocL661hhsti8SrlhWKSgxO1XjpAcPSDjhJVj8oLrRRbPM0PW37R6N76SwYEXeFKeNmAZIOR3\/nI5mOhAZmenk75nZGuvbw1DIo\/5YVikoMTtV46QHD0g44SVY\/KC60UWzzND1t+0eje+ksGBF3hSnhve9vb0tvf\/vb0v\/\/7v+myyy6bZ0A2b96ctm3bVmlnZWG9NUxZNt9ZrbxQTHJwotZLBwiOftBRoupReaGVYoun+WHLLxrdW3\/JgKArXAEvf+zqqquuSp\/5zGea6HMNSJduvOpFnbeGQZVXeaGY5OBErZcOEBz9oKNE1aPyQivFFk\/zw5ZfNLq3\/pIBQVe4At7tt9+e7r\/\/\/vT444\/PMyBdu\/FKBqSCeMAhvQ04VHpR89IBAqUQLk5UPSovro5Ko2l+lDLIXe+tv2RAuPWHR7vvvvsa85F\/72OuAXnZy17WuRuvZEDg8qADehtwKAKi5qUDBEohXJyoelReXB2VRtP8KGWQu95bf40cO3bsbC8KTpw40fz1xMQElyHjaJHyOn78eDp48GDD2Je+9KV08uTJ5r+vW7eu+a2P\/J9df0Wq19xaKK9uKTNqvQ4fPtwUYmpqqlsF6bPbqPWaSTtqfsqrW22o+dGtennrLxmQbulndrfZbOTf9Dhz5swiA\/Ka17wm3XrrrR3NbP62vTUMilTlhWKSgxO1XjpAcPSDjhJVj8oLrRRbPM0PW37R6N76Sx\/BQleYgPef\/\/mf6ZZbbkn5P2deMx\/BOv\/889Ntt92WduzYQdiJfQhvbxmiMlZeKCY5OFHrpY9QcPSDjhJVj8oLrRRbPM0PW37R6N76SwYEXWFjvHzj1a5du5rvfMx95f\/95JNPpuc+97mN+ZABMS5EIby3QVCYzuxy5YVikoOjAwSHZ3QU9RmaUVu8qPXS\/LDVDRrdmw5lQNAVNsbLN14dPXp0UZT8bkg2ISMjIzIgxjVAwHsbBIicMobyQjHJwdEBgsMzOor6DM2oLV7Ueml+2OoGje5NhzIg6Aob4s3ceLUwxNq1a9Pll1+e7rzzzuYf6R0QwyKAoL0NAlBaMiAoIkk4OkCQiAaH0fwAE2oMF7Vemh\/GwgHDe9OhDAi4wFZwR44cSXv37l0EPzo6mvbt25ceeuih9I53vEMGxKoAYFxvgwCVnvJCMcnB0QGCwzM6ivoMzagtXtR6aX7Y6gaN7k2HMiDoChvg5Y9W7dy5M50+fXoR+vT0dJqcnGzMhwyIAflGkN4GASpN5YVikoOjAwSHZ3QU9RmaUVu8qPXS\/LDVDRrdmw5lQNAVBuP1uvFqJsTmzZvTtm3bmv8pAwIm3hjO2yBApau8UExycHSA4PCMjqI+QzNqixe1XpoftrpBo3vToQwIusJAvKVuvMohNmzYkHbv3t186VwGBEg6CcrbIEClrbxQTHJwdIDg8IyOoj5DM2qLF7Vemh+2ukGje9OhDAi6wkC8pW68Gh8fb37pfPXq1bPR9A4IkHgClLdBgEpZeaGY5ODoAMHhGR1FfYZm1BYvar00P2x1g0b3pkMZEHSFQXjL3XiVfwF9bGxsXiQZEBDxJBhvgwCVtvJCMcnB0QGCwzM6ivoMzagtXtR6aX7Y6gaN7k2HMiDoCgPw+t14tX79+kVRZEAAxBMhvA0CVOrKC8UkB0cHCA7P6CjqMzSjtnhR66X5YasbNLo3HcqAoCtciNfmxqteIWRACoknL\/c2CFDpKy8UkxwcHSA4PKOjqM\/QjNriRa2X5oetbtDo3nQoA4KucAHecjdeTU1Npe3bty+JLgNSQHyFpd4GAYoC5YVikoOjAwSHZ3QU9RmaUVu8qPXS\/LDVDRrdmw5lQNAVHhJvkBuv9A7IkCQ7WuZtEKCoUV4oJjk4OkBweEZHUZ+hGbXFi1ovzQ9b3aDRvelQBgRd4SHxBrnxSgZkSJIdLfM2CFDUKC8UkxwcHSA4PKOjqM\/QjNriRa2X5oetbtDo3nQoA4Ku8BB4g954JQMyBMnOlngbBCh6lBeKSQ6ODhAcntFR1GdoRm3xotZL88NWN2h0bzqUAUFXeEC8YW68kgEZkGSHj3sbBCiKlBeKSQ6ODhAcntFR1GdoRm3xotZL88NWN2h0bzqUAUFXeAC8YW+8kgEZgGSnj3obBCialBeKSQ6ODhAcntFR1GdoRm3xotZL88NWN2h0bzqUAUFXuCVeyY1XMiAtSXb8mLdBgKJKeaGY5ODoAMHhGR1FfYZm1BYvar00P2x1g0b3pkMZEHSFW+CV3nglA9KCZOePeBsEKLqUF4pJDo4OEBye0VHUZ2hGbfGi1kvzw1Y3aHRvOpQBQVe4BV7pjVcyIC1Idv6It0GAokt5oZjk4OgAweEZHUV9hmbUFi9qvTQ\/bHWDRvemQxkQdIX74CFuvJIBIRfNIJy3QYBKUXmhmOTg6ADB4RkdRX2GZtQWL2q9ND9sdYNG96ZDGRB0hZfBQ914JQNCLJpRKG+DAJWm8kIxycHRAYLDMzqK+gzNqC1e1HppftjqBo3uTYcyIOgKL4GHvPFKBoRUNMMw3gYBKlXlhWKSg6MDBIdndBT1GZpRW7yo9dL8sNUNGt2bDmVA0BXugYe+8UoGhFA04xDeBgEqXeWFYpKDowMEh2d0FPUZmlFbvKj10vyw1Q0a3ZsOZUDQFV6AZ3HjlQyIcdEI8N4GASpl5YVikoOjAwSHZ3QU9RmaUVu8qPXS\/LDVDRrdmw5lQNAVXoBnceOVDIhx0Qjw3gYBKmXlhWKSg6MDBIdndBT1GZpRW7yo9dL8sNUNGt2bDmVA0BWeg2d145UMiGHRSNDeBgEqbeWFYpKDowMEh2d0FPUZmlFbvKj10vyw1Q0a3ZsOZUDQFf42nuWNVzIgRkUjwnobBKjUlReKSQ6ODhAcntFR1GdoRm3xotZL88NWN2h0bzqUAUFXOKVkfeOVDIhB0ciQ3gYBKn3lhWKSg6MDBIdndBT1GZpRW7yo9dL8sNUNGt2bDmVAwBVm3HglAwIuWgU4b4MARYHyQjHJwdEBgsMzOor6DM2oLV7Ueml+2OoGje5NhzIgwAqzbrySAQEWrRKUt0GAokF5oZjk4OgAweEZHUV9hmbUFi9qvTQ\/bHWDRvemQxkQYIVZN17JgACLVgnK2yBA0aC8UExycHSA4PCMjqI+QzNqixe1XpoftrpBo3vToQwIqMLMG69kQEBFqwjjbRCgqFBeKCY5ODpAcHhGR1GfoRm1xYtaL80PW92g0b3pUAYEUGH2jVcyIICiVYbwNghQdCgvFJMcHB0gODyjo6jP0Iza4kWtl+aHrW7Q6N50KANSWOEaN17JgBQWzcFyb4MARYnyQjHJwdEBgsMzOor6DM2oLV7Ueml+2OoGje5NhzIgBRWudeOVDEhB0Zws9TYIULQoLxSTHBwdIDg8o6Ooz9CM2uJFrZfmh61u0OjedCgDMmSFa954JQMyZNEcLfM2CFDUKC8UkxwcHSA4PKOjqM\/QjNriRa2X5oetbtDo3nQoAzJkhWveeCUDMmTRHC3zNghQ1CgvFJMcHB0gODyjo6jP0Iza4kWtl+aHrW7Q6N50KAMyRIVr33glAzJE0Zwt8TYIUPQoLxSTHBwdIDg8o6Ooz9CM2uJFrZfmh61u0OjedCgDMmCFPdx4JQMyYNEcPu5tEKAoUl4oJjk4OkBweEZHUZ+hGbXFi1ovzQ9b3aDRvelQBmSACnu58UoGZICiOX3U2yBA0aS8UExycHSA4PCMjqI+QzNqixe1XpoftrpBo3vToQxIywp7uvFKBqRl0Rw\/5m0QoKhSXigmOTg6QHB4RkdRn6EZtcWLWi\/ND1vdoNG96VAGpEWFvd14JQPSomjOH\/E2CFB0KS8UkxwcHSA4PKOjqM\/QjNriRa2X5oetbtDo3nQoA9Kiwt5uvJIBaVE05494GwQoupQXikkOjg4QHJ7RUdRnaEZt8aLWS\/PDVjdodG86lAHpU2GPN17JgKDbko\/nbRCgGFBeKCY5ODpAcHhGR1GfoRm1xYtaL80PW92g0b3pUAZkmQp7vfFKBgTdlnw8b4MAxYDyQjHJwdEBgsMzOor6DM2oLV7Ueml+2OoGje5NhzIgS1TY841XMiDotuTjeRsEKAaUF4pJDo4OEBye0VHUZ2hGbfGi1kvzw1Y3aHRvOpQB6VFh7zdeyYCg25KP520QoBhQXigmOTg6QHB4RkdRn6EZtcWLWi\/ND1vdoNG96VAGZEGFu3DjlQwIui35eN4GAYoB5YVikoOjAwSHZ3QU9RmaUVu8qPXS\/LDVDRrdmw5lQBZUuAs3XsmAoNuSj+dtEKAYUF4oJjk4OkBweEZHUZ+hGbXFi1ovzQ9b3aDRvelQBmROhbty45UMCLot+XjeBgGKAeWFYpKDowMEh2d0FPUZmlFbvKj10vyw1Q0a3ZsOR44dO3a2V5InTpxo\/npiYgLNQVW8pfI6fvx4Onjw4KK9rVq1Kt18881p3bp1VffdL\/ihQ4dS\/pNfW7dubf5EeK00HXa9ZqpXtyp4+PDhZsNTU1Pd2nif3UbV4UzaUfNTXt1qQ82PbtXLW3\/JgKSUTp48mQ4cOJDOnDmzSE1btmxJmzZtcq8yGRD3JZq3QW+DAMWe8kIxycHRAYLDMzqK+gzNqC1e1HppftjqBo3uTYcr\/iNYXbzxqpco3\/GOd6T8J7927NjR\/Inw8vaWIYpT5YVikoMTtV76CAVHP+goUfWovNBKscXT\/LDlF43urb9WtAHp6o1XMiDotuTjeRsEKAaUF4pJDo4OEBye0VHUZ2hGbfGi1kvzw1Y3aHRvOlzRBqSrN17JgKDbko\/nbRCgGFBeKCY5ODpAcHhGR1GfoRm1xYtaL80PW92g0b3pcMUakM9\/\/vPpgQceWFTftWvXNt8HGRsbQ9feFE8fwTKlFw7ubRCgElReKCY5ODpAcHhGR1GfoRm1xYtaL80PW92g0b3pcEUakHzj1YMPPriotqOjo2nfvn1p\/fr16Lqb48mAmFMMDeBtEKCSU14oJjk4OkBweEZHUZ+hGbXFi1ovzQ9b3aDRvelwxRmQhx56qHmH4znPec6i2k5PT6fJyUl0zSl4MiAUmmFBvA0CVGLKC8UkB0cHCA7P6CjqMzSjtnhR66X5YasbNLo3Ha4oA5JvvLruuuvS008\/nfJHrea+8j3427dvR9ebhicDQqMaEsjbIIAklVJSXigmOTg6QHB4RkdRn6EZtcWLWi\/ND1vdoNG96XDFGJCZG6\/+6Z\/+qanpXAOyYcOGtHv37jQyMoKuNw1PBoRGNSSQt0EASUoGBEUjDUcHCBrV0ECaH1A6zcGi1kvzw1w60ADedLhiDMjMjVenTp2aZ0DGx8fT\/v370+rVq6GFZoPJgLAZL4vnbRCUZfOd1coLxSQHRwcIDs\/oKOozNKO2eFHrpflhqxs0ujcdrggDcu+9987eeDXXgHT1xqteopQBQbeqLZ63QYDKVnmhmOTg6ADB4RkdRX2GZtQWL2q9ND9sdYNG96bD8AbkyJEjae\/evbN1nDEgL3jBCzp745UMCLot+XjeBgGKAeWFYpKDowMEh2d0FPUZmlFbvKj10vyw1Q0a3ZsOQxuQJ554Iu3cuTOdPn16kQH57d\/+7c7eeCUDgm5LPp63QYBiQHmhmOTg6ADB4RkdRX2GZtQWL2q9ND9sdYNG96bDsAYk33h1yy23pPyfc1\/5HZB81W42IJFe+ghWt6rpbRCg2FNeKCY5ODpAcHhGR1GfoRm1xYtaL80PW92g0b3pMKQBmbnxKr8DsvB1ySWXpBtuuCFt2rQJXduqeDIgVekfOLi3QTBwAkssUF4oJjk4OkBweEZHUZ+hGbXFi1ovzQ9b3aDRvekwpAGZufFqYfHyjVdbtmxJ5513Xtq4cSO6tlXxZECq0j9wcG+DYOAEZEBQlFXF0QGiKv1DB9f8GJq6Kguj1kvzo4qchg7qTYfhDMjcG6\/mVmnmxqsvfvGLzV\/LgAytYepCbw2DSl55oZjk4EStlw4QHP2go0TVo\/JCK8UWT\/PDll80urf+CmVAFt54NVO80dHR2RuvvBUAJTC9A4JikoMTVYfKi6MfVBQdIFBMcnHUZ1y+S6NFrZfmR6kyuOu96TCMAel149VMaaenp2dvvPJWAJT8ZEBQTHJwoupQeXH0g4qiAwSKSS6O+ozLd2m0qPXS\/ChVBne9Nx2GMCBL3XiVSzs1NZW2b98+W2VvBUDJTwYExSQHJ6oOlRdHP6goOkCgmOTiqM+4fJdGi1ovzY9SZXDXe9Nh5w3IcjdebdiwIe3evTuNjIzIgHB1DovmrWFQiSkvFJMcnKj10gGCox90lKh6VF5opdjiaX7Y8otG99ZfnTcgy914tX\/\/\/rR69ep5NfRWAJTA9A4IikkOTlQdKi+OflBRdIBAMcnFUZ9x+S6NFrVemh+lyuCu96bDThuQfjdejY2NLaqutwKg5CcDgmKSgxNVh8qLox9UFB0gUExycdRnXL5Lo0Wtl+ZHqTK4673psLMGpM2NV71K660AKPnJgKCY5OBE1aHy4ugHFUUHCBSTXBz1GZfv0mhR66X5UaoM7npvOuykAWl745UMCFfcFtG8NQwqR+WFYpKDE7VeOkBw9IOOElWPygutFFs8zQ9bftHo3vqrcwZkkBuvZEDQ8uXjeWsYFAPKC8UkBydqvXSA4OgHHSWqHpUXWim2eJoftvyi0b31V6cMyKA3XsmAoOXLx\/PWMCgGlBeKSQ5O1HrpAMHRDzpKVD0qL7RSbPE0P2z5RaN7669OGZBBb7ySAUHLl4\/nrWFQDCgvFJMcnKj10gGCox90lKh6VF5opdjiaX7Y8otG99ZfnTEgw9x4JQOCli8fz1vDoBhQXigmOThR66UDBEc\/6ChR9ai80EqxxdP8sOUXje6tvzphQIa98UoGBC1fPp63hkExoLxQTHJwotZLBwiOftBRoupReaGVYoun+WHLLxrdW3+5NyAlN17JgKDly8fz1jAoBpQXikkOTtR66QDB0Q86SlQ9Ki+0UmzxND9s+UWje+sv1wak9MYrGRC0fPl43hoGxYDyQjHJwYlaLx0gOPpBR4mqR+WFVootnuaHLb9odG\/95daA9Lvx6q1vfWs655xzBq6PtwIMnMASC\/RDhCgmOThRdai8OPpBRdEBAsUkF0d9xuW7NFrUeml+lCqDu96bDt0aEMSNV3oHhCtui2jeGgaVo\/JCMcnBiVovHSA4+kFHiapH5YVWii2e5octv2h0b\/3l0oAsdePVmjVr0h133JHGxsaGrou3AgydyIKFegcExSQHJ6oOlRdHP6goOkCgmOTiqM+4fJdGi1ovzY9SZXDXe9OhOwOy3I1Xe\/bsSRMTE0UV81aAomTmLJYBQTHJwYmqQ+XF0Q8qig4QKCa5OOozLt+l0aLWS\/OjVBnc9d506MqAoG+86lVabwVAyU8GBMUkByeqDpUXRz+oKDpAoJjk4qjPuHyXRotaL82PUmVw13vToRsDYnHjlQwIV9wW0bw1DCpH5YVikoMTtV46QHD0g44SVY\/KC60UWzzND1t+0eje+suFAbG68UoGBC1fPp63hkExoLxQTHJwotZLBwiOftBRoupReaGVYoun+WHLLxrdW3+5MCBWN17JgKDly8fz1jAoBpQXikkOTtR66QDB0Q86SlQ9Ki+0UmzxND9s+UWje+uv6gbE8sYrGRC0fPl43hoGxYDyQjHJwYlaLx0gOPpBR4mqR+WFVootnuaHLb9odG\/9VdWAWN94JQOCli8fz1vDoBhQXigmOThR66UDBEc\/6ChR9ai80EqxxdP8sOUXje6tv6oZEMaNV14NyE033ZTe9a53Lautiy++OH31q19trT\/dgtWaKhcPehsEKFKUF4pJDo4OEBye0VHUZ2hGbfGi1kvzw1Y3aHRvOqxiQFg3Xnk1IL\/4i7+YHnjgARmQFt3lrWFabLnVI8qrFU1uHopaLx0g3EhsoI1E1aPyGkgG1R\/W\/KhegoE24K2\/6AaEeeOVVwPyMz\/zM+ljH\/tYeu1rX5t27NjRU0Dnnntu+uEf\/uHW4tI7IK2pcvGgt0GAIkV5oZjk4OgAweEZHUV9hmbUFi9qvTQ\/bHWDRvemQ7oBYd545dWAvOxlL0vHjx9Pt912W\/qd3\/kdiMZkQCA00kC8DQJU4soLxSQHRwcIDs\/oKOozNKO2eFHrpflhqxs0ujcdUg0I+8YrrwZk3bp16Utf+lLzPZA3v\/nNEI3JgEBopIF4GwSoxJUXikkOjg4QHJ7RUdRnaEZt8aLWS\/PDVjdodG86pBmQGjdeeTUgF1xwQXr22WfTn\/7pn6Zrr70WojEZEAiNNBBvgwCVuPJCMcnB0QGCwzM6ivoMzagtXtR6aX7Y6gaN7k2HFANS68YrjwbkG9\/4RlqzZk2ztU984hPpJ37iJyAakwGB0EgD8TYIUIkrLxSTHBwdIDg8o6Ooz9CM2uJFrZfmh61u0OjedGhuQGreeOXRgHzxi19ML3nJS5qtff7zn0+XX355yqYkf+k8\/xn2JQMyLHN11nkbBCgWlBeKSQ6ODhAcntFR1GdoRm3xotaRHXVOAAAT5ElEQVRL88NWN2h0bzo0NSC1b7zyaECyADZt2tRsbXx8PH35y19OZ86caf73d3\/3dzfviNx4441pcnJyIO3JgAxEV\/WHvQ0CFCHKC8UkB0cHCA7P6CjqMzSjtnhR66X5YasbNLo3HZoakNo3Xnk0II888kj60R\/90fTMM88sq6385fQ77rgjjYyMtNKgDEgrmtw85G0QoIhRXigmOTg6QHB4RkdRn6EZtcWLWi\/ND1vdoNG96dDMgHi48cqjAcl7yjdg\/eu\/\/mu67LLL0iWXXNKYjPxOyMMPP5yyafvCF77QbP3tb397uvXWW1tpUAakFU1uHvI2CFDEKC8UkxwcHSA4PKOjqM\/QjNriRa2X5oetbtDo3nQ4ctddd53tlWT+rkJ+vfjFLx6Yg8ceeyx96EMfWrRu1apVzY\/vvfCFLxwYE7WgJK+Fe8jf33jlK1\/Z\/PVXvvKV9Oijj\/bc5sTERLr00ktbpfDUU081P0CYv7h\/4YUXpq997Wvp\/PPPb9bed999S75z8tGPfjTlP\/mVf+gw\/4nwQtbLEx\/Ky1M1+u8lar3+\/u\/\/vkn+Fa94RX8SOvRE1HrNlCBqfsqrQ02WUtL86Fa9vPUX3IB8\/etfT3\/2Z3+WvvWtby2qTD4Uf9\/3fV\/ViiELMNeA3H333Wn79u09c3vPe96T3vSmNzX\/LPOSjdhyr7vuumv2+Y9\/\/OPpJ3\/yJ5vHP\/jBDzZGp9dLBqSqrAYOjtThwMENFygvQ3INoHWAMCCVAKk+I5AMDBG1XpofQJEQoLzpEPoRLG83XvWqp9VbUG0NSBuNffrTn26+J5JfbX8rRB\/BasOsn2esdFg7Q+VVuwKDxddHKAbjy8vT6jMvlWi3j6j10vxoV38vT3nTIcyAeLzximlAkALLvw8y89Gu\/FG2V73qVX3hZUD6UuTqAW+DAEWO8kIxycHRAYLDMzqK+gzNqC1e1HppftjqBo3uTYcwA+LxxquuGpDM5W233dZs\/+TJk+lFL3pRXx3KgPSlyNUD3gYBihzlhWKSg6MDBIdndBT1GZpRW7yo9dL8sNUNGt2bDiEGxOuNVx4NSDYUy30hPd+AlX8nJH8ZPX8x9O\/+7u9aaVAGpBVNbh7yNghQxCgvFJMcHB0gODyjo6jP0Iza4kWtl+aHrW7Q6N50WGxAjhw5kvbu3buIp9HR0bRnz56Ub4Dy9KpdgGuuuSadOnUq\/fzP\/3x6+ctf3twyds4556Qnn3wyfepTn2q4zF\/kP++88xrzkW\/EavOSAWnDkp9nauvQignlZcWsDa4OEDa8WqOqz6wZxuJHrZfmB1Yn1mjedFhkQPJVsTt37kynT59exNv09PTAv+ZtTX7Gr12A17zmNc1tVsu9XvCCF6R77rknvfrVr25NiQxIa6pcPFhbh1YkKC8rZm1wdYCw4dUaVX1mzTAWP2q9ND+wOrFG86bDoQ1IF2686lXM2gXI7268973vTR\/72MfSiRMnmnc7zp49m57\/\/OenK664ojEdb3jDG9JFF100kBZlQAaiq\/rDtXVoRYDysmLWBlcHCBterVHVZ9YMY\/Gj1kvzA6sTazRvOhzKgHTlxiuPBsRKYDIgVsza4HobBKgslReKSQ6ODhAcntFR1GdoRm3xotZL88NWN2h0bzocyoB05cYrGRC0fPl43hoGxYDyQjHJwYlaLx0gOPpBR4mqR+WFVootnuaHLb9odG\/9NbAB6dKNVzIgaPny8bw1DIoB5YVikoMTtV46QHD0g44SVY\/KC60UWzzND1t+0eje+msgA9K1G69kQNDy5eN5axgUA8oLxSQHJ2q9dIDg6AcdJaoelRdaKbZ4mh+2\/KLRvfVXawPSxRuvZEDQ8uXjeWsYFAPKC8UkBydqvXSA4OgHHSWqHpUXWim2eJoftvyi0b31VysD0tUbr2RA0PLl43lrGBQDygvFJAcnar10gODoBx0lqh6VF1optniaH7b8otG99VdfA3LllVemXbt2pfwOyMLXhg0b0lvf+tbmh\/S68vJWABRvugULxSQHJ6oOlRdHP6goOkCgmOTiqM+4fJdGi1ovzY9SZXDXe9NhXwPy13\/91+no0aOLWBofH0\/79+9Pq1ev5jJYGM1bAQrTmV0uA4JikoMTVYfKi6MfVBQdIFBMcnHUZ1y+S6NFrZfmR6kyuOu96XBZA7KU+VizZk2644470tjYGJc9QDRvBQCk1EDIgKCY5OBE1aHy4ugHFUUHCBSTXBz1GZfv0mhR66X5UaoM7npvOlzSgLzvfe9LBw8eTGvXrp3H0OjoaNqzZ0+amJjgMgeK5q0AoLRkQFBEknCi6lB5kQQECqMDBIhIMoz6jEx4Ybio9dL8KBQGebk3HfY0IPn7Hm984xvTmTNnFhmQ6enpNDk5SaYNF85bAVCZ6R0QFJMcnKg6VF4c\/aCi6ACBYpKLoz7j8l0aLWq9ND9KlcFd702HiwzIzI1X\/\/Zv\/9YwM\/cdkKmpqbR9+3YuY+Bo3gqASk8GBMUkByeqDpUXRz+oKDpAoJjk4qjPuHyXRotaL82PUmVw13vT4TwD8s1vfnP2xqtTp07NMyBdvPGqV2m9FQAlPxkQFJMcnKg6VF4c\/aCi6ACBYpKLoz7j8l0aLWq9ND9KlcFd702H8wzI7bffPnvj1VwD0tUbr2RAuOK2iOatYVA5Ki8UkxycqPXSAYKjH3SUqHpUXmil2OJpftjyi0b31l+zBuTee+9NDzzwwGy+Mwbk0ksv7eyNVzIgaPny8bw1DIoB5YVikoMTtV46QHD0g44SVY\/KC60UWzzND1t+0eje+qsxIEeOHEl79+6dl2s2IKtWrUrvfve7O3vjlQwIWr58PG8Ng2JAeaGY5OBErZcOEBz9oKNE1aPyQivFFk\/zw5ZfNLq3\/hp5\/PHHz+7cuTOdPn16kQHZsmVLuuGGG9AcVMXzVgAUGfoOCIpJDk5UHSovjn5QUXSAQDHJxVGfcfkujRa1Xpofpcrgrvemw5Hrr7\/+7FNPPbWIhY0bN6Zrrrkm5f+M9PJWABS3MiAoJjk4UXWovDj6QUXRAQLFJBdHfcbluzRa1HppfpQqg7vemw5Hrr766rMLKcg3Xl199dXpnHPOkQHh6mPoaDIgQ1NXZaG3QYAiQXmhmOTg6ADB4RkdRX2GZtQWL2q9ND9sdYNG96bDRQZk5sarz33uc03uegcELQEbPBkQG16tUL0NAlSeygvFJAdHBwgOz+go6jM0o7Z4Ueul+WGrGzS6Nx3OMyBr1qyZvfHK20ZRhYialwwISiEcnKg6VF4c\/aCi6ACBYpKLoz7j8l0aLWq9ND9KlcFd702HswZkdHQ07dmzZ\/bGK28bRZUpal4yICiFcHCi6lB5cfSDiqIDBIpJLo76jMt3abSo9dL8KFUGd703Hc4akOnp6TQ5OTnLhreNosoUNS8ZEJRCODhRdai8OPpBRdEBAsUkF0d9xuW7NFrUeml+lCqDu96bDhsDMjU1lbZv3z6PCW8bRZUpal4yICiFcHCi6lB5cfSDiqIDBIpJLo76jMt3abSo9dL8KFUGd703HY78\/u\/\/fvM7IAtf3jaKKlPUvGRAUArh4ETVofLi6AcVRQcIFJNcHPUZl+\/SaFHrpflRqgzuem86bH4JvRcF3jaKKlPUvGRAUArh4ETVofLi6AcVRQcIFJNcHPUZl+\/SaFHrpflRqgzuem86lAHh1t8smgyIGbUmwN4GASpJ5YVikoOjAwSHZ3QU9RmaUVu8qPXS\/LDVDRrdmw5lQNAVroQnA1KJ+CHDehsEQ6axaJnyQjHJwdEBgsMzOor6DM2oLV7Ueml+2OoGje5NhzIg6ApXwpMBqUT8kGG9DYIh05ABQRFXCUcHiErEF4bV\/CgkkLw8ar00P8hCKgznTYcyIIUF9bJcBsRLJdrtw9sgaLfr\/k8pr\/4ceXpCBwhP1Wi\/F\/VZe648PBm1XpofHtTVfg\/edCgD0r52rp+UAXFdHr1T0K3yrJh66QDRTWF6O0igWFReKCY5OJofHJ5RUbz1lwwIqrKVcWRAKhdgwPDeBsGA21\/yceWFYpKDowMEh2d0FPUZmlFbvKj10vyw1Q0a3ZsOZUDQFa6EJwNSifghw3obBEOmsWLeKYhaLx0gUMrn4kTVo\/Li6qg0muZHKYPc9d76SwaEW3+zaDIgZtSaAHsbBKgklReKSQ6ODhAcntFR1GdoRm3xotZL88NWN2h0bzqUAUFXuBKeDEgl4ocM620QDJmG3gFBEVcJRweISsQXhtX8KCSQvDxqvTQ\/yEIqDOdNhzIghQX1slwGxEsl2u3D2yBot+v+Tymv\/hx5ekIHCE\/VaL8X9Vl7rjw8GbVemh8e1NV+D950KAPSvnaun5QBcV0evVPQrfKsmHrpANFNYXo7SKBYVF4oJjk4mh8cnlFRvPWXDAiqspVxZEAqF2DA8N4GwYDbX\/Jx5YVikoOjAwSHZ3QU9RmaUVu8qPXS\/LDVDRrdmw5lQNAVroQnA1KJ+CHDehsEQ6axYt4piFovHSBQyufiRNWj8uLqqDSa5kcpg9z13vpLBoRbf7NoMiBm1JoAexsEqCSVF4pJDo4OEBye0VHUZ2hGbfGi1kvzw1Y3aHRvOpQBQVe4Ep4MSCXihwzrbRAMmYbeAUERVwlHB4hKxBeG1fwoJJC8PGq9ND\/IQioM502HMiCFBfWyXAbESyXa7cPbIGi36\/5PKa\/+HHl6QgcIT9Vovxf1WXuuPDwZtV6aHx7U1X4P3nQoA9K+dq6flAFxXR69U9Ct8qyYeukA0U1hejtIoFhUXigmOTiaHxyeUVG89ZcMCKqylXFkQCoXYMDw3gbBgNtf8nHlhWKSg6MDBIdndBT1GZpRW7yo9dL8sNUNGt2bDmVA0BWuhCcDUon4IcN6GwRDprFi3imIWi8dIFDK5+JE1aPy4uqoNJrmRymD3PXe+mvk2LFjZ3tRcOLEieavJyYmuAwZR4ua16FDh1L+k19bt25t\/kR4Ra2X8uqWOqPW6\/Dhw00hpqamulWQPruNWq+ZtKPmp7y61YaaH92ql7f+kgHpln6W3K0MSLcK6W0QoNhTXigmOTg6QHB4RkdRn6EZtcWLWi\/ND1vdoNG96VAfwUJXuBKePoJVifghw3p7K3TINBYtU14oJjk4+ggFh2d0FPUZmlFbvKj10vyw1Q0a3ZsOZUDQFa6EJwNSifghw3obBEOmIQOCIq4Sjg4QlYgvDKv5UUggeXnUeml+kIVUGM6bDmVACgvqZbkMiJdKtNuHt0HQbtf9n1Je\/Tny9IQOEJ6q0X4v6rP2XHl4Mmq9ND88qKv9HrzpUAakfe1cPykD4ro8eqegW+VZMfXSAaKbwvR2kECxqLxQTHJwND84PKOieOsvGRBUZSvjyIBULsCA4b0NggG3v+TjygvFJAdHBwgOz+go6jM0o7Z4Ueul+WGrGzS6Nx3KgKArXAlPBqQS8UOG9TYIhkxjxbxTELVeOkCglM\/FiapH5cXVUWk0zY9SBrnrvfWXDAi3\/mbRZEDMqDUB9jYIUEkqLxSTHBwdIDg8o6Ooz9CM2uJFrZfmh61u0OjedCgDgq5wJTwZkErEDxnW2yAYMg29A4IirhKODhCViC8Mq\/lRSCB5edR6aX6QhVQYzpsOZUAKC+pluQyIl0q024e3QdBu1\/2fUl79OfL0hA4QnqrRfi\/qs\/ZceXgyar00Pzyoq\/0evOlQBqR97Vw\/KQPiujx6p6Bb5Vkx9dIBopvC9HaQQLGovFBMcnA0Pzg8o6J46y8ZEFRlK+PIgFQuwIDhvQ2CAbe\/5OPKC8UkB0cHCA7P6CjqMzSjtnhR66X5YasbNLo3HcqAoCtcCU8GpBLxQ4b1NgiGTGPFvFMQtV46QKCUz8WJqkflxdVRaTTNj1IGueu99ZcMCLf+ZtFkQMyoNQH2NghQSSovFJMcHB0gODyjo6jP0Iza4kWtl+aHrW7Q6N50KAOCrnAlPBmQSsQPGdbbIBgyDb0DgiKuEo4OEJWILwyr+VFIIHl51HppfpCFVBjOmw5lQAoL6mW5DIiXSrTbh7dB0G7X\/Z9SXv058vSEDhCeqtF+L+qz9lx5eDJqvTQ\/PKir\/R686VAGpH3tXD8pA+K6PHqnoFvlWTH10gGim8L0dpBAsai8UExycDQ\/ODyjonjrLxkQVGUr48iAVC7AgOG9DYIBt7\/k48oLxSQHRwcIDs\/oKOozNKO2eFHrpflhqxs0ujcdyoCgK1wJTwakEvFDhvU2CIZMY8W8UxC1XjpAoJTPxYmqR+XF1VFpNM2PUga56731lwwIt\/5m0WRAzKg1AfY2CFBJKi8UkxwcHSA4PKOjqM\/QjNriRa2X5oetbtDo3nQoA4KucCU8GZBKxA8Z1tsgGDINvQOCIq4Sjg4QlYgvDKv5UUggeXnUeml+kIVUGM6bDmVACgvqZbkMiJdKtNuHt0HQbtf9n1Je\/Tny9IQOEJ6q0X4v6rP2XHl4Mmq9ND88qKv9HrzpUAakfe1cPykD4ro8eqegW+VZMfXSAaKbwvR2kECxqLxQTHJwND84PKOieOsvGRBUZSvjyIBULsCA4b0NggG3v+TjygvFJAdHBwgOz+go6jM0o7Z4Ueul+WGrGzS6Nx3KgKArXAlPBqQS8UOG9TYIhkxjxbxTELVeOkCglM\/FiapH5cXVUWk0zY9SBrnrvfWXDAi3\/mbRZEDMqDUB9jYIUEkqLxSTHBwdIDg8o6Ooz9CM2uJFrZfmh61u0OjedCgDgq5wJTwZkErEDxnW2yAYMg29A4IirhKODhCViC8Mq\/lRSCB5edR6aX6QhVQYzpsO\/z\/MrWNBFJOUrAAAAABJRU5ErkJggg==)\n\n那么如何维护这样一个下凸壳呢？\n\n可以发现凸壳中的相邻两点的斜率是递增的\n\n我们可以用单调队列维护\n\n那么查询呢？\n\n我们可以发现：\n\n如果当前直线经过的点左边的斜率<当前斜率<右边的斜率,\n\n那么这个点就是最优的。\n\n我们可以按照下面的方案实现：\n\n设队头为$h$,队尾为$t$,队列数组为$q$,$s(i,j)$为直线$ij$的斜率\n\n1. while($s(q_h,q_{h+1})<2a_i$)++h;\n2. 当前队头的点最优,用这个点计算出$f_i$\n3. while($s(q_{t-1},q_t)>s(q_{t-1},i)$)--t;\n4. 队尾插入点$i$\n\n对于$3$操作的解释：\n\n![](data:image\/png;base64,iVBORw0KGgoAAAANSUhEUgAAAyAAAAMgCAYAAADbcAZoAAAgAElEQVR4Xuy9DbSdVXnv++zPfGeT8CGQYAAJmoAo2QhUrVX5ELAYzLVqPRntqGh6T0\/PuPYEpR3t7bgdt2doW6P22NFzi+eop4dxHa2eIGKtShFvrSIaEEEIKAVTCV9qIISEkGTvfcda2xX22utd6\/2v9X48c77vb4+R4ZD9vHvP9Z+\/+Z\/zv5695x6amZmZMeFj27Zt1vjX+Ni6dWvzHx9md9xxR1OGyclJ5DD06AYBnLQrgx7JpFx33XXNT2zZsgU\/wU+6MsD6yd9Pbrnxh3bPdx5r+8ILFo7a1R+4wMYXjEa5HuGkfdo8\/PXG7\/zEbv5+O1eNUa1YMm4feOtZtmzRmDtbXpwMEUCyzb3XxGUbdXFPo0eytuiS\/4GhOIr9vrLHBun3atO\/M+sGP0mnJPsbX88+87x96sO329RU+\/uxF150ql34xjXKEIKsYf34BpA7H9pjn7zlwQ42xkaGm+HjpBWLguDGixMCSMbp95q4jMMu7HH04MCgwAUndEDgRFEAP1FUyuonVex+NHTLqouifUw1Zb7Bs+un++2jN+20I1PTHRJtuXStnbNmRTDSeXFCAMmIgNfEZRx2YY+jBwcGBS44IYDAiaIAfqKolMVPqtr9IIB0klNWANnz7PP2F5+\/z\/Y9d7hjEL963mq77NyTFaxLq8myfrIMkgCSRT3eYehQzwvkjNNY+OPo0i4xehBAlEUHJwSQojmpaveDAOITQA4dmbI\/v+E+e\/zp5zoGcO5pK+zqi9cqSJda4+WzBJCM0+w1cRmHXdjj6MGBQYELTgggcKIogJ8oKg3qJ1XufhBAyg8gjTudPnHzg3b3rqc6vvma45fY+65cZ43f\/wjtY9D1k\/V1EEAyKug1cRmHXdjj6MGBQYELTgggcKIogJ8oKg3qJ1XufhBAyg8gMdx4lbSeBl0\/ytrsVUMAyaig18RlHHZhj6MHBwYFLjghgMCJogB+oqg0iJ9UvftBACk3gMRy4xUBRHGUSGoGMb5IXtpAw0QPDgwKOHBCAIETRQH8RFFpED+peveDAFJeAInpxisCiOIokdQMYnyRvLSBhokeHBgUcOCEAAInigL4iaJSv35Sh+4HAaScABLbjVcEEMVRIqnp1\/gieVkDDxM9ODAo8MAJAQROFAXwE0Wlfv2kDt0PAkjxASTGG68IIIqjRFLTr\/FF8rIGHiZ6cGBQ4IETAgicKArgJ4pK\/fhJXbofBJBiA0isN14RQBRHiaSmH+OL5CVlGiZ6cGBQAIITAgicKArgJ4pK\/fhJXbofBJBiA0i3G6+WLx6zP9h0ti1bNKagG0RNP+snzwFzC1ZGNb0mLuOwC3scPTgwKHDBCQEEThQF8BNFJdVP6tT9IIAUF0B63Xi1deN6W33sYgXbYGrU9ZP3gAkgGRX1mriMwy7scfTgwKDABScEEDhRFMBPFJVUP6lT94MAUkwAif3Gq6T1pK4fZS32U0MA6UethFqvics47MIeRw8ODApccEIAgRNFAfxEUUnxk7p1Pwgg+QeQKtx4RQBRHCWSGsX4InkpuQwTPTgwKCDBCQEEThQF8BNFJcVP6tb9IIDkG0CqcuMVAURxlEhqFOOL5KXkMkz04MCggAQnBBA4URTATxSV0vykjt0PAkh+AaRKN14RQBRHiaQmzfgieRm5DRM9ODAoMMEJAQROFAXwE0WlND+pY\/eDAJJfAKnSjVcEEMVRIqlJM75IXkZuw0QPDgwKTHBCAIETRQH8RFGpl5\/UtftBAMkngFTtxisCiOIokdRwkGqfKPTgwKAsXTghgMCJogB+oqjUy0\/q2v0ggGQPIFW88YoAojhKJDUcpAggCqpwAicKJ9ddd12zbMuWLUp55WtYNwQQBfJunNS5+0EAyRZAet14deV5q+1N556soBlFjZfPcg1vRjy8Ji7jsAt7HD04MChwwQkdEDhRFMBPFJW6+Umdux8EkMEDSJVvvKIDojhKJDUcpHhnW0EVTuBE4YQOCJwonOAn6ZzUvftBABksgFT9xisCiOKwkdSwEaRvBJFMZaHDhBM4UQAjgMCJwgl+ks5J3bsfBJDBAkjVb7wigCgOG0kNG0H6RhDJVBY6TDiBEwUwAgicKJzgJ705ofsxqw+ctHOS5q91uPGKAKI4bCQ1LHAODAqqcAInCidpG6TyNapUw7pJnk106e0ndD8IIEkrp5e\/1uXGKwJIhXZINgIOlgrOcAInCicEEDhROMFPunNC9+MFbeBE64DU6cYrAojisJHUsMA5MCiowgmcKJwQQOBE4QQ\/6c4J3Q8CSLc1lOSvdbvxigCiOGwkNWwEHBgUVOEEThROCCBwonCCnyRz8tK1Z9unPny7TU3NtBVceNGpduEb1yjSVqoGTnp3QOp44xUBpEJLnAXOgUHBGU7gROGEAAInCif4STInTz+yzO75zmNtn1ywcNSu\/sAFNr5gVJG2UjVw0juA1PHGKwJIhZY4C5wDg4IznMCJwgkBBE4UTvCTTk4OHpiyO28+SPdjjjRw0j2A1PXGKwKI4rCR1LDAOTAoqMIJnCicEEDgROEEP+nk5O5vPWV7Hx+j+0EA6bqEWv76prf+O\/voTTvtyNR0R+2WS9faOWtWKMuwMjVefjI00\/ghOOFj27Zt1vjX+Ni6dWvzHx\/csz2fAS+QQ2cRXThYKowSQOBE4QQ\/aVfpm9\/4jt3y2cdt+bKJtk\/U9Xc\/WiLASWcH5Lkjw\/b48knb99zhjqV25Xmr7U3nnqwswUrVeHFCAMmIkdfEZRx2YY+jR7K06MLBUll0BBA4UTjBT9pV+tTH\/8n+7YEDNjHxQgCp8+9+EECSV9F\/\/X+us288sdxWnnx6R8G5p62wqy9eqyy\/ytV4+QkBJCNKXhOXcdiFPY4eBBAFLjhJVokAQgBh\/SgKvFDT+LsfH\/mjr9jMtLUFkLp3PxoK4bMvcNL4YZ8tH\/yMPX5gzNasab8Rbc3xS+x9V66zsZHh\/uCrSLUXJ0M7duyQfgTr+uuvt8a\/xsfmzZub\/\/gw27lzZ1OGdevWIYehRzcI4KRdGfRIJmX79u3NT2zatAk\/wU+6MsD6eUGaxu9+3LvjieZ\/WLZsWfN\/R8eH7OK3n2ijY\/U8ULbUgZMXOPmXfz1gN93+cPM\/nHTSSUc\/sXh8yDa\/asIWj9eXFS9OCCAZt3mvics47MIeR49kadGFAKIsOgIInCic4CezKjVuvmr87scze\/e1BZAzz11uZ75yNozU+QNOZmf\/h08esi\/d+6w99tjsFc2tADI6bPb2DcvthGX1u6J57rrw4oQfwcroTl6tq4zDLuxx9EiWFl3adUGPZE74ESw4UcyZ9TOrUuuvnu\/du7f5\/xu\/A8LvfrxAEJyY7frp\/qM3Xu3ataspTutHsOp441WSv3hxQgBR3L5HjdfEZRx2YY+jBwFEgQtOCCBwoiiAn3RTqfG7H62\/ej43gPC7HwSQlgJ7nn3e\/uLz9x298WpuAKnrjVcEkMF9N7gnOUjxjqUCJZzAicIJHRA4UTjBT17ofjT0agWQE150bG3\/6nlIB0uF4aJrDh2Zsj+\/4T57\/Onnjn6rVgC56vWvrO2NVyFxQgck4ypgI+DAoCAEJ3CicEIAgROFk7r7ydzux9wA8qZNr7AL39h+w5GiZ1Vr6spJ48arT9z8oN2966m2qW0EkGPGp+yTf\/j22t54RQCp0Gqv6wLvNoXokawMunCwVGyPAAInCid195PW7360tGp0QBo3X73\/g5fb+IJ6\/0LxXH7qyskXvvsT++pds79wPvfjiUcetted+Iz9x3\/\/XmWZ1abGixM6IBkR85q4jMMu7HH0IIAocMFJskoEEAII66e3AvO7H60OSOPmq1+\/+vWKfLWpqaPP3vnQHvvkLQ92zHHjb3ycfOD7NjE+ZVu2bKkNA8oL9eKEAKLMTo8ar4nLOOzCHkcPAogCF5wQQOBEUQA\/ma\/A\/O5H4\/P7n3um+Xc\/LrjwVYOLWsEn6+azc2+8mj+djRuvvv2Vzzb\/MwEkjDd6CCAZTaduCzxNLvTgwJDGSOPzcEIAgRNFAfxkrgJJ3Y\/G5190+kzz735MTk4OLmoFn6yTz86\/8WrudLZuvKLDHJafEEAymk6dFrgiFXqEtcCVOfOogRMCiMIdnOAncxVI6n40\/u7HhkvGm3\/1nAASxjvbytrOsybpxqvW1z\/3tBVHb7wigITlJwSQjKuADbKehtcvNnACJwozbJBwonBSRz\/p1v1o\/N2PsYmfNWUjgNRv\/XS78aqhxJrjl9j7rlx39MYr\/JUAovhrNDV13Ah6TQ56hLXAQ11IcEIHRGETTvCTlgLduh9Xf+ACu+cH3yeAJKBSh\/XT7car5YvH7A82nW3LFo0dVYYAEpaf0AFRdsEeNXVY4P1IhB5hLfB+5q7MWjghgCi8wQl+0lCgV\/ej8Xc\/4KSenPS68WrrxvW2+tjFbcIQQMLihACi7IIEEFklNoKwFrg8cSUXwgkBREEOTvCThgK9uh+Nv\/sBJ\/XjJO3Gq3PWrOgQhQASFicEEGUXJIDIKrERhLXA5YkruRBOCCAKcnCCn3TrflzwxjX2Sxed2hQITurFSa8br371vNV22bknJwpCAAmLEwKIsgsSQGSV2AjCWuDyxJVcCCcEEAU5OMFPkrofY+Mj9p5rL7TGDVgEkO4rqYrrR73xKkkVAkhYfkIAUXZBAoisUhUNT37xcCJLBScEEAUWOAnrwKDMWZ41SveDAFKfANLPjVcEEH0levksAUSfo8RKr4nLOOzCHkePeh8YVLDghACisAIn9fYTpftBAKlPAOnnxisCiOKwszVePksA0eeIACJo5QWyMDTXEnRplx89CCDKgoST+gYQtfvheYBSGPasqdL66ffGKwKITp4XJwQQfY4IIIJWXiALQ3MtQRcCiAIgP6MMJwondfATtftBAKl+B2SQG68IIIqT0AHRVQqwsg4bQT+yo0d937GEk34UoAOiqIWf1NNP+ul+EECqHUAGvfGKAKI4LAFEVynASjZI3rFUsIQTOFE4oQMCJwonVfeTfrofBJDqBpAsN14RQBQnIYDoKgVYWfWNoF\/J0aOe71jCSb8K0AFRFMNP6ucn\/XY\/CCDVDCBZb7wigCgOSwDRVQqwkg2SdywVLOEEThRO6IDAicJJlf2k3+4HAaSaASTrjVcEEMVJCCC6SgFWVnkjGERu9KjfO5ZwMogCdEAU1fCTevnJIN0PAkj1AkgeN14RQBSHJYDoKgVYyQbJO5YKlnACJwondEDgROGkqn4ySPeDAFKtAJLXjVcEEMVJCCC6SgFWVnUjGFRq9KjXO5ZwMqgCdEAU5fCT+vjJoN0PAkh1AkieN14RQBSHJYDoKgVYyQbJO5YKlnACJwondEDgROGkin4yaPeDAFKNAJL3jVcEEMVJCCC6SgFWVnEjyCIzetTnHUs4yaIAHRBFPfykHn6SpftBAIk\/gBRx4xUBRHFYAoiuUoCVbJC8Y6lgCSdwonBCBwROFE6q5idZuh8EkPgDSBE3XhFAFCchgOgqBVhZtY0gq8ToUY93LOEkqwJ0QBQF8ZPq+0nW7gcBJO4AUtSNVwQQxWEJILpKAVayQfKOpYIlnMCJwgkdEDhROKmSn2TtfhBA4g0gRd54RQBRnIQAoqsUYGWVNoI85EWP6r9jCSd5KEAHRFERP6m2n+TR\/SCAxBlAir7xigCiOCwBRFcpwEo2SN6xVLCEEzhROKEDAicKJ1Xxkzy6HwSQ+AJIGTdeEUAUJyGA6CoFWFmVjSAvadGj2u9YwkleCtABUZTET6rrJ3l1PwggcQWQsm68IoAoDksA0VUKsJINkncsFSzhBE4UTuiAwInCSRX8JK\/uBwEkrgBS1o1XBBDFSQggukoBVlZhI8hTVvSo7juWcJKnAnRAFDXxk2r6SZ7dDwJIPAGkzBuvCCCKwxJAdJUCrGSD5B1LBUs4gROFEzogcKJwEruf5Nn9IIDEEUDKvvGKAKI4CQFEVynAytg3grwlRY9qvmMJJ3krQAdEURQ\/qZ6f5N39IICEH0B63Xj15slVdvmGVYodZK7hDZ6w\/GRopvEbQcLHtm3brPGv8bF169bmPz7M2CB5x1JZB3ACJwonbJBwonASs5\/k3f0ggIQdQLxuvKIDojgJHRBdpQArY94IipATPcJ6h6GIOc7ja8IJHRCFIziplp8U0f0ggIQbQDxvvCKAKA5LANFVCrCSDZJ3LBUs4QROFE7ogMCJwkmsflJE94MAEm4A8bzxigCiOAkBRFcpwMpYN4KipESPar1jCSdFKUAHRFEWP6mOnxTV\/SCAhBlAvG+8IoAoDksA0VUKsJINkncsFSzhBE4UTuiAwInCSYx+UlT3gwASXgAJ4cYrAojiJAQQXaUAK2PcCIqUET2q844lnBSpAB0QRV38pBp+UmT3gwASVgAJ5cYrAojisAQQXaUAK9kgecdSwRJO4EThhA4InCicxOYnRXY\/CCDhBJCQbrwigChOQgDRVQqwMraNoGgJ0aMa71jCSdEK0AFRFMZP4veTorsfBJAwAkivG69WrVxs11y13sZGhpVlX1gNb\/CE5Sf8HZCMqLNB8o6lghCcwInCCRsknCicxOQnRXc\/CCBhBJBeN15de9VZNrFkXEG70Br8lQBSKGBlf\/GYNoIytEGPsBZ4GXM+yPeAEzogCjdwEreflNH9IID4B5AQb7xKUoUAEpaf0AFRdsEeNWyQvGOpIAQncKJwwgYJJwonsfjJ177wI7v79kfbXtLY+Ii959oLbcHCUeWlSjWx6CG9mByLytAl1BuvCCA6SGVwkjQaAog+R4mVXhOXcdiFPY4eYb3DUNhEZ\/zCcEIHREEITuL1k7K6H3RA\/DogId94RQBRHHa2xstnCSD6HBFABK28QBaG5lqCLryzrQBIBwROFE5i8JOyuh+eByhlrjxriuQk9BuvCCA6eUVy0msUBBB9jgggglZeIAtDcy1BFw6WCoAEEDhROAndT8rsfhBAyu+AxHDjFQFEcRI6ILpKAVaGvhGULRl6JCuOLhwslbVIAIEThZPQ\/aTM7gcBpPwAEsONVwQQxUkIILpKAVaGvhGULRl6EEAU5uAkWSUCCAEk9vVTdveDAFJuAInlxisCiOIkBBBdpQArOUhxYFCwhBM4UTghgMCJwknIflJ294MAUl4AienGKwKI4iQEEF2lACtD3gg85EIPOiAKd3BCBwROFAXi8hOP7gcBpJwAEtuNVwQQ3V+89mN+CV2fo8RKr4nLOOzCHkePuA4MhYGQ8oXhhACisAcncfmJR\/eDAFJ8AInxxisCiOKwdEB0lQKsZINsnxT0iOvA4LWk4IQAorAHJ\/H4iVf3gwBSbACJ9cYrAojisAQQXaUAK9kgCSAKlnACJwon\/A4InCichOgnXt0PAkixASTWG68IIIqTEEB0lQKsDHEj8JQJPeJ5xxJOPBWgA6Koj5\/E4See3Q8CSHEBJOYbrwggisMSQHSVAqxkg+QdSwVLOIEThRM6IHCicBKan3h2PwggxQSQ2G+8IoAoTkIA0VUKsDK0jcBbIvSI4x1LOPFWgA6IMgP4Sfh+4t39IIDkH0CqcOMVAURxWAKIrlKAlWyQvGOpYAkncKJwQgcEThROQvIT7+4HASTfAFKVG68IIIqTEEB0lQKsDGkjCEEe9Aj\/HUs4CUEBOiDKLOAnYftJCN0PAkh+AaRKN14RQBSHJYDoKgVYyQbJO5YKlnACJwondEDgROEkFD8JoftBAMkvgNz03UfsK3c92vEFly8es2uvOssmlowreAZbg7+G9YYGf4gw41IJZSPI+DJyexw9wlrguU1szl8ITuiAKEjBSbh+0q37ceEb19iFF52qTG9uNXCSnZOq3XhFB0RfXl7rhwCiz1FipdfEZRx2YY+jR\/aNoLDJCegLwwkBRMERTsL1k1C6H3RAsndAqnjjFQFEcdjZGi+fJYDoc0QAEbTyAlkYmmsJurTLjx4EEGVBwkmYASSk7ofnAUph2LNGWT+9b7xabZdvONnzJeT6vfkRrLD8ZGjHjh0zygxff\/311vjX+Ni8eXPzHx9mO3fubMqwbt065DD06AYBnLQrgx7JpGzfvr35iU2bNuEn+ElXBrzXzz23PW277t\/fNr6R0SG7+B0n2tj4cOnseutR+gsWv2GaLoenZuwzO\/bangPTHV9x7fFj9uazl4nfKY4y\/DV5ntI4KWp2CSAZlfWauIzDLuxx9AhrgRc20Rm\/MJwQQBSE4CQ8Pzl4YMpu+ezjNjPvzHrmK5fZmecuV6Y19xo46Z+TmRmzm37wrD30s0MdDx+3dMTeObncRoeHcp8rzy9IAOmfkyLnix\/Byqiu0uLM+C2iehw9kqcLXdp1QY9kTvgRAThRDN9z\/YT0ux8trTz1UObLq6aXLlW\/8SpJc\/w1rPMJASSjM2B8HBgUhOAEThRO2CDhROHEy09C+90PAkhvWrpxUocbrwggipPM1nj5CQFEn6PESq+Jyzjswh5Hj7DeYShsojN+YTihA6IgBCdh+UmI3Q\/PA5TCsGdN0vqpy41XBBCdPC+fJYDoc0QAEbTyAlkYmmsJuvDOtgIgHRA4UTjx8JNQux8EkO7EzOekTjdeEUAUJ6EDoqsUYKXHRhCgDEeHhB5hvWMZKitwQgdEYRNOwvGTULsfBBAtgBw6MmV\/fsN99vjTz3U8cO5pK+zqi9cqSzLqGt7gCcdPGiOhA5JxObFB8o6lghCcwInCCRsknCiclO0nIXc\/CCDpAWTDhg32iZsftLt3PdVRvGrlYrvmqvU2NlL+9ckK63nW4K8EkDx5cv9aZW8E7i84ZQDoEdYCD5UXOKEDorAJJ2H4ScjdDwJIegB5dPpF9pW7Hu0oXL54zK696iybWDKuLMfoawggYfhJaxR0QDIuKTZI3rFUEIITOFE4YYOEE4WTMv0k9O4HAaR3APnhk4fsm4+MdBQ1Oh5bN6631ccuVpCrRA3+SgCpBMitF1HmRhCDcOgR1gIPlRk4oQOisAkn\/n4SeveDANJ9JX3p1tvt77\/3jC1dNtFRtOXStXbOmhXKMqxMDQHE30\/mjoAOSMalxQbJO5YKQnACJwonbJBwonBSlp\/E0P0ggCQT07jx6vf\/+7\/Yc4enbWKiPYC8eXK1Xb7hZAW1StXgrwSQSgFd1kYQi2joEdYCD5UbOKEDorAJJ75+EkP3gwDSyUjrxqsHdj3e\/OTcAFKXG6+SVg4BxNdP5n93OiDKLtijhg2SdywVhOAEThRO2CDhROGkDD+JpftBAGknZmZm5uiNV3v37m0LIHW68YoAojjJbE0ZfpI0GgKIPkeJlV4Tl3HYhT2OHmG9w1DYRGf8wnCSLCABhACiLK0y1k8s3Q\/PA5QyV2XX3PTdR47eeDU3gNTtxisCiE5eGX5CANHnQ670mjh5gCUXogcBREEOTgggcKIo4OMnMXU\/CCAvMHLnQ3vsk7c8ePQ\/tALIcStX1O7GKwKI7i9e+zEdEH2O6IAIWnmBLAzNtQRdeGdbAZAOCJwonBTtJzF1Pwggs8Ts+ul+++hNO+3I1HRHAHn\/r51XuxuvCCCKk8zWFO0n3UZCANHniAAiaOUFsjA01xJ04WCpAEgAgROFkyL9JLbuh+cBSpmrMmoaN179xefvs33PHW77do0OyIWnLrL\/8LbXljGM4L8H\/po8RUX6SS8oCCAZl4zXxGUcdmGPo0dYC7ywic74heEkWUA2SAKIsrSKXD+xdT\/qHkBaN149\/vRzHeicMH7A3nz2MpucnFSwqnwN\/hrW+YQAknHJFbkRZByay+PoEdYCd4FA+KZwQgARMHH70QBlbJ41Ra2fGLsfdQ4gc2+8ms9j48arN774oI0ODxFAfiEOASSs8wkBJOMuUtRGkHFYbo+jR1gL3A2ElG8MJwQQhU04KddPYux+1DmAzL3xai4prRuvHrz\/nuZ\/pgMyqw4BpFw\/SfN4AkiaQhyk+lKIA0NYC7yvySuxGE4IIApucFKen8Ta\/ahrAJl\/41WLlLGR4aM3XrF+2tcPAaQ8P1H8nQCiqNSjhgXeLg56hLXAM+Jd2ONwQgBR4IKT8vwk1u5HHQNI0o1XLVK2XLr26I1XrB8CSMg+SwBRZocAIquE4ZV3YJAnJcBCOCGAKFjCSTl+EnP3o24BpNuNVw0drphcZVdsWHUUGtYPASRknyWAKLNDAJFVwvDKOTDIExJoIZwQQBQ04aQcP4m5+1GnANLrxqtzT1thV1+8tg0Y1g8BJGSfJYAos0MAkVXC8Mo5MMgTEmghnBBAFDThpHg\/ib37UZcAknbj1TVXrbfG73\/M\/WD9EEBC9lkCiDI7BBBZJQyv+AODPBkBF8IJAUTBE06K95PYux91CSBpN15NLBnvgIX1QwAJ2WcJIMrsEEBklTC84g8M8mQEXAgnBBAFTzgp1k+q0P2oQwBRbrxKIoX1QwAJ2WcJIMrsEEBklTC8Yg8M8kQEXggnBBAFUTgp1k+q0P2oegBRb7wigKQ7CtfwFusn6TPQXkEA6VexefVskO2CoEdYCzwj3oU9DicEEAUuOCnOT6rS\/ahyAOnnxisCSLqjEECK85N09TsrCCCDqDbnGTZIAoiCEJzAicIJGyScKJzk4SdV6X5UNYD0e+MVASR95eCvBJB0SiKqyGMjiOjlpg4VPcJa4KkT5lQAJ3RAFPTgpBg\/qVL3o4oBZJAbrwgg6Y5CACnGT9KVT66gAzKocr94jg2SdywVhOAEThRO2CDhROEkq59UqftRxQAyyI1XBJD0lYO\/EkDSKYmoIutGENFLlYaKHmEtcGnSHIrghA6Igh2c5O8nVet+VC2ADHrjFQEk3VEIIPn7Sbrq3SvogGRRz8zYIHnHUkEITuBE4YQNEk4UTrL4SdW6H1UKIFluvCKApK8c\/JUAkk5JRBVZNoKIXqY8VPQIa4HLE1dyIZzQAVGQg5N8\/aSK3Y+qBJC9+w\/Zh9fcZjwAACAASURBVG641\/Y9d7hj0q+YXGVXbFilLJm2GtZPu2QEkHz9pG8g5z1ABySjgixw3rFUEIITOFE4YYOEE4WTQf2kit2PKgSQxo1X227cabv3HOiY\/nNPW2FXX7xWwaKjZlBOBvpmETyEvxJAIsBUHyILnAODQgucwInCCRsknCicDOInVe1+xB5A8rrxKombQThR+Iu1Bn8lgMTKbuK4WeAcGBSg4QROFE7YIOFE4WQQP6lq9yP2AJLXjVcEkPSVg78SQNIpiahikI0gopfX91DRI6wF3vcElvQAnCQLzQZJAFGWYL\/rp8rdj5gDSJ43XhFA0lcO\/hrW+YTfAUlntmdFvxtBxm8X\/OPoEdYCDxUYOCGAKGzCST5+UuXuR6wBJO8brwgg6Y5CAMnHT9KV1ioIIJpOXavYIHnHUkEITuBE4YQNEk4UTvrxk6p3P2IMIEXceEUASV85+CsBJJ2SiCr62QgielkDDxU9wlrgA09kwQ\/CCR0QBTE4ye4nVe9+xBZAirrxigCS7igEkOx+kq6yXkEHRNcqsZINkncsFYTgBE4UTtgg4UThRPWTOnQ\/YgogRd54RQBJXzn4KwEknZKIKtSNIKKXlGmo6BHWAs80mQU+DCd0QBS84CSbn9Sh+xFTACnyxisCSLqjEECy+Um6wv1V0AHpT6+OajZI3rFUEIITOFE4YYOEE4UTxU\/q0v2IJYAUfeMVASR95eCvBJB0SiKqUDaCiF5O5qGiR1gLPPOEFvQF4IQOiIIWnAzuJ3XpfsQQQMq48YoAku4oBJDB\/SRd3f4r6ID0r1nbE2yQvGOpIAQncKJwwgYJJwonaX5Sp+5H6AGkrBuvCCDpKwd\/JYCkUxJRRdpGENFLyWWo6BHWAs9lUgv4InBCB0TBCk4G85M6dT9CDiBl3nhFAEl3FALIYH6SruxgFXRABtPt6FNskLxjqSAEJ3CicMIGCScKJ738pFv344I3rLFfuvhU5ctHVxOiv5Z94xUBJB1b\/JUAkk5JRBUhGp+nfOgR1gL3ZKHX94YTOiAKm3DSv5\/UrfsRagek7BuvCCDpjkIA6d9P0lUdvIIOyODaNZ9kg+QdSwUhOIEThRM2SDhROOnmJ3XsfoS4D3e78Wp0ZNiu2bjeVh+7WJnmzDXsO+0S4q8EkMyLKqQvwALnwKDwCCdwonDCBgknCifd\/KSO3Y\/QAkivG6\/efdEZtuH0lcoU51LDvkMAUUDy4oQOiDI7PWq8Ji7jsAt7HD3CeoehsInO+IXhJFlAAggBRFlaSeunrt2PkAJIrxuvLt9wsr15crUyvbnV4LMEEAUmL04IIMrsEEBklbxAlgfoVIguHCwV9AggcKJwkuQnde1+hBJAet14dc6aFbbl0rXK1OZaw75DAFGA8uKEAKLMDgFEVskLZHmAToXowsFSQY8AAicKJ\/P9pM7djxACSNqNV1s3rrPx0RFlanOtYd8hgChAeXFCAFFmhwAiq+QFsjxAp0J04WCpoEcAgROFk\/l+UufuRwgB5Is7HrEvf+\/RjqlbvnjMrr3qLJtYMq5Ma+417DsEEAUqL04IIMrsEEBklbxAlgfoVIguHCwV9AggcKJwMtdP6t798A4godx4lcQN+w4BpF8\/UerzqiGAZFSSBc6BQUEITuBE4YQAAicKJ3P9pO7dD88AEtKNVwSQ9JWDvyZr5HU+IYCkM9uzwmviMg67sMfRI6wFXthEZ\/zCcJIsIBskAURZWq3189K1Z9unPny7TU3NtD1W5b96HspBO7Qbr0LRReHXqwZ\/Det8QgDJuBI4SHFgUBCCEzhROGGDhBOFk5af7N293O6+vf13D8bGR+w9115oCxaOKl+qEjVl+2uIN14RQNJRxl8JIOmURFRRtvGFLg16hLXAQ+UFTuiAKGzCSXc\/OXhgyu68+WDtux8NhcrkJNQbrwgg6Y5CAAnrfEIHJJ3ZnhVlGl\/GoZbyOHqEtcBLmfQBvgmcEEAUbOCku5\/cc9vT9vRj7V2OOnY\/yg4god54RQBJdxQCSFjnEwJIOrMEkD404sAQ1gLvY+pKLYUTAogCHJwkq\/TNb3zHbvns47Z82URbQd1+96P14sviJOQbrwgg6Y5CAAnrfEIASWeWANKHRmVtBH0MKYhSdGmfBvQggCgLE06SVfr0X91iu+7fbxMTLwSQunY\/yuqAhH7jFQEk3VEIIASQdEoiqmCD5GCp4AoncKJwwgYJJ2mcNP7ux0f+6Cs2M21tAaSu3Y8yAkgMN14RQNJWjhn+SgBJpySiCg6WHBgUXOEEThRO2CDhJI2TW7\/wI\/vnr+5slrU6IHXufhQdQGK58YoAkrZyCCDdFPI6n\/AjWOnM9qzwmriMwy7scfQI6x2GwiY64xeGk2QBCSAEkF5Lq\/VXz\/fsebotgNS5+1FkAInpxisCSPqmhL+GdT4Z2rFjR\/tfMOoyh9dff701\/jU+Nm\/e3PzHh9nOnbPvRK1btw45DD26QQAn7cqgRzIp27dvb35i06ZN+Al+0sHAD2572n58\/37bt29f83PLli2zkdEhu\/gdJ9rY+HBtmSnKT7710AH7zq6DHbouHh+yd503YUsXhK15UbrEChr+mjxzXpwQQDKuJK+Jyzjswh5Hj7AWeGETnfELwwkBREEITl5QqfF3Pxo3XzV+92NuAFn7imX20g3LFTkrW1MEJz988pB96d5nOzQbGTZ7x4bldsKy8P\/QYxG6xAwRASSs8wk\/gpVxNfGjJO0CokcyUOgCJ4rV8CMCcNKNk8bvfnz\/F3\/1fO\/evc2y445fWbu\/ep6kT97+GuONV2XoonhYyDX4a1jnEwJIxtWSt\/FlHI774+gR1gJ3B6LLAOAkWRg2SAJIEhmt3\/2Ympr9ielWALn0qnPsly4+NdRlXtq48vSTWG+8IoCk44a\/hnU+IYCkM9uzIk\/jyziUIB5Hj7AWeBBQJAwCTgggCptwMqvS3O5HK4A0fvfj\/R+63BYsDP9HgZS5zlKTFycx33hFAEkniAAS1vmEAJLOLAGkD43y2gj6+JZRlKIL72wroLJBwsl8TuZ3P1oBpPG7H+967xsUrCpfk4e\/xn7jFQEkHXP8lQCSTklEFXkYX0QvN3Wo6BHWAk+dMKcCOEkWng2SADKfjPndj8bnn93\/TPPmqwt\/6VVOKzisb5uHn3xxxyP25e892vHCli8es2uvOssmloyH9aKF0eShi\/BtoinBX8M6n9ABybh0WOAcGBSE4AROFE7YIOFkrgJJ3Y\/G5084dbp589Xk5KSCVeVrsvrrnQ\/tsU\/e8mCHTqMjw3bNxvW2+tjFUWqYVZcoX3SPQeOvBJBKMc0C58CgAA0ncKJwwgYJJ3MVSOp+NP7q+eSlC5p\/94MAMqtWFn+tyo1XSf6SRRfFr2KrwV8JILEx23O8LHAODArQcAInCidskHDSUqBb96PxV8\/HV\/y8WUYAyRZAet94tcrePLlKWbbB1rDvtE8N\/koACXaxDjIwFjgHBoUbOIEThRM2SDhpKdCt+\/Geay+0H9z7fQLIHFQG8deq3XhFByTdYfFXAkg6JRFVDGJ8Eb28voeKHmEt8L4nsKQH4CRZaDZIAkhDgV7dj8bf\/WD9ZOOkijdeEUDSNy\/8NazzCb+Ens5szwo2gmwbQUb5o3kcTuBEgZUNEk4aCvTqfjT+7gd+ko2TKt54RQBJd1j8lQCSTklEFWwE2TaCiKY601DhBE4UgNgg4SSt+9FQCD8ZnJOq3nhFAEl3WPyVAJJOSUQVbASDbwQRTXPmocIJnCgQsUHCSVr3gwDSuZJUf63yjVcEkHSHxV8JIOmURFShGl9ELynTUNEjrAWeaTILfBhOksVlg6x3AFG6HwSQwQJI1W+8IoCkb1j4a1jnE34HJJ3ZnhUcpOp9YFDxgRM4UVhhg6w3J0r3gwDSfwCpw41XBJB0h8VfCSDplERUwcGy3gcGFVU4gROFFTbI+nKidj8IIP0FkLrceEUASXdY\/JUAkk5JRBUcLOt7YOgHUziBE4UXNsj6cqJ2Pwgg\/QWQutx4RQBJd1j8lQCSTklEFRws63tg6AdTOIEThRc2yHpy0k\/3gwCiB5A63XhFAEl3WPyVAJJOSUQVHCzreWDoF1E4gROFGTbIenLST\/eDAKIFkLrdeEUASXdY\/JUAkk5JRBUcLOt5YOgXUTiBE4UZNsj6cdJv94MAkh5A6njjFQEk3WHxVwJIOiURVXCwrN+BYRA84QROFG7YIOvHSb\/dDwJI7wBS1xuvCCDpDou\/EkDSKYmogoNl\/Q4Mg+AJJ3CicMMGWS9OBul+EEC6B5ANGzbYJ25+0O7e9VRH0aqVi23rxnU2PjqiLMVK1LDvtE8j\/koAqcTCbr0IFni9DgyDwgsncKKwwwZZL04G6X4QQLoHkMdmXmRf\/t6jHQXLF4\/ZtVedZRNLxpVlWJka9h0CiAKzFyf8IUJldnrUeE1cxmEX9jh6hPUOQ2ETnfELw0mygASQ+gSQQbsfBJDkAPLDJw\/ZNx\/p7G6MjgzbNRvX2+pjF2d0rfgex2cJIAq1XpwQQJTZIYDIKnmBLA\/QqRBd6nOwzIIYAaQ+nAza\/SCAdK6wL916u\/39956xpcsmOj757ovOsA2nr8yyLKN9ln2HAKLA68UJAUSZHQKIrJIXyPIAnQrRpT4HyyyIEUDqwUmW7gcBpJ2Rxo1X7\/9v37DnDk\/bxER7ALl8wyp78+SqLEsy6mfZdwggCsBenBBAlNkhgMgqeYEsD9CpEF3qcbDMihcBpB6cZOl+EEBeYKR149V9Dz\/W\/I9zA8g5a1bYlkvXZl2SUT\/PvkMAUQD24oQAoswOAURWyQtkeYBOhehSj4NlVrwIINXnJGv3gwAyy8jMzMzRG6\/27t3bFkDqeONVkvew7xBAlD3JixMCiDI7BBBZJS+Q5QE6FaJL9Q+WeaBFAKk+J1m7HwSQWUa+uOORozdezQ0gdb3xigCS7sD4a7JGXucTAkg6sz0rvCYu47ALexw9wlrghU10xi8MJ8kCskFWO4B0636c\/\/oX26svOU1eVXVfP3c+tMc+ecuDR\/VqBZBjV66o7Y1XBJD05YO\/hnU+IYCkM0sA6UOjum+M3aRCl2ofLPtYIj1L2SCrzUke3Y+6d0B2\/XS\/ffSmnXZkarojgPzepsna3nhFAEl3YfyVAJJOSUQVHCyrfWDIC0U4gROFJTbI6nKSV\/ejzgGkcePVh2641\/Y9d7gNlEYH5IJTF9nvvu21yjKrTQ37TvtU468EkEotfhZ4dQ8MeYIKJ3Ci8MQGWV1O8up+1DWAtG682r3nQMdSOnbsOXvLy5fa5OSkssxqU8O+QwBRYPfihB\/BUmanR43XxGUcdmGPo0dY7zAUNtEZvzCcJAtIAKlmAMmz+1HHADL3xqv5K6dx49UbTjloYyNDBJB54uCzBBBlq\/bihACizA4BRFbJC2R5gE6F6FLNg2XeOBFAqslJnt2POgaQuTdezSWkdePVg\/ff0\/zPdECquX7y8ln8Naw3SAkgGcnmYInhKQjBCZwonLBBVo+TvLsfdQsg82+8ahEyOjJ89MYr\/DWsg6XidR41+GtYnBBAMq4CjK96B4aMSCQ+DidwonDFBlk9TvLuftQpgCTdeNUi5N0XnXH0xiv8NayDpeJ1HjX4a1icEEAyrgKMr3oHhoxIEEAEAVk3ySKxQVbLT4roftQlgHS78arx+i8792T71fNWH4UFPwnrYClsAS4l+GtYnBBAMi4DjK9aB4aMOHR9HE7gRGGLDbJanBTR\/ahDAOl149U5a1bYlkvXtoGCv4Z1sFS8zqMGfw2LEwJIxlWA8VXrwJARBwKIKCDrhg6IgkrMnBTV\/ah6AEm78WrrxnU2PjpCABEWUMzrR3h5fZcQQAggfUMT8gMscAKIwiecwInCCRtkdTgpqvtR9QCSduPVxJLxjqWEv4Z1sFS8zqMGfw2LEzogGVcBxledA0NGFHo+DidwovDFBlkNTorsflQ5gCg3XiWtI\/w1rIOl4nUeNfhrWJwQQDKuAoyvGgeGjBikPg4ncJIKiZmxQVaDkyK7H1UNIOqNVwQQxUlma9h32rXCXwkg+uqJoJIFXo0DQ9GowQmcKIyxQcbPSdHdjyoeLPu58YoAojgJASRJJfyVAKKvnggqOVjGf2AoAzM4gROFMzbI+DkpuvtRtQDS741XBBDFSQggBJDwOeFHsPQ5SqzkYBn\/gSEjAtLjcAInCigEkLg5KaP7UaUAMsiNVwQQxUkIIASQ8DkhgOhzRAARtOKgHVaLU5gylxI4SZadABJ3ACmj+1GlAHLTjkfsK997tGMxLF88ZtdedZYl3XhFANEtG59t1wp\/Det8QgDR1zIBRNAKwwtrgQtT5lICJwQQBbyYOCmr+1GVADLojVcEEGXl0AGhAxI+JwQQfY4IIIJWMR0YhJeTWwm6xP3Odm4gpHwh3qGLl5Oyuh9VCCBZbrwigOhuxL5DB0ShxYsTAogyOz1qvCYu47ALexw96IAocMEJHZAqcVJm9yP2AJL1xisCiLJy6IDQAQmfEwKIPkd0QAStOFgSQARMuJ++i0h0QOLsgJTZ\/Yg5gORx4xUBRHFYAggBJHxOCCD6HBFABK0IIAQQARMCCAFEwSQKTsrufsQaQPK68YoAIi2dZhH7cbtWvMET1vmEAKKvZQKIoBWGF9YCF6bMpQROkmVng4yvA1J29yPWg2W3G6+WLRqz33+rfuMVAUS3bHyWAKLQ4sUJAUSZnR41XhOXcdiFPY4eBBAFLjghgFSBE4\/uR4wBpNeNV7935Tpbc\/wSBYeuNfgJ+44CEG\/whMUJAUShlgAiq8RGENYClyeu5EI4IYAoyIXOiUf3I7YAkveNV3RAlJUzWxP6+tFfST6VBJCwzicEkIxcs8DbBUSPsBZ4RrwLexxOCCAKXCFz4tX9iOlgWcSNVwQQZeUQQJJUIoCEdT4hgOhrObEy5A0y40sb6HH0CGuBDzSJJTwEJwQQBbOQOfHqfsQSQNJuvHrvJWfY0NCQgkFqTcicpA6+wAJ0aReXABLW+YQAknHxs8DpgCgIwQmcKJywQcbBiWf3I4YAUuSNV3RAFCehA0IHJHxOCCD6HNEBEbTioB3WOwzClLmUwAkdEAW8UDnx7H7EEECKvPGKAKKsHAIIASR8Tggg+hwRQAStQj0wCEMvtARd4nhnu1AIhC9OByR8Try7H6EHkKJvvCKACEbyixL2nXat8New3iAlgOhrmQAiaIXhhbXAhSlzKYETOiAKeCFy4t39CDmAlHHjFQFEWTl0QOiAhM8JAUSfIwKIoFWIBwZh2IWXoEv472wXDoHwDXiHLmxOQuh+hBpAyrrxigAiGAkdkESR8New3iAlgOhrmQAiaMVBO6wFLkyZSwmc0AFRwAuNkxC6HyEGkDJvvCKAKCuHDggdkPA5IYDoc0QAEbQK7cAgDLmUEnQJ+53tUiAQvgnv0IXLSSjdj9ACSNk3XhFABCOhA0IHRMfE7Q9WEkD6mCSML10sDtp0QNIp4S\/0dtOIABJuAAml+xFaACn7xiv2YcVh6YDQAQmfEwKIPkd0QAStCCAEEAETt3dclLF51hBAwgwgIXU\/QgogHjdeEUB0h2I\/btcKfw3rfEIA0dcyAUTQCsMLa4ELU+ZSAifJsrNBhhlAQup+hBJAvG68IoDolo3PEkAUWrw4IYAos9OjxmviMg67sMfRgwCiwAUnBJBYOAmt+xFCAOl149Wbzj3ZrjxvtTK9udXgJ+w7Cky8wRMWJ0M7duyYUSbu+uuvt8a\/xsfmzZub\/\/gw27lzZ1OGdevWIYehRzcI4KRdGfRIJmX79u3NT2zatAk\/CcRPfnDb0\/bj+\/e3zcfI6JBd\/I4TbWx82GWePNfP4akZ+7s7n7GfPTvV8dpPP27crjx7qQ0NlSuLpx7lvtL+vhu6tOuFvybz48UJAaS\/9dxR7TVxGYdd2OPoEdYCL2yiM35hOCGAKAh5c3LwwJTd8tnHbWa6fbRnnLPUXjY5obyEQmq8dJmZMbvpB8\/aQz871PG6jls6Yu\/YsNzGRkpOH4EE1UImOuMX9eIk47ALe5wAEtb5hB\/Byog6rd92AdEjGSh0gRPFavgRgbA4Ce13P1rqePlJCDdeJa0jLz2UNe1Zgy7t6uOvYZ1PCCAZ3YEFHtaBIeN0FvY4nMCJAhcbZDichPi7H54BJJQbrwggipPM1rDvEEAUWrw4IYAos9OjxmviMg67sMfRI6x3GAqb6IxfGE6SBSSAhBNAQu1+eBwsQ7rxigCimy8+SwBRaPHihACizA4BRFbJC2R5gE6F6BLOwdIJAenbEkDC4CTk7kfZASS0G68IIJKV0AFJkAl\/DesNUgKIvpYTKzlYhnFgyDiNhT8OJ3CiQMYGGQYnIXc\/ygwgh45M2bYbd9ruPQc68D1nzQp77yVn2FDZV14lLCT8NayDpeJ1HjX4a1icEEAyrgKML4wDQ8ZpLPxxOIETBTI2SH9OQu9+lBVAZmZm7BM3P2h373qqA91VKxfb1o3rbHx0RMG68Br8NayDZeETPuA3wF\/D4oQAMiDIrccwPv8DQ8YpLOVxOIETBTQ2SH9OQu9+lBVAQr3xKmkd4a9hHSwVr\/OowV\/D4oQAknEVYHz+B4aMU1jK43ACJwpobJC+nMTQ\/SgjgIR84xUBRHGS2Rr2nXat8FcCiL56IqhkgfseGCJAhI0gYZJYN8nkskH6+kkM3Y+iD5ah33hFANF3PXyWAKLQ4sUJHRBldnrUeE1cxmEX9jh6hPUOQ2ETnfELwwkBREGoTE5i6X4UGUBiuPGKAKKsHDogSSrxBk9Y5xMCiL6WEyvL3CAzDrWUx9EjrAVeyqQP8E3ghACiYFMmJ1\/7wo\/s7tsfbRvW2PiIvefaC23BwlFluKXVFKFLLDdeEUB0zIrgRP\/u4VUSQMI6nxBAMq4RFni7gOgR1gLPiHdhj8MJAUSBqyxOunc\/1tirLzlVGWqpNXnrEtONVwQQHbW8OdG\/c5iVBJCwzicEkIzrhAVOAFEQghM4UThhg\/ThJKbuR0OhvP0kphuvCCCKk8zW5M2J\/p3DrMRfCSBhkjngqFjgPgeGAafL7TE4gRMFPjbI8jmJrfuR98EythuvCCCKkxBAklTCXwkg+uqJoJKDZfkHhgiw6BginMCJwi0bZPmcxNb9yDOAxHjjFQFEcRICCAEkfE74ESx9jhIrOViWf2DIOGUuj8MJnCjgEUDK5STG7kdeASTWG68IIIqTEEAIIOFzQgDR54gAImjFQTusFqcwZS4lcJIsOwGk3AASY\/cjjwAS841XBBDdsvHZdq3w17DOJwQQfS0TQAStMLywFrgwZS4lcEIAUcArkpNYux9ZA0jsN14RQJSVQweEDkj4nBBA9DkigAhaFXlgEL59sCXoUu4728GCkDIw3qErj5NYux9ZA0jsN14RQHR3Y9+hA6LQ4sUJAUSZnR41XhOXcdiFPY4edEAUuOCEDognJzF3P7IEkCrceEUAUVYOHRA6IOFzQgDR54gOiKAVB0sCiIAJ99N3EYkOSDkdkJi7H4MGkKrceEUAURyWAEIACZ8TAog+RwQQQSsCCAFEwIQAQgBRMCmEk9i7H4MEkF43Xl127sn2q+etluYj1CL2HfYdhU3e4AmLEwKIQm2PGoyvnHcsM06T++NwAicKhGyQxXMSe\/ej3wBStRuv6IAoTkIHhA5I+JwQQPQ5ogMiaMVBO6x3GIQpcymBk2TZCSDFBpAqdD\/6CSBVvPGKAKJbNj7brhX+Gtb5hACir2UCiKAVhhfWAhemzKUETgggCnh5c1KF7kc\/AaSKN14RQJSVQweEDkj4nBBA9DkigAha5X1gEL5lFCXoUuw721FAIAySd+iK46Qq3Y\/5AeTQk0\/avvvutQO7fmzP\/fjHNn7CCbZ4zan2b2Mr7dM\/HumgbnRk2H7vynW25vglApFxlOCvvPGlkIq\/hsUJAUShtkcNxlfcgSHj1AT1OJzAiQIkG2RxnFSl+zE3gJzy+GP2k7\/9dAdaU9Mztv\/gEdv9orW249wr7cj4oqM1777oDNtw+koFx2hq8NewDpahgoO\/hsUJASTjSsH4ijswZJyaoB6HEzhRgGSDLIaTKnU\/WgHkyP\/8Hzb62KMdWM3MmD178LBNz8x+6vDYQvvnX\/p3tveYE60KN14lrSP8NayDpeJ1HjX4a1icEEAyrgKMr5gDQ8ZpCe5xOIETBUo2yGI4qVL3o6HQdz74n236u9+xsbGxDqyePXjEGh2QuR\/7F0\/YE5u32tW\/eo4NDQ0pKEZVg7+GdbAMFR78NSxOCCAZVwrGV8yBIeO0BPc4nMCJAiUbZP6cVK37se\/eH9i9\/+cfNoWaH0AOPD9lh6emO1AbGR6yNRuvtFPffbWCYXQ1+GtYB8tQAcJfw+KEAJJxpWB8+R8YMk5JkI\/DCZwoYLJB5s9J1bofP\/n0J233F27sCCDPH562g4enOjAbHjJbunDMGo2Pyb\/7nIJhdDX4a1gHy1ABwl\/D4oQAknGlYHz5HxgyTkmQj8MJnChgskHmy0nVuh8NdR74v\/7Ynrr7+20B5PDUjB14\/kgHYo0ftlqycNQaHZDGx8s\/\/tfNW7Kq9oG\/hnWwDJUv\/DUsTgggGVcKxpfvgSHjdAT7OJzAiQInG2S+nFSt+9FQ5453vM0OHz58NIC0brxq\/62PWR0XLxi1sZEXfufjJdd8wI551fkKilHV4K9hHSxDhQd\/DYsTAkjGlYLx5XtgyDgdwT4OJ3CiwMkGmR8nVex+zA8go6NjbTdezVVv4diILRgbbhOUAKKswurUsO+0zyX+SgCpzupuvBt1xx3N1zM5OVmp1zXoi0GPsBb4oPNY9HNwkqwwG2R+AaSK3Y+GOnN\/BOv5qaGOG68aNWMjw7Z4QecfIeRHsIp2trC+Pj5LAFGI9OKEDogyOz1qvCYu47ALexw9CCAKXHBCACmSk6p2L329CwAAIABJREFUPxqatX4J\/eCRGZue6bxSt\/H7HksXjnbIO7J4sb3yU3+ryB5dDX7CvqNAyxs8YXFCAFGoJYDIKrERhLXA5YkruRBOCCAKcoNyUtXuR0OzAw8\/bDve939Y4xfPh4baf8Rq7o1X8\/U9+W1vt5N+7e2K7NHVDMpJdC+0zwGjCx0QBRkvTgggyuwQQGSVvECWB+hUiC7twqMHAURZioNwUuXuR0OzOx\/aY7du+2t75a7b2wLI\/Buv5uq7eM2ptu7PP6xIHmXNIJxE+UL7HDS6EEAUZLw4IYAos0MAkVXyAlkeoFMhuhBAFPT4EYHsnFS5+7Hrp\/vtozfttJ\/vecpeu\/NmW\/vkA0cFm3\/jVesT48cdZy+55lpbfNppCoJR1uCvydOGLgQQZUF7cUIAUWaHACKr5AWyPECnQnTJfrB0mrpSvy0BJBsnVe5+7N1\/yD50w72277nDtnfv3qZQLzvwuJ131022zI503HjV+PwJl1\/R\/LGr0SVLS+W47G+GvxJAFObw17A4IYAo1BJAZJXYCMJa4PLElVwIJ8mCs0FmCyBV7X4cOjJl227cabv3HGgK1AogExMT9soTF9jbTxu2\/Tt32v4fP2xLTj3NFp16qjV+7KqKf3QwaeXgJ+w7yhaGv4bFCQFEoZYAIqvERhDWApcnruRCOCGAKMj1w0lVux8zMzP2iZsftLt3PXVUslYAWX\/aSbZ14zobH+28clfRtyo1\/XBSldesvA50aVeJABLW+YQAoqxiAoisEoYX1gKXJ67kQjghgCjI9cNJVbsfX9zxiH35e4+2ydUIIIvGhu0v3vPLNrFkXJGy0jX9cFJpIea9OHQhgCi8e3FCAFFmhwAiq+QFsjxAp0J0aRcePQggylJUOalq96Nx49Unb3mwQ6pn9+21t5+73K54wwWKjJWvUTmpvBAEkJ5TTAckrDdICSAZHQnj42CpIAQncKJwwgY5GCdV7H60brw6MjXdgc5rVk\/ZmSeM2+TkpIJV5Wvw17AOlqECh7+GxQkBJONKwfgGOzBklD26x+EEThRo2SD756SK3Y+5N17N5+ayc0+2k4aeaP5nAsisOvhrWAdLxes8avDXsDghgGRcBRhf\/weGjJJH+TicwIkCLhtk\/5xUrfsx\/8aruYqcs2aFvfeSM+zOO+8kgMwRBn8N62CpeJ1HDf4aFicEkIyrAOPr\/8CQUfIoH4cTOFHAZYPsj5OqdT+SbrxqKbJq5eKjN17hJ\/1xoqy9KtbASfus4q8EkEqtcxY4G4ECNJzAicIJG2R\/nFSt+5F041VDkWWLxuz333rW0Ruv8JP+OFHWXhVr4IQAonDtxQkdEGV2etR4TVzGYRf2OHqE9Q5DYROd8QvDSbKABBD9YFm17ke3G69GR4bt965cZ2uOX3JUHNaPzklGq4r6cTghgCgAe3FCAFFmhwAiq+QFsjxAp0J04cCgoEcA0TmpUvfjkZ8fsA\/feJ8l3Xj17ovOsA2nr2wTBj\/ROVHWXVVr4IQAorDtxQkBRJkdAoiskhfI8gCdCtGFA4OCHgFE46RK3Y\/GjVd\/9vl77ZkDhzsQedMrT7YrX7W647\/jJxonypqrcg2cEEAUvr04IYAos0MAkVXyAlkeoFMhunBgUNAjgGicVKX7odx4NTQ0RABJWTz4a7JA6EIAUfYdL07kAKK8iDrWeE1cqFqjBxuBwiacJKtEAEkPIFXqflz31R\/Z3bue6oBh7o1XSaSwftI5UXyo6jVwQgBRGPfihACizA4dEFklL5DlAToVogsHBgU9Akg6J1Xpfqg3XhFA0lcO\/sobX+mUmOGvYXFCAFGoJYDIKrERhLXA5YkruRBO6IAoyM3npCrdj35uvCKApJOCn7DvpFNCAOmmkdf6SQ0gBw8etE996lOpc\/u6173OzjrrrNS6qhV4TVyoOqIHG4HCJpwQQAbhpArdj35vvCKApJOCn7DvpFNCAIkugDz99NP2mc98JnVuCSCTqRrVoYCNgI1A4RxOCCD9clKF7scgN14RQNJJwU\/Yd9IpIYBEF0Aef\/xxu+GGG5rjvvzyy23BggWJr2FiYsIWL16sMFCpGoyvfTrRg41AWeBwQgDpl5PYux+D3nhFAEknBT9h30mnhAASXQB5+OGH7ctf\/nJz3L\/9279tw8PDyjzXpgbjI4AosMMJnCic8EuSsyr9689+bDfd82V74N9+aA8\/8282OjpmY89M2KIjy+yUQ+vspCMvadad\/\/o19upLTlWkda\/pduPViccssg+8db2Nj47IY8RP8BMFFjhpVwl\/DSuopv4OyM6dO+3rX\/+6LVy40H7rt35LYb5WNSxwNgIFeDiBE4UTNkiz\/3fH5+wzO\/5XU67Dh2f\/ON\/M1LAdPjx1VMITD51urzryJvuda19vCxaOKtK61vS68er9V623lUuTf7Kg26DxE\/xEARpOCCAhc5IaQL73ve\/Zt7\/9bVuxYoW9853vVF5LrWpY4GwECvBwAicKJ3UPIB+79b\/aLQ\/881GpGgFkZsbs8PMzHfIdv+Q4++9Xf8SWLliiSOtWk\/XGq6SB4yf4iQI0nBBAQuYkNYDcdtttdtddd9nJJ59sGzduVF5LrWpY4GwECvBwAicKJ3UOIN9++Lv2n7\/ykTaZGgHkyKEZm55uV6\/xx8EXLx23K19+mW15zW8q0rrU5HHjFQEkferw12SN0IUAkr56zLw4SQ0gX\/va1+yBBx6wM844wy655BKbmpqy6elpGxsbU15X5Wu8Ji5UYdGDjUBhE06SVapzAHnnJ6+2\/YcOtAlz6NBhO3RwyoaG2n\/3cHx8xMYWzP7OxMfe9kF7yXHh\/R5IXjdeEUDSHQU\/Yd9Jp4RfQu+mkdf6SQ0gX\/rSl2zXrl1Hb796\/vnnm69haGjIjj32WDv99NPt7LPP7no7lgJFzDVeExeqZujBRqCwCScEkLkK3L37XvvDm\/60Q5Tn9h+yqSPTNjTn8pNW96NV\/Ovn\/W\/2rvPepmBXWk2eN14RQNKnDT9h30mnhAASXQBpdUB6Te6SJUvsiiuusOOOO05hoFI1GF\/7dKIHG4GywOGEADJXgX+6\/+v2l1\/\/mzZRGr\/7sX\/fQbMZawsgc7sfjQcuOHXS\/uiyaxTsSqvJ88YrAkj6tOEn7DvplBBAogsgjQHv3r27eQvW0qVLbXx8vHkzyZ49e6xxQ9b999\/ffE2LFi2yd73rXc3P1+kD4yOAKLzDCZwonNT1R7Dm3nzV0qnxo1eHnp+9BavVAZnf\/Wh87uyT1tkHN\/6xIm8pNXnfeEUASZ82\/JUAkk4JASTKANJrYu+++2775je\/2Sy54IILbMOGDQoHlanB+DhYKjDDCZwonNQ1gNx495fsv33rfx6VqNH9OPDsIZv5xW+ftwLI\/O5HaAGkiBuvCCDpKwd\/JYCkU0IACS6A\/M3f\/E3n\/YZmzU7G61\/\/ejv11N6\/3DczM2N\/+7d\/awcOHGi7Keuxxx6zm266SWEi6prG78c0PtasWRP168hr8OiRrCS6tOuCHsmcfOMb32h+4pd\/+ZfzWpJRfJ0njvzMvn7w9qNjnT5iNj09ZI39pfHR+J3DxsfoeOd2ddb4Wjt7\/Ez317n30Ih984nlNjVviI2xbzj2WTt58aHcxsj6wU8UmOCkXaW6+msaK16cDHULIK0Bn3TSSbZs2bLmHyP82Mc+1vzPjet4P\/KRjzR\/Cb3x8cUvftF+8pOftP2tEAJI2pRX8\/NeIIeuJrpwYFAYresGeWjmsN2w\/6uzEs2YHTk8GzjmBpDhkRkbTvhj4a9ZsMFWj52kyFtYzcGpIfvG48vt4FT7bV2Nb7h2+UF72THP5fq98RP8RAEKTgggIXOSegtWa\/C33nqrffzjH2\/+UcI\/+ZM\/sfe+971HX9eNN95ojz76qL3oRS+yTZs2Ka+3MjW0ftunEj2S0UYXOFFMr64\/gtXQpvV7II3f\/Wj91fPWj2ANjww3\/+7H\/I8Qfv+j6BuvkrjBT\/ATxU\/gpF2lOvtrL168OJEDSLfBHzlyxD796U83fzF9\/fr19iu\/8ivKuqhMjdfEhSogehBAFDbhJFmlum+Q\/+EzH7Cdj\/zrUXFaAWTBwrGjf\/ej9ckl44vtL3\/tQ\/aiZccryBVWU\/SNVwSQ9KnDT9h30inhd0C6aeS1fnoGkEOHDjV\/9rbXHx381re+Zd\/\/\/vebr+stb3mLrVq1SuGgMjVeExeqgOjBRqCwCScEkCQFtv+v79hnHrjefj62u\/npZgAZGrKlyxe0lR+\/9Dh73xv+dztn1VkKboXVlHHjFQEkffrwE\/addEoIIFEFkJ\/+9KfNXyR\/yUte0gwWjd\/5WLBggR08eND27t3bvIa39TOGp512ml122WUKA5WqwfjapxM92AiUBQ4nBJD5Cjz7zPP2qQ\/fblNTM\/av49+zhxbcZQeG9trI2LAtWjz741eNrscbX\/q65h8eXLpgiYJaYTVl3XhFAEmfQvyEfSedEgJIdAHkc5\/7XOq8NgLKG9\/4RhsdHU2trVoBxkcAUZiGEzhROKnzj2B97Qs\/srtvf7RNpqcO\/NReepnZ2WevsxctP8H9x61ag3vk5wfswzfeZ0empjum9d0XnWEbTl+pTPfANfgJfqLAAyftKtXZX3vx4sVJ6u+ANG63evDBB+3JJ5+0ffv2WeN3PhpBo\/HXz0888UR72cteZo2bsur64TVxoeqNHrwTpbAJJ3RA5iowt\/sx978fv2bKXjY5YZOTkwpWpdTs3X\/I\/uzz99ozB2b\/SOLcj0tfeZK95VWnFD4O1g8BRIEMTgggIXOSGkCUwde5hgXORqDwDydwonBS13fokrofY+MjNnnpAhsbHw4mgHjceJXEDX6Cnyh+AicEkJA5IYAos9OjhgXORqAgBCdwonBSxwDSrftx\/utfbAtW7mnKFkoHxOPGKwJI+srBX5M1QhcCSPrqMfPiRA4gzzzzjC1fvlx5LbWq8Zq4UEVGDzYChU04SVapjgGkW\/fjPddeaD+4d\/aGxRACiNeNVwSQdEfBT9h30inhl9C7aeS1fuQAsm3bNmv8a3xs3bq1+Y8Pv+QYqvZeIIeqR2tc6EIHRGG0bgGkV\/fj1Zec5vbO3Py58rzxigCSvnLwVwJIOiUEEAKIQklENRgfB0sFVziBE4WTugWQXt2PBQtHgwgg3jdeEUDSVw7+SgBJp4QAQgBRKImoBuPjYKngCidwonBSpwCS1v1o6OW9bkK48YoAkr5yvDlJH6FPBbq0614nf+2HOC9O+BGsfmYpodZr4jIOu7DH0YN3ohS44CRZpTptkGndD+8AEsqNVwSQdEfBT9h30imhA0IHRKEkohqMj3e2FVzhBE4UTuoSQJTuh3cACeXGKwJI+srBXwkg6ZQQQAggCiUR1WB8HCwVXOEEThRO6hJAlO6HZwAJ6cYrAkj6ysFfCSDplBBACCAKJRHVYHwcLBVc4QROFE7qEEDU7odXAAntxisCSPrKwV8JIOmUEEAIIAolEdVgfBwsFVzhBE4UTuoQQNTuh0cACfHGKwJI+srBXwkg6ZQQQAggCiUR1WB8HCwVXOEEThROqh5A+ul+lB1AQr3xigCSvnLwVwJIOiUEEAKIQklENRgfB0sFVziBE4WTqgeQfrofZQaQkG+8IoCkrxz8lQCSTgkBhACiUBJRDcbHwVLBFU7gROGkygGk3+5HmQEk5BuvCCDpKwd\/JYCkU0IAIYAolERUg\/FxsFRwhRM4UTipcgDpt\/tRVgD5hzt22z\/eubtjepYtGrP3X7XeVi5doExdqTX4CX6iAAcn7SpV2V8VHgggWVQK8FkWOBuBgiWcwInCSVU3yEG6H2UEkBhuvKIDkr5y8Fc6IOmU0AEhgCiURFSD8XGwVHCFEzhROKlqABmk+1F0AInlxisCSPrKwV8JIOmUEEAIIAolEdVgfBwsFVzhBE4UTqoYQAbtfhQZQGK68YoAkr5y8FcCSDolBBACiEJJRDUYHwdLBVc4gROFkyoGkEG7H0UFkNhuvCKApK8c\/JUAkk4JAYQAolASUQ3Gx8FSwRVO4EThpGoBJEv3o6gAEtuNVwSQ9JWDvxJA0ikhgBBAFEoiqsH4OFgquMIJnCicVC2A3HrTg\/b9b7ffMDU2PmLvufZCW7BwNFWSvNdNjDdeEUBSMbG8OUn\/jnFUoEv7PFXNX\/Oi0IuToZmZmRnlRWzbts0a\/xofW7dubf7jwzC+eRB4gRw6i+hCAFEYrdIGmbX7kXcHJNYbrwgg6SsHf6UDkk4JHRA6IAolEdVgfBwsFVzhBE4UTqoUQLJ2P\/IMIDHfeEUASV85+CsBJJ0SAggBRKEkohqMj4OlgiucwInCSVUCSB7dj7wCSOw3XhFA0lcO\/koASaeEAEIAUSiJqAbj42Cp4AoncKJwUpUAkkf3I48AUoUbrwgg6SsHfyWApFNCACGAKJREVIPxcbBUcIUTOFE4qUIAyav7kUcAqcKNVwSQ9JWDvxJA0ikhgBBAFEoiqsH4OFgquMIJnCicVCGA5NX9yBpAqnLjFQEkfeXgrwSQdEoIIAQQhZKIajA+DpYKrnACJwonsQeQPLsfWQJIlW68IoCkrxz8lQCSTgkBhACiUBJRDcbHwVLBFU7gROEk9gCSZ\/dj0ABStRuvCCDpKwd\/JYCkU0IAIYAolERUg\/FxsFRwhRM4UTiJOYDk3f0YJID0uvHqklecZBvPP0WZhuBr8BP8RIEUTtpVitlflfketMaLE\/4Q4aAz9ovnvCYu47ALexw9eCdKgQtOklWKeYPMu\/vRbwCp6o1XdEDSHQU\/Yd9Jp4QOCB0QhZKIajA+3olScIUTOFE4iTWAFNH96DeAVPXGKwJI+srBXwkg6ZQQQAggCiUR1WB8HCwVXOEEThROYg0gRXQ\/+gkgVb7xigCSvnLwVwJIOiUEEAKIQklENRgfB0sFVziBE4WTGANIUd0PNYBU\/cYrAkj6ysFfCSDplBBACCAKJRHVYHwcLBVc4QROFE5iDCBFdT+UAFKHG68IIOkrB38lgKRTQgAhgCiURFSD8XGwVHCFEzhROIktgBTZ\/UgLIHW58YoAkr5y8FcCSDolBBACiEJJRDUYHwdLBVc4gROFk9gCSJHdj14BpE43XhFA0lcO\/koASaeEAEIAUSiJqAbj42Cp4AoncKJwElMA6db9eNWvvNhec+lpystNrem2bup04xUBJBUTw18JIOmUEEAIIAolEdVgfBwsFVzhBE4UTmIKIEV3P7p1QOp24xUBJH3l4K8EkHRKCCAEEIWSiGowPg6WCq5wAicKJ7EEkDK6H0kBpI43XhFA0lcO\/koASaeEAEIAUSiJqAbj42Cp4AoncKJwEksAKaP7MT+A1PXGKwJI+srBXwkg6ZQQQAggCiUR1WB8HCwVXOEEThROYgggZXU\/5gaQM172cvuzz99rzxw43CHjJa84yTaef4oib2Vq8BP8RIEZTtpVisFflXnNu8aLk6GZmZkZ5cVs27bNGv8aH1u3bm3+48P45bd5EHiBHDqL6MKBQWE0hg2yrO5HK4AcnpqxW3+y0HbvOdAh4TlrVth7LznDhoaGFHkrU4Of4CcKzHBCAAmZEwKIMjs9aljgbAQKQnACJwonoQeQMrsfrQDyhXuetZ8fXtQh34nHLLIPvHW9jY+OKNJWqgY\/wU8UoOGEABIyJwQQZXYIILJKGF6yVOjCgUFZRKEHkDK7Hw29\/upz\/2K3\/\/g5m5iYaJNv2aIxe\/9V623l0gWKrJWrwU\/wEwVqOCGAhMwJAUSZHQKIrBKGRwBRYIGTZJVCDiBldz8aN159dPsdTaHmBpDRkWH7vSvX2ZrjlyioVbKG9UMAUcCGEwJIyJwQQJTZIYDIKmF4BBAFFjiJL4CU2f1o3Xj18z1PdQSQd190hm04faWCWWVrWD8EEAVuOCGAhMwJAUSZHQKIrBKGRwBRYIGTuAJImd2PvfsPHb3xau\/evW0BpI43XiWRwvohgOCzigIEEEUlLz8hgCizQwCRVfICWR6gUyG6cGBQ0Av1R7DK6n4cOjJl227cefTGq7kBpK43XhFA0lcO\/sobX+mU8HdAumnktX4IIAq1BBBZJS+Q5QE6FaILAURBL8QAUmb347qv\/sju3jX7Y1eNj1YAeemaE2t74xUBJH3l4K8EkHRKCCAEEIWSiGowPg6WCq5wAicKJyEGkLK6H\/9wx277xzt3t8nUCCCLxobtQ1e\/trY3XhFA0lcO\/koASaeEAEIAUSiJqAbj42Cp4AoncKJwEloAKav70bjx6pO3PNgh0bP79trbz11uV7zhAkW+2tTgJ\/iJAjuctKsUmr8qc1hGjRcn\/AhWxtn1mriMwy7scfTgnSgFLjhJVim0DbKM7kfrxqsjU9Mdorxm9ZSdecK4TU5OKljVpob1QwBRYIcTAkjInBBAlNnpUcMCZyNQEIITOFE4CSmAlNH9mHvj1Xx9GjderR55svmfCSCsn17rB3\/lja\/Y\/FUZb1k1XuuHAJJxhr0mLuOwC3scPdgIFLjgJPwOSNHdj\/k3Xs1VZN3qCfudy860O++8kwCSgArrh0CGzyoK0AFRVPLyEwKIMjt0QGSVvECWB+hUiC4cGBT0QumAlNH9mH\/jVUufE49ZZNdsXG8Lx0eMdcMbGsq6gRM4UTgJxV+VsZZZ47V+CCAZZ9lr4jIOu7DH0YONQIELTsLugBTd\/Ui68aqhyLJFY\/b+q9YfvfEKTvAT\/ERRAE4UlQggYXFCAFGopQMiq8SBIawFLk9cyYVwEm4AKbr70e3Gq5HhIftPb1lva45fclQcOMFPFGuCEzhROCGAhMUJAUShlgAiq8RGENYClyeu5EI4CTeAFNn96HXj1W+8\/nQ7f+1xbcLACX6iWBOcwInCCQEkLE4IIAq1BBBZJTaCsBa4PHElF8JJmAGkyO5H2o1XG88\/pUMUOMFPFGuCEzhROCGAhMXJ0I4dO2aUibv++uut8a\/xsXnz5uY\/Psx27tzZlGHdunXIYejRDQI4aVcGPZJJ2b59e\/MTmzZtcvGTe2572nbdv7\/te4+MDtnF7zjRxsaHBx7T4akZ+7s7n7GfPTvV8TXWrByzq85ZZkNDnV8eTpIlRxf8RFmMcNKukre\/KnPmUePFCQEk42x7TVzGYRf2OHpwYFDggpPwAsjBA1N2y2cft5l5fw\/wjHOW2csmlyvT2rXmC\/c8aw\/97FDH51cuHrZ3Tk7Y+GhC+uANja56sn4IIMqChBMCSMic8CNYyuz0qKH12y4OeiTDgi5woliN548IFPW7H+qNV0n6sG7wE2XdwAmcKJx4+qsyPq8ar\/VDAMk4414Tl3HYhT2OHmwEClxwkqyS1wZZ1O9+9HPjFQFEWTmzNawf3tBQaIGTdpW8\/FWZK88aL04IIBln3WviMg67sMfRgwCiwAUnYQWQIrof\/d54RQBRVg4BBE7gRFeAAKJo5bUfE0CU2elR4zVxGYdd2OPoQQBR4IKTcAJIEd2PQW684mCprBwCCJzAia4AAUTRyms\/JoAos0MAkVXyAlkeoFMhurQLjx7hBJC8ux+HjkzZtht32u49Bzpe5LrVE\/Y7l51pQ0lXXiVIAie8oaFYNpzAicIJP4IVFicEEIVaAoisEhtBWAtcnriSC+EkjABSRPfjuq\/+yO7e9VTHCzzxmEV2zcb1tnB8RKYNTvATBRY4gROFEwJIWJwQQBRqCSCySmwEYS1weeJKLoSTMAJI3t2PLDdeJSkCJ\/iJYk1wAicKJwSQsDghgCjUEkBkldgIwlrg8sSVXAgn\/gEk7+5H1huvCCD6ImT9tGuFHuw7yuohgITFCQFEoZYAIqvERhDWApcnruRCOPEPIHl2P\/K48YoAoi9C1g8BRKEFTtpVIoCEdT4hgCirmAAiq4ThhbXA5YkruRBOfANInt2PvG68IoDoi5D1QwBRaIETAkjInBBAlNkhgMgqYXgEEAUWOPENIHl1P\/K88YoAoqyc2RrWDwFEoQVOCCAhc0IAUWaHACKrhOERQBRY4MQvgOTZ\/cjzxisCiLJyCCBwAie6AgQQRSuv\/ZgAoswOAURWyQtkeYBOhejCO5YKemX8jHJe3Y9\/uOMR+8c7H+14WcsWjdn7r1pvK5cuUF5yzxrWDW9oKBDBCZwonJThr8o4QqvxWj8EkIwkeE1cxmEX9jh6sBEocMGJTwckr+5HETde8c62snLogMAJnOgK0AFRtPLajwkgyuzQAZFV8gJZHqBTIbrQAVHQK\/odujy6H0XdeMXBUiGEAAIncKIrQABRtPI6nxBAlNkhgMgqeYEsD9CpEF0IIAp6RQaQPLofRd54xcFSIYQAAidwoitAAFG08jqfEECU2SGAyCp5gSwP0KkQXQggCnpFBpCs3Y+ib7ziYKkQQgCBEzjRFSCAKFp5nU8IIMrsEEBklbxAlgfoVIguBBAFvaICSB7dj6JvvOJgqRBCAIETONEVIIAoWnmdTwggyuwQQGSVvECWB+hUiC4EEAW9ogJI1u5HGTdecbBUCCGAwAmc6AoQQBStvM4nBBBldgggskpeIMsDdCpEFwKIgl4RASRr96OsG684WCqEEEDgBE50BQggilZe5xMCiDI7BBBZJS+Q5QE6FaILAURBr4gAkqX7UeaNVxwsFUIIIHACJ7oCBBBFK6\/zCQFEmR0CiKySF8jyAJ0K0YUAoqCXdwDJ0v3odePVxa84ya46\/xTlJWWqYd0ky4cu+ImysOCEABIyJwQQZXYIILJKGB4HBgUWOElWKe8AMmj3w+PGK97ZVlYOHRA4gRNdAQKIopXXfkwAUWaHACKr5AWyPECnQnThHUsFvTwDSJbuh8eNVxwsFUIIIHACJ7oCBBBFK6\/zCQFEmR0CiKySF8jyAJ0K0YUAoqCXZwAZtPvhdeMVB0uFEAIInMCJrgABRNHK63xCAFFmhwAiq+QFsjxAp0J0IYAo6OUVQAbtfnjeeMXBUiGEAAIncKIrQADyyjFCAAAgAElEQVRRtPI6nxBAlNkhgMgqeYEsD9CpEF0IIAp6eQWQQbof3jdecbBUCCGAwAmc6AoQQBStvM4nBBBldgggskpeIMsDdCpEFwKIgl4eAaRb9+O8151ir33T6YnDCOHGKw6WCiEEEDiBE10BAoiildf5hACizA4BRFbJC2R5gE6F6EIAUdDLI4D02\/0I5cYrDpYKIQQQOIETXQECiKKV1\/mEAKLMDgFEVskLZHmAToXoQgBR0MsaQAbpfoRy4xUHS4UQAgicwImuAAFE0crrfEIAUWaHACKr5AWyPECnQnQhgCjoZQ0g\/XY\/QrrxioOlQggBBE7gRFeAAKJo5XU+IYAos0MAkVXyAlkeoFMhuhBAFPSyBJB+ux+h3XjFwVIhhAACJ3CiK0AAUbTyOp8QQJTZIYDIKnmBLA\/QqRBdCCAKelkCSD\/djxBvvOJgqRBCAIETONEVIIAoWnmdTwggyuwQQGSVvECWB+hUiC4EEAW9QQNIP92PUG+84mCpEEIAgRM40RUggChaeZ1PCCDK7BBAZJW8QJYH6FSILgQQBb1BA4ja\/Qj5xisOlgohBBA4gRNdAQKIopXX+YQAoswOAURWyQtkeYBOhehCAFHQGySA9NP9CPnGKw6WCiEEEDiBE10BAoiildf5hACizA4BRFbJC2R5gE6F6EIAUdAbJICo3Y\/Qb7ziYKkQQgCBEzjRFSCAKFp5nU8IIMrsEEBklbxAlgfoVIguBBAFvX4DiNr9iOHGKw6WCiEEEDiBE10BAoiildf5hACizA4BRFbJC2R5gE6F6EIAUdDrN4Ao3Y9YbrziYKkQQgCBEzjRFSCAKFp5nU8IIMrsEEBklbxAlgfoVIguBBAFvX4CiNL9iOnGKw6WCiEEEDiBE10BAoiildf5hACizA4BRFbJC2R5gE6F6EIAUdDrJ4CkdT9iu\/GKg6VCCAEETuBEV4AAomjldT4hgCizQwCRVfICWR6gUyG6EEAU9NQAonQ\/YrvxioOlQggBBE7gRFeAAKJo5XU+IYAos0MAkVXyAlkeoFMhuhBAFPTUAJLW\/YjxxisOlgohBBA4gRNdAQKIopXX+YQAoswOAURWyQtkeYBOhehCAFHQUwJIWvcj1huvOFgqhBBA4AROdAUIIIpWXucTAogyOwQQWSUvkOUBOhWiCwFEQU8JIF\/\/4oN21227277c2PiIvefaC+2n+w\/Zh2+8z45MTXd8u994\/el2\/trjlGEEU8O6SZ4KdMFPlEUKJwSQkDkhgCizQwCRVcLwODAosMBJskppAaRX9+Plr11tf\/b5e+2ZA4c7vvjFrzjJrjr\/FGVqgqqBE\/xEARJO4EThJM1fla9RxRqv9UMAyUiT18RlHHZhj6MHG4ECF5wMFkC6dT9+Y+v59ldf+aHt3nOg4wuvWz1hv3PZmTY0NKRMTVA1cIKfKEDCCZwonBBAwuKEAKJQSwdEVomNIKwFLk9cyYVw0n8A6dX9uG9oyu7e9VTHFz3xmEV2zcb1tnB8pOQZzufbwQl+opAEJ3CicEIACYsTAohCLQFEVomNIKwFLk9cyYVw0n8A6db9WPWmU+yf7nmi4wsuWzRm779qva1cuqDk2c3v28EJfqLQBCdwonBCAAmLEwKIQi0BRFaJjSCsBS5PXMmFcNJfAOnW\/Tjm5cfajn2dP3Y1Mjxk\/+kt623N8UtKntl8vx2c4CcKUXACJwonBJCwOCGAKNQSQGSV2AjCWuDyxJVcCCf9BZCk7sdzI0P22CkLrfO+K7MYb7xKUgRO8BPFmuAEThROCCBhcUIAUaglgMgqsRGEtcDliSu5EE70AJLU\/Xh+ZsZ+dMywLVyxsOMLXXTOifbWC15c8owW8+3gBD9RyIITOFE4IYCExQkBRKGWACKrxEYQ1gKXJ67kQjjRA8j87sfUzIztmDpkK06bsOGR9putYr7xig6IvghZP+1aoQf7jrJ6CCBhcUIAUaglgMgqsRGEtcDliSu5EE60AJLU\/bjr8PN26JhxW3n84rYvEvuNVwQQfRGyfgggCi1w0q4SASSs8wkBRFnFBBBZJQwvrAUuT1zJhXCiBZD53Y8HjxyyH09P2YtfsqKt+1GFG68IIPoiZP0QQBRa4IQAEjInBBBldgggskoYHgFEgQVO0gPI\/O7H41NH7J7Dh2zi2EVt3Y+q3HhFAFFWzmwN64cAotACJwSQkDkhgCizQwCRVcLwCCAKLHCSHkDmdj+emZ627xx63mzYOrofVbnxigCirBwCCJzAia4AAUTRyms\/JoAos0MAkVXyAlkeoFMhuvCOpYJe62eU3\/XO37RPffh2m5qascaNV98+dLD5v8fM635U6cYrDpYKIQQQOIETXQECiKKV1\/mEAKLMDgFEVskLZHmAToXoQgBR0GsFkDNPfqPdddtua9x41eh87JuZtuHhobbuR9VuvOJgqRBCAIETONEVIIAoWnmdTwggyuwQQGSVvECWB+hUiC4EEAW9RgA58vyQTf30pc3uR+PGqyenppqPzu1+VPHGKw6WCiEEEDiBE10BAoiildf5hACizA4BRFbJC2R5gE6F6EIAUdBrBJAn\/nXMlo2ebo0brx46cqT52NzuR1VvvOJgqRBCAIETONEVIIAoWnmdTwggyuwQQGSVvECWB+hUiC4EEAW9v\/74J+zB7y6w8ZNXNW+8mvnFQ63uR5VvvOJgqRBCAIETONEVIIAoWnmdTwggyuwQQGSVvECWB+hUiC4EEAW9\/\/vaT9nux8bskeOPs+lfxI+53Y8q33jFwVIhhAACJ3CiK0AAUbTyOp8QQJTZIYDIKnmBLA\/QqRBdCCBp6DX+7scf\/Me\/twcWLbLRJUuOlre6H1W\/8YqDZRohL3weP8FPFFrghAASMicEEGV2CCCyShheslTowoEhbRHd\/IUf2kf\/4fv23MiILVq0qFne6n6cteYY+\/dvOrP5\/+v0wbrBTxTe4QROFE5atwxu2bJFKa9Njdf6IYBkRMxr4jIOu7DH0YONQIELTtpVanQ\/fvdPvmb\/tv9Zs6FhW7h4cbOg0f1Yv\/ZYu2bjels4PqJIW6kaOMFPFKDhBE4UTgggYXFCAFGopQMiq8RGENYClyeu5EI4aRf8T\/\/4BvvGk0ds6hdX7o4tWWIjY2P20vXH2R+87eV23LIFJc9QGN8OTvAThUQ4gROFEwJIWJwQQBRqCSCySmwEYS1weeJKLoSTWcFnpqftgb+7wd73\/83+ynkrgIyMjduxq1fan7570k4\/cVnJsxPOt4MT\/EShEU7gROGEABIWJ0M7duxo3fTYc\/6uv\/56a\/xrfGzevLn5jw+znTt3NmVYt24dchh6dIMATtqVQQ8zm5626du+ZY\/fv9v+y5HzmgJNT083\/3d0dMTe8aaT7BUvnv1dkLp+wEnyzKMLfqJ4Apy0q7R9+\/bmf9i0aZMiX21qvDghgGREzGviMg67sMfRgwODAlftOflF+Jj+0Q+bcv2P519uP7KVRwPIq08dt6suX6NIWema2nPSZXbRhQCiLHw4IYCEzAk\/gqXMTo8aWr\/t4qBHMizoAictBRo\/dvXEjZ+3p+\/Y0SbKrc+eYLfvXWAnLZ+yD\/7l72Z0pmo8zrrBTxSS4QROFE74EaywOCGAKNQSQGSV2AjCWuDyxJVcWFdOuoWPlvx3jYzaM6tWG9dEzipSV07SliO68IZGGiOsn06FCCBhnU8IIMoqJoDIKrExhrXA5YkrubCOnKSFjxOueLN97gf3NmeCAEIA6bUk67h+0KN\/k4aTds0IIGGdTwgg\/a\/ptidY4LwTpSAEJ\/XmRAkfK1\/9GmODrDcnipfwznanSvhrWAdLleOy6\/DXsDghgGRcARgfBwYFITipLydq+GgoxAZZX04UH2nV4CdwovACJ3RAQuaEAKLMTo8aFjgbgYIQnNSTk37CBwGEd7YVL6EDAidwoipAAFGU8jqfEECU2SGAyCp5gSwP0KkQXeoXQPoNHwQQDpaqPeEn9fMTlY25dXBCAFG48eKEAKLMDgFEVskLZHmAToXoUq8DwyDhgwBCAFHtCT+pl5+oXMyvgxMCiMKOFycEEGV2CCCySl4gywN0KkSX+hwYBg0fBBACiGpP+El9\/ERlIqkOTgggCj9enBBAlNkhgMgqeYEsD9CpEF3qcWDIEj4IIAQQ1Z7wk3r4icpDtzo4IYAoDHlxQgBRZocAIqvkBbI8QKdCdKn+gSFr+CCAEEBUe8JPqu8nKgu96uCEAKJw5MUJAUSZHQKIrJIXyPIAnQrRpdoHhjzCBwGEAKLaE35SbT9ROUirgxMCSBojjc97cUIAUWaHACKr5AWyPECnQnSp7oEhr\/BBACGAqPaEn1TXT1QGlDo4IYCEzAkBRJkdAoisEoaXLBW6VPPAkGf4IIAQQFSjxU+q6Sfq\/Kt1cEIAUVjx4oQAoswOAURWyQtkeYBOhehSvQND3uGDAEIAUe0JP6men6hz308dnBBAFF68OCGAKLNDAJFV8gJZHqBTIbpU68BQRPgggBBAVHvCT6rlJ+q891sHJwQQhRkvTgggyuwQQGSVvECWB+hUiC7VOTAUFT4IIAQQ1Z7wk+r4iTrng9TBCQFE4caLEwKIMjsEEFklL5DlAToVoks1DgxFhg8CCAFEtSf8pBp+os73oHVwQgBR2PHihACizA4BRFbJC2R5gE6F6BL\/gaHo8EEAIYCo9oSfxO8n6lxnqYMTAojCjxcnBBBldgggskpeIMsDdCpEl7gPDGWEDwIIAUS1J\/wkbj9R5zlrHZwQQBSGvDghgCizQwCRVfICWR6gUyG6xHtgKCt8EEAIIKo94Sfx+ok6x3nUwQkBROHIixMCiDI7BBBZJS+Q5QE6FaJLnAeGMsMHAYQAotoTfhKnn6jzm1cdnBBAFJa8OCGAKLNDAJFV8gJZHqBTIbrEd2AoO3wQQAggqj3hJ\/H5iTq3edbBCQFE4cmLEwKIMjsEEFklL5DlAToVoktcBwaP8EEAIYCo9oSfxOUn6rzmXQcnBBCFKS9OCCDK7BBAZJW8QJYH6FSILvEcGLzCBwGEAKLaE34Sj5+oc1pEHZwQQBSuvDghgCizQwCRVfICWR6gUyG6xHFg8AwfBBACiGpP+EkcfqLOZ1F1cEIAUdjy4oQAoswOAURWyQtkeYBOhegS\/oHBO3wQQAggqj3hJ+H7iTqXRdbBCQFE4cuLEwKIMjsEEFklL5DlAToVokvYB4YQwgcBhACi2hN+ErafqPNYdB2cEEAUxrw4IYAos0MAkVXyAlkeoFMhuoR7YAglfBBACCCqPeEn4fqJOodl1MEJAUThzIsTAogyOwQQWSUvkOUBOhWiS5gHhpDCBwGEAKLaE34Spp+o81dWHZwQQBTWvDghgCizQwCRVfICWR6gUyG6hHdgCC18EEAIIKo94Sfh+Yk6d2XWwQkBROHNixMCiDI7BBBZJS+Q5QE6FaJLWAeGEMMHAYQAotoTfhKWn6jzVnYdnBBAFOa8OCGAKLNDAJFV8gJZHqBTIbqEc2AINXwQQAggqj3hJ+H4iTpnHnVwQgBRuPPihACizA4BRFbJC2R5gE6F6BLGgSHk8EEAIYCo9oSfhOEn6nx51cEJAURhz4sTAogyOwQQWSUvkOUBOhWii\/+BIfTwQQAhgKj2hJ\/4+4k6V551cEIAUfjz4oQAoswOAURWyQtkeYBOhejie2CIIXwQQAggqj3hJ75+os6Tdx2cEEAUBr04IYAos0MAkVXyAlkeoFMhuvgdGGIJHwQQAohqT\/iJn5+ocxRCHZwQQBQOvTghgCizQwCRVfICWR6gUyG6+BwYYgofBBACiGpP+ImPn6jzE0odnBBAFBa9OCGAKLNDAJFV8gJZHqBTIbqUf2CILXwQQAggqj3hJ+X7iTo3IdXBCQFE4dGLEwKIMjsEEFklL5DlAToVoku5B4YYwwcBhACi2hN+Uq6fqPMSWh2cEEAUJr04IYAos0MAkVXyAlkeoFMhupR3YIg1fBBACCCqPeEn5fmJOich1sEJAUTh0osTAogyOwQQWSUvkOUBOhWiSzkHhpjDBwGEAKLaE35Sjp+o8xFqHZwQQBQ2vTghgCizQwCRVfICWR6gUyG6FH9giD18EEAIIKo94SfF+4k6FyHXwQkBROHTixMCiDI7BBBZJS+Q5QE6FaJLsQeGKoQPAggBRLUn\/KRYP1HnIfQ6OCGAKIx6cUIAUWaHACKr5AWyPECnQnQp7sBQlfBBACGAqPaEnxTnJ+ocxFAHJwQQhVMvTgggyuwQQGSVvECWB+hUiC7FHBiqFD4IIAQQ1Z7wk2L8RNU\/ljo4IYAorHpxQgBRZocAIqvkBbI8QKdCdMn\/wFC18EEAIYCo9oSf5O8nqvYx1cEJAUTh1YsTAogyOwQQWSUvkOUBOhWiS74HhiqGDwIIAUS1J\/wkXz9RdY+tDk4IIAqzXpwQQJTZIYDIKnmBLA\/QqRBd8jswVDV8EEAIIKo94Sf5+YmqeYx1cEIAUbj14oQAoswOAURWyQtkeYBOheiSz4GhyuGDAEIAUe0JP8nHT1S9Y62DEwKIwq4XJwQQZXYIILJKXiDLA3QqRJfsB4aqhw8CCAFEtSf8JLufqFrHXAcnBBCFXy9OCCDK7BBAZJW8QJYH6FSILtkODHUIHwQQAohqT\/hJNj9RdY69Dk4IIArDXpwQQJTZIYDIKnmBLA\/QqRBdBj8w1CV8EEAIIKo94SeD+4mqcRXq4IQAonDsxQkBRJkdAoiskhfI8gCdCtFlsANDncIHAYQAotoTfjKYn6j6VqUOTgggCstenBBAlNkhgMgqeYEsD9CpEF36PzDULXwQQAggqj3hJ\/37iaptlerghACi8OzFCQFEmR0CiKySF8jyAJ0K0aW\/A0MdwwcBhACi2hN+0p+fqLpWrQ5OCCAK016cEECU2SGAyCp5gSwP0KkQXfQDQ13DBwGEAKLaE36i+4mqaRXr4IQAonDtxQkBRJkdAoiskhfI8gCdCtFFOzDUOXwQQAggqj3hJ5qfqHpWtQ5OCCAK216cEECU2SGAyCp5gSwP0KkQXdIPDHUPHwQQAohqT\/hJup+oWla5Dk4IIArfXpwQQJTZIYDIKnmBLA\/QqRBdeh8YCB+z+lx33XXN\/92yZYsTqWF9W9ZN8nygCwFEWalwQgAJmRMCiDI7BBBZJQyPA4MCy1xOCB8vKEYA4WDZ7\/pR6qtew77DvqMwjr+GxQkBRKGWACKrxEYQ1gKXJ67kwhYnG84915648fP29B07EkdwwhVvtpWvfk3Jo\/P7dmyQBBCFPnwWTuBEUYAOiKKSl58QQJTZIYDIKnmBLA\/QqRBdEg4M09O26pGfED7mSEMA4WCpWBR+AidwoihAAFFU8vITAogyOwQQWSUvkOUBOhWiy7wDw3e\/a9O3fcuWPfkEnQ8CSNdVybpJlgZdCCDKVgYnBJCQOSGAKLNDAJFVwvA4MKTB0vidjx1\/9XGb\/tEPbWJioqO8bj92NVcAOiAcLNPWT+Pz+CycwImiAAFEUcnLTwggyuwQQGSVvECWB+hUiC6zwrd+4XzX125p\/v\/5AaTO4aOhBwGEg6ViUfgJnMCJogABRFHJy0+GduzYMaMM8Prrr7fGv8bH5s2bm\/\/4MNu5c2dThnXr1iGHoUc3CODEzKanmz921eh87Nu3rynVsmXLjko2\/Krzbfiss2u9jrZv3958\/Zs2baq1Dq0Xz7pJxgBd2nVBDzhRDBN\/DYsTAohCbY8ajI+NQEGo9pzMCR8NveYHEMLHLEVskPgJfqIoACeKSrXfd+aJhL8GFkBmZmakDsi2bdus8a\/xsXXr1uY\/PvhZ3PkMeLXyQmexzrok\/Z2PvXv3Nqes8SNYdf+xq7ns8iNY7Su5zuuml6ehC5woex6ctKuEvyZT48UJvwOirOIeNV4Tl3HYhT2OHmEt8MImWvzC3f7IYCuArP31d9Xq73ykycYGycEyjZHG5\/FZOIETRQECiKKSl58QQJTZIYDIKnmBLA\/QqbCOuvT6C+eNANL4satX\/cZvOs1ImN+WAMLBUiGzjn5CR0ghg\/XTSyX8Naw3SAkg\/a\/ptifYCDA8BaG6cdIrfDT02nfmS5u\/cD45OanIV5saNkj8RIG9bn6Spgl6hHWwTJsvr8\/jr2FxQgDJuBIwPg4MCkJ14iQtfDR+5+PhBQubshFA2ulhg8RP8BNFAThRVKrTvqPogb8SQBROoqlhgbMRKLDWhRMlfKx89Wv4GfYu0LBB4if4iaIAnCgq1WXfUbRo1OCvBBCVlSjqWOBsBAqodeBEDR8Nveqgh8LF\/Bo2SPxE4Yb1AydwoijQXoO\/EkD6pybgJ9gI2AgUPKvOST\/hgwDSnRg2SPwEP1EUgBNFparvO4oGc2vwVwJIv8wEXc8CZyNQAK0yJ\/2GDwIIAURZM3DSXaUq+4nKxtw69AjrYDnIHJbxDAEkLE74JfSM1GN8BBAFoapyMkj44GBJAFHWDJwQQOBEVSCsg2W2URf3NAEkLE4IIBlZr+rBclBZ0COsBT7oPCrPDRo+OFgSQBS+4IQAAieqAvXZd7IoQgAJixMCSBaa+WXaDvUIIGEt8Ix4d308S\/jgYEkAUbnET+rhJyoP3ergBE4UhgggYXFCAFGo7VGD8bWLgx5hLfCMeCc+njV8EEAIICqX+En1\/URloVcdnMCJwhEBJCxOCCAKtQQQWSU2grAWuDxxYmEe4YMAQgARceO65i5C4bO88aWsIThpV4kAEtb5hACirGICiKwShhfWApcnTijMK3wQQAggAm7NEvykun6iMqDUwQmcKJwQQMLihACiUEsAkVViIwhrgcsTl1KYZ\/jgYEkAUbnET6rpJ+r8q3VwAicKKwSQsDghgCjUEkBkldgIwlrg8sT1KMw7fBBACCAql\/hJ9fxEnft+6uAEThReCCBhcUIAUaglgMgqsRGEtcDlietSWET4IIAQQFQu8ZNq+Yk67\/3WwQmcKMwQQMLihACiUEsAkVViIwhrgcsTl1BYVPgggBBAVC7xk+r4iTrng9TBCZwo3BBAwuKEAKJQSwCRVWIjCGuByxM3r7DI8EEAIYCoXOIn1fATdb4HrYMTOFHYIYCExQkBRKGWACKrxEYQ1gKXJ25OYdHhgwBCAFG5xE\/i9xN1rrPUwQmcKPwQQMLihACiUEsAkVViIwhrgcsT94vCMsIHAYQAonKJn8TtJ+o8Z62DEzhRGCKAhMUJAUShlgAiq8RGENYClyfOzMoKHwQQAojKJX4Sr5+oc5xHHZzAicIRASQsTgggCrUEEFklNoKwFrg6cWWGDwIIAUTlEj+J00\/U+c2rDk7gRGGJABIWJwQQhVoCiKwSG0FYC1yZuLLDBwGEAKJwCSfdVcJn27VBj\/j2HdUD8qwjgITFCQEkI90YHxuBglConHiEDw6WBBBlzcAJAQROVAXCOlhmG3VxTxNAwuKEAJKR9VAPlhlf1sCPo0dYC7zXRHqFDw6WBBDVYPCTePxEndMi6uAEThSuCCBhcUIAUajtUYPx0QFREAqNE8\/wQQAhgChrBk7ogMCJqkBYB8tsoy7uaQJIWJwQQDKyHtrBMuPL+f\/bO\/MgO6tyX6\/OSCYSDFMCB0HEQxQl1xQIIud4vATkoOdaUes6RJxFpVAsywH1OhaOoEKh5YCWFkFvXTV6C2eLfyhRSgP3gGDkXiGAhIAYMQNJZ+j0rfW1O\/ZOdvd+du\/e\/a6997NPdemx36975bee9a719LeHti83j7IWeKPRRMuHB0sFhDYa+0n5\/YTOZSfr5EROCF8KSFmcKCCEWu+A4JTcCMpa4AeOpgT5UEAUENpQ7Cdl9xM6j52ukxM5IYwpIGVxooAQahUQnJIbQVkLfPRoSpEPBUQBoQ3FflJuP6FzOBV1ciInhDMFpCxOFBBCrQKCU3IjKGuB10ZTknwoIAoIbSj2kzL7CZ2\/qaqTEzkhrCkgZXGigBBqFRCckhtBWQs8j6Y0+VBAFBDaUOwn5fUTOndTWScnckJ4U0DK4kQBIdQqIDglN4KyFniJ8qGAKCC0odhPyuondN6muk5O5IQwp4CUxYkCQqhVQHBKbgTlLPBS5UMBUUBoQ7GflNNP6JxF1MmJnBDuFJCyOFFACLUKCE7JjaCMBV6yfCggCghtKPaTMvoJna+oOjmRE8KeAlIWJwoIoVYBwSm5EcQv8NLlQwFRQGhDsZ\/E9xM6V5F1ciInhD8FpCxOFBBCrQKCU3IjiF3g3SAfCogCQhuK\/SS2n9B5iq6TEzkhDCogZXGigBBqFRCckhtB3ALvFvlQQBQQ2lDsJ3H9hM5RCXVyIieEQwWkLE4UEEKtAoJTciOIWeDdJB8KiAJCG4r9JKaf0PkppU5O5ISwqICUxYkCQqhVQHBKbgRTv8C7TT4UEAWENhT7ydT3Ezo3JdXJiZwQHhWQsjhRQAi1CghOyY1gahd4N8qHAqKA0IZiP5nafkLnpbQ6OZETwqQCUhYnCgihVgHBKbkRTN0C71b5UEAUENpQ7CdT10\/onJRYJydyQrhUQMriRAEh1CogOCU3gqlZ4N0sHwqIAkIbiv1kavoJnY9S6+RETgibCkhZnCgghFoFBKfkRtD5Bd7t8qGAKCC0odhPOt9P6FyUXCcnckL4VEDK4kQBIdQqIDglN4LOLvBekA8FRAGhDcV+0tl+Queh9Do5kRPCqAJSFicKCKFWAcEpuRF0boH3inwoIAoIbSj2k871EzoH3VAnJ3JCOFVAyuJEASHUKiA4JTeCzizwXpIPBUQBoQ3FftKZfkLz75Y6OZETwqoCUhYnCgihVgHBKbkRTP4C7zX5UEAUENpQ7CeT309o9t1UJydyQnhVQMriRAEh1CogOCU3gsld4L0oHwqIAkIbiv1kcvsJzb3b6uRETgizCkhZnCgghFoFBKfkRjB5C7xX5UMBUUBoQ7GfTF4\/oZl3Y52cyAnhVgEpixMFhFCrgOCU3PXOklcAACAASURBVAgmZ4Fn+bhv7Q\/SfbfdlZZM23nQDz3y3y9IT3j2WXheSiuUk8Yz4gZZn4ucTE4\/KW39T\/Z45EROCFP217I4UUAItQoITsmNoP0Ffu\/DW9P\/+taN6Q8Pbat+2OKB3em1szakGQPD1f\/f7fLhHRDvgNCGYj9pv5\/QrLu5Tk7khPCrgJTFiQJCqFVAcEpuBBNf4Bv+vD39+NaN6a57H007NmxIKY0IR37864xH05kzNveEfCggCghtKPaTifcTmnEv1MmJnBCOFZCyOFFACLUKCE7JjaD1BV4Tj\/UPbqku3rt1axrc9FDdDzpx2uPp4v\/29PSEs56D56LkQjlpPDtukPW5yEnr\/aTkdd+pscmJnBC27K9lcaKAEGoVEJySGwFf4AeKR+3K4eHhtHPDhrRvz+79P+wFp\/1Tesl\/\/zc8D6UXyokCQhiVE95PSJ69WiMnckLYVkDK4kQBIdQqIDglN4LmC3ws8Rh95b5du9Kuhzel+UM70wuec1JaecGz8Rx0Q6GcKCCEUzlp3k9Ijr1eIydyQhhXQMriRAEh1CogOCU3grEX+Kate9P9g4tS7alW44W6eMHsdN7ypen0kxanGdOn4fy7pVBOFBDCqpyUdWAgcxZRIydyQrhTQMriRAEh1CogOCU3goOjync8rr3ht+mBx\/amhQsXjptlr4tH7R8vJwoIaSpyUtaBgcxZRI2cyAnhTgEpixMFhFCrgOCU3Aj+EdX9j25PP7p1Y\/r9n7akLVtGXmA+loBk8Th3+ZL0rJMO78k7HgcCJCcKCGkqclLWgYHMWUSNnMgJ4U4BKYsTBYRQq4DglNwIUhotHrXgxhKQJ8yflc77L0v7Rjy8AzL+UnKDrM\/HflLWgQFvBFNcKCdyQpCzv5bFiQJCqFVAcEr9vBE0Eo+xBKRfxUMBUUBwM0kp9XM\/GS8nc1FUyTqSk\/qUFBAFhKybrqlxgbsRjCceBwrICccc0Zd3PA5c0K6bxi3ODdJ+QjY\/14+cyAlJQAEhKUX1E++AkNnxDghOKQpkPMBJLCTiUft1+wa3ptOPn5tW\/\/sZffEaj2Yx9xMnzbIY\/X0FxIMl4cX1IydyQhJQQEhKUf1EASGzo4DglKJAxgOchMIsHj++9aF015\/+1vSn5adanbt8aZq1\/YE0fdpAWrFiRdNr+qGgHziZyDwqIB4sCTeuHzmRE5KAAkJSiuonCgiZHQUEpxQFMh5gG4UTEY8znjLyrla9nMtEIjWPxqkpIB4syXpy\/ciJnJAEFBCSUlQ\/UUDI7CggOKUokPEAJ1DYingcNm\/kXa1q4lH7db2YywSi3H+JeSgghB85aZySuSggrh+SgAJCUorqJwoImR0FBKcUBTIeYAuFkyEeCogHqBaQS94B8WBJeOmlPkv+vc1qzMM+24yR\/H37a1mcDKxbt26YTNyaNWtS\/sqP1atXV18+Ulq\/fn0Vw7Jly4wj9UYej2zbm27ZMJg2bN7ddE7nzxpIzzphbnrq0bOq13iM9ZCT+mTMozEpa9eurb6xatWqpuz1Q4GcNJ5lc7GfkPUvJ\/Up2V\/L6icKCFnF49S4wHtnIxgRj51pw+Y9Tamg4lH7QXLSO5w0haONAjdIOSH42E\/kRE5IAgoISSmqn\/gULDI749R467c+nG7MY+SpVhvTXX\/a0pSGsV7j0ezCbsyl2b+pne+bR+P0fIpA9\/eTdtYFvdb1IyeEFTmpT8n+2piaKE4UELKKFRCcUhTIeICjClsVj\/x2umf+88i7WrX66KZcWv23TaTePBQQwo2clHVgIHMWUSMnckK4U0DK4kQBIdQqIDilbtgIWhKP\/Dkepy5NZ558RJoxzms8mgXUDbk0+zdM5vfNQwEhPMlJWQcGMmcRNXIiJ4Q7BaQsThQQQq0CglMqeSOIEI9acCXngid3EgvNQwEhOMlJWQcGMmcRNXIiJ4Q7BaQsThQQQq0CglMqcSOoxOO2h9JdDzT\/5PLDJumOx4GBlZgLntQOFJqHAkKwkpOyDgxkziJq5EROCHcKSFmcKCCEWgUEp1TSRtCqeKw8dUl69slHtvVUq7GCKikXPJkdLDQPBYTgJSdlHRjInEXUyImcEO4UkLI4UUAItQoITqmEjaAk8agFV0IueBKnoNA8FBCCmZyUdWAgcxZRIydyQrhTQMriRAEh1CogOKXIjaBE8VBAymp4GOSgQjfI+uAj+0kQAujXmoucEFDkpD4l+2tZ+7ECQlaxAoJTimh4D27ekX647sF0J3yNRyefajVWUBG54EkLKDQP74AQ7OSkrAMDmbOIGjmRE8KdAlIWJwoIoVYBwSlN5UbQingsmjcrnbu8c6\/xaBbQVObSbCwlfN88FBDCoZyUdWAgcxZRIydyQrhTQMriRAEh1CogOKWp2AhaF4+l6dltfo4HDmCMwqnIpd0xTuX15qGAEN7kpKwDA5mziBo5kRPCnQJSFicKCKFWAcEpdXIj6EbxqAXXyVzw5BRUaB4KCMFRTso6MJA5i6iREzkh3CkgZXGigBBqFRCcUic2gm4WDwWkrIaHQQ4qdIOsD74T\/SRoaif115qLnBCg5KQ+JftrWfuxAkJWsQKCU5rMhtcL4qGAlNXwMMhBhW6QHiwJepPZZ8nvK73GPOyzhFH7a1mcKCCEWgUEpzQZG0HL4pE\/QHBZZz5AEP\/DmxRORi6TNZYSfo55NJ4FN0gFhKxP14+cyAlJwDsgJKWofqKAkNlRQHBK7YDcingsnDsznbd8afHi4R2Qsv7igkEOKlRAPFgS9Nrps+Tnd1uNedhnCbP217I4UUAItQoITmkiG0Evi4cCUlbDwyAHFbpBKiAEvYn0WfJzu7XGPOyzhF37a1mcKCCEWgUEp9TKRtAP4qGAlNXwMMhBhW6QCghBr5U+S35et9eYh32WMGx\/LYsTBYRQq4DglMhGkMXjR7c+mH53\/9+a\/tz8VKtz81OtTj4izZw+rWl9qQUkl1LH3olxmUfjVN0gFRCy3lw\/ciInJIH6GvurAtI6NQVf4UbAN4J+FA\/vgJTV8ApuJdXQ3CB5Pyl9Ljs5PvcdOSF8yYkCUjIn3gEhs+MdEJxSo4bXz+KhgCggePEoIAdF5QHK9UPWj5zICeHEP\/CUxYkCQqhVQHBKozeClsRj3qx0bn473S5\/qtVYQblB+hdLsojcIOWEcGI\/kRM5IQl4B4SkFNVPFBAyOwoITimD\/Oj2ofTArsPSHfc\/1vS6hT0uHt4BKesvLk2BDC5QQDxYEgSjDgxkbBE15mGfJdzZX8viRAEh1CogKKV8x+PaG36b7vnL7rRw4cJxr+kX8VBAymp4COTAIjdIBYTg54FbTuSEJOAdEJJSVD9RQMjsKCDjppTF48e3bqzueGzZsqWqHUtA+k08FBAFpJUWo4B4sCS8RB0YyNgiaszDPku4s7+WxYkCQqhVQBomMFo8agVjCUi\/iocCUlbDa3O5d\/xyN0gFhEDmgVtO5IQk4B0QklJUP1FAyOwoIHUJNBKPsQQki8fKZyxJZy3r7s\/xaBOTFLXA2x13p643j8bJKiAeLMmac\/3IiZyQBBQQklJUP1FAyOwoIFUCG\/+6I\/1o3YPpjnE+QLB2B+S4pUcoHqO4iVrgbeLdscvNQwEhcMlJ45TMRQFx\/ZAEFBCSUlQ\/UUDI7PS5gBDxqEW0Z+fWdPoT56YLX3BGV39yeZtYHHR51AKf7H\/HZP0881BACEtyooDICUlATkhK3mEuixMFhFDbpwLSingcOndmOvfUpWnOzj+lGdMG0ooVK9pMtrcu9yDlXywJ0W6QckI4sZ\/IiZyQBLwDQlKK6icKCJmdPhOQiYhH7TUeUSC3OY0dv9xcPDAQyBQQOSGc2E\/kRE5IAgoISSmqnyggZHb6REBaFY+Vpy5Jz1l2ZN1TraJAbnMaO365uXhgIJApIHJCOLGfyImckAQUEJJSVD9RQMjs9LiAZPHIn+Nx+33NP7k8P9WqkXjUIooCuc1p7Pjl5uKBgUCmgMgJ4cR+IidyQhJQQEhKUf1EASGz06MCMpnioYCMD1LUAm8T745dbh6No1VAPFiSRef6kRM5IQkoICSlqH6igJDZ6TEBaUk85sxMK5cf\/FSrsSKJArnNaez45ebigYFApoDICeHEfiInckISUEBISlH9RAEhs9MjAtKqeJxz6pJ09lPrX+PRLK4okJuNK\/r75uKBgTCogMgJ4cR+IidyQhJQQEhKUf1EASGz0+UCMhXiUYsoCuQ2p7Hjl5uLBwYCmQIiJ4QT+4mcyAlJQAEhKUX1EwWEzE6XCkgWj5\/ctjH95wbw4vI5M9NE7ngcGE0UyG1OY8cvNxcPDAQyBUROCCf2EzmRE5KAAkJSiuonCgiZnS4TkAjx8A7I+CBFLfA28e7Y5ebROFoFxIMlWXSuHzmRE5KAAkJSiuonCgiZnS4RkEjxUEAUkFaWUlTDa2WMEbUKiAdLwp3rR07khCSggJCUovqJAkJmp3ABKUE8FBAFpJWlFNXwWhljRK0C4sGScOf6kRM5IQkoICSlqH6igJDZKVRARsTjofSfG\/7a9F9x6CS9xqPZL4oCudm4or9vLh4YCIMKiJwQTuwnciInJAEFhKQU1U8UEDI7hQlIieLhHRDvgLSylKIaXitjjKhVQDxYEu5cP3IiJyQBBYSkFNVPFBAyO4UISKvi8V9PXZL+pcXP8WgzjhQFcrvj7vT15uKBgTCmgMgJ4cR+IidyQhJQQEhKUf1EASGzEywg3SAe3gHxDkgrSymq4bUyxohaBcSDJeHO9SMnckISUEBISlH9RAEhsxMkIN0kHgqIAtLKUopqeK2MMaJWAfFgSbhz\/ciJnJAEFBCSUlQ\/UUDI7EyxgGx6bEf60a38AwQjnmo1ViRRILc5jR2\/3Fw8MBDIFBA5IZzYT+RETkgCCghJKaqfKCBkdqZIQFoWj2ccnf7laUelmdOntfmvmLzLo0CevH9BZ36SuXhgIGQpIHJCOLGfyImckAQUEJJSVD9RQMjsdFhAWhGPBfntdAsUj1pEUSC3OY0dv9xcPDAQyBQQOSGc2E\/kRE5IAgoISSmqnyggZHY6JCC9JB4KyPggRS3wNvHu2OXm0ThaBcSDJVl0rh85kROSgAJCUorqJwoImZ1JFpBeFA8FRAFpZSlFNbxWxhhRq4B4sCTcuX7kRE5IAgoISSmqnyggZHYmSUCyePz4tofS\/7m3+SeXl\/5Uq7EiiQK5zWns+OXm4oGBQKaAyAnhxH4iJ3JCElBASEpR\/UQBIbPTpoC0Lh5L0tlPPTLNmlHOi8tpTFEg0\/FF1ZmLBwbCngIiJ4QT+4mcyAlJQAEhKUX1EwWEzM4EBaSfxKMWURTIbU5jxy83Fw8MBDIFRE4IJ\/YTOZETkoACQlKK6icKCJmdFgWkH8VDARkfpKgF3ibeHbvcPBpHq4B4sCSLzvUjJ3JCElBASEpR\/UQBIbMDBaQV8Zh\/yIy08tSlXftUq7EiiQK5zWns+OXm4oGBQKaAyAnhxH4iJ3JCElBASEpR\/UQBIbPTREA2P743Pbjn8HTbvZub\/rQsHuc8Y0n1AYLd+BqPZv\/AKJCbjSv6++bigYEwqIDICeHEfiInckISUEBISlH9RAEhs9OgZuvgtnTPI4+m\/3nj7Wnj5nlp0aJF4\/6kXheP2j8+CuQJTuOUXWYuHhgIbAqInBBO7CdyIickAQWEpBTVTxSQA2bn8d070tadW9OWnVtTloza15bBbWnb4Pb0t51bqv9t87ZdadNjO9OePXvStDQzHb\/ggjR72mEHzXWvPtVqLKijQCaLLLLGXDwwEP4UEDkhnNhP5EROSAIKCEkpqp\/0jYDs3DN4kFTsl4u\/y8a2wW1p776hpvO1a89Q+n+btlV1WUDyY\/Gcp6YjZz1r\/7Xz\/v5Uq3\/t0adaKSBNMakriFrgrY1y6qrNo3HWCogHS7IKXT9yIickAQWEpBTVT7peQHbt3d1QLA68g7FnaEQUJuMxuHso\/fHhegFZMGtJOnbO81MWj5U9\/BqPZvlFgdxsXNHfNxcPDIRBBUROCCf2EzmRE5KAAkJSiuonxQpIFoYDJWL0U6Jq\/31wzy6S76TX3P\/o9rRt5979d0COOXR5uvBZ\/9GzLy6nAUaBTMcXVWcuHhgIewqInBBO7CdyIickAQWEpBTVT0IE5K+PP5a27tp+8OssRr3uYnDPIMktrGbawIy07fHp6bHH9qTjFy1N\/+Olr07zZs8OG08pvzgK5FL+\/WONw1w8MBBGFRA5IZzYT+RETkgCCghJKaqfTJqA7BveV71I+8DXVYx+EXe+o7Fj9w6SR1jN9GnT08I5h6ZDZ89Phx6yoPqq\/v\/832v\/eciCNGfmIdUYoyYuLKAmv9g8GgdkLh4YyJpVQOSEcGI\/kRM5IQkoICSlqH6CBeTyKz+evnr919K0Q6anF774P9JZ\/\/acuneJ2r7rcfLvDK3JIrFozsI0f\/a8f0hFTTBmz6\/+t7mz5rY0xqiJa2mQU1hsHgoIwU1OGqekgHiwdP2QBOSEpGSfVUBK5gQJyPW\/\/U763k3\/O91zzz3Vv+XEE09MT3rSk8i\/a0pqFvz9bkXtTkX+zwWHjNzBqP1vuaYTDxe4GwHhSk7khHCigMgJ4cR+IidyQhJQQEhKUf1k4Iorrhgeb4C70u60Lt2VNm\/eXH3lx+LFi6uvTj9mDE9PswZmpdkDs9LM4RlpdppZ\/V\/+z1mjvjo9jvF+\/oMPPlh9+9hjj40cRjG\/2zwaT4W51OdiHo05ueWWW6pvnHHGGcWs6ciByIn9hPAnJ3JCOLG\/lsXJwJIlS8YVkOnzZ6QnnHNMGhoaqr7yY\/r06dXXRB\/De\/aloZ17077BoZGvnUNp366hg\/63if78qbyu9jkgM2fOnMpfW+zvMo\/GU2Mu9bmYR2NOduwYeY3c3LmtPRW02IbQ5sDkxH5CEJITOSGc2F\/L4qSpgOThHva8JWlg3vSmArJvz75\/SMXgUBoePEAqdo0Ix\/DQuM5DOCqmxsbnwZLAKCdyQjhxg5QTwon9RE7khCRQX2N\/LUxAmj0FKw93R9qZbvq\/v073\/fn+NDQ4lJ78T09Kp\/zzKXVPg8pPi5qWprVORJdf4a3f+gk0j8ZAm4uckFbnUwTkhHBiP5ETOSEJ1NfYX8s6n6AXoechX3nlldVXfrzzne+svnz4NrwHMhD1YqbSWTSX+hkyj8bE+iJ0OSG9zPUjJ3JCEqivsb82ziyqnyggrTNcd0XUxLU57I5dbh5lLfCOTXSbP1hOFBCCkJzYT+SEJCAnJCUFpCxOFBBC7Tg1bpD+JYogJCdyQjhxg5QTwon9RE7khCTgHRCSUlQ\/UUDI7CggOKUokPEAgwrNxQMDQU8BkRPCif1ETuSEJKCAkJSi+okCQmZHAcEpRYGMBxhUaC4eGAh6CoicEE7sJ3IiJyQBBYSkFNVPFBAyOwoITikKZDzAoEJz8cBA0FNA5IRwYj+REzkhCSggJKWofqKAkNlRQHBKUSDjAQYVmosHhiD0uvrXum4aT5+52E\/IwpYTBaRkThQQMjsKCE7JhueBgcAiJyQla+TEfkJWgZzICeHEO8xlcaKAEGoVEJySG0FZCxxP3BQXyskUB96lv05O7CcEXTmRE8KJAlIWJwoIoVYBwSm5EZS1wPHETXGhnIwE\/r3vfS+95CUvaZr++vXr08knn9y0rtcK5MR+QpiWEzmpJbB9+\/b02te+Nn33u99Ns2fPToODg\/vDGUtA9u3bl6699tr0zW9+M919991px44d6bjjjksvetGLqg\/dPuKIIwiGXVsTtX4UkDaRiZq4NofdscvNw42AwCUnIyl9+ctfTm9+85ubRqaArGiaUT8VuH7qZ9s83HdyAn\/4wx\/SqlWrUu6X+UEEZNeuXemFL3xh+sUvftEwxKVLl6af\/exn6ZRTTunZFhO1fhSQNpGKmrg2h92xy83DjYDAJScjKV1++eXpAx\/4QHriE5+Y1qxZM2Z0K1asSHPmzCHR9lSNnNhPCNByIif5bnK+87Ft27bqjsWjjz6KBOSSSy5J11xzTRXgxRdfnN7whjekBQsWpF\/96lfpXe96V3rkkUfSk5\/85HT77benuXPnEhy7riZq\/SggbaISNXFtDrtjl5uHGwGBS05GUnrHO96RPv\/5z6ezzz473XTTTSS6vqqRE\/sJAV5O+peToaGhdNlll6XPfOYzVQj5aVMXXHBBeuMb39hQQI4\/\/vh07rnnVrUPPPBAOvHEE9PevXtTFpGrr766Lsg777wz5T\/+7N69O33uc59Ll156KcGx62qi1s\/Aww8\/PHzUUUc1DezKK69M+Ss\/8nPi8pePlKImrtTszaN\/N4JWmJSTkbRe9apXVXc+8utAvvOd77QSYV\/Uyon9hIAuJ\/3LyZ\/\/\/Oe0fPnytGnTpvTud787feITn0hf\/\/rXxxSQM888Mz396U+vAvv4xz+e3v\/+96fp06enjRs3pkZn4QsvvDBdd911admyZen3v\/89wbHraqLWz8A3vvGN4Ve\/+tVNA1NA+neBN4VjVEEUyK2MMaLWXOpTN4+RPM4\/\/\/z005\/+NL31rW9NX\/jCFyLQLPp3yon7DgFUTvqbk5tvvjndd9996ZWvfGUVRH5KVb6j0eg1IPn1HkuWLKnqzjnnnHTjjTemM844I\/36179uGGJ+MftLX\/rS6nv5d+Sny\/baI2r9DLz97W8fzk8BaPZQQPp7gTfjo\/b9KJDp+KLqzEUBacTeaaedltatW5c+8pGPpA9+8INReBb7e1037jsETjmRk9EJXHXVVdXTpRoJyJve9Kb9pUcffXT1Go+LLroofelLX2oY4h\/\/+Md00kknVd\/7\/ve\/Xz3Fq9ceUetn4PnPf\/7wT37yk6Z5KiAu8KaQJJ+SNlZGUQuczFlEjXmMpH7CCSdUf1XLm1\/eBPPbPw4MDPTlC84bcSgn7jukP8mJnIxOIP9RPb++bjwB2blz5\/4XlX\/sYx+r3gyk0SO\/S9YhhxxSfeuTn\/xkes973kOQ7KqaqPUzcNpppw3\/5je\/aRqWAuICbwqJAjJmRFELnMxZRI15jKSe320lv299\/kvcli1bUt4U82PevHnp9NNPT\/n5x\/l1Ivk5yv34kBP3HcK9nMhJqwLy0EMPpWOOOaa6LD\/9NT8NdqxHrU\/nd8X69Kc\/TZDsqpqo9TOwbNmyYfLCGgXEBU5WVBTIZGyRNeZSn755pDQ8PFy9A8uGDRvGRfOss85KP\/zhD9OiRYsiEQ753XLivkPAkxM5IQKS36r3xS9+cVV6zz33VG+vmx9f+9rX0ute97oxUctv6\/uXv\/wlveUtb0lf\/OIXCZJdVRO1fhSQNjGJmrg2h92xy83DjYDAJScjKeU7Hvntd\/NbQx577LHVrf7NmzenW265pXrXwdpb85533nnVi9X77SEn9hPCvJzISasCcu+991Z\/AMqP\/Cnor3\/968dE7fDDD6\/6sgJCViOvGVixYsVwfhFks4d3QFzgzRjJ33cjkBM5IQk0r9m3b1\/19rz5hY\/5kT8YK7+FZD897Cf2E8K7nMgJEZCvfOUrqfYi9Pzi8\/zU1\/ygT8HKHz9xxRVXECS7qiZq\/QysXLly+Oc\/\/3nTsBQQF3hTSBSQMSOKWuBkziJqzIOlfvfdd6eTTz65Kv7whz+cPvShD7ELe6RKTtx3CMpyIietCkj+cME5c+ak\/Ice+iL0yy+\/PL3vfe8jSHZVTdT6GbjooouGx3r7sdEJKiAucLKiokAmY4usMZf69M2jMY35L3Tz589Pr3jFK\/YX5Kdl5Xdi6cfPCpET9x3St+VETqiAvOY1r0mzZs2qymvvQkjfhvfb3\/52etnLXkaQ7KqaqPUzcM011wxffPHFTcNSQFzgTSHxDsiYEUUtcDJnETXmMbaALF68eP8LJfNf5\/JmOTQ0lN773vdWn\/LbTw85cd8hvMuJnFABGf1BhKtWraqe4ko\/iPDOO+9MT3va0wiSXVUTtX4G1q9fP1y7xT9eYgqIC5ysqCiQydgia8zFOyAT4e+Xv\/xlOvvss6tLv\/Wtb6WXv\/zlE\/kxXXuN68Z9h8ArJ3JCBWTFihUpf+XHV7\/61eo1Ifltzjdu3JiOOuqog4LMb4V+3XXXVd97+OGHCY5dVxO1fgaG83tBgocC4gIHmPgi9DFCilrgZM4iaswjVZvZkUcemaZNm9ZwCvLTrp73vOdVLz4\/9NBD0\/333993b8UrJ+47pD\/JiZxQARl9hzl\/9tJxxx2Xtm7dmi655JJ09dVX1wV51113pWc+85kpv14kfwBh\/iDCXnxErR8FpE2aoiauzWF37HLzcCMgcMlJqt5NJf8FLr\/TVf6sj6c85SnVBxDmD8jKt\/rzH31+97vfVXFeddVV6W1vexuJtqdq5MR+QoCWEzmhApLrau+Elf\/7pz71qerprflx6aWXVm\/Hm\/\/gc\/PNN6f8rlebNm1K+W14c09udIeE8Fl6TdT6UUDaJCNq4tocdscuNw83AgKXnKT02c9+ttrgxnvMmDEjffSjH02XXXYZibXnauTEfkKglhM5maiA5CcB5adZrVmzpmGICxcuTD\/4wQ\/Sc5\/7XIJiV9ZErR8FpE1coiauzWF37HLzcCMgcMlJqm7rX3\/99emGG25Id9xxR\/WXtvy0q7zh5Q\/Iyhte\/ktd7dN6Sa69ViMn9hPCtJzIyUQFpHZdfoer\/C6E+a7z448\/no455ph0\/vnnV38kyh8U28uPqPWjgLRJVdTEtTnsjl1uHm4EBC45ISlZIyf2E7IK5EROCCdZMPJj9FOwyHW9XhO1fhSQNsmKmrg2h92xy83DjYDAJSckJWvkxH5CVoGcyAnhRAEpixMFhFA7To2Nrz4c8yhrgbeJd8cul5OORdtTP1hO7CcEaDmRE8KJAlIWJwoIoVYBwSm5EZS1wPHETXGhnDQO3A3SP2iQpej6kRM5IQnU19hfyzqfKCCtM1x3hRuBGwFBzNea1AAAD7dJREFUSE7khHDiBiknhBP7iZzICUlAASEpRfUTBYTMjndAcEpRIOMBBhWaiwcGgp4CIieEE\/uJnMgJSUABISlF9RMFhMyOAoJTigIZDzCo0Fw8MBD0FBA5IZzYT+RETkgCCghJKaqfKCBkdhQQnFIUyHiAQYXm4oGBoKeAyAnhxH4iJ3JCElBASEpR\/UQBIbOjgOCUokDGAwwqNBcPDAQ9BUROCCf2EzmRE5KAAkJSiuonCgiZHQUEpxQFMh5gUKG5eGAg6CkgckI4sZ\/IiZyQBBQQklJUP1FAyOwoIDilKJDxAIMKzcUDA0FPAZETwon9RE7khCSggJCUovqJAkJmRwHBKUWBjAcYVGguHhgIegqInBBO7CdyIickAQWEpBTVTxQQMjsKCE4pCmQ8wKBCc\/HAQNBTQOSEcGI\/kRM5IQkoICSlqH6igJDZUUBwSlEg4wEGFZqLBwaCngIiJ4QT+4mcyAlJQAEhKUX1EwWEzI4CglOKAhkPMKjQXDwwEPQUEDkhnNhP5EROSAIKCEkpqp8oIGR2FBCcUhTIeIBBhebigYGgp4DICeHEfiInckISUEBISlH9RAEhs6OA4JSiQMYDDCo0Fw8MBD0FRE4IJ\/YTOZETkoACQlKK6icKCJkdBQSnFAUyHmBQobl4YCDoKSByQjixn8iJnJAEFBCSUlQ\/UUDI7CggOKUokPEAgwrNxQMDQU8BkRPCif1ETuSEJKCAkJSi+okCQmZHAcEpRYGMBxhUaC4eGAh6CoicEE7sJ3IiJyQBBYSkFNVPFBAyOwoITikKZDzAoEJz8cBA0FNA5IRwYj+REzkhCSggJKWofqKAkNlRQHBKUSDjAQYVmosHBoKeAiInhBP7iZzICUlAASEpRfUTBYTMjgKCU4oCGQ8wqNBcPDAQ9BQQOSGc2E\/kRE5IAgoISSmqnyggZHYUEJxSFMh4gEGF5uKBgaCngMgJ4cR+IidyQhJQQEhKUf1EASGzo4DglKJAxgMMKjQXDwwEPQVETggn9hM5kROSgAJCUorqJwoImR0FBKcUBTIeYFChuXhgIOgpIHJCOLGfyImckAQUEJJSVD9RQMjsKCA4pSiQ8QCDCs3FAwNBTwGRE8KJ\/URO5IQkoICQlKL6iQJCZkcBwSlFgYwHGFRoLh4YCHoKiJwQTuwnciInJAEFhKQU1U8UEDI7CghOKQpkPMCgQnPxwEDQU0DkhHBiP5ETOSEJKCAkpah+ooCQ2VFAcEpRIOMBBhWaiwcGgp4CIieEE\/uJnMgJSUABISlF9RMFhMyOAoJTigIZDzCo0Fw8MBD0FBA5IZzYT+RETkgCCghJKaqfKCBkdhQQnFIUyHiAQYXm4oGBoKeAyAnhxH4iJ3JCElBASEpR\/UQBIbOjgOCUokDGAwwqNBcPDAQ9BUROCCf2EzmRE5KAAkJSiuonCgiZHQUEpxQFMh5gUKG5eGAg6CkgckI4sZ\/IiZyQBBQQklJUP1FAyOwoIDilKJDxAIMKzcUDA0FPAZETwon9RE7khCSggJCUovqJAkJmRwHBKUWBjAcYVGguHhgIegqInBBO7CdyIickAQWEpBTVTxQQMjsKCE4pCmQ8wKBCc\/HAQNBTQOSEcGI\/kRM5IQkoICSlqH4ysG7dumEywDVr1qT8lR+rV6+uvnyktH79+iqGZcuWGUcyj7EgkJP6ZMyjMSlr166tvrFq1Sr7if1kTAZcP\/YT0iDkpD4l+2tjaqI4UUDIKh6nJmri2hx2xy43j7IWeMcmus0fLCcKCEFITuwnckISkBOSkgJSFic+BYtQO05N1K2rNofdscvNo3G05lKfi3k05sSnYMkJac6uHzmRE5JAfY39tazziQLSOsN1V7gRuBEQhORETggnbpByQjixn8iJnJAEFBCSUlQ\/UUDI7HgHBKcUBTIeYFChuXhgIOgpIHJCOLGfyImckAQUEJJSVD9RQMjsKCA4pSiQ8QCDCs3FAwNBTwGRE8KJ\/URO5IQkoICQlKL6iQJCZkcBwSlFgYwHGFRoLh4YCHoKiJwQTuwnciInJAEFhKQU1U8UEDI7CghOKQpkPMCgQnPxwEDQU0DkhHBiP5ETOSEJKCAkpah+ooCQ2VFAcEpRIOMBBhWaiwcGgp4CIieEE\/uJnMgJSUABISlF9RMFhMyOAoJTigIZDzCo0Fw8MBD0FBA5IZzYT+RETkgCCghJKaqfKCBkdhQQnFIUyHiAQYXm4oGBoKeAyAnhxH4iJ3JCElBASEpR\/UQBIbOjgOCUokDGAwwqNBcPDAQ9BUROCCf2EzmRE5KAAkJSiuonCgiZHQUEpxQFMh5gUKG5eGAg6CkgckI4sZ\/IiZyQBBQQklJUP1FAyOwoIDilKJDxAIMKzcUDA0FPAZETwon9RE7khCSggJCUovqJAkJmRwHBKUWBjAcYVGguHhgIegqInBBO7CdyIickAQWEpBTVTxQQMjsKCE4pCmQ8wKBCc\/HAQNBTQOSEcGI\/kRM5IQkoICSlqH6igJDZUUBwSlEg4wEGFZqLBwaCngIiJ4QT+4mcyAlJQAEhKUX1EwWEzI4CglOKAhkPMKjQXDwwEPQUEDkhnNhP5EROSAIKCEkpqp8oIGR2FBCcUhTIeIBBhebigYGgp4DICeHEfiInckISUEBISlH9RAEhs6OA4JSiQMYDDCo0Fw8MBD0FRE4IJ\/YTOZETkoACQlKK6icKCJkdBQSnFAUyHmBQobl4YCDoKSByQjixn8iJnJAEFBCSUlQ\/UUDI7CggOKUokPEAgwrNxQMDQU8BkRPCif1ETuSEJKCAkJSi+okCQmZHAcEpRYGMBxhUaC4eGAh6CoicEE7sJ3IiJyQBBYSkFNVPFBAyOwoITikKZDzAoEJz8cBA0FNA5IRwYj+REzkhCSggJKWofqKAkNlRQHBKUSDjAQYVmosHBoKeAiInhBP7iZzICUlAASEpRfUTBYTMjgKCU4oCGQ8wqNBcPDAQ9BQQOSGc2E\/kRE5IAgoISSmqnyggZHYUEJxSFMh4gEGF5uKBgaCngMgJ4cR+IidyQhJQQEhKUf1EASGzo4DglKJAxgMMKjQXDwwEPQVETggn9hM5kROSgAJCUorqJwoImR0FBKcUBTIeYFChuXhgIOgpIHJCOLGfyImckAQUEJJSVD9RQMjsKCA4pSiQ8QCDCs3FAwNBTwGRE8KJ\/URO5IQkoICQlKL6iQJCZkcBwSlFgYwHGFRoLh4YCHoKiJwQTuwnciInJAEFhKQU1U8UEDI7CghOKQpkPMCgQnPxwEDQU0DkhHBiP5ETOSEJKCAkpah+ooCQ2VFAcEpRIOMBBhWaiwcGgp4CIieEE\/uJnMgJSUABISlF9RMFhMyOAoJTigIZDzCo0Fw8MBD0FBA5IZzYT+RETkgCCghJKaqfKCBkdhQQnFIUyHiAQYXm4oGBoKeAyAnhxH4iJ3JCElBASEpR\/UQBIbOjgOCUokDGAwwqNBcPDAQ9BUROCCf2EzmRE5KAAkJSiuonCgiZHQUEpxQFMh5gUKG5eGAg6CkgckI4sZ\/IiZyQBBQQklJUP1FAyOwoIDilKJDxAIMKzcUDA0FPAZETwon9RE7khCSggJCUovqJAkJmRwHBKUWBjAcYVGguHhgIegqInBBO7CdyIickAQWEpBTVTxQQMjsKCE4pCmQ8wKBCc\/HAQNBTQOSEcGI\/kRM5IQkoICSlqH6igJDZUUBwSlEg4wEGFZqLBwaCngIiJ4QT+4mcyAlJQAEhKUX1EwWEzI4CglOKAhkPMKjQXDwwEPQUEDkhnNhP5EROSAIKCEkpqp8oIGR2FBCcUhTIeIBBhebigYGgp4DICeHEfiInckISUEBISlH9RAEhs6OA4JSiQMYDDCo0Fw8MBD0FRE4IJ\/YTOZETkoACQlKK6icKCJkdBQSnFAUyHmBQobl4YCDoKSByQjixn8iJnJAEFBCSUlQ\/UUDI7CggOKUokPEAgwrNxQMDQU8BkRPCif1ETuSEJKCAkJSi+okCQmZHAcEpRYGMBxhUaC4eGAh6CoicEE7sJ3IiJyQBBYSkFNVPFBAyOwoITikKZDzAoEJz8cBA0FNA5IRwYj+REzkhCSggJKWofqKAkNlRQHBKUSDjAQYVmosHBoKeAiInhBP7iZzICUlAASEpRfUTBYTMjgKCU4oCGQ8wqNBcPDAQ9BQQOSGc2E\/kRE5IAgoISSmqnyggZHYUEJxSFMh4gEGF5uKBgaCngMgJ4cR+IidyQhJQQEhKUf1EASGzo4DglKJAxgMMKjQXDwwEPQVETggn9hM5kROSgAJCUorqJwoImR0FBKcUBTIeYFChuXhgIOgpIHJCOLGfyImckAQUEJJSVD9RQMjsKCA4pSiQ8QCDCs3FAwNBTwGRE8KJ\/URO5IQkoICQlKL6iQJCZkcBwSlFgYwHGFRoLh4YCHoKiJwQTuwnciInJAEFhKQU1U8UEDI7CghOKQpkPMCgQnPxwEDQU0DkhHBiP5ETOSEJKCAkpah+ooCQ2VFAcEpRIOMBBhWaiwcGgp4CIieEE\/uJnMgJSUABISlF9RMFhMyOAoJTigIZDzCo0Fw8MBD0FBA5IZzYT+RETkgCCghJKaqfKCBkdhQQnFIUyHiAQYXm4oGBoKeAyAnhxH4iJ3JCElBASEpR\/UQBIbOjgOCUokDGAwwqNBcPDAQ9BUROCCf2EzmRE5KAAkJSiuonCgiZHQUEpxQFMh5gUKG5eGAg6CkgckI4sZ\/IiZyQBBQQklJUP1FAyOwoIDilKJDxAIMKzcUDA0FPAZETwon9RE7khCSggJCUovqJAkJmRwHBKUWBjAcYVGguHhgIegqInBBO7CdyIickAQWEpBTVTxQQMjsKCE4pCmQ8wKBCc\/HAQNBTQOSEcGI\/kRM5IQkoICSlqH6igJDZUUBwSlEg4wEGFZqLBwaCngIiJ4QT+4mcyAlJQAEhKUX1EwWEzI4CglOKAhkPMKjQXDwwEPQUEDkhnNhP5EROSAIKCEkpqp8oIGR2FBCcUhTIeIBBhebigYGgp4DICeHEfiInckISUEBISlH9RAEhs6OA4JSiQMYDDCo0Fw8MBD0FRE4IJ\/YTOZETkoACQlKK6icD69atGyYDXLNmTcpf+bF69erqy0dK69evr2JYtmyZcSTzGAsCOalPxjwak7J27drqG6tWrbKf2E\/GZMD1Yz8hDUJO6lOyvzamJooTBYSs4nFqoiauzWF37HLzKGuBd2yi2\/zBcqKAEITkxH4iJyQBOSEpKSBlceJTsAi149RE3bpqc9gdu9w8GkdrLvW5mEdjTnwKlpyQ5uz6kRM5IQnU19hfyzqfKCCtM1x3hRuBGwFBSE7khHDiBiknhBP7iZzICUlAASEpRfWT\/w9LlfQpcEPI\/QAAAABJRU5ErkJggg==)\n\n假设当前插入的是红点,那么绿点明显在凸包内,要删除掉\n\n\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\n#define N 50011\nint n,L,c[N];\nll f[N],s[N];\ndb a(int i){return s[i]+i;}\ndb b(int i){return s[i]+i+L+1;}\ndb x(int i){return b(i);}\ndb y(int i){return f[i]+b(i)*b(i);}\ndb S(int i,int j){return (y(i)-y(j))\/(x(i)-x(j));}\nint q[N];\nint main(){\n    in(n,L);\n    Fur(i,1,n)in(s[i]),s[i]+=s[i-1];\n    int h=1,t=1;\n    Fur(i,1,n){\n        while(h<t&&S(q[h],q[h+1])<(a(i)*2))++h;\n        f[i]=f[q[h]]+(a(i)-b(q[h]))*(a(i)-b(q[h]));\n        while(S(q[t-1],q[t])>S(q[t-1],i))--t;\n        q[++t]=i;\n    }\n    cout<<f[n]<<endl;\n}\n```\n","link":null,"tags":["斜率优化","动态规划"],"title":"LG 3195 [HNOI2008]玩具装箱TOY"},{"categories":[["刷题记录"]],"content":"\n一个点对应的只有可能是$R,G,B$\n\n那么枚举$3$次就完事了\n\n枚举以$R$为起点,$G$为起点,$B$为起点\n\n记录前缀和$S_i$表示前$i$个出错的有几个\n\n$ans=\\min_{i\\ge k}(S_i-S_{i-k})$\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\n#define N 200011\nint n,k,a[N],s[N];\nchar ch[N];\nvoid work(){\n    in(n,k);\n    in(ch+1);\n    Fur(i,1,n){\n        if(ch[i]=='R')a[i]=0;\n        if(ch[i]=='G')a[i]=1;\n        if(ch[i]=='B')a[i]=2;\n    }\n    int ans=inf;\n    Fur(t,0,2)\n        Fur(i,1,n){\n            s[i]=s[i-1]+(a[i]!=((i+t)%3));\n            if(i>=k)ans=MIN(ans,s[i]-s[i-k]);\n        }\n    out(ans,ln);\n}\nint main(){\n    int T;in(T);\n    while(T--)work();\n    flush();\n}\n```\n","link":null,"tags":["前缀和","枚举"],"title":"LG CF1196D2 RGB-Substring"},{"categories":[["刷题记录"]],"content":"\n删除完这个字符串后面的就接到前面\n\n我们可以想到用栈解决\n\n然后判断剩下的串当前位置是否和目标字符串匹配我们可以用hash来解决\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;rg char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\n#define N 1000011\n#define base 1331\nint n,q[N],tp=0,m;\nchar a[N],s[N];\null h[N],pw[N],sta=0;\nint main(){\n    in(a+1);\n    in(s+1);\n    n=strlen(a+1);\n    m=strlen(s+1);\n    pw[0]=1;\n    Fur(i,1,n)\n        pw[i]=pw[i-1]*base;\n    Fur(i,1,m)sta=sta*base+s[i];\n    Fur(i,1,n){\n        q[++tp]=i;\n        h[tp]=h[tp-1]*base+a[i];\n        if(tp>=m&&h[tp]-h[tp-m]*pw[m]==sta)tp-=m;\n    }\n    Fur(i,1,tp)pt(a[q[i]]);\n    flush();\n}\n```\n","link":null,"tags":["字符串","栈","hash","kmp"],"title":"LG 4824 [USACO15FEB]Censoring"},{"categories":[["刷题记录"]],"content":"\n经典的最小路径覆盖问题\n\n可以看出一开始有 $1$~$n$条路径（$1～n$)\n\n每次可以挑选一个点,合并两条路径\n\n但是一个点只能用一次\n\n所以我们把点拆成两个\n\n从源点向每个点的入点连一条边权为$1$的边\n\n从每个点的出点与汇点连一条边权为$1$的边\n\n每个点的入点向能到达的点的出点连一条边权为1的边\n\n用 n-最大流 就是答案\n\n至于输出：\n\n~~突然有点尴尬~~\n\n随便乱搞吧\n\n用过的边就是合并过的\n\n把这些边合并起来就可以得出路径\n\n（搞个并茶几？？？）\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i=x;i<=y;i++)\n    #define Fdr(i,x,y) for(int i=x;i>=y;i--)\n    #define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) (int(log2(n)))\n    #define inf 0x3f3f3f3f\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 355\n#define M 6011\nint n,head[N],d[N],q[M],cnt=1,st,ed,m;\nstruct edge{\n    int to,nxt,w;\n}e[M*2];\nbool v[M*2];\nvoid add(int x,int y,int w){\n    e[++cnt].to=y;e[cnt].w=w;e[cnt].nxt=head[x];head[x]=cnt;\n    e[++cnt].to=x;e[cnt].w=0;e[cnt].nxt=head[y];head[y]=cnt;\n}\nbool bfs(){\n    int h=0,t=1;\n    clr(d,0);\n    d[q[h]=st]=1;    \n    while(h<t){\n        int x=q[h++];\n        if(x==ed)return 1;\n        fl(i,x)if(e[i].w&&!d[to]){\n            d[to]=d[x]+1;\n            q[t++]=to;\n        }\n    }\n    return 0;\n}\nint dfs(int x,int mf){\n    if(x==ed)return mf;\n    int us=0,w;\n    fl(i,x)\n    if(e[i].w&&d[to]==d[x]+1){\n        w=dfs(to,MIN(mf-us,e[i].w));\n        e[i].w-=w;e[i^1].w+=w;\n        us+=w;\n        if(us==mf)return mf;\n    }\n    if(!us)d[x]=-1;\n    return us;\n}\nint f[N];\nint gf(int x){return (f[x]==x)?x:(f[x]=gf(f[x]));}\nvoid op(int x){\n\tout<<x<<\" \";\n\tfl(i,x)\n\tif(!e[i].w&&e[i].to>n&&e[i].to<st)op(e[i].to-n);\n}\nint dinic(){\n    int ans=0;\n    while(bfs())ans+=dfs(st,inf);\n    return ans;\n}\nint main(){\n    in>>n>>m;\n\tint x,y;\n\tst=n*2+1,ed=n*2+2;\n\tFur(i,1,n)add(st,i,1),add(i+n,ed,1),f[i]=i;\n\tFur(i,1,m)\n\t\tin>>x>>y,\n\t\tadd(x,y+n,1);\n    \n\tint tmp=dinic();\n\tFur(i,2,cnt)\n\t\tif(e[i^1].to<=n&&e[i].to>n&&e[i].to<st&&!e[i].w)\n\t\tf[gf(e[i].to-n)]=gf(e[i^1].to);\n\t\t\n\tFur(i,1,n)\n\tif(gf(i)==i)op(i),out<<\"\\n\";\n\tout<<n-tmp<<ln;\n}\n```\n","link":null,"tags":["网络流"],"title":"LG 2764 最小路径覆盖问题"},{"categories":[["刷题记录"]],"content":"\nRobotic-Sort\ntop: 0\n\n\n同排序机械臂\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;rg char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\n#define N 100011\n#define ls c[rt][0]\n#define rs c[rt][1]\nint sz[N],val[N],rnd[N],rev[N],c[N][2],RT,cnt,n,s[N];\nvoid pu(int rt){\n    sz[rt]=sz[ls]+sz[rs]+1;\n    s[rt]=MIN(val[rt],MIN(s[ls],s[rs]));\n}\nvoid pd(int rt){\n    if(rev[rt]){\n        SWAP(ls,rs);\n        rev[ls]^=1;rev[rs]^=1;\n        rev[rt]=0;\n    }\n}\nint ne(int v){val[++cnt]=v;s[cnt]=v;sz[cnt]=1;rnd[cnt]=rand();return cnt;}\nvoid sl(int rt,int k,int &x,int &y){\n    if(!rt){x=y=0;return;}\n    pd(rt);\n    if(sz[ls]>=k)y=rt,sl(ls,k,x,ls);\n    else x=rt,sl(rs,k-sz[ls]-1,rs,y);\n    pu(rt);\n}\nint mg(int x,int y){\n    if(!x||!y)return x+y;\n    pd(x);pd(y);\n    if(rnd[x]<rnd[y]){\n        c[x][1]=mg(c[x][1],y);\n        pu(x);\n        return x;\n    }\n    else{\n        c[y][0]=mg(x,c[y][0]);\n        pu(y);\n        return y;\n    }\n}\nint get(int rt){\n    pd(rt);\n    if(s[ls]==s[rt])return get(ls);\n    if(val[rt]==s[rt])return sz[ls]+1;\n    return sz[ls]+1+get(rs);\n}\nstruct node{\n    int v,p;\n    bool operator<(node t){if(v!=t.v)return v<t.v;return p<t.p;}\n}a[N];\nint b[N];\nvoid work(){\n    clr(s,0);clr(c,0);clr(val,0);clr(rev,0);RT=0;clr(rnd,0);clr(sz,0);\n    in(n);\n    if(!n)flush(),exit(0);\n    Fur(i,1,n)in(a[i].v),a[i].p=i;\n    sort(a+1,a+n+1);\n    Fur(i,1,n)b[a[i].p]=i;\n    int x,y,z,t;\n    s[0]=inf;sz[0]=0;\n    Fur(i,1,n)RT=mg(RT,ne(b[i]));\n    Fur(i,1,n){\n        sl(RT,i-1,x,y);\n        int p=get(y);\n        out(p+i-1,\" \");\n        sl(y,p,y,z);\n        rev[y]^=1;\n        RT=mg(x,mg(y,z));\n    }\n    out(ln);\n}\nint main(){\n    while(1)work();\n}\n```\n","link":null,"tags":["平衡树"],"title":"LG SP2059 CERC07S"},{"categories":[["刷题记录"]],"content":"\n设$f(i,j)$表示前$i$个划分成$j$段最少的费用\n\n我们设$calc(l,r)$表示$[l,r]$划分成一段的费用\n\n$$f(i,j)=\\min_{x=1}^i(f(x-1,j-1)+calc(x,i))$$\n\n可以发现这个dp方程具有决策单调性\n\n若$i<i'$,那么$k_i\\le k_{i'}$(决策点)\n\n> 把连续一段拆成两边更优$x^2+y^2\\le (x+y)^2(x,y\\ge 0)$\n\n更巧的是$w(l,r)$可以用类似莫队的方法线性转移\n\n这里采用分治的方法实现\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\n#define N 100011\nint n,q,a[N],c[N];\nll f[N],g[N],w=0;\n#define inc(x) w+=c[a[x]]++\n#define dec(x) w-=--c[a[x]]\nvoid solve(int L,int R,int l,int r){\n    if(L>R)return;\n    int k=0,m=(L+R)>>1,t;\n    g[m]=inf;\n    Fur(i,L,m)inc(i);\n    Fur(i,MIN(m,r),l){\n        dec(i);\n        if(f[i]+w<g[m])g[m]=f[i]+w,k=i;\n    }\n\n    Fur(i,l,MIN(m,r))inc(i);\n    Fur(i,L,m)dec(i);\n    \/\/还原\n\n    solve(L,m-1,l,k);    \n\n    Fur(i,L,m)inc(i);\n    Fur(i,l,k-1)dec(i);\n\n    solve(m+1,R,k,r);\n\n    Fur(i,L,m)dec(i);\n    Fur(i,l,k-1)inc(i);\n    \/\/还原\n}\nint main(){\n    in(n,q);\n    Fur(i,1,n)\n        in(a[i]),\n        f[i]=f[i-1]+c[a[i]]++;\n    \/\/第一次直接算\n    \n    clr(c,0);\n    while(--q)\/\/转移k次,省去一维\n        solve(1,n,1,n),std::swap(f,g);\n\n    cout<<f[n]<<endl;\n}\n```\n","link":null,"tags":["决策单调性","动态规划"],"title":"LG CF868F Yet-Another-Minimization-Problem"},{"categories":[["刷题记录"]],"content":"\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n\t#pragma GCC optimize(3)\n\t#define il __inline__ __attribute__ ((always_inline))\n\t#define rg register\n\t#define ll long long\n\t#define ull unsigned long long\n\t#define db double\n\t#define sht short\n\t#define MB template <class T>il\n\t#define Fur(i,x,y) for(int i=x;i<=y;i++)\n\t#define Fdr(i,x,y) for(int i=x;i>=y;i--)\n\t#define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n\t#define clr(x,y) memset(x,y,sizeof(x))\n\t#define cpy(x,y) memcpy(x,y,sizeof(x))\n\t#define fin(s) freopen(s\".in\",\"r\",stdin)\n\t#define fout(s) freopen(s\".out\",\"w\",stdout)\n\t#define fcin ios::sync_with_stdio(false)\n\t#define l2(n) (int(log2(n)))\n\t#define inf 0x3f3f3f3f\n\tMB T ABS(T x){return x>0?x:-x;}\n\tMB T MAX(T x,T y){return x>y?x:y;}\n\tMB T MIN(T x,T y){return x<y?x:y;}\n\tMB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n\tMB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){clr(ch,0);if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 1011\n#define mod 1000000007\nint n,head[N],cnt=0,c[N][N];\nstruct edge{\n\tint to,nxt;\n}e[N];\nvoid add(int x,int y){\n\te[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;\n}\nint s[N];\nint dfs(int x){\n\tif(s[x])return s[x];\n\ts[x]=1;\n\tfl(i,x)dfs(to);\n}\nint main(){\n\tc[0][0]=1;\n\tFur(i,1,20)c[i][0]=1;\n\tFur(i,1,20)\n\t\tFur(j,1,20)c[i][j]=(c[i-1][j]+c[i-1][j-1])%mod;\n\tint T;in>>T;\n\twhile(T--){\n\t\tclr(head,0);cnt=0;\n\t\t\n\t\tin>>n;\n\t\tchar ch;\n\t\tint x,y;\n\t\tFur(i,1,n-1){\n\t\t\tin>>x>>ch>>y;\n\t\t\tif(ch=='>')SWAP(x,y);\n\t\t\tadd(x,y);\n\t\t}\n\t}\n}\n```\n","link":null,"tags":[],"title":"LG 4099 [HEOI2013]SAO"},{"categories":[["刷题记录"]],"content":"\n1. $b_i = a_i + 1$\n   > 一条链\n   > \n   > 直接二分最小值,然后判断即可\n2. $m=1$\n   > 直接找树的直径\n3. $a_i = 1$\n   > 记录所有边权,设边权为$w$,然后排序\n   > \n   > 求$w_1 + w_{2m} , w_2 + w_{2m-1}, ...$的最小值\n4. 分支不超过$3$(基本上就是正解了)\n\n\n明摆着就是正解嘛\n\n$dfs(x,f,w)$求出$x$的子树连接$x$长度不超过$w$的最长路径\n\n路径分为两种\n\n一种$\\ge w$,那直接条数++\n\n另一种$a+b \\ge w$\n\n那我们直接用multiset存,每次lowerbound找到最接近的,然后返回\n\n我$stl$,还是太弱了$Q\\omega Q$\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n\t#pragma GCC optimize(3)\n\t#define il __inline__ __attribute__ ((always_inline))\n\t#define rg register\n\t#define ll long long\n\t#define ull unsigned long long\n\t#define db double\n\t#define sht short\n\t#define MB template <class T>il\n\t#define Fur(i,x,y) for(int i=x;i<=y;i++)\n\t#define Fdr(i,x,y) for(int i=x;i>=y;i--)\n\t#define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n\t#define clr(x,y) memset(x,y,sizeof(x))\n\t#define cpy(x,y) memcpy(x,y,sizeof(x))\n\t#define fin(s) freopen(s\".in\",\"r\",stdin)\n\t#define fout(s) freopen(s\".out\",\"w\",stdout)\n\t#define fcin ios::sync_with_stdio(false)\n\t#define l2(n) (int(log2(n)))\n\t#define inf 0x3f3f3f3f\n\tMB T ABS(T x){return x>0?x:-x;}\n\tMB T MAX(T x,T y){return x>y?x:y;}\n\tMB T MIN(T x,T y){return x<y?x:y;}\n\tMB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n\tMB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 50011\nint n,m,head[N],cnt=0,ans;\nmultiset<int>s[N];\nstruct edge{\n\tint to,nxt,w;\n}e[N*2];\nvoid add(int x,int y,int w){\n\te[++cnt].to=y;e[cnt].nxt=head[x];e[cnt].w=w;head[x]=cnt;\n}\nint dfs(int x,int f,int w){\n\ts[x].clear();\n\tint v;\n\tfl(i,x)if(to!=f){\n\t\tv=dfs(to,x,w)+e[i].w;\n\t\tif(v>=w)ans++;\n\t\telse s[x].insert(v);\n\t}\n\tmultiset<int>::iterator it;\n\tv=0;\n\twhile(!s[x].empty()){\n\t\tint t=*s[x].begin();\n\t\tif(s[x].size()==1)return MAX(v,t);\n\t\tit=s[x].lower_bound(w-t);\n\t\tif(it==s[x].begin()&&s[x].count(*it))it++;\n\t\tif(it==s[x].end())v=MAX(v,t),s[x].erase(s[x].begin());\n\t\telse{\n\t\t\tans++;\n\t\t\ts[x].erase(s[x].begin());\n\t\t\ts[x].erase(it);\n\t\t}\n\t}\n\treturn v;\n}\nbool chk(int w){\n\tans=0;\n\tdfs(1,0,w);\n\treturn ans>=m;\n}\nint main(){\n\tin>>n>>m;\n\tint x,y,w;\n\tFur(i,1,n-1)in>>x>>y>>w,add(x,y,w),add(y,x,w);\n\tint l=0,r=1<<30,mid,as=0;\n\twhile(l<=r){\n\t\tmid=(l+r)>>1;\n\t\tif(chk(mid))as=mid,l=mid+1;\n\t\telse r=mid-1;\n\t}\n\tout<<as<<ln;\n}\n```\n","link":null,"tags":["dfs","set"],"title":"LG 5021 赛道修建"},{"categories":[["刷题记录"]],"content":"\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i=x;i<=y;++i)\n    #define Fdr(i,x,y) for(int i=x;i>=y;--i)\n    #define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 0x3f3f3f3f\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){clr(ch,0);if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 10011\nint n,m,f[1<<5][N],b[1<<5][N];\nint main(){\n    fin(\"in\");\n    in>>n>>m;\n    Fur(i,1,m){\n        int p,aa,bb,x,A=0,B=0;\n        in>>p>>aa>>bb;\n        Fur(i,1,aa)in>>x,x=(x-p+n)%n,A|=(1<<x);\n        Fur(i,1,bb)in>>x,x=(x-p+n)%n,B|=(1<<x);\n        Fur(j,0,31)if((j&A)||(~j&B))++b[j][p];\n    }\n    int ans=0;\n    Fur(t,0,31){\n        Fur(i,0,31)f[i][0]=-inf;\n        f[t][0]=0;\n        Fur(i,1,n)\n            Fur(j,0,31)\n                f[j][i]=MAX(f[(j&15)<<1][i-1],f[(j&15)<<1|1][i-1])+b[j][i];\n        ans=MAX(ans,f[t][n]);\n    }\n    out<<ans<<ln;\n}\n```\n","link":null,"tags":[],"title":"LG 3622 [APIO2007]动物园"},{"categories":[["刷题记录"]],"content":"\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i=x;i<=y;++i)\n    #define Fdr(i,x,y) for(int i=x;i>=y;--i)\n    #define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) (int(log2(n)))\n    #define inf 0x3f3f3f3f\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){clr(ch,0);if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 1011\nint n,m,h[N],sta[N],v[N],tp;\nbool a[N][N];\nchar ch[N];\nint main(){\n\tfin(\"in\");\n\tin>>n>>m;\n\tFur(i,1,n){\n\t\tin>>(ch+1);\n\t\tFur(j,1,m)\n\t\ta[i][j]=ch[j]=='.';\n\t}\n\tll ans=0;\n\ttp=0;\n\tFur(i,1,n){\n\t\tFur(j,1,m){\n\t\t\tif(!a[i][j])h[j]=i;\n\t\t\twhile(tp&&h[sta[tp]]<h[j])tp--;\n\t\t\tsta[++tp]=j;\n\t\t\tv[tp]=v[tp-1]+(i-h[sta[tp]])*(sta[tp]-sta[tp-1]);\n\t\t\tans+=v[tp];\n\t\t}\n\t\ttp=0;\n\t}\n\tout<<ans<<ln;\n}\n\n```\n","link":null,"tags":[],"title":"LG 1950 长方形_NOI导刊2009提高（2）"},{"categories":[["刷题记录"]],"content":"\n设$g_i$表示交集个数至少为$i$的方案数\n\n那么$g_i = {n\\choose i}(2^{2^{n-i}}-1)$\n\n> 先从$n$中选$i$个,然后其他可以随便取\n> \n> 那就是有$2^{n-i}$个集合可以取\n> \n> 然后又可以取至少1个集合\n> \n> 那么答案就是${n\\choose i}(2^{2^{n-i}}-1)$\n\n设$f_i$表示恰好为$i$的\n\n那么$g_k=\\sum_{i=k}^n f_i\\cdot {i\\choose k}$\n\n反演$f_k=\\sum_{i=k}^n g_i\\cdot{i\\choose k} (-1)^{i-k}$\n\n不能直接快速幂,因为指数不能$\\mod p$,要用$2^{2^i}=(2^{2^{i-1}})^2$倒着枚举算\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;rg char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\n#define N 1000011\nconst int mod=1000000007;\nint n,k,g[N],fac[N],inv[N];\nint C(int a,int b){\n    return 1ll*fac[a]*inv[b]%mod*inv[a-b]%mod;\n}\nint pw(int x,int p){\n    int ans=1;\n    while(p){\n        if(p&1)ans=1ll*ans*x%mod;\n        p>>=1;x=1ll*x*x%mod;\n    }\n    return ans;\n}\nsigned main(){\n    in(n,k);\n    fac[0]=inv[0]=1;\n    Fur(i,1,n)fac[i]=1ll*fac[i-1]*i%mod;\n    inv[n]=pw(fac[n],mod-2);\n    Fdr(i,n-1,1)inv[i]=1ll*inv[i+1]*(i+1)%mod;\n\n    Fur(i,0,n)\n        g[i]=1ll*C(n,i)*(pw(2,(pw(2,n-i))-1+mod)%mod)%mod;\n    \n    int ans=0,b=2;\n    Fdr(i,n,k){\n        int t=1ll*C(n,i)%mod*C(i,k)%mod*(b-1)%mod;\n        if((i-k)&1)ans=(ans-t+mod)%mod;\n        else ans=(ans+t)%mod;\n        b=1ll*b*b%mod;\n    }\n    printf(\"%d\\n\",ans);\n}\n```\n","link":null,"tags":["动态规划","容斥"],"title":"BZ 2839 集合计数"},{"categories":[["刷题记录"]],"content":"\n首先将数列按位分解成32个位数列.\n\n枚举区间的左端点,,区间的and值要对答案有贡献必须为1,随着右端点右移,and值为不递增的,而区间的or值要对答案有贡献必须为1,随着右端点右移,or值为不递减的。\n\n可以求出每一段一段的最大长度然后统计\n\n\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i=x;i<=y;++i)\n    #define Fdr(i,x,y) for(int i=x;i>=y;--i)\n    #define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) (int(log2(n)))\n    #define inf 0x3f3f3f3f\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){clr(ch,0);if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 100011\n#define mod 1000000007\nint n,p[66],L[33][N],R[33][N];\nbool a[33][N];\nll ans=0;\nint main(){\n\tint x;\n\tin>>n;\n\tFur(i,1,n){\n\t\tin>>x;\n\t\tFur(j,0,32)\n\t\t\ta[j][i]=x&1,x>>=1;\n\t}\n\t\n\tp[0]=1;Fur(i,1,64)p[i]=(p[i-1]<<1)%mod;\n\t\n\tFur(i,0,32){\n\t\tint l=1,r=1;\n\t\twhile(l<=n){\n\t\t\tif(!a[i][l])L[i][l]=0;\n\t\t\telse{\n\t\t\t\tr=MAX(r,l);\n\t\t\t\twhile(r<n&&a[i][r+1])++r;\n\t\t\t\tL[i][l]=r;\n\t\t\t}\n\t\t\t++l;\n\t\t}\n\t}\n\t\n\tFur(i,0,32){\n\t\tint l=1,r=1;\n\t\twhile(l<=n){\n\t\t\tif(a[i][l])R[i][l]=l;\n\t\t\telse{\n\t\t\t\tr=MAX(r,l);\n\t\t\t\twhile(r<=n&&!a[i][r])++r;\n\t\t\t\tR[i][l]=r;\n\t\t\t}\n\t\t\t++l;\n\t\t}\n\t}\n\t\n\tFur(i,0,32)\n\t\tFur(j,1,n)\n\t\tif(a[i][j])\n\t\t\tFur(k,0,32)\n\t\t\t\tif(R[k][j]<=L[i][j])\n\t\t\t\tans=(ans+(ll)(L[i][j]-R[k][j]+1)*p[i+k])%mod;\n\t\t\t\t\n\tcout<<ans<<endl;\n}\n\n```\n","link":null,"tags":["位运算"],"title":"51nod 1674 区间的价值 V2"},{"categories":[["刷题记录"]],"content":"\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n\t#pragma GCC optimize(3)\n\t#define il __inline__ __attribute__ ((always_inline))\n\t#define rg register\n\t#define ll long long\n\t#define ull unsigned long long\n\t#define db double\n\t#define sht short\n\t#define MB template <class T>il\n\t#define Fur(i,x,y) for(int i=x;i<=y;i++)\n\t#define Fdr(i,x,y) for(int i=x;i>=y;i--)\n\t#define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n\t#define clr(x,y) memset(x,y,sizeof(x))\n\t#define cpy(x,y) memcpy(x,y,sizeof(x))\n\t#define fin(s) freopen(s\".in\",\"r\",stdin)\n\t#define fout(s) freopen(s\".out\",\"w\",stdout)\n\t#define fcin ios::sync_with_stdio(false)\n\t#define l2(n) (int(log2(n)))\n\t#define inf 0x3f3f3f3f\n\tMB T ABS(T x){return x>0?x:-x;}\n\tMB T MAX(T x,T y){return x>y?x:y;}\n\tMB T MIN(T x,T y){return x<y?x:y;}\n\tMB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n\tMB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 210011\nint n,m,q;\nbool rev[N];\nint c[N][2],s[N],f[N],st[N],v[N];\n#define ls c[x][0]\n#define rs c[x][1]\nbool irt(int x){return c[f[x]][0]!=x&&c[f[x]][1]!=x;}\nvoid pu(int x){s[x]=MAX(MAX(s[ls],s[rs]),v[x]);}\nvoid pr(int x){\n\tSWAP(ls,rs);\n\trev[x]^=1;\n}\nvoid pd(int x){\n\tif(rev[x]){\n\t\tif(ls)pr(ls);\n\t\tif(rs)pr(rs);\n\t\trev[x]=0;\n\t}\n}\nbool g(int x){return c[f[x]][1]==x;}\nvoid turn(int x){\n\tint y=f[x],z=f[y],l=g(x),r=!l,w=c[x][r];\n\tif(!irt(y))c[z][g(y)]=x;\n\tc[x][r]=y;c[y][l]=w;\n\tif(w)f[w]=y;\n\tf[x]=z;f[y]=x;\n\tpu(y);pu(x);\n}\nvoid splay(int x){\n\tint y=x,z=0;\n\tst[++z]=y;\n\twhile(!irt(y))st[++z]=y=f[y];\n\twhile(z)pd(st[z--]);\n\twhile(!irt(x)){\n\t\ty=f[x],z=f[y];\n\t\tif(!irt(y))\n\t\t\tturn(((c[y][0]==x)^(c[z][0]==y))?x:y);\n\t\tturn(x);\n\t}\n\tpu(x);\n}\nvoid access(int x){\n\tfor(int y=0;x;x=f[y=x])\n\t\tsplay(x),rs=y,pu(x);\n}\nvoid mrt(int x){\n\taccess(x);splay(x);\n\tpr(x);\n}\nint frt(int x){\n\taccess(x);splay(x);\n\twhile(ls)pd(x),x=ls;\n\tsplay(x);\n\treturn x;\n}\nvoid sl(int x,int y){\n\tmrt(x);access(y);splay(y);\n}\nvoid link(int x,int y){\n\tmrt(x);\n\tif(frt(y)!=x)f[x]=y;\n}\nstruct edge{\n\tint x,y,w;\n}e[300011];\nbool cmp(edge x,edge y){\n\treturn x.w<y.w;\n}\nint main(){\nint T;in>>T;\nwhile(T--){\n\tin>>n>>m;\n\tint x,y,w,cnt=n;\n\tFur(i,1,m)in>>e[i].x>>e[i].y>>e[i].w;\n\tsort(e+1,e+m+1,cmp);\n\tFur(i,1,m){\n\t\tx=e[i].x;y=e[i].y;w=e[i].w;\n\t\tif(frt(x)!=frt(y))v[++cnt]=w,link(x,cnt),link(y,cnt);\n\t}\n\tin>>q;\n\twhile(q--){\n\t\tin>>x>>y;\n\t\tif(frt(x)==frt(y))\n\t\t\tsl(x,y),out<<s[y]<<ln;\n\t\telse out<<\"impossible\\n\";\n\t}\n}\n}\n```\n","link":null,"tags":[],"title":"LG 2245 星际导航"},{"categories":[["刷题记录"]],"content":"\n$f[x]$表示状态为$x$时最少走多少步\n\n枚举现在取哪两个点,然后\n\n$f[x|2^{i-1}|2^{j-1}]=\\min(f[x|2^{i-1}|2^{j-1}],f[x])$\n\n如果直接枚举不剪枝的话可能会$TLE$\n\n所以我们只要找到第一位是$1$的,然后往后面枚举就可以了,因为不关怎么样我们都要把全部取完,先取后取是一样的\n\n(如果不懂可以自己模拟一下)\n\n\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i=x;i<=y;i++)\n    #define Fdr(i,x,y) for(int i=x;i>=y;i--)\n    #define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 0x3f3f3f3f\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){clr(ch,0);if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 10001\nint n;\nstruct node{\n    int x,y;\n}a[N];\nint f[1<<24];\nint d(int i,int j){\n    return (a[i].x-a[j].x)*(a[i].x-a[j].x)+(a[i].y-a[j].y)*(a[i].y-a[j].y);\n}\nint calc(int i,int j){\n    return MIN(d(0,i)+d(i,j)+d(j,0),d(0,j)+d(j,i)+d(i,0));\n}\nint main(){\n    cin>>a[0].x>>a[0].y>>n;\n    Fur(i,1,n)cin>>a[i].x>>a[i].y;\n    out<<\"23333\\n\";\n    clr(f,126);\n    f[0]=0;\n    Fur(x,0,(1<<24)-1)\n        Fur(i,1,24)\n            Fur(j,i+1,24)\n            if(!(x&(1<<(i-1)))&&!(x&(1<<(j-1)))){\n                int y=(x|(1<<(i-1)))|(1<<(j-1));\n                f[y]=MIN(f[y],f[x]+calc(i,j));\n            }\n    out<<f[(1<<24)-1]<<ln;\n}\n\n```\n","link":null,"tags":["状态dp"],"title":"LG CF8C Looking-for-Order"},{"categories":[["刷题记录"]],"content":"\n动态规划\n\n设$f[n][k]$表示$n$个节点,高度为$k$\n\n根节点是固定不变的\n\n左右子树可以自由变换\n\n那么：\n\n$f[n][k] = \\sum_{i=1}^n f[i][k-1] \\times f[n-i-1][k-1]$\n\n挺好的题\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i=x;i<=y;++i)\n    #define Fdr(i,x,y) for(int i=x;i>=y;--i)\n    #define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 0x3f3f3f3f\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){clr(ch,0);if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 100011\nint n,m;\nll f[39][39];\nint main(){\n    fin(\"in\");\n    in>>n>>m;\n    Fur(i,0,n)f[0][i]=1;\n    Fur(k,1,n)\n        Fur(i,1,n)\n            Fur(j,0,i-1)\n            f[i][k]+=f[j][k-1]*f[i-j-1][k-1];\n\n    out<<f[n][n]-f[n][m-1]<<ln;\n}\n```\n","link":null,"tags":[],"title":"LG CF9D How many trees"},{"categories":[["刷题记录"]],"content":"\n$lct$无脑做\n\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n\t#pragma GCC optimize(3)\n\t#define il __inline__ __attribute__ ((always_inline))\n\t#define rg register\n\t#define ll long long\n\t#define ull unsigned long long\n\t#define db double\n\t#define sht short\n\t#define MB template <class T>il\n\t#define Fur(i,x,y) for(int i=x;i<=y;i++)\n\t#define Fdr(i,x,y) for(int i=x;i>=y;i--)\n\t#define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n\t#define clr(x,y) memset(x,y,sizeof(x))\n\t#define cpy(x,y) memcpy(x,y,sizeof(x))\n\t#define fin(s) freopen(s\".in\",\"r\",stdin)\n\t#define fout(s) freopen(s\".out\",\"w\",stdout)\n\t#define fcin ios::sync_with_stdio(false)\n\t#define l2(n) (int(log2(n)))\n\t#define inf 0x3f3f3f3f\n\tMB T ABS(T x){return x>0?x:-x;}\n\tMB T MAX(T x,T y){return x>y?x:y;}\n\tMB T MIN(T x,T y){return x<y?x:y;}\n\tMB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n\tMB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 300011\n#define ls c[x][0]\n#define rs c[x][1]\nint st[N],f[N],c[N][2],v[N],s[N];\nbool rev[N];\nbool irt(int x){return c[f[x]][0]!=x&&c[f[x]][1]!=x;}\nvoid pr(int x){\n\tSWAP(ls,rs);\n\trev[x]^=1;\n}\nvoid pd(int x){\n\tif(rev[x]){\n\t\tif(ls)pr(ls);\n\t\tif(rs)pr(rs);\n\t\trev[x]=0;\n\t}\n}\nbool g(int x){return c[f[x]][1]==x;}\nvoid turn(int x){\n\tint y=f[x],z=f[y],l=g(x),r=!l,w=c[x][r];\n\tif(!irt(y))c[z][g(y)]=x;\n\tc[x][r]=y;c[y][l]=w;\n\tif(w)f[w]=y;\n\tf[x]=z;f[y]=x;\n}\nvoid splay(int x){\n\tint y=x,z=0;\n\tst[++z]=y;\n\twhile(!irt(y))st[++z]=y=f[y];\n\twhile(z)pd(st[z--]);\n\twhile(!irt(x)){\n\t\ty=f[x],z=f[y];\n\t\tif(!irt(y))\n\t\t\tturn(((c[y][0]==x)^(c[z][0]==y))?x:y);\n\t\tturn(x);\n\t}\n}\nvoid access(int x){\n\tfor(int y=0;x;x=f[y=x])\n\t\tsplay(x),rs=y;\n}\nvoid mrt(int x){\n\taccess(x);splay(x);\n\tpr(x);\n}\nint frt(int x){\n\taccess(x);splay(x);\n\twhile(ls)pd(x),x=ls;\n\tsplay(x);\n\treturn x;\n}\nvoid link(int x,int y){\n\tmrt(x);\n\tif(frt(y)!=x)f[x]=y;\n}\nvoid cut(int x,int y){\n\tmrt(x);\n\tif(frt(y)==x&&f[y]==x&&!c[y][0])\n\t\tc[x][1]=f[y]=0;\n}\nint n,m,X[N],Y[N],cnt=0;\nint main(){\n\tin>>n>>m;\n\tint x,y;char u;\n\tFur(i,1,n-1)in>>x>>y,link(x,y);\n\twhile(m--){\n\t\tin>>u>>x;\n\t\tif(u=='Q')in>>y,out<<(frt(x)==frt(y)?\"Yes\":\"No\")<<ln;\n\t\tif(u=='C')in>>y,cut(x,y),X[++cnt]=x,Y[cnt]=y;\n\t\tif(u=='U')link(X[x],Y[x]);\n\t}\n}\n```\n","link":null,"tags":["lct"],"title":"LG 3950 部落冲突"},{"categories":[["刷题记录"]],"content":"\n这篇题解可能是对楼下的补充\n\n我们考虑每个点能贡献多少次\n\n![无标题.png](https:\/\/i.loli.net\/2019\/10\/25\/Evy74V8rpIaec1F.png)\n\n设当前节点为$x$,路径有三种情况,上图分别对应情况$1$,情况$2$,情况$3$\n\n1. $x$子树内$\\rightarrow x \\rightarrow x$子树外(包括$x$)\n    \n2. $x$子树内(包括$x$)$\\rightarrow x \\rightarrow x$子树内\n\n3. $x$子树外$\\rightarrow x \\rightarrow x$子树内\n\n我们可以先处理出与$x$的距离为偶数和与$x$的距离为奇数的点的个数,分别记作$f_x,g_x$\n\n那么$f_x = 1 + \\sum g_{to},g_x = 1 + \\sum f_{to}$($to$指$x$的孩子)\n\n我们来考虑所有情况\n\n1. $ans += V_x \\times (f_x-g_x) \\times (n-siz_x+1)$(可以在$x$的子树中随机选一个往子树外面走(可以指走到$x$))\n\n2. $ans += V_x \\times (g_{to}-f_{to}) \\times (siz_x-siz_{to}-1)$\n  \n   $ans+= V_x \\times (siz_x-1)$(可以从$x$直接向下走)\n\n3. 我们需要记录$x$子树外与$x$的距离为偶数和与$x$的距离为奇数的点的个数,分别记作$uf_x,ug_x$\n\n\t我们可以通过$bfs$从上到下来处理,那么\n    \n   $uf_x=ug_{fa_x}+g_{fa_x}-f_x$\n    \n   $ug_x=uf_{fa_x}+f_{fa_x}-g_x$\n   \n   $ans += V_x \\times (uf_x-ug_x) \\times siz_x$\n   \n接下来放代码：\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i=x;i<=y;++i)\n    #define Fdr(i,x,y) for(int i=x;i>=y;--i)\n    #define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 0x3f3f3f3f\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){clr(ch,0);if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 200011\nconst ll mod = 1000000007;\nint n,cnt=0,head[N];\nll ans=0;\nstruct edge{\n    int to,nxt;\n}e[N*2];\nil void add(int x,int y){\n    e[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;\n}\nint a[N],siz[N],f[N],g[N],fa[N];\nil ll mo(ll x,ll y){\n    if(x>y)return x-y;\n    return x;\n}\n#define A%B mo(A,B)\nvoid dfs(int x){\n    f[x]=siz[x]=1;\n    fl(i,x)if(to!=fa[x]){\n        fa[to]=x;dfs(to);\n        siz[x]+=siz[to];\n        f[x]+=g[to];\n        g[x]+=f[to];\n    }\n    \/\/ 1:\n    ans=(ans+1ll*(f[x]-g[x])*(n-siz[x]+1)%mod*a[x]%mod)%mod;\n    \/\/2:\n    ans=(ans+1ll*(siz[x]-1)*a[x]%mod)%mod;\n    fl(i,x)if(to!=fa[x])\n        ans=(ans+1ll*(g[to]-f[to])*(siz[x]-siz[to]-1)%mod*a[x]%mod)%mod;\n}\nint uf[N],ug[N];\nil void bfs(){\n    queue<int>q;\n    fl(i,1)q.push(to);\n    while(!q.empty()){\n        int x=q.front();q.pop();\n        uf[x]=ug[fa[x]]+g[fa[x]]-f[x];\n        ug[x]=uf[fa[x]]+f[fa[x]]-g[x];\n        ans=(ans+1ll*(uf[x]-ug[x])*siz[x]%mod*a[x]%mod)%mod;\n        fl(i,x)if(to!=fa[x])q.push(to);\n    }\n}\nint main(){\n    fin(\"in\");\n    in>>n;\n    Fur(i,1,n)in>>a[i];\n    int x,y;\n    Fur(i,1,n-1)in>>x>>y,add(x,y),add(y,x);\n    dfs(1);\n    bfs();\n    cout<<(ans+mod)%mod<<endl;\n}\n```\n","link":null,"tags":["动态规划","树形dp"],"title":"LG CF960E Alternating Tree"},{"categories":[["刷题记录"]],"content":"\n我们每次找最右的0,这个位置p的答案为++cnt,然后把$a_p+1,...a_n$减去cnt\n\n一直重复n遍即可\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    \/\/ #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;rg char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\n#define N 200011\n#define int ll\n#define inf (1ll<<50)\n#define ls rt<<1\n#define rs rt<<1|1\n#define pu s[rt]=MIN(s[ls],s[rs])\nint n;\nll s[N<<2],laz[N<<2];\nvoid build(int l,int r,int rt){\n    if(l==r)return void(in(s[rt]));\n    int m=(l+r)>>1;\n    build(l,m,ls);build(m+1,r,rs);\n    pu;\n}\nvoid pd(int rt){\n    if(laz[rt]){\n        laz[ls]+=laz[rt];\n        laz[rs]+=laz[rt];\n        s[ls]+=laz[rt];\n        s[rs]+=laz[rt];\n        laz[rt]=0;\n    }\n}\nvoid upd(int L,int R,int v,int l,int r,int rt){\n    if(L==n+1)return;\n    if(L<=l&&r<=R){\n        s[rt]+=v;laz[rt]+=v;\n        return;\n    }\n    int m=(l+r)>>1;\n    pd(rt);\n    if(L<=m)upd(L,R,v,l,m,ls);\n    if(R>m)upd(L,R,v,m+1,r,rs);\n    pu;\n}\nll ask(int L,int R,int l,int r,int rt){\n    if(L<=l&&r<=R)return s[rt];\n    int m=(l+r)>>1;\n    ll ans=inf;\n    pd(rt);\n    if(L<=m)ans=ask(L,R,l,m,ls);\n    if(R>m)ans=MIN(ans,ask(L,R,m+1,r,rs));\n    return ans;\n}\nint lz(){\n    int l=1,r=n,ans=n;\n    while(l<=r){\n        int m=(l+r)>>1;\n        if(ask(m,n,1,n,1)==0)ans=m,l=m+1;\n        else r=m-1;\n    }\n    return ans;\n}\nint ANS[N];\nsigned main(){\n    in(n);\n    build(1,n,1);\n    Fur(i,1,n){\n        int x=lz();\n        ANS[x]=i;\n        upd(x,x,inf,1,n,1);\n        upd(x+1,n,-i,1,n,1);\n    }\n    Fur(i,1,n)out(ANS[i],\" \");\n    flush();\n}\n```\n","link":null,"tags":["线段树"],"title":"LG CF1208D Restore-Permutation"},{"categories":[["刷题记录"]],"content":"\n先把连续的块缩成一个点\n\n设$f[i][j]$表示$[i,j]$全部涂成一种颜色最少要多少次\n\n$f[i][j] = \\min(f[i+1][j],f[i][j-1])+1$\n\n若$c[i]==c[j]$,$f[i][j]=f[i+1][j-1]+1$\n\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i=x;i<=y;++i)\n    #define Fdr(i,x,y) for(int i=x;i>=y;--i)\n    #define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 0x3f3f3f3f\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){clr(ch,0);if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 5111\nint n,a[N],f[N][N];\nint main(){\n    fin(\"in\");\n    in>>n;\n    clr(f,126);\n    Fur(i,1,n){\n        in>>a[i];\n        if(a[i]==a[i-1])--i,--n;\n    }\n    Fur(i,1,n)f[i][i]=0;\n    Fur(k,2,n)\n        Fur(i,1,n-k+1){\n            int j=i+k-1;\n            if(a[i]==a[j])f[i][j]=f[i+1][j-1]+1;\n            else f[i][j]=MIN(f[i+1][j],f[i][j-1])+1;\n        }\n    \n    out<<f[1][n]<<ln;\n}\n```\n","link":null,"tags":["动态规划","区间dp"],"title":"LG CF1114D Flood Fill"},{"categories":[["刷题记录"]],"content":"\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n\t#pragma GCC optimize(3)\n\t#define il __inline__ __attribute__ ((always_inline))\n\t#define rg register\n\t#define ll long long\n\t#define ull unsigned long long\n\t#define db double\n\t#define sht short\n\t#define MB template <class T>il\n\t#define Fur(i,x,y) for(int i=x;i<=y;i++)\n\t#define Fdr(i,x,y) for(int i=x;i>=y;i--)\n\t#define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n\t#define clr(x,y) memset(x,y,sizeof(x))\n\t#define cpy(x,y) memcpy(x,y,sizeof(x))\n\t#define fin(s) freopen(s\".in\",\"r\",stdin)\n\t#define fout(s) freopen(s\".out\",\"w\",stdout)\n\t#define fcin ios::sync_with_stdio(false)\n\t#define l2(n) (int(log2(n)))\n\t#define inf 0x3f3f3f3f\n\tMB T ABS(T x){return x>0?x:-x;}\n\tMB T MAX(T x,T y){return x>y?x:y;}\n\tMB T MIN(T x,T y){return x<y?x:y;}\n\tMB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n\tMB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){clr(ch,0);if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 31\n#define mod 998244353\nint n,m;\nll f[N],c[N][N],ans=0;\nchar ch[N];\nint main(){\n\tin>>n>>m;\n\tc[0][0]=1;\n\tFur(i,1,20)c[i][0]=1;\n\tFur(i,1,20)\n\t\tFur(j,1,20)c[i][j]=(c[i-1][j]+c[i-1][j-1])%mod;\n\t\n\tf[0]=1;\n\tFur(i,1,20)\n\t\tFur(j,1,i)\n\t\t\tf[i]=(f[i]+f[i-j]*c[i][j])%mod;\n\tint x;ll v;\n\tFur(i,1,m){\n\t\tin>>ch>>v;x=0;\n\t\tFur(i,0,n-1)x+=ch[i]-48;\n\t\tans=(ans+v*f[x]%mod*f[n-x]%mod)%mod;\n\t}\n\tout<<ans<<ln;\n}\n```\n","link":null,"tags":[],"title":"LG 4996 咕咕咕 "},{"categories":[["刷题记录"]],"content":"\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n\t#pragma GCC optimize(3)\n\t#define il __inline__ __attribute__ ((always_inline))\n\t#define rg register\n\t#define ll long long\n\t#define ull unsigned long long\n\t#define db double\n\t#define sht short\n\t#define MB template <class T>il\n\t#define Fur(i,x,y) for(int i=x;i<=y;i++)\n\t#define Fdr(i,x,y) for(int i=x;i>=y;i--)\n\t#define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n\t#define clr(x,y) memset(x,y,sizeof(x))\n\t#define cpy(x,y) memcpy(x,y,sizeof(x))\n\t#define fin(s) freopen(s\".in\",\"r\",stdin)\n\t#define fout(s) freopen(s\".out\",\"w\",stdout)\n\t#define fcin ios::sync_with_stdio(false)\n\t#define l2(n) (int(log2(n)))\n\t#define inf 0x3f3f3f3f\n\tMB T ABS(T x){return x>0?x:-x;}\n\tMB T MAX(T x,T y){return x>y?x:y;}\n\tMB T MIN(T x,T y){return x<y?x:y;}\n\tMB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n\tMB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 10011\nint main(){\n\t\n}\n```\n","link":null,"tags":["期望"],"title":"LG 3802 小魔女帕琪 "},{"categories":[["刷题记录"]],"content":"\n可以理解成从左上角到右下角的最长路(每层只能取一个)\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i=x;i<=y;++i)\n    #define Fdr(i,x,y) for(int i=x;i>=y;--i)\n    #define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 0x3f3f3f3f\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){clr(ch,0);if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 101\nint n,m,f[N][N],p[N][N],a[N][N],as[N];\nint main(){\n    fin(\"in\");\n    in>>n>>m;\n    Fur(i,1,n)\n        Fur(j,1,m)\n        in>>a[i][j];\n    Fur(i,1,n)f[1][i]=a[1][i];\n    Fur(i,2,n)\n        Fur(j,i,m){\n            f[i][m]=-inf;\n            Fur(k,i-1,j-1)\n                if(f[i-1][k]+a[i][j]>f[i][j])\n                    f[i][j]=f[i-1][k]+a[i][j],p[i][j]=k;\n        }\n    int ans=0,pos,x,y;\n    Fur(i,n,m)\n        if(f[n][i]>ans)ans=f[n][i],pos=i;\n    out<<ans<<ln;\n    x=pos;\n    Fdr(i,n,1){\n        as[i]=x;\n        x=p[i][x];\n    }\n    Fur(i,1,n)out<<as[i]<<\" \";out<<ln;\n}\n```\n","link":null,"tags":["动态规划"],"title":"LG 1854 花店橱窗布置"},{"categories":[["刷题记录"]],"content":"\n我们可以考虑放$n-k$个节点然后使深度最大的最小\n\n\n\n一开始的时候可以反过来想：树里面长度最大的路径就是树的直径,它的两个端点的度都是$1$（也就是叶子节点）\n\n\n\n我们可以从每个叶子结点开始,向中心包围。可以用队列的方式实现。\n\n（代码很短）\n\n\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i=x;i<=y;++i)\n    #define Fdr(i,x,y) for(int i=x;i>=y;--i)\n    #define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) (int(log2(n)))\n    #define inf 0x3f3f3f3f\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){clr(ch,0);if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 100001\nint n,cnt(0),k,head[N],q[N],c[N],d[N];\nstruct edge{\n\tint to,nxt;\n}e[N*2];\nil void add(int x,int y){\n\te[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;\n}\nint main(){\n\tfin(\"in\");\n\tin>>n>>k;\n\tint x,y;\n\tFur(i,1,n-1)\n\t\tin>>x>>y,\n\t\tadd(x,y),add(y,x),c[x]++,c[y]++;\n\t\n\tint h=0,t=0,cnt=n-k;\n\tFur(i,1,n)if(c[i]==1)q[t++]=i,d[i]=1;\n\twhile(h<t){\n\t\tx=q[h++];\n\t\tif(!--cnt)return out<<d[x]<<ln,0;\n\t\tfl(i,x)if(--c[to]==1)\n\t\t\td[to]=d[x]+1,q[t++]=to;\n\t}\n}\n\n```\n","link":null,"tags":["树的直径"],"title":"LG 5536 【XR-3】核心城市"},{"categories":[["刷题记录"]],"content":"\n倍增找$k$级祖先+~~dsu on tree~~静态链分治\n\n设当前节点为$x$\n\n如果$d_x < k$,那么答案当然为$0$\n可以找到第$k$级祖先,然后在$k$级祖先上添加一组询问(求它子树中深度为$d_x$的节点数)\n\n因为这个还算上了$x$本身,所以把结果-1就是答案了\n\n统计区间中各个深度的点有多少个就直接$tot[d_x]+=(1\\text{或}-1)$就可以了\n\n\n上代码：\n```cpp\n#include<bits\/stdc++.h>\n#pragma GCC optimize(3)\n#define il inline\n#define rg register\n#define Fur(i,x,y) for(register int i=x;i<=y;++i)\n#define fl(i,x) for(register int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n#define clr(x,y) memset(x,y,sizeof(x))\n#define fin(s) freopen(s\".in\",\"r\",stdin)\n#define l2(n) ((int)(log2(n)))\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 100011\nint n,m,cnt=0,head[N],CNT=0,HEAD[N],tt=0,RT[N];\nstruct edge{\n    int to,nxt;\n}e[N],E[N];\nil void add(int x,int y){\n    e[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;\n}\nil void pb(int x,int y){\n    E[++CNT].to=y;E[CNT].nxt=HEAD[x];HEAD[x]=CNT;\n}\nint f[17][N],d[N],siz[N],son[N],T[N],L[N],R[N],dfn=0;\nil void dfs(int x){\n    siz[x]=1;T[L[x]=++dfn]=x;\n    fl(i,x){\n        f[0][to]=x;d[to]=d[x]+1;\n        dfs(to);siz[x]+=siz[to];\n        if(siz[to]>siz[son[x]])son[x]=to;\n    }\n    R[x]=dfn;\n}\nil void st(){\n    int k=l2(n);\n    Fur(j,1,k)\n        Fur(i,1,n)\n        if(~f[j-1][i])f[j][i]=f[j-1][f[j-1][i]];\n}\nil int get(int x,int k){\n    int t=0;\n    while(k){\n        if(k&1){\n            x=f[t][x];\n            if(!(~x))return -1;\n        }\n        k>>=1;++t;\n    }\n    return x;\n}\nstruct que{int d,id;}q[N];\nint ANS[N];\nint tot[N];\nil void Add(int x,int v){\n    tot[d[x]]+=v;\n}\nil void upd(int x,int v){\n    Fur(i,L[x],R[x])Add(T[i],v);\n}\nil void sol(int x){\n    fl(i,x)if(to!=son[x]){\n        sol(to);\n        upd(to,-1);\n    }\n    if(son[x])sol(son[x]);\n    Add(x,1);\n    fl(i,x)if(to!=son[x])upd(to,1);\n    for(register int i=HEAD[x],to;to=E[i].to,i;i=E[i].nxt)ANS[q[to].id]=tot[q[to].d]-1;\n}\nint main(){\n    in>>n;\n    register int x,k;\n    Fur(i,1,n){\n        in>>x;\n        if(!x)RT[++RT[0]]=i;\n        else add(x,i);\n    }\n    clr(f,-1);\n    Fur(i,1,RT[0])dfs(RT[i]);\n    st();\n    in>>m;\n    Fur(i,1,m){\n        in>>x>>k;\n        if(d[x]>=k)q[++tt]=que{d[x],i},pb(get(x,k),tt);\n        else ANS[i]=0;\n    }\n    Fur(i,1,RT[0])sol(RT[i]),upd(RT[i],-1);\n    Fur(i,1,m)out<<ANS[i]<<\" \";\n}\n```\n","link":null,"tags":["静态链分治"],"title":"LG CF208E Blood Cousins"},{"categories":[["刷题记录"]],"content":"\n```cpp\n#include<bits\/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD=1e9+7;\nconst ll N=50005;\nll f[2][N];\nll g[2][N];\nll h[N];\nll n,m;\nint main(){\n    scanf(\"%lld\",&n);m=sqrt(n);\n    f[0][0]=1;\n    int now=0,now1=0;\n    for (ll u=1;u<=m;u++){\n        now^=1;\n        for (ll i=0;i<u;i++) f[now][i]=f[now^1][i];\n        for (ll i=u;i<=n;i++) f[now][i]=(f[now][i-u]+f[now^1][i])%MOD;\n    }\n    m++;\n    g[0][0]=1;h[0]=1;\n    for (ll u=1;u<=m;u++){\n        now1^=1;\n        for (ll i=0;i<=n;i++)\n        {\n            g[now1][i]=0;\n            if (i>=m) g[now1][i]=(g[now1][i]+g[now1^1][i-m])%MOD;\n            if (i>=u) g[now1][i]=(g[now1][i]+g[now1][i-u])%MOD;\n            h[i]=(h[i]+g[now1][i])%MOD;\n        }\n    }\n    ll ans=0;\n    for (ll u=0;u<=n;u++)   ans=(ans+f[now][u]*h[n-u]%MOD)%MOD;\n    printf(\"%lld\\n\",ans);\n}\n```\n","link":null,"tags":[],"title":"51nod 1259 整数划分-V2"},{"categories":[["刷题记录"]],"content":"\ntarjan找出环 答案是每个环上的最小值加起来\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;rg char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\n#define N 200011\nint n,c[N],a[N];\nint dfn[N],low[N],sz=0,bl[N],tp=0,z[N];\nbool v[N];\nvoid tarjan(int x){\n    dfn[x]=low[x]=++sz;\n    z[++tp]=x;v[x]=1;\n    if(!dfn[a[x]])tarjan(a[x]),low[x]=MIN(low[x],low[a[x]]);\n    else if(v[a[x]])low[x]=MIN(low[x],dfn[a[x]]);\n\n    if(low[x]==dfn[x]){\n        while(int k=z[tp--]){\n            bl[k]=x;v[k]=0;\n            if(k==x)break;\n            c[x]=MIN(c[x],c[k]);\n        }\n    }\n}\nint main(){\n    in(n);\n    Fur(i,1,n)in(c[i]);\n    Fur(i,1,n)in(a[i]);\n    Fur(i,1,n)if(!dfn[i])tarjan(i);\n    int ans=0;\n    Fur(i,1,n)if(i==bl[i]&&bl[a[i]]==i)ans+=c[i];\n    printf(\"%d\\n\",ans);\n}\n```\n","link":null,"tags":["环","tarjan"],"title":"LG CF1027D Mouse-Hunt"},{"categories":[["刷题记录"]],"content":"\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n\t#pragma GCC optimize(3)\n\t#define il __inline__ __attribute__ ((always_inline))\n\t#define rg register\n\t#define ll long long\n\t#define ull unsigned long long\n\t#define db double\n\t#define sht short\n\t#define MB template <class T>il\n\t#define Fur(i,x,y) for(int i=x;i<=y;i++)\n\t#define Fdr(i,x,y) for(int i=x;i>=y;i--)\n\t#define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n\t#define clr(x,y) memset(x,y,sizeof(x))\n\t#define cpy(x,y) memcpy(x,y,sizeof(x))\n\t#define fin(s) freopen(s\".in\",\"r\",stdin)\n\t#define fout(s) freopen(s\".out\",\"w\",stdout)\n\t#define fcin ios::sync_with_stdio(false)\n\t#define l2(n) (int(log2(n)))\n\t#define inf 0x3f3f3f3f\n\tMB T ABS(T x){return x>0?x:-x;}\n\tMB T MAX(T x,T y){return x>y?x:y;}\n\tMB T MIN(T x,T y){return x<y?x:y;}\n\tMB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n\tMB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){clr(ch,0);if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 10011\nint n,m,ans=0,cnt=0,head[N],s[2],C[N];\nstruct edge{\n\tint to,nxt;\n}e[N];\nvoid add(int x,int y){\n\te[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;\n}\nbool u[N];\nbool dfs(int x,int c){\n\tif(u[x])return (C[x]==c);\n\tu[x]=1;\n\ts[C[x]=c]++;\n\tfl(i,x)if(!dfs(to,c^1))return 0;\n\treturn 1;\n}\nint main(){\n\tin>>n>>m;\n\tint x,y;\n\tFur(i,1,m)\n\t\tin>>x>>y,\n\t\tadd(x,y),add(y,x);\n\t\n\tFur(i,1,n)\n\tif(!u[i]){\n\t\ts[0]=s[1]=0;\n\t\tif(!dfs(i,0))return out<<\"Impossible\\n\",0;\n\t\tans+=MIN(s[1],s[0]);\n\t}\n\tout<<ans<<ln;\n}\n```\n","link":null,"tags":[],"title":"LG 1330 封锁阳光大学"},{"categories":[["刷题记录"]],"content":"\n$$\n(a_i+a_j)(a_i^2+a_j^2)\\equiv k \\mod p\n\\\\\\\\\n(a_i + a_j) \\times (a_i - a_j) \\times (a_i^2 + a_j^2) \\equiv k(a_i - a_j) \\mod p\n\n\\\\\\\\\n\n(a_i^2 - a_j^2) \\times (a_i^2 + a_j^2) \\equiv k(a_i - a_j) \\mod p\n\n\\\\\\\\\n\na_i^4 - a_j^4 \\equiv ka_i - ka_j \\mod p\n\n\\\\\\\\\n\na_i^4 - ka_i \\equiv a_j^4 - ka_j \\mod p\n\n$$\n\n那么只要把$(a_i^4 - ka_i) \\mod p$放到桶里就可以知道有多少个数符合\n\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n\t#pragma GCC optimize(3)\n\t#define il __inline__ __attribute__ ((always_inline))\n\t#define rg register\n\t#define ll long long\n\t#define ull unsigned long long\n\t#define db double\n\t#define sht short\n\t#define MB template <class T>il\n\t#define Fur(i,x,y) for(int i=x;i<=y;i++)\n\t#define Fdr(i,x,y) for(int i=x;i>=y;i--)\n\t#define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n\t#define clr(x,y) memset(x,y,sizeof(x))\n\t#define cpy(x,y) memcpy(x,y,sizeof(x))\n\t#define fin(s) freopen(s\".in\",\"r\",stdin)\n\t#define fout(s) freopen(s\".out\",\"w\",stdout)\n\t#define fcin ios::sync_with_stdio(false)\n\t#define l2(n) (int(log2(n)))\n\t#define inf 0x3f3f3f3f\n\tMB T ABS(T x){return x>0?x:-x;}\n\tMB T MAX(T x,T y){return x>y?x:y;}\n\tMB T MIN(T x,T y){return x<y?x:y;}\n\tMB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n\tMB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 10011\nint n,k,p;\nmap<int,int>t;\nint main(){\n\tin>>n>>p>>k;\n\tll x,ans=0;\n\tFur(i,1,n){\n\t\tin>>x;\n\t\tx=(1ll*x*x%p*x%p*x%p-(1ll*k*x%p)+p)%p;\n\t\tif(t.count(x))ans+=t[x];\n\t\tt[x]++;\n\t}\n\tout<<ans<<ln;\n}\n```\n","link":null,"tags":["数论"],"title":"LG CF1188B Count-Pairs"},{"categories":[["刷题记录"]],"content":"\n```cpp\n#include<iostream>\nusing namespace std;\nint n,m,ans,dp[(1<<10)][(1<<10)][3],a[105],Sum[(1<<10)];\nchar x;\nint getsum(int S){\n    int tot=0;\n    while(S) {if(S&1) tot++; S>>=1;}\n    return tot;\n}\nint main(){\n    cin>>n>>m;\n    for(int i=0;i<n;i++)\n        for(int j=0;j<m;j++)\n            cin>>x,a[i]<<=1,a[i]+=(x=='H'?1:0);\n    for(int i=0;i<(1<<m);i++)\n        Sum[i]=getsum(i);\n    for(int S=0;S<(1<<m);S++)\n        if(!(S&a[0] || (S&(S<<1)) || (S&(S<<2))))\n            dp[0][S][0]=Sum[S];\n    for(int L=0;L<(1<<m);L++)\n        for(int S=0;S<(1<<m);S++)\n            if(!(L&S || L&a[0] || S&a[1] || (L&(L<<1)) || (L&(L<<2)) || (S&(S<<1)) || (S&(S<<2))))\n                dp[L][S][1]=Sum[S]+Sum[L];\n    for(int i=2;i<n;i++)\n        for(int L=0;L<(1<<m);L++)\n            if(!(L&a[i-1] || (L&(L<<1)) || (L&(L<<2))))\n            for(int S=0;S<(1<<m);S++)\n                if(!(S&a[i] || L&S || (S&(S<<1)) || (S&(S<<2))))\n                for(int FL=0;FL<(1<<m);FL++)\n                    if(!(FL&L || FL&S || FL&a[i-2] || (FL&(FL<<1)) || (FL&(FL<<2))))\n                    dp[L][S][i%3]=max(dp[L][S][i%3],dp[FL][L][(i-1)%3]+Sum[S]);\n    for(int L=0;L<(1<<m);L++)\n        for(int S=0;S<(1<<m);S++)\n            ans=max(ans,dp[L][S][(n-1)%3]);\n    cout<<ans;\n}\n```\n","link":null,"tags":[],"title":"LG 2704 [NOI2001]炮兵阵地"},{"categories":[["刷题记录"]],"content":"\n首先,我们只用分析 NO 的情况,其他的都是 YES,NO 的情况有两种： \n\n1. x 既不在 A 中,也不在 B 中,即找不到 a-x 和 b-x,NO； \n2. x 既可以在 A 中,也可以在 B 中,也就是找到了 a-x 和 b-x,如果 x 在 A 中,那么 b-x 一定不在 B 中,因为数唯一,所以 b-x 只能在 A 中,也就是说必须存在 a-(b-x),如果不存在就行不通,同理得如果 x 在 B 中,则必须存在 b-(a-x),如果不存在就行不通,那么如果两个方案都行不通了,也就是说 NO 了。 \n   \n```cpp\n#include <iostream>\n#include <algorithm>\n\n#define YES 1\n#define NO 0\n\nusing namespace std;\n\nconst int MAXN = 1e5 + 10;\n\nint p[MAXN];\n\nint bs(int l, int h, int v)\n{\n    int m;\n    while (l < h)\n    {\n        m = (l + h) >> 1;\n        if (p[m] == v)\n        {\n            return YES;\n        }\n        if (p[m] < v)\n        {\n            l = m + 1;\n        }\n        else\n        {\n            h = m;\n        }\n    }\n    return NO;\n}\n\nint main(int argc, const char * argv[])\n{\n\/\/    freopen(\"\/Users\/zyj\/Desktop\/input.txt\", \"r\", stdin);\n\n    int n, a, b;\n    cin >> n >> a >> b;\n\n    for (int i = 0; i < n; i++)\n    {\n        scanf(\"%d\", p + i);\n    }\n    sort(p, p + n);\n\n    for (int i = 0; i < n; i++)\n    {\n        bool A = bs(0, n, a - p[i]);\n        bool B = bs(0, n, b - p[i]);\n        if (!A && !B)\n        {\n            cout << \"NO\\n\";\n            return 0;\n        }\n        if (A && B)\n        {\n            bool A_ = bs(0, n, a - b + p[i]);\n            bool B_ = bs(0, n, b - a + p[i]);\n            if (!A_ && !B_)\n            {\n                cout << \"NO\\n\";\n                return 0;\n            }\n        }\n    }\n    cout << \"YES\\n\";\n}\n\n```\n","link":null,"tags":["排序","二分"],"title":"51nod 1557 两个集合"},{"categories":[["刷题记录"]],"content":"\n```cpp\n#include<cstdio>\n#include<algorithm>\n#define RG register\n#define I inline\n#define R int\n#define lc c[x][0]\n#define rc c[x][1]\n#define G if(++ip==ie)if(fread(ip=ibuf,1,L,stdin))\nusing namespace std;\nconst int N=5e5+9,M=1.5e6+9,L=1<<19;\nchar ibuf[L],*ie=ibuf+L,*ip=ie-1;\nint n,f[M],c[N][2],t[N],n1[N],n2[N],v[M],q[M],d[N];\nI int max(R x,R y){return x>y?x:y;}\nI int in(){\n    G;while(*ip<'-')G;\n    R x=*ip&15;G;\n    while(*ip>'-'){(x*=10)+=*ip&15;G;}\n    return x;\n}\nI bool nrt(R x){\n    return c[f[x]][0]==x||c[f[x]][1]==x;\n}\nI void up(R x){\n    if(!(n1[x]=n1[rc])&&!(n1[x]=x*(v[x]!=1)))n1[x]=n1[lc];\n    if(!(n2[x]=n2[rc])&&!(n2[x]=x*(v[x]!=2)))n2[x]=n2[lc];\n}\nI void dn(R x,R tg){\n    v[x]^=3;swap(n1[x],n2[x]);t[x]+=tg;\n}\nI void all(R x){\n    if(nrt(x))all(f[x]);\n    if(t[x])dn(lc,t[x]),dn(rc,t[x]),t[x]=0;\n}\nI void rot(R x){\n    R y=f[x],z=f[y],k=c[y][1]==x,w=c[x][!k];\n    if(nrt(y))c[z][c[z][1]==y]=x;\n    f[f[f[c[c[x][!k]=y][k]=w]=y]=x]=z;up(y);\n}\nI void sp(R x){\n    all(x);\n    for(R y;nrt(x);rot(x))\n        if(nrt(y=f[x]))rot((c[f[y]][0]==y)^(c[y][0]==x)?x:y);\n    up(x);\n}\nI void ac(R x){\n    for(R y=0;x;sp(x),rc=y,up(y=x),x=f[x]);\n}\nint main(){\n    n=in();R he,tl=0,i,x,tp,nowrt;\n    for(i=1;i<=n;++i)d[f[in()]=f[in()]=f[in()]=i]=3;\n    for(;i<=3*n+1;++i)v[q[++tl]=i]=in()<<1;\n    for(he=1;he<=tl;++he){\n        x=q[he];if(x<=n)up(x);\n        v[f[x]]+=v[x]>>1;\n        if(!--d[f[x]])q[++tl]=f[x];\n    }\n    nowrt=v[1]>>1;\n    for(R q=in();q;--q){\n        tp=(v[x=in()]^=2)-1;\n        ac(x=f[x]);sp(x);\n        if((~tp?n1:n2)[x]){\n            sp(x=(~tp?n1:n2)[x]);\n            dn(rc,tp),up(rc);\n            v[x]+=tp;up(x);\n        }\n        else dn(x,tp),up(x),nowrt^=1;\n        putchar(nowrt|'0');putchar('\\n');\n    }\n}\n```\n","link":null,"tags":["lct"],"title":"LG 4332 [SHOI2014]三叉神经树"},{"categories":[["刷题记录"]],"content":"\n一个区间合法,仅当这个区间中包含的颜色没在区间外出现过\n\n我们可以把每种颜色出现的每个位置都赋值使得这些位置上的值加起来为$0$\n\n这样我们就可以用前缀和的方式统计了\n\n\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i=x;i<=y;++i)\n    #define Fdr(i,x,y) for(int i=x;i>=y;--i)\n    #define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){clr(ch,0);if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 300011\nint n,s[N];\nvector<int>b[N];\nmap<ll,int>mp;\nconst ll mod = 1000000000000;\nvoid work(){\n    in>>n;\n    ll res,x,ans=0;\n    clr(s,0);\n    Fur(i,1,n)in>>x,b[x].push_back(i);\n    Fur(i,1,n)\n    if(!b[i].empty()){\n        res=0;\n        for(int j=0;j<b[i].size()-1;++j){\n            x=rand()*rand()%mod*rand()%mod*rand()%mod*rand()%mod;\n            if(rand()&1)x=-x;\n            s[b[i][j]]=x;res+=x;\n        }\n        s[b[i][b[i].size()-1]]=-res;\n    }\n    mp.clear();mp[0]=1;res=0;\n    Fur(i,1,n){\n        res+=s[i];\n        ans+=mp[res];\n        ++mp[res];\n    }\n    out<<ans<<ln;\n    Fur(i,1,n)b[i].clear();\n}\nint main(){\n    fin(\"in\");\n    int tt;in>>tt;\n    while(tt--)work();\n}\n```\n","link":null,"tags":["hash"],"title":"LG 4065 [JXOI2017]颜色"},{"categories":[["刷题记录"]],"content":"\n分成两部分\n\n1. dp出结尾最小是多少\n\n2. dp出字典序最大的方案\n\n第一步：\n\n设$f_i$表示以$i$结尾最靠近$i$的下标\n\n枚举$j$,判断$j$是否可行\n\n$f_i = max(j)|(num(f[j],j) < num(j+1,i))$\n\n\n\n第二步：\n\n方法类似第一步\n\n记得考虑前导零\n\n\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i=x;i<=y;++i)\n    #define Fdr(i,x,y) for(int i=x;i>=y;--i)\n    #define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 0x3f3f3f3f\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){clr(ch,0);if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 1011\nint n,f[N];\nchar a[N];\nil bool cmp(int l,int r,int L,int R){\n    while(a[l]=='0'&&l<=r)l++;\n    while(a[L]=='0'&&L<=R)L++;\n    if(R-L+1==0||r-l+1==0)return 0;\n    if(R-L+1>r-l+1)return 1;\n    if(R-L+1<r-l+1)return 0;\n    Fur(i,1,r-l+1)\n        if(a[L+i-1]<a[l+i-1])return 0;\n        else if(a[L+i-1]>a[l+i-1])return 1;\n    return 0;\n}\nint g[N];\nint main(){\n    fin(\"in\");\n    in>>(a+1);\n    n=strlen(a+1);\n    Fur(i,1,n){\n        f[i]=1;\n        Fdr(j,i,1)\n            if(cmp(f[j-1],j-1,j,i)){\n                f[i]=j;\n                break;\n            }\n    }\n    \/\/ Fur(i,1,n)out<<f[i]<<\" \"<<i<<ln;\n    g[f[n]]=n;\n    int zero=f[n];\n    while(a[zero-1]=='0')g[--zero]=n;\n    Fdr(i,f[n]-1,1){\n        Fdr(j,f[n]-1,i)\n            if(cmp(i,j,j+1,g[j+1])){\n                g[i]=j;\n                break;\n            }\n    }\n    int p=1,ff=0;\n    while(p<=n){\n        if(ff)out.pt(',');\n        ff=1;\n        Fur(i,p,g[p])out.pt(a[i]);\n        p=g[p]+1;\n    }\n}\n```\n","link":null,"tags":[],"title":"LG 1415 拆分数列"},{"categories":[["刷题记录"]],"content":"\n假设我们已经知道区间$[l,r]$左右节点的答案\n\n记录：\n\n```plain\nlv,rv:左右端点的值\ns: 区间答案\nl:以左端开始最长下降\nr:以右端结束的最长上升\nL:以左端开始最长先上升(再下降)\nR:以右端结束最长先上升(再下降)\n```\n然后考虑最高点再左节点还是有节点\n\n\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i=x;i<=y;++i)\n    #define Fdr(i,x,y) for(int i=x;i>=y;--i)\n    #define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 0x3f3f3f3f\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){clr(ch,0);if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 300011\n#define int ll\nint n,a[N];\nstruct node{\n    int l,r,lv,rv,s,L,R,len;\n    \/\/ lv,rv:左右端点的值\n    \/\/ s: 区间答案\n    \/\/ l:以左端开始最长下降\n    \/\/ r:以右端结束的最长上升\n    \/\/ L:以左端开始最长先上升(再下降)\n    \/\/ R:以右端结束最长先上升(再下降)\n}s[N<<2];\nint add[N<<2];\nnode operator + (node x,node y){\n    node c;\n    c.len=x.len+y.len;\n\n    c.lv=x.lv;c.rv=y.rv;\n\n    c.l=x.l;\n    if(x.l==x.len&&x.rv>y.lv)c.l+=y.l;\n\n    c.r=y.r;\n    if(y.r==y.len&&y.lv>x.rv)c.r+=x.r;\n\n    c.L=x.L;c.R=y.R;\n    if(x.L==x.len&&x.rv>y.lv)c.L+=y.l;\n    if(x.r==x.len&&x.rv<y.lv)c.L=MAX(c.L,x.r+y.L);\n\n    if(y.R==y.len&&y.lv>x.rv)c.R+=x.r;\n    if(y.l==y.len&&y.lv<x.rv)c.R=MAX(c.R,x.R+y.l);\n\n    c.s=MAX(x.s,y.s);\n\n    if(x.rv>y.lv)c.s=MAX(c.s,x.R+y.l);\n    if(y.lv>x.rv)c.s=MAX(c.s,y.L+x.r);\n        \n    return c;\n}\n#define ls rt<<1\n#define rs rt<<1|1\nvoid build(int l,int r,int rt){\n    if(l==r){\n        s[rt].lv=s[rt].rv=a[l];\n        s[rt].len=s[rt].l=s[rt].r=s[rt].s=s[rt].L=s[rt].R=1;\n        return;\n    }\n    int m=(l+r)>>1;\n    build(l,m,ls);build(m+1,r,rs);\n    s[rt]=s[ls]+s[rs];\n}\nvoid pd(int rt){\n    if(add[rt]){\n        add[ls]+=add[rt];add[rs]+=add[rt];\n        s[ls].lv+=add[rt];\n        s[ls].rv+=add[rt];\n        s[rs].lv+=add[rt];\n        s[rs].rv+=add[rt];\n        add[rt]=0;\n    }\n}\nvoid upd(int L,int R,int v,int l,int r,int rt){\n    if(L<=l&&r<=R){\n        s[rt].lv+=v;s[rt].rv+=v;\n        add[rt]+=v;\n        return;\n    }\n    int m=(l+r)>>1;\n    pd(rt);\n    if(L<=m)upd(L,R,v,l,m,ls);\n    if(R>m)upd(L,R,v,m+1,r,rs);\n    s[rt]=s[ls]+s[rs];\n}\nsigned main(){\n    fin(\"in\");\n    in>>n;\n    Fur(i,1,n)in>>a[i];\n    build(1,n,1);\n    int q,l,r,v;\n    in>>q;\n    while(q--){\n        in>>l>>r>>v;\n        upd(l,r,v,1,n,1);\n        out<<s[1].s<<ln;\n    }\n}\n```\n","link":null,"tags":["线段树"],"title":"LG CF739C Alyona and towers"},{"categories":[["刷题记录"]],"content":"\n先按左端点排序,每次添加右端点的时候如果堆中个数等于$k$就统计答案,然后弹出最小的右端点\n\n\n\n\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i=x;i<=y;i++)\n    #define Fdr(i,x,y) for(int i=x;i>=y;i--)\n    #define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) (int(log2(n)))\n    #define inf 0x3f3f3f3f\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){clr(ch,0);if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 100011\nint n,k,m;\nll s[N];\nstruct node{\n\tint l,r;\n\tbool operator<(const node& x){\n\t\treturn l<x.l||(l==x.l&&r<x.r);\n\t}\n}a[N];\npriority_queue<int,vector<int>,greater<int> >q;\nint main(){\n\tfin(\"in\");\n\tin>>n>>k>>m;\n\tFur(i,1,n)in>>s[i],s[i]+=s[i-1];\n\tFur(i,1,m)in>>a[i].l>>a[i].r;\n\tsort(a+1,a+m+1);\n\tll ans=0;\n\tFur(i,1,n){\n\t\tq.push(a[i].r);\n\t\tif(q.size()==k){\n\t\t\tans=MAX(ans,s[q.top()]-s[a[i].l-1]);\n\t\t\tq.pop();\n\t\t}\n\t}\n\tout<<ans<<ln;\n} \n\n```\n","link":null,"tags":["贪心","堆"],"title":"51nod 1672 区间交"},{"categories":[["刷题记录"]],"content":"\n设$f(i,k)$表示将前$i$个分$k$次的分数\n\n我们可以dp$k$次就可以了\n\n设$f_i$为前$i$个,$g_i$为上一次dp的结果\n\n$$\nf_i=\\max_{j=1}^{i-1}(g_j+s_j\\times(s_i-s_j))\n$$\n\n取任意$0\\le k<j <i$且从$j$转移比从$k$更优,那么\n\n$$g_j+s_j\\times(s_i-s_j)\\ge g_k+s_k\\times(s_i-s_k)$$\n展开得\n\n$$g_j+s_is_j-{s_j}^2\\ge g_k+s_is_k-{s_k}^2$$\n移项得\n$$s_i(s_j-s_k) \\ge {s_j}^2-{s_k}^2+g_k-g_j$$\n整理得\n$$s_i\\ge \\frac{({s_j}^2-g_j)-({s_k}^2-g_k)}{s_j-s_k}\n$$\n\n注意$s_j-s_k$有可能为$0$,要特判\n\n因为要求的是最大值,所以我们维护一个上凸壳就可以了\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\n#define N 100011\nint n,k,q[N],pre[N][201];\nll s[N],f[N],g[N];\ndb S(int i,int j){\n    if(s[i]==s[j])return -1e18;\n    return (db)(s[i]*s[i]-g[i]-s[j]*s[j]+g[j])\/(db)(s[i]-s[j]);\n}\nvoid op(int n,int t){\n    if(pre[n][t])op(pre[n][t],t-1);\n    out(n,\" \");\n}\nint main(){\n    in(n,k);\n    Fur(i,1,n)in(s[i]),s[i]+=s[i-1];\n    Fur(tt,1,k){\n        int h=1,t=1;\n        q[1]=0;\n        Fur(i,1,n){\n            while(h<t&&S(q[h],q[h+1])<=s[i])++h;\n            f[i]=g[q[h]]+s[q[h]]*(s[i]-s[q[h]]);\n            pre[i][tt]=q[h];\n            while(h<t&&S(q[t-1],q[t])>=S(q[t-1],i))--t;\n            q[++t]=i;\n        }\n        std::swap(f,g);\n    }\n    out(g[n],ln);\n    op(pre[n][k],k-1);\n    flush();\n}\n```\n","link":null,"tags":["动态规划","斜率优化","前缀和"],"title":"LG 3648 [APIO2014]序列分割"},{"categories":[["刷题记录"]],"content":"\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;rg char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\n#define N 200011\n#define ls rt<<1\n#define rs rt<<1|1\n#define pu s[rt]=s[ls]+s[rs]\nint n,s[N<<2],laz[N<<2];\nvoid pd(int rt,int ln,int rn){\n    if(laz[rt]){\n        laz[ls]=laz[rs]=1;\n        s[ls]=ln,s[rs]=rn;\n        laz[rt]=0;\n    }\n}\nvoid upd(int L,int R,int l,int r,int rt){\n    if(L<=l&&r<=R){\n        s[rt]=r-l+1;laz[rt]=1;\n        return;\n    }\n    int m=(l+r)>>1;\n    pd(rt,m-l+1,r-m);\n    if(L<=m)upd(L,R,l,m,ls);\n    if(R>m)upd(L,R,m+1,r,rs);\n    pu;\n}\nint main(){\n    int q;\n    in(n,q);\n    while(q--){\n        int l,r;\n        in(l,r);\n        upd(l,r,1,n,1);\n        out(n-s[1],ln);\n    }\n    flush();\n}\n```\n","link":null,"tags":["线段树"],"title":"LG 1840 Color-the-Axis_NOI导刊2011提高（05）"},{"categories":[["刷题记录"]],"content":"\n直接二分天数即可\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n\t#pragma GCC optimize(3)\n\t#define il __inline__ __attribute__ ((always_inline))\n\t#define rg register\n\t#define ll long long\n\t#define ull unsigned long long\n\t#define db double\n\t#define sht short\n\t#define MB template <class T>il\n\t#define Fur(i,x,y) for(int i=x;i<=y;i++)\n\t#define Fdr(i,x,y) for(int i=x;i>=y;i--)\n\t#define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n\t#define clr(x,y) memset(x,y,sizeof(x))\n\t#define cpy(x,y) memcpy(x,y,sizeof(x))\n\t#define fin(s) freopen(s\".in\",\"r\",stdin)\n\t#define fout(s) freopen(s\".out\",\"w\",stdout)\n\t#define fcin ios::sync_with_stdio(false)\n\t#define l2(n) (int(log2(n)))\n\t#define inf 0x3f3f3f3f\n\tMB T ABS(T x){return x>0?x:-x;}\n\tMB T MAX(T x,T y){return x>y?x:y;}\n\tMB T MIN(T x,T y){return x<y?x:y;}\n\tMB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n\tMB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 2000011\n#define int ull\nint n,S,L,h[N],a[N];\nbool chk(int w){\n\tint t=0;\n\tFur(i,1,n)\n\t\tif(h[i]+a[i]*w>=L){\n\t\t\tt+=(h[i]+a[i]*w);\n\t\t\tif(t>=S)return 1;\n\t\t}\n\treturn 0;\n}\nsigned main(){\n\tin>>n>>S>>L;\n\tFur(i,1,n)in>>h[i];\n\tFur(i,1,n)in>>a[i];\n\tint l=0,r=1000000000000000000ll,m,ans=0;\n\tif(chk(0))return out<<\"0\\n\",0;\n\twhile(l<=r){\n\t\tm=(l+r)>>1;\n\t\tif(chk(m))ans=m,r=m-1;\n\t\telse l=m+1;\n\t}\n\tout<<ans<<ln;\n}\n```\n","link":null,"tags":["二分"],"title":"LG 4058 [Code+t1]木材"},{"categories":[["刷题记录"]],"content":"\n$f[i][j]$表示翻转$i$次,还有$j$个与目标状态不同位置的方案数\n\n每次翻转可以使与目标状态不同位置数量改变\n\n\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i=x;i<=y;i++)\n    #define Fdr(i,x,y) for(int i=x;i>=y;i--)\n    #define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 0x3f3f3f3f\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){clr(ch,0);if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 111\n#define mod 1000000007\nint n,m,k;\nll f[N][N],C[N][N];\nchar a[N],b[N];\nint main(){\n    in>>n>>k>>m>>(a+1)>>(b+1);\n    int tot=0;\n    Fur(i,1,n)tot+=(a[i]!=b[i]);\n    Fur(i,0,MAX(n,m))C[i][0]=C[i][i]=1;\n    Fur(i,1,n)\n        Fur(j,1,m)\n        C[i][j]=(C[i-1][j]+C[i-1][j-1])%mod;\n    \n    f[0][tot]=1;\n    Fur(i,1,k)\n        Fur(j,0,n)\n            Fur(t,0,MIN(j,m))\n            if(j-t*2+m>=0&&j-t*2+m<=n)\n                f[i][j-t*2+m]=(f[i][j-t*2+m]+(f[i-1][j]*C[n-j][m-t]%mod*C[j][t]%mod))%mod;\n\n    out<<f[k][0]<<ln;\n}\n\n```\n","link":null,"tags":["动态规划"],"title":"LG 2182 翻硬币"},{"categories":[["刷题记录"]],"content":"\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i=x;i<=y;++i)\n    #define Fdr(i,x,y) for(int i=x;i>=y;--i)\n    #define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 0x3f3f3f3f\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){clr(ch,0);if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 100011\nint n,m,b;\nint c[N],K[N],M[N];\nint main(){\n    in>>n>>m>>b;\n    Fur(i,1,n){\n        in>>c[i]>>K[i]>>M[i];\n    }\n\n}\n```\n","link":null,"tags":[],"title":"LG CF417D Cunning Gena"},{"categories":[["刷题记录"]],"content":"\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n\t#pragma GCC optimize(3)\n\t#define il __inline__ __attribute__ ((always_inline))\n\t#define rg register\n\t#define ll long long\n\t#define ull unsigned long long\n\t#define db double\n\t#define sht short\n\t#define MB template <class T>il\n\t#define Fur(i,x,y) for(int i=x;i<=y;i++)\n\t#define Fdr(i,x,y) for(int i=x;i>=y;i--)\n\t#define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n\t#define clr(x,y) memset(x,y,sizeof(x))\n\t#define cpy(x,y) memcpy(x,y,sizeof(x))\n\t#define fin(s) freopen(s\".in\",\"r\",stdin)\n\t#define fout(s) freopen(s\".out\",\"w\",stdout)\n\t#define fcin ios::sync_with_stdio(false)\n\t#define l2(n) (int(log2(n)))\n\t#define inf 0x3f3f3f3f\n\tMB T ABS(T x){return x>0?x:-x;}\n\tMB T MAX(T x,T y){return x>y?x:y;}\n\tMB T MIN(T x,T y){return x<y?x:y;}\n\tMB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n\tMB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){clr(ch,0);if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 10011\nint main(){\n\t\n}\n```\n","link":null,"tags":[],"title":"51nod 1788 波浪数"},{"categories":[["刷题记录"]],"content":"\n先两次dfs找树的直径\n\nemmmm, $n \\le 300$ !!!\n\n随便写好了\n\n原来bzoj还有一道加强版,~~双倍经验多好~~\n\n一定要在直径上取,而且距离不可以大于$s$,那么单调队列的思想不是可以吗？\n\n因为离直径中点越近“贡献越大”\n\n意会一下QwQ\n\n这样下来代码量也很短 =￣ω￣=\n\n而且可以ac bzoj的加强版\n\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n\t#pragma GCC optimize(3)\n\t#define il __inline__ __attribute__ ((always_inline))\n\t#define rg register\n\t#define ll long long\n\t#define ull unsigned long long\n\t#define db double\n\t#define sht short\n\t#define MB template <class T>il\n\t#define Fur(i,x,y) for(int i=x;i<=y;i++)\n\t#define Fdr(i,x,y) for(int i=x;i>=y;i--)\n\t#define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n\t#define clr(x,y) memset(x,y,sizeof(x))\n\t#define cpy(x,y) memcpy(x,y,sizeof(x))\n\t#define fin(s) freopen(s\".in\",\"r\",stdin)\n\t#define fout(s) freopen(s\".out\",\"w\",stdout)\n\t#define fcin ios::sync_with_stdio(false)\n\t#define l2(n) (int(log2(n)))\n\t#define inf 0x3f3f3f3f\n\tMB T ABS(T x){return x>0?x:-x;}\n\tMB T MAX(T x,T y){return x>y?x:y;}\n\tMB T MIN(T x,T y){return x<y?x:y;}\n\tMB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n\tMB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 500011\nint n,s,cnt=0,head[N],d[N],f[N],tmp=0,top,ans=inf;\nbool b[N];\nstruct edge{\n\tint to,nxt,w;\n}e[N*2];\nvoid add(int x,int y,int w){\n\te[++cnt].to=y;e[cnt].w=w;e[cnt].nxt=head[x];head[x]=cnt;\n}\nvoid dfs(int x){\n\tif(d[x]>d[tmp])tmp=x;\n\tfl(i,x)\n\tif(to!=f[x]&&!b[to])d[to]=d[x]+e[i].w,f[to]=x,dfs(to);\n}\nint main(){\n\tin>>n>>s;\n\tint x,y,w;\n\tFur(i,1,n-1)\n\t\tin>>x>>y>>w,\n\t\tadd(x,y,w),add(y,x,w);\n\t\n\td[1]=1;dfs(1);\n\td[tmp]=0;f[tmp]=0;\n\tdfs(tmp);\n\ttop=tmp;\n\tint h=0,t=1;\n\tfor(int i=top,j=top;i;i=f[i]){\n\t\twhile(d[j]-d[i]>s)j=f[j];\n\t\tans=MIN(ans,MAX(d[top]-d[j],d[i]));\n\t}\n\tfor(int i=top;i;i=f[i])b[i]=1;\n\tfor(int i=top;i;i=f[i]){\n\t\tx=i;d[i]=0;\n\t\tdfs(i);\n\t}\n\tFur(i,1,n)ans=MAX(ans,d[i]);\n\tout<<ans<<ln;\n}\n```\n","link":null,"tags":["dfs"],"title":"LG 1099 树网的核"},{"categories":[["刷题记录"]],"content":"\nABCDEF\ntop: 0\n\n\n$\\frac{a \\times b + c}d -e = f$\n\n$a \\times b + c = de+df$\n\n\n我们可以先搜索$a+b+c$可能的结果和$de+df$可能的结果,然后合并即可\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i=x;i<=y;i++)\n    #define Fdr(i,x,y) for(int i=x;i>=y;i--)\n    #define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 0x3f3f3f3f\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){clr(ch,0);if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 10000011\nint n,v[N],a[N],b[N],ta=0,tb=0;\nint main(){\n    in>>n;\n    Fur(i,1,n)in>>v[i];\n    Fur(i,1,n)\n        Fur(j,1,n)\n            Fur(k,1,n)\n            a[++ta]=v[i]*v[j]+v[k];\n    \n    Fur(i,1,n)\n    if(v[i])\n        Fur(j,1,n)\n            Fur(k,1,n)\n            b[++tb]=v[i]*(v[j]+v[k]);\n    \n    sort(a+1,a+ta+1);\n    sort(b+1,b+tb+1);\n    int ans=0,r=1;\n    Fur(i,1,ta){\n        int p=1,q=0;\n        while(a[i]==a[i+1])++i,++p;\n        while(b[r]<a[i])++r;\n        if(b[r]==a[i]){\n            q=1;\n            while(b[r]==b[r+1])++q,++r;\n            ans+=p*q;\n        }\n    }\n    out<<ans<<ln;\n}\n```\n","link":null,"tags":["折半搜索"],"title":"LG SP4580 ABCDEF"},{"categories":[["刷题记录"]],"content":"\n二分最大差值\n\n然后bfs判断\n\n~~我怎么又刷水了QwQ~~\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n\t#pragma GCC optimize(3)\n\t#define il __inline__ __attribute__ ((always_inline))\n\t#define rg register\n\t#define ll long long\n\t#define ull unsigned long long\n\t#define db double\n\t#define sht short\n\t#define MB template <class T>il\n\t#define Fur(i,x,y) for(int i=x;i<=y;i++)\n\t#define Fdr(i,x,y) for(int i=x;i>=y;i--)\n\t#define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n\t#define clr(x,y) memset(x,y,sizeof(x))\n\t#define cpy(x,y) memcpy(x,y,sizeof(x))\n\t#define fin(s) freopen(s\".in\",\"r\",stdin)\n\t#define fout(s) freopen(s\".out\",\"w\",stdout)\n\t#define fcin ios::sync_with_stdio(false)\n\t#define l2(n) (int(log2(n)))\n\t#define inf 0x3f3f3f3f\n\tMB T ABS(T x){return x>0?x:-x;}\n\tMB T MAX(T x,T y){return x>y?x:y;}\n\tMB T MIN(T x,T y){return x<y?x:y;}\n\tMB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n\tMB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 511\nint n,m,a[N][N],tot=0,sx,sy,p[N*N],q[N*N],dx[4]={0,1,0,-1},dy[4]={1,0,-1,0},b[N][N],v[N][N];\nbool chk(int w){\n\tclr(v,0);\n\tint h=0,t=1,ans=0;\n\tp[0]=sx;q[0]=sy;\n\twhile(h<t){\n\t\tint x=p[h],y=q[h++],nx,ny;\n\t\tans+=b[x][y];v[x][y]=1;\n\t\tFur(i,0,3){\n\t\t\tnx=x+dx[i];ny=y+dy[i];\n\t\t\tif(ABS(a[x][y]-a[nx][ny])>w||nx>n||nx<1||ny>m||ny<1||v[nx][ny])continue;\n\t\t\tp[t]=nx;q[t++]=ny;v[nx][ny]=1;\n\t\t}\n\t}\n\treturn ans==tot;\n}\nint main(){\n\tin>>n>>m;\n\tFur(i,1,n)\n\t\tFur(j,1,m)\n\t\tin>>a[i][j];\n\t\t\n\tFur(i,1,n)\n\t\tFur(j,1,m){\n\t\t\tin>>b[i][j];\n\t\t\tif(b[i][j])sx=i,sy=j,tot++;\n\t\t}\n\tint l=0,r=1000000000,ans=0;\n\twhile(l<=r){\n\t\tint mid=(l+r)>>1;\n\t\tif(chk(mid))ans=mid,r=mid-1;\n\t\telse l=mid+1;\n\t}\n\tout<<ans<<ln;\n}\n```\n","link":null,"tags":["bfs","二分"],"title":"LG 2658 汽车拉力比赛"},{"categories":[["刷题记录"]],"content":"\n前置定理：\n\n$$\nd(ij) = \\sum_{x|i} \\sum_{y|j}[gcd(x,y) = 1]\n$$\n\n所以：\n\n设$n<m$\n\n$$\n\\sum_{i=1}^n \\sum_{j=1}^m d(ij)\n\\\\\n=\\sum_{i=1}^n \\sum_{j=1}^m \\sum_{x|i} \\sum_{y|j}[gcd(x,y) = 1]\n\\\\\n=\\sum\\limits_{x=1}^n\\sum\\limits_{y=1}^m \\left\\lfloor\\frac{n}{x}\\right\\rfloor \\left\\lfloor\\frac{m}{y}\\right\\rfloor [\\gcd(x,y)=1]\n$$\n\n$x、y$换成$i、j$\n\n$$\n\\sum\\limits_{i=1}^n\\sum\\limits_{j=1}^m \\left\\lfloor\\frac{n}{i}\\right\\rfloor \\left\\lfloor\\frac{m}{j}\\right\\rfloor[\\gcd(i,j)=1]\n\\\\\n=\\sum\\limits_{i=1}^n\\sum\\limits_{j=1}^m \\left\\lfloor\\frac{n}{i}\\right\\rfloor \\left\\lfloor\\frac{m}{j}\\right\\rfloor \\sum_{k|gcd(i,j)}\\mu(k)\n$$\n\n设$g(i)=\\sum_{i=1}^n \\left \\lfloor \\frac ni \\right \\rfloor$\n\n$$\nans=\\sum_{k=1}^n\\mu(k) g(\\left \\lfloor \\frac nk \\right \\rfloor) g(\\left \\lfloor \\frac mk \\right \\rfloor)\n\\\\\n$$\n\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n\t#pragma GCC optimize(3)\n\t#define il __inline__ __attribute__ ((always_inline))\n\t#define rg register\n\t#define ll long long\n\t#define ull unsigned long long\n\t#define db double\n\t#define sht short\n\t#define MB template <class T>il\n\t#define Fur(i,x,y) for(int i=x;i<=y;i++)\n\t#define Fdr(i,x,y) for(int i=x;i>=y;i--)\n\t#define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n\t#define clr(x,y) memset(x,y,sizeof(x))\n\t#define cpy(x,y) memcpy(x,y,sizeof(x))\n\t#define fin(s) freopen(s\".in\",\"r\",stdin)\n\t#define fout(s) freopen(s\".out\",\"w\",stdout)\n\t#define fcin ios::sync_with_stdio(false)\n\t#define l2(n) (int(log2(n)))\n\t#define inf 0x3f3f3f3f\n\tMB T ABS(T x){return x>0?x:-x;}\n\tMB T MAX(T x,T y){return x>y?x:y;}\n\tMB T MIN(T x,T y){return x<y?x:y;}\n\tMB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n\tMB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 50000\nint pri[N+11],mu[N+11],tot=0;\nll g[N+11];\nbool f[N+11];\nvoid sm(int n){\n\tmu[1]=f[1]=1;\n\tFur(i,2,n){\n\t\tif(!f[i])pri[++tot]=i,mu[i]=-1;\n\t\tFur(j,1,tot){\n\t\t\tif(pri[j]*i>n)break;\n\t\t\tf[i*pri[j]]=1;\n\t\t\tif(i%pri[j])mu[i*pri[j]]=-mu[i];\n\t\t\telse break;\n\t\t}\n\t}\n\tFur(i,2,n)mu[i]+=mu[i-1];\n\tFur(i,1,n)\n\t\tfor(int l=1,r=0;l<=i;l=r+1){\n\t\t\tr=i\/(i\/l);\n\t\t\tg[i]+=(r-l+1)*(i\/l);\n\t\t}\n}  \nint main(){\n\tsm(N);\n\tint T,n,m;\n\tin>>T;\n\twhile(T--){\n\t\tin>>n>>m;\n\t\tif(n>m)SWAP(n,m);\n\t\tll ans=0;\n\t\tfor(int l=1,r=0;l<=n;l=r+1){\n\t\t\tr=MIN(n\/(n\/l),m\/(m\/l));\n\t\t\tans+=1ll*(mu[r]-mu[l-1])*g[n\/l]*g[m\/l];\n\t\t}\n\t\tout<<ans<<ln;\n\t}\n}\n```\n","link":null,"tags":["数论","莫比乌斯"],"title":"LG 3327 [SDOI2015]约数个数和"},{"categories":[["刷题记录"]],"content":"\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n\t#pragma GCC optimize(3)\n\t#define il __inline__ __attribute__ ((always_inline))\n\t#define rg register\n\t#define ll long long\n\t#define ull unsigned long long\n\t#define db double\n\t#define sht short\n\t#define MB template <class T>il\n\t#define Fur(i,x,y) for(int i=x;i<=y;i++)\n\t#define Fdr(i,x,y) for(int i=x;i>=y;i--)\n\t#define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n\t#define clr(x,y) memset(x,y,sizeof(x))\n\t#define cpy(x,y) memcpy(x,y,sizeof(x))\n\t#define fin(s) freopen(s\".in\",\"r\",stdin)\n\t#define fout(s) freopen(s\".out\",\"w\",stdout)\n\t#define fcin ios::sync_with_stdio(false)\n\t#define l2(n) (int(log2(n)))\n\t#define inf 0x3f3f3f3f\n\tMB T ABS(T x){return x>0?x:-x;}\n\tMB T MAX(T x,T y){return x>y?x:y;}\n\tMB T MIN(T x,T y){return x<y?x:y;}\n\tMB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n\tMB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 61\nint n,m,T,f[N][N][2600],g[N][2600],s[N];\nchar a[N][N];\nint main(){\n\tin>>n>>m>>T;\n\tFur(i,1,n)in>>(a[i]+1);\n\tFur(i,1,n){\n\t\tFur(j,1,m)s[j]=s[j-1]+a[i][j]-48;\n\t\tFur(j,1,m)\n\t\t\tFur(k,1,m)\n\t\t\t\tFur(q,j-1,k-1)\n\t\t\t\tf[i][j][k]=MAX(f[i][j][k],f[i][j-1][q]+MAX(s[k]-s[q],k-q-s[k]+s[q]));\n\t}\n\tFur(i,1,n)\n\t\tFur(j,1,T)\n\t\t\tFur(k,0,MIN(j,m))\n\t\t\tg[i][j]=MAX(g[i][j],g[i-1][j-k]+f[i][k][m]);\n\tint ans=0;\n\tFur(i,1,T)ans=MAX(ans,g[n][i]);\n\tout<<ans<<ln;\n}\n```\n","link":null,"tags":[],"title":"LG 4158 [SCOI2009]粉刷匠"},{"categories":[["刷题记录"]],"content":"\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i=x;i<=y;++i)\n    #define Fdr(i,x,y) for(int i=x;i>=y;--i)\n    #define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) (int(log2(n)))\n    #define inf 0x3f3f3f3f\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){clr(ch,0);if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 2011\nint n,a[N][N],b[N][N],f[N][N],F[N][N],p[N][N],q[N][N];\nchar ans[N*N];\nint main(){\n    fin(\"in\");\n    in>>n;\n    int x,y,X=0,Y=0;\n    Fur(i,1,n)Fur(j,1,n){\n        int x;in>>x;\n        if(x==0)X=i,Y=j;\n        else{\n            while(x%2==0)a[i][j]++,x>>=1;\n            while(x%5==0)b[i][j]++,x\/=5;\n        }\n    }\n    if(X){\n        out<<\"0\\n\";\n        Fur(i,1,X-1)out<<\"D\";\n        Fur(i,1,Y-1)out<<\"R\";\n        Fur(i,X+1,n)out<<\"D\";\n        Fur(i,Y+1,n)out<<\"R\";\n        return 0;\n    }\n    f[1][1]=a[1][1];\n    F[1][1]=b[1][1];\n    Fur(i,2,n){\n        f[1][i]=f[1][i-1]+a[1][i];\n        F[1][i]=F[1][i-1]+b[1][i];\n        f[i][1]=f[i-1][1]+a[i][1];p[i][1]=1;\n        F[i][1]=F[i-1][1]+b[i][1];q[i][1]=1;\n    }\n    Fur(i,2,n)\n        Fur(j,2,n){\n            if(f[i-1][j]<f[i][j-1])f[i][j]=f[i-1][j]+a[i][j];\n            else p[i][j]=1,f[i][j]=f[i][j-1]+a[i][j];\n            if(F[i-1][j]<F[i][j-1])F[i][j]=F[i-1][j]+b[i][j];\n            else q[i][j]=1,F[i][j]=F[i][j-1]+b[i][j];\n        }\n    int d=0;\n    if(f[n][n]<F[n][n]){\n        out<<f[n][n]<<ln;\n        x=n,y=n;\n        while(x!=1||y!=1){\n            if(p[x][y])ans[d++]='D',x--;\n            else ans[d++]='R',y--;\n        }\n    }\n    else{\n        out<<F[n][n]<<ln;\n        x=n,y=n;\n        while(x!=1||y!=1){\n            if(q[x][y])ans[d++]='D',x--;\n            else ans[d++]='R',y--;\n        }\n    }\n    reverse(ans,ans+d);\n    out<<ans<<ln;\n}\n```\n","link":null,"tags":[],"title":"LG CF5E Bindian Signalizing"},{"categories":[["刷题记录"]],"content":"\n### 线段树解法：\n\n我们记录$d_x$表示$x$的深度还有$dfs$序\n\n每个点修改的时候把它的子树都加上$val$\n\n因为记录了深度,所以$d_{x'}$如果和$d_x$同奇偶则加上$val$,否则减去$val$\n\n\n\n### 树状数组解法：\n\n\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i=x;i<=y;++i)\n    #define Fdr(i,x,y) for(int i=x;i>=y;--i)\n    #define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 0x3f3f3f3f\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){clr(ch,0);if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 100011\nint n,q,a[N],head[N],cnt=0;\nstruct edge{\n    int to,nxt;\n}e[N];\nvoid add(int x,int y){\n    e[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;\n}\nint L[N],R[N],dfn=0,d[N];\nvoid dfs(int x,int f){\n    L[x]=++dfn;\n    fl(i,x)if(to!=f){\n        d[to]=d[x]^1;\n        dfs(to,x);\n    }\n    R[x]=dfn;\n}\n#define lb(x) (x&-x)\nint s[N];\nil void upd(int x,int v){\n    while(x<=n)s[x]+=v,x+=lb(x);\n}\nil  int ask(int x){\n    int ans=0;\n    while(x)ans+=s[x],x^=lb(x);\n    return ans;\n}\n\nint main(){\n    in>>n;\n    Fur(i,1,n)in>>a[i];\n    int x,y;\n    Fur(i,1,n-1)in>>x>>y,add(x,y),add(y,x);\n    dfs(1,0);\n    in>>q;\n    int u,v,c;\n    while(q--){\n        in>>c>>u;\n        if(c==1){\n            in>>v;\n            upd(L[u],d[u]?v:-v),upd(R[u]+1,d[u]?-v:v);\n        }\n        else{\n            int t=ask(L[u],v)\n        }\n    }\n}\n```\n","link":null,"tags":["dfs序","树状数组","线段树"],"title":"LG CF383C Propagating tree"},{"categories":[["刷题记录"]],"content":"\n一个矩形要想被保护的话,必须满足所有行 \/ 所有列上均有一个车的限制。这样我们解决问题就可以转化为判断一个矩形所有行上是否都有一个车了（对于列只需要把图转一下做就可以）。这样我们自然想到线段树 + 扫描线,我是用列上的扫描线从上到下,每一次扫到一个矩形的下边界就判断一下。线段树上维护每一列上距离最远的一个车的纵坐标,我们判断一个矩形是否被保护就只需要判断最远的车是否在当前矩形的范围内了。感觉OFN说的扫描线就是把问题转化到一个前缀的维护上面去其实是挺有道理的恩~\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i=x;i<=y;i++)\n    #define Fdr(i,x,y) for(int i=x;i>=y;i--)\n    #define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) (int(log2(n)))\n    #define inf 0x3f3f3f3f\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){clr(ch,0);if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 600011\n#define ls rt<<1\n#define rs rt<<1|1\nstruct node{\n    int x,y;\n    friend bool operator<(const node&a,const node&b){\n        return a.y>b.y;\n    }\n}p[N];\nstruct sqr{\n    int x,y,x_,y_,id;\n    friend bool operator <(const sqr&a,const sqr&b){\n        return a.y>b.y;\n    }\n}a[N];\nint s[N<<2],n,m,k,q;\nbool ans[N];\nvoid upd(int x,int y,int l,int r,int rt){\n    if(l==r){\n        s[rt]=y;\n        return;\n    }\n    int m=(l+r)>>1;\n    if(x<=m)upd(x,y,l,m,ls);\n    else upd(x,y,m+1,r,rs);\n    s[rt]=MAX(s[ls],s[rs]);\n}\nint ask(int L,int R,int l,int r,int rt){\n    if(L<=l&&r<=R)return s[rt];\n    int m=(l+r)>>1,ans=0;\n    if(L<=m)ans=ask(L,R,l,m,ls);\n    if(R>m)ans=MAX(ans,ask(L,R,m+1,r,rs));\n    return ans;\n}\nvoid work(){\n    sort(p+1,p+k+1);\n    sort(a+1,a+q+1);\n    clr(s,126);\n    int now=1;\n    Fur(i,1,q){\n        while(now<=k&&p[now].y>=a[i].y)\n            upd(p[now].x,p[now].y,1,n,1),now++;\n        int t=ask(a[i].x,a[i].x_,1,n,1);\n        if(t<=a[i].y_&&t)ans[a[i].id]=1;\n    }\n}\nint main(){\n    in>>n>>m>>k>>q;\n    Fur(i,1,k)in>>p[i].x>>p[i].y;\n    Fur(i,1,q)in>>a[i].x>>a[i].y>>a[i].x_>>a[i].y_,a[i].id=i;\n    work();\n    Fur(i,1,k)SWAP(p[i].x,p[i].y);\n    Fur(i,1,q)SWAP(a[i].x,a[i].y),SWAP(a[i].x_,a[i].y_);\n    SWAP(n,m);\n    work();\n    Fur(i,1,q)out<<(ans[i]?\"YES\":\"NO\")<<ln;\n}\n\n```\n","link":null,"tags":["线段树","排序","扫描线"],"title":"51nod 1559 车和矩形"},{"categories":[["刷题记录"]],"content":"\n可以用并查集把环套树上额外的一条边找出来\n\n然后就是树剖了\n\n用树状数组维护前缀和\n\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;rg char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\n#define N 100011\nstruct edge{\n    int to,nxt,w,id;\n}e[N*2];\nstruct link{\n    int x,y,w,p;\n    il bool operator<(link b){\n        return w<b.w;\n    }\n}E[N];\nint head[N],cnt=0,n,q,ext;\nil void add(int x,int y,int w,int id){\n    e[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;\n    e[cnt].w=w;e[cnt].id=id;\n}\nstruct BIT{\n    int s[N];\n    il void upd(int x,int v){while(x<=n)s[x]+=v,x+=(x&-x);}\n    il int g(int x){\n        int ans=0;\n        while(x)ans+=s[x],x-=(x&-x);\n        return ans;\n    }\n    il int ask(int l,int r){\n        return g(r)-g(l-1);\n    }\n}T;\nint f[N],top[N],id[N],d[N],siz[N],sz=0,val[N];\nvoid dfs(int x){\n    siz[x]=1;\n    fl(i,x)if(to!=f[x]){\n        f[to]=x;\n        d[to]=d[x]+1;\n        val[to]=e[i].id;\n        dfs(to);\n        siz[x]+=siz[to];\n    }\n}\nvoid bt(int x,int tp){\n    top[x]=tp;id[x]=++sz;\n    T.upd(id[x],E[val[x]].w);\n    E[val[x]].p=id[x];\n    int k=0;\n    fl(i,x)if(to!=f[x]&&siz[to]>siz[k])k=to;\n    if(!k)return;bt(k,tp);\n    fl(i,x)if(!top[to])bt(to,to);\n}\nil int ask(int x,int y){\n    int ans=0;\n    while(top[x]!=top[y]){\n        if(d[top[x]]<d[top[y]])SWAP(x,y);\n        ans+=T.ask(id[top[x]],id[x]);x=f[top[x]];\n    }\n    if(id[x]>id[y])SWAP(x,y);\n    return ans+T.ask(id[x]+1,id[y]);\n}\nint fa[N];\nint gf(int x){return (x==fa[x])?x:(fa[x]=gf(fa[x]));}\nint main(){\n    in(n,q);\n    int x,y,w,opt;\n    Fur(i,1,n)in(x,y,w),E[i]={x,y,w,0},fa[i]=i;\n    Fur(i,1,n){\n        x=E[i].x,y=E[i].y,w=E[i].w;\n        if(gf(x)!=gf(y)){\n            fa[gf(x)]=gf(y);\n            add(x,y,w,i),add(y,x,w,i);\n        }\n        else ext=i;\n    }\n    dfs(1);bt(1,1);\n    while(q--){\n        in(opt,x,y);\n        if(opt==1){\n            if(x!=ext)T.upd(E[x].p,y-E[x].w);\n            E[x].w=y;\n        }\n        else{\n            int ans=ask(x,y);\n            ans=MIN(ans,ask(x,E[ext].x)+E[ext].w+ask(E[ext].y,y));\n            ans=MIN(ans,ask(x,E[ext].y)+E[ext].w+ask(E[ext].x,y));\n            out(ans,ln);\n        }\n    }\n    flush();\n}\n```\n","link":null,"tags":["树链剖分","树状数组"],"title":"LG 4949 最短距离"},{"categories":[["刷题记录"]],"content":"\n倍增思想\n\n$f[s][i][j]$表示最多走$s$条边,$i,j$之间最大掉边权和时多少\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i=x;i<=y;++i)\n    #define Fdr(i,x,y) for(int i=x;i>=y;--i)\n    #define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) (int(log2(n)))\n    #define inf 0x3f3f3f3f\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){clr(ch,0);if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 305\nint n,m,cnt=0,f[15][N][N],g[N][N],t[N][N];\nint main(){\n    fin(\"in\");\n    memset(f,0xcf,sizeof(f));\n    memset(g,0xcf,sizeof(g));\n    int x,y,w;\n    in>>n>>m;\n    Fur(i,1,m){\n        in>>x>>y;\n        in>>f[0][x][y]>>f[0][y][x];\n    }\n    Fur(i,1,n)f[0][i][i]=0,g[i][i]=0;\n    Fur(s,1,10)\n        Fur(k,1,n)\n            Fur(i,1,n)\n                Fur(j,1,n)\n                    f[s][i][j]=MAX(f[s][i][j],f[s-1][i][k]+f[s-1][k][j]);\n    int ans=0;\n    Fdr(s,10,0){\n        bool ff=0;\n        memset(t,0xcf,sizeof(t));\n        Fur(k,1,n)\n            Fur(i,1,n)\n                Fur(j,1,n)\n                    t[i][j]=MAX(t[i][j],g[i][k]+f[s][k][j]);\n\n        Fur(i,1,n)if(t[i][i]>0){\n            ff=1;\n            break;\n        }\n        if(!ff){\n            Fur(i,1,n)Fur(j,1,n)g[i][j]=t[i][j];\n            ans+=(1<<s);\n        }\n    }\n    if(ans>=n)ans=0;\n    else ans++;\n    out<<ans<<ln;\n}\n\n```\n","link":null,"tags":["倍增"],"title":"LG CF147B Smile House"},{"categories":[["刷题记录"]],"content":"\n$f_{t,i,j} = MAX(f_{t-1,x',y'})+1$\n\n复杂度:$O(Tnm)$,只能过50%\n\n看到$k \\le 200$那么我们是不是可以直接用？\n\n设$f_{k,i,j}$为在区间$k$中在位置$(i,j)$能最多滑行多远\n\n$f_{k,i,j} = MAX(f_{k-1,i,j},f_{k-1,i',j'}+dis_{(i,j),(i',j'))})$\n\n那么复杂度就是$O(kn^3)$,可以用单调队列优化掉其中一个$n$\n\n\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n\t#pragma GCC optimize(3)\n\t#define il __inline__ __attribute__ ((always_inline))\n\t#define rg register\n\t#define ll long long\n\t#define ull unsigned long long\n\t#define db double\n\t#define sht short\n\t#define MB template <class T>il\n\t#define Fur(i,x,y) for(int i=x;i<=y;i++)\n\t#define Fdr(i,x,y) for(int i=x;i>=y;i--)\n\t#define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n\t#define clr(x,y) memset(x,y,sizeof(x))\n\t#define cpy(x,y) memcpy(x,y,sizeof(x))\n\t#define fin(s) freopen(s\".in\",\"r\",stdin)\n\t#define fout(s) freopen(s\".out\",\"w\",stdout)\n\t#define fcin ios::sync_with_stdio(false)\n\t#define l2(n) (int(log2(n)))\n\t#define inf 0x3f3f3f3f\n\tMB T ABS(T x){return x>0?x:-x;}\n\tMB T MAX(T x,T y){return x>y?x:y;}\n\tMB T MIN(T x,T y){return x<y?x:y;}\n\tMB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n\tMB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 211\nint n,m,X,Y,K,u,len,ans=0,f[N][N],q[N],p[N];\nint dx[5]={0,-1,1,0,0},dy[5]={0,0,0,-1,1};\nchar a[N][N];\nvoid work(int x,int y){\n\tint h=1,t=0;\n\tfor(int i=1;x>=1&&x<=n&&y>=1&&y<=m;i++,x+=dx[u],y+=dy[u])\n\tif(a[x][y]=='x')h=1,t=0;\n\telse{\n\t\twhile(h<=t&&q[t]+i-p[t]<f[x][y])t--;\n\t\tp[++t]=i;\n\t\tq[t]=f[x][y];\n\t\tif(p[t]-p[h]>len)h++;\n\t\t\n\t\tf[x][y]=q[h]+i-p[h];\n\t\t\n\t\tans=MAX(ans,f[x][y]);\n\t}\n}\nint main(){\n\tin>>n>>m>>X>>Y>>K;\n\tFur(i,1,n)in>>(a[i]+1);\n\tint s,t;\n\tclr(f,128);\n\tf[X][Y]=0;\n\tFur(k,1,K){\n\t\tin>>s>>t>>u;\n\t\tlen=t-s+1;\n\t\tif(u==1)Fur(i,1,m)work(n,i);\n\t\tif(u==2)Fur(i,1,m)work(1,i);\n\t\tif(u==3)Fur(i,1,n)work(i,m);\n\t\tif(u==4)Fur(i,1,n)work(i,1);\n\t}\n\tout<<ans<<ln;\n}\n```\n","link":null,"tags":["动态规划","单调队列"],"title":"LG 2254 [NOI2005]瑰丽华尔兹"},{"categories":[["刷题记录"]],"content":"\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n\t#pragma GCC optimize(3)\n\t#define il __inline__ __attribute__ ((always_inline))\n\t#define rg register\n\t#define ll long long\n\t#define ull unsigned long long\n\t#define db double\n\t#define sht short\n\t#define MB template <class T>il\n\t#define Fur(i,x,y) for(int i=x;i<=y;i++)\n\t#define Fdr(i,x,y) for(int i=x;i>=y;i--)\n\t#define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n\t#define clr(x,y) memset(x,y,sizeof(x))\n\t#define cpy(x,y) memcpy(x,y,sizeof(x))\n\t#define fin(s) freopen(s\".in\",\"r\",stdin)\n\t#define fout(s) freopen(s\".out\",\"w\",stdout)\n\t#define fcin ios::sync_with_stdio(false)\n\t#define l2(n) (int(log2(n)))\n\t#define inf 0x3f3f3f3f\n\tMB T ABS(T x){return x>0?x:-x;}\n\tMB T MAX(T x,T y){return x>y?x:y;}\n\tMB T MIN(T x,T y){return x<y?x:y;}\n\tMB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n\tMB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 100111\nstruct edge{\n\tint to,nxt,w;\n}e[N*2];\nint n,m,head[N],r[N],c[N],cnt=0;\ndb s[N];\nvoid add(int x,int y,int w){\n\te[++cnt].to=y;e[cnt].nxt=head[x];e[cnt].w=w;head[x]=cnt;\n}\nint q[N];\nint main(){\n\tin>>n>>m;\n\tint x,y,w,top=0;\n\tFur(i,1,m)in>>x>>y>>w,add(y,x,w),r[x]++,c[x]++;\n\tq[++top]=n;\n\twhile(top){\n\t\tx=q[top--];\n\t\tfl(i,x){\n\t\t\ts[to]+=s[x]+e[i].w;\n\t\t\tif(--r[to]==0)s[to]\/=(db)c[to],q[++top]=to;\n\t\t}\n\t}\n\tprintf(\"%.2f\\n\",s[1]);\n}\n```\n","link":null,"tags":["期望","拓扑"],"title":"LG 4316 绿豆蛙的归宿"},{"categories":[["刷题记录"]],"content":"\n我们定义第x个数中从右往左数第i位的贡献：有多少个在x之前的数j满足$a_j \\bigoplus a_{j+1} \\bigoplus ... \\bigoplus a_x$的第$i$位是$1$.\n\n设$f[x][i]$表示第x个数第$i$位的贡献,$a[x][i]$表示第$x$个数第$i$位是多少。\n\n若$a[x][i]=0$,取$j=x$不会产生贡献。若$j < x,aj \\bigoplus a_{j+1} \\bigoplus ... \\bigoplus a_x=a_j \\bigoplus a_{j+1} \\bigoplus ... \\bigoplus a_{x-1}$。所以$f[x][i]=f[x-1][i]$.\n\n若$a[x][i]=1$,取$j=x$产生$1$的贡献。若$j$小于$x,aj \\bigoplus a_{j+1} \\bigoplus ... \\bigoplus a_x$和$a_j \\bigoplus a_{j+1} \\bigoplus ... \\bigoplus a_{x-1}$相反。所以$f[x][i]=(x-1-f[x-1][i])(j小于x的贡献）+1(j=x的贡献）=x-f[x-1][i]$.\n\n设$f[x]=f[x][0]×1+f[x][1]×2+f[x][2]×4+...+f[x][31]×2^{31}$.\n\n则答案就是$f[1]+f[2]+...+f[n]$.\n\n可以用滚动数组\n\n```cpp\n#include<bits\/stdc++.h>\nusing namespace std;\nint n,a,f[32];\nlong long ans;\nint main(){\n    int i,j;\n    scanf(\"%d\",&n);\n    for(i=1;i<=n;++i){\n        scanf(\"%d\",&a);\n        for(j=31;j>-1;--j){\n            if(a&(1<<j)) f[j]=i-f[j];\n            ans+=1LL*f[j]*(1<<j);\n        }\n    }\n    printf(\"%lld\",ans);\n}\n```\n","link":null,"tags":["位运算"],"title":"LG 3917 异或序列"},{"categories":[["刷题记录"]],"content":"\n求$\\sum [lcm(i,j)=i\\times j]$\n\n相当于求$\\sum_{i=1}^n \\sum_{j=1} ^n[gcd(i,j) = 1]$\n\n> 时间限制:$10.00s$\n> \n> $1 \\le n,m \\le 10^9$且$\\min(n,m) \\le 10^6$\n\n\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;rg char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\n#define N 100011\nint n;\nint main(){\n    \n}\n```\n","link":null,"tags":["数论"],"title":"LG UVA12888 Count-LCM"},{"categories":[["刷题记录"]],"content":"\n我们设学生1的债务为$x$\n\n可以根据连边来计算出其他学生债务的表达式($ax+b$)\n\n如果出现矛盾,立即输出`impossible`并输出\n\n最后可以求出$x$,并推出所有学生的债务\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;rg char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\n#define N 1011\nint n,m;\nstruct node{\n    int x,b;\n}s[N];\nstruct edge{\n    int to,nxt,w;\n}e[200011];\nint cnt=0,head[N];\nvoid add(int x,int y,int w){\n    e[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;\n    e[cnt].w=w;\n}\nbool v[N];\ndb xx;\nvoid dfs(int x,int f){\n    fl(i,x)if(to!=f){\n        if(v[to]){\n            if(s[to].x+s[x].x==0){\n                if(s[to].b+s[x].b!=e[i].w){\n                    printf(\"IMPOSSIBLE\\n\");\n                    exit(0);\n                }\n            }\n            else\n                xx=(db)(e[i].w-s[x].b-s[to].b)\/(s[x].x+s[to].x);\n        }\n        else{\n            v[to]=1;\n            s[to].x=-s[x].x;\n            s[to].b=e[i].w-s[x].b;\n            dfs(to,x);\n        }\n    }\n}\nint main(){\n    in(n,m);\n    int x,y,w;\n    Fur(i,1,m)in(x,y,w),add(x,y,w),add(y,x,w);\n    s[1]=node{1,0};v[1]=1;\n    dfs(1,0);\n    Fur(i,1,n)\n        printf(\"%.2f\\n\",(db)s[i].x*xx+s[i].b);\n}\n```\n","link":null,"tags":["dfs"],"title":"LG 2428 债务清单"},{"categories":[["刷题记录"]],"content":"\n算法：贪心+堆维护\n\n贪心策略：\n\n我们考虑先按$t$贪心,中途再更改。\n按$t$从小到大排序之后,开始轮流遍历每个建筑。\n如果中途某个建筑$i$无法在$t_it$的时间内修复,那么在先前选择修复的建筑中拿出$a_j$最大的$j$号建筑。若$a_i < a_j$,则放弃$j$转而修$i$\n\n策略证明:\n\n若第$i$号出现时间不足,那么前$i$个建筑中最多修复$i-1$个建筑\n则我们必然选择$a_i$较小的前$i-1$个建筑,给后面的修复留下更多的时间\n实现方法:\n\n使用堆来维护选择的建筑中$a_i$最大的。\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;rg char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\n#define N 150011\nint n,ans=0;\nstruct node{\n    int t,a;\n}b[N];\nbool cmp(node x,node y){\n    return x.t<y.t;\n}\nbool v[N];\nint main(){\n    fin(\"in\");\n    in(n);\n    Fur(i,1,n)in(b[i].a,b[i].t);\n    sort(b+1,b+n+1,cmp);\n    int now=0;\n    priority_queue<int>q;\n    Fur(i,1,n)\n        if(now+b[i].a>b[i].t){\n            if(b[i].a<q.top()){\n                now-=q.top();q.pop();\n                q.push(b[i].a);\n                now+=b[i].a;\n            }\n        }\n        else{\n            q.push(b[i].a);\n            ++ans;\n            now+=b[i].a;\n        }\n    IO::out(ans,ln);\n    IO::flush();\n}\n```\n","link":null,"tags":["贪心","堆"],"title":"LG 4053 [JSOI2007]建筑抢修"},{"categories":[["刷题记录"]],"content":"\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;rg char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\n#define N 100011\nint n,k,a[N],ans[5000010],nxt[5000010];\nint main(){\n    in(k,n);\n    priority_queue<int,vector<int>,greater<int>>q;\n    q.push(1);\n    Fur(i,1,k){\n        a[i]=q.top();q.pop();\n        q.push(a[i]<<1|1);q.push(a[i]*4+5);\n        out(a[i]);\n    }out(ln);\n    clr(ans,126);\n    int d=0,x;\n    Fdr(i,k,1){\n        x=a[i];\n        while(x){\n            ans[++d]=x%10;\n            x\/=10;\n        }\n    }\n    reverse(ans+1,ans+d+1);\n    Fur(i,0,d-1)nxt[i]=i+1;\n    while(n--){\n        int l=0;\n        while(ans[nxt[l]]>=ans[nxt[nxt[l]]])l=nxt[l];\n        nxt[l]=nxt[nxt[l]];\n    }\n    for(int i=0;nxt[i];i=nxt[i])out(ans[nxt[i]]);\n    flush();\n}\n```\n","link":null,"tags":["贪心","堆"],"title":"LG 1323 删数问题"},{"categories":[["刷题记录"]],"content":"\n直接建立20棵线段树统计$1,2,4,8,...,2^20$就可以了\n\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;rg char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\n#define N 100011\n#define int ll\n#define ls rt<<1\n#define rs rt<<1|1\n#define pu s[rt]=s[ls]+s[rs]\nint n;\nstruct seg{\n    int s[N<<2],laz[N<<2];\n    void pd(int rt,int ln,int rn){\n        if(laz[rt]){\n            laz[ls]^=1;\n            laz[rs]^=1;\n            s[ls]=ln-s[ls];\n            s[rs]=rn-s[rs];\n            laz[rt]=0;\n        }\n    }\n    void upd(int L,int R,int l,int r,int rt){\n        if(L<=l&&r<=R){\n            s[rt]=r-l+1-s[rt];\n            laz[rt]^=1;\n            return;\n        }\n        int m=(l+r)>>1;\n        pd(rt,m-l+1,r-m);\n        if(L<=m)upd(L,R,l,m,ls);\n        if(R>m)upd(L,R,m+1,r,rs);\n        pu;\n    }\n    int ask(int L,int R,int l,int r,int rt){\n        if(L<=l&&r<=R)return s[rt];\n        int m=(l+r)>>1,ans=0;\n        pd(rt,m-l+1,r-m);\n        if(L<=m)ans=ask(L,R,l,m,ls);\n        if(R>m)ans+=ask(L,R,m+1,r,rs);\n        return ans;\n    }\n}T[21];\nsigned main(){\n    in(n);\n    int q,opt,l,r,x;\n    Fur(i,1,n){\n        in(x);\n        Fur(j,0,20){\n            if(x&1)T[j].upd(i,i,1,n,1);\n            x>>=1;\n        }\n    }\n    in(q);\n    while(q--){\n        in(opt,l,r);\n        if(opt==1){\n            ll ans=0;\n            Fur(i,0,20)ans+=(1<<i)*T[i].ask(l,r,1,n,1);\n            out(ans,ln);\n        }\n        else{\n            in(x);\n            Fur(i,0,20){\n                if(x&1)T[i].upd(l,r,1,n,1);\n                x>>=1;\n            }\n        }\n    }\n    flush();\n}\n```\n","link":null,"tags":["线段树","位运算"],"title":"LG CF242E XOR-on-Segment"},{"categories":[["刷题记录"]],"content":"\n打算直接把标记用$vector$记录里,以为可以水过去,结果mle了\n\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i=x;i<=y;++i)\n    #define Fdr(i,x,y) for(int i=x;i>=y;--i)\n    #define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 0x3f3f3f3f\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){clr(ch,0);if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 300011\n#define ls rt<<1\n#define rs rt<<1|1\n#define mod 1000000009\n#define pu s[rt]=(s[ls]+s[rs])%mod\nint n,q;\nll f[N],sf[N],s[N<<2];\nvector<int>add[N<<2];\nvoid build(int l,int r,int rt){\n    if(l==r){\n        in>>s[rt];\n        return;\n    }\n    int m=(l+r)>>1;\n    build(l,m,ls);build(m+1,r,rs);\n    pu;\n}\nint get(int p,int len){\n    return (sf[p+len-1]-sf[p-1]+mod)%mod;\n}\nvoid pd(int rt,int ln,int rn){\n    if(add[rt].empty())return;\n    Fur(i,0,add[rt].size()-1){\n        int v=add[rt][i];\n        add[ls].push_back(v);\n        add[rs].push_back(v+ln);\n        s[ls]+=get(v,ln);\n        s[rs]+=get(v+ln,rn);\n    }\n    add[rt].clear();\n}\nvoid upd(int L,int R,int l,int r,int rt){\n    if(L<=l&&r<=R){\n        s[rt]=(s[rt]+get(l-L+1,r-l+1))%mod;\n        add[rt].push_back(l-L+1);\n        return;\n    }\n    int m=(l+r)>>1;\n    pd(rt,m-l+1,r-m);\n    if(L<=m)upd(L,R,l,m,ls);\n    if(R>m)upd(L,R,m+1,r,rs);\n    pu;\n}\nint ask(int L,int R,int l,int r,int rt){\n    if(L<=l&&r<=R)return s[rt]%mod;\n    int m=(l+r)>>1,ans=0;\n    pd(rt,m-l+1,r-m);\n    if(L<=m)ans=ask(L,R,l,m,ls);\n    if(R>m)ans+=ask(L,R,m+1,r,rs);\n    return ans%mod;\n}\nsigned main(){\n    in>>n>>q;\n    f[1]=f[2]=1;\n    Fur(i,3,n)f[i]=(f[i-1]+f[i-2])%mod;\n    Fur(i,1,n)sf[i]=(sf[i-1]+f[i])%mod;\n    build(1,n,1);\n    int l,r,u;\n    while(q--){\n        in>>u>>l>>r;\n        if(u==1)upd(l,r,1,n,1);\n        else out<<ask(l,r,1,n,1)<<ln;\n    }\n}\n```\n\n[正解：](https:\/\/xiaohuang888.github.io\/2019\/08\/02\/%E3%80%8E%E9%A2%98%E8%A7%A3%E3%80%8FCodeforces446C%20DZY%20Loves%20Fibonacci%20Numbers)\n\n设$S_n=\\sum_{i=1}^n f_i$\n\n$S_n = f_{n+2} - f_2$\n\n证明：\n\n$S_{i+1}=S_i + f_{i+1} = f_{i+2} - f_2 + f_{i+1} = f_{i+3} - f_2$\n\n任意两段不同的广义斐波那契数列段相加（逐项相加）,所得的数列任然是广义斐波那契数列。\n\n\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i=x;i<=y;++i)\n    #define Fdr(i,x,y) for(int i=x;i>=y;--i)\n    #define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 0x3f3f3f3f\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){clr(ch,0);if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 300011\n#define ls rt<<1\n#define rs rt<<1|1\n#define mod 1000000009\nint n,q;\nll f[N],S[N],s[N<<2],sum[N],a1[N<<2],a2[N<<2];\nvoid pu(int rt,int p){\n    a1[rt]%=mod,a2[rt]%=mod;\n    s[rt]=(s[ls]+s[rs]+a1[rt]*f[p]+a2[rt]*f[p+1]-a2[rt])%mod;\n}\nvoid pd(int rt,int ln,int rn){\n    if(!a1[rt]&&!a2[rt])return;\n    a1[ls]+=a1[rt];a1[rs]+=a1[rt]*(ln-1)+a2[rt]*f[ln];\n    a2[ls]+=a2[rt];a2[rs]+=a1[rt]*ln+a2[rt]*f[ln+1];\n    a1[rt]=a2[rt]=0;\n    pu(ls,ln);pu(rs,rn);\n}\nvoid upd(int L,int R,int l,int r,int rt){\n    if(L<=l&&r<=R){\n        a1[rt]+=f[l-L+1];a1[rt]%=mod;\n        a2[rt]+=f[l-L+2];a2[rt]%=mod;\n        pu(rt,r-l+1);\n        return;\n    }\n    int m=(l+r)>>1;\n    pd(rt,m-l+1,r-m);\n    if(L<=m)upd(L,R,l,m,ls);\n    if(R>m)upd(L,R,m+1,r,rs);\n    pu(rt,r-l+1);\n}\nint ask(int L,int R,int l,int r,int rt){\n    if(L<=l&&r<=R)return s[rt]%mod;\n    int m=(l+r)>>1,ans=0;\n    pd(rt,m-l+1,r-m);\n    if(L<=m)ans=ask(L,R,l,m,ls);\n    if(R>m)ans+=ask(L,R,m+1,r,rs);\n    return ans%mod;\n}\nsigned main(){\n    fin(\"in\");\n    in>>n>>q;\n    f[1]=f[2]=1;\n    Fur(i,3,n+1)f[i]=(f[i-1]+f[i-2])%mod;\n    Fur(i,1,n+1)S[i]=(S[i-1]+f[i])%mod;\n    Fur(i,1,n)in>>sum[i],sum[i]+=sum[i-1];\n    int l,r,u;\n    while(q--){\n        in>>u>>l>>r;\n        if(u==1)upd(l,r,1,n,1);\n        else out<<(ask(l,r,1,n,1)+(sum[r]-sum[l-1]+mod)%mod)%mod<<ln;\n    }\n}\n```\n","link":null,"tags":["线段树"],"title":"LG CF446C DZY Loves Fibonacci Numbers"},{"categories":[["刷题记录"]],"content":"\n把风铃看成一棵树\n\n因为交换一根杆的两端不会影响它下面的子树的情况,所以可以采用**分治+分类讨论**\n\n我们先预处理出最小深度和最大深度\n\n如果差大于1,那么不满足要求\n\n一个端点可以分成三种情况\n\n0. 都是最小深度\n\n1. 都是最大深度\n   \n2. 两种都有\n\n如果一根杆左右端点分别为$0,1$或$0,2$或$2,1$那么它就需要交换左右端点\n\n如果左右端点都是$2$那么交换也没用,直接输出$-1$,结束程序\n\n然后把状态向上传递就可以了\n\n\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i=x;i<=y;++i)\n    #define Fdr(i,x,y) for(int i=x;i>=y;--i)\n    #define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 0x3f3f3f3f\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){clr(ch,0);if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 100011\nint n,ans=0,l[N],r[N],mx=0,mi=inf;\nvoid dfs(int x,int d){\n    if(x==-1){\n        mi=MIN(d,mi);\n        mx=MAX(d,mx);\n        return;\n    }\n    dfs(l[x],d+1);dfs(r[x],d+1);\n}\nint DFS(int x,int d){\n    if(x==-1)return d!=mi;\n    int ls=DFS(l[x],d+1),rs=DFS(r[x],d+1);\n    if((ls==0&&rs==1)||(ls==2&&rs==1)||(ls==0&&rs==2))++ans;\n    if(ls==2&&rs==2)out<<\"-1\\n\",exit(0);\n    if(ls==2||rs==2)return 2;\n    if(ls^rs)return 2;\n    if(!ls&&!rs)return 0;\n    return 1;\n}\nint main(){\n    fin(\"in\");\n    in>>n;\n    int x,y;\n    Fur(i,1,n)in>>l[i]>>r[i];\n    dfs(1,0);\n    DFS(1,0);\n    if(mx-mi>1)out<<\"-1\\n\";\n    else if(mx-mi==0)out<<\"0\\n\";\n    else out<<ans<<ln;\n}\n```\n","link":null,"tags":["dfs","分治"],"title":"LG 3621 [APIO2007]风铃"},{"categories":[["刷题记录"]],"content":"\n$n\\le12$\n\n设$f[sta][x]$表示状态为$sta$,当前位置为$x$的情况下最短的(字典序最小)\n\n$f[sta][y]=\\min(f[sta'][x]+cost)$\n\n看到这个可以联想到**AC自动机**和**最短路**(貌似是最短哈密顿路径?)\n\n每个字符串长度都小于$50$,如果用**AC自动机**可能就~~核弹打蚊子~~了\n\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;rg char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\n#define N 15\nint n,g[N][N],f[N][15];\nchar s[N][55];\nint cost(int x,int y){\n    int lx=strlen(s[x]+1),ly=strlen(s[y]+1);\n    Fur(i,1,lx){\n        bool ff=1;\n        Fur(j,1,ly){\n            if(i+j-1>lx)break;\n            if(s[x][i+j-1]!=s[y][j]){ff=0;break;}\n        }\n        if(ff)return MAX(i+ly-1-x,0);\n    }\n}\nint main(){\n    in(n);\n    Fur(i,1,n)in(s[i]+1);\n    sort(s+1,s+n+1);\n    Fur(i,1,n)\n        Fur(j,1,n)\n        if(i!=j)g[i][j]=cost(i,j);\n    \n    Fur(i,1,n)f[1<<(i-1)][i];\n\n    Fur(i,1,(1<<n)-1){\n        Fur(j,1,n)\n            if()\n    }\n}\n```\n","link":null,"tags":["状态压缩","动态规划","字符串","AC自动机","最短路"],"title":"LG 2322 [HNOI2006]最短母串问题"},{"categories":[["刷题记录"]],"content":"\n思路剧毒无比\n\n设$f[i][j]$表示在$i$的子树中,$i$所在的连体块大小为$j$时$\\frac{\\text{最大得分}}{j}$\n\n$f[i][j] = \\max(f[i][k] \\times f[to][j-k])$\n\n$f[i][0] = \\max(f[i][0],f[i][j] \\times j)$\n\n还没完\n\n吐血的是还要写高精\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i=x;i<=y;++i)\n    #define Fdr(i,x,y) for(int i=x;i>=y;--i)\n    #define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){clr(ch,0);if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 711\nint n,cnt=0,head[N],siz[N];\n#define M 20\n#define base 1000000000\nstruct node{\n    node(){clr(a,0);len=1;}\n    ll a[M],len;\n    il void operator = (node x){cpy(a,x.a);len=x.len;}\n    il bool operator > (node x){\n        if(len!=x.len)return len>x.len;\n        Fdr(i,len,1)\n            if(a[i]<x.a[i])return 0;\n            else if(a[i]>x.a[i])return 1;\n        return 1;\n    }\n    il void op(){\n        printf(\"%d\",a[len]);\n        Fdr(i,len-1,1)printf(\"%10d\",a[i]);\n    }\n}f[N][N];\nnode operator * (node c,int y){\n    node x;\n    Fur(i,1,x.len){\n        x.a[i]+=c.a[i]*y;\n        if(x.a[i]>=base)\n            x.a[i+1]+=x.a[i]\/base;\n    }\n    while(x.a[x.len]>=base){\n        x.a[x.len+1]+=x.a[x.len]\/base;\n        x.a[x.len]%=base;\n        ++x.len;\n    }\n    return x;\n}\nnode operator * (node x,node y){\n    node c;\n    c.len=x.len+y.len-1;\n    Fur(i,1,x.len)\n        Fur(j,1,y.len){\n            c.a[i+j-1]+=x.a[i]*y.a[j];\n            if(c.a[i+j-1]>=base)\n                c.a[i+j]+=c.a[i+j-1]\/base,\n                c.a[i+j-1]%=base;\n        }\n    \n    while(c.a[c.len]>=base){\n        c.a[c.len+1]+=c.a[c.len]\/base;\n        c.a[c.len]%=base;\n        ++c.len;\n    }\n    return c;\n}\nstruct edge{\n    int to,nxt;\n}e[N*2];\nil void add(int x,int y){\n    e[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;\n}\nvoid dfs(int x,int fa){\n    f[x][0].a[1]=1;\n    f[x][1].a[1]=1;\n    siz[x]=1;\n    fl(i,x)if(to!=fa){\n        dfs(to,x);\n        siz[x]+=siz[to];\n        Fdr(j,siz[x],0)\n            Fdr(k,MIN(j,siz[x]-siz[to]),MAX(1,j-siz[to]))\n                f[x][j]=MAX(f[x][j],f[x][k]*f[to][j-k]);\n    }\n    Fur(i,1,siz[x])\n        f[x][0]=MAX(f[x][0],f[x][i]*i);\n}\nint main(){\n    fin(\"in\");\n    in>>n;\n    int x,y;\n    Fur(i,1,n-1)in>>x>>y,add(x,y),add(y,x);\n    dfs(1,0);\n    f[1][0].op();\n}\n```\n","link":null,"tags":["树形dp","高精度"],"title":"LG 1411 树"},{"categories":[["刷题记录"]],"content":"\n$$\n\\sum_i^n \\sum_{j=i+1}^n gcd(i,j)\n\\\\\\\\\n=\\sum_i^n \\sum_j^{i-1} gcd(i,j)\n\\\\\\\\\n=\\sum_d^n d \\sum_i^n \\sum_j^{i-1} [gcd(i,j)=d]\n\\\\\\\\\n=\\sum_d^n d \\sum_i^{\\frac nd} \\sum_j^{i-1} [gcd(i,j)=1]\n\\\\\\\\\n=\\sum_d^n d \\sum_i^{\\frac nd} \\varphi(i)\n\\\\\\\\\n$$\n于是欧拉筛加整除分块就可以了\n\n\n\n本题为七倍经验题！！！\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n\t#pragma GCC optimize(3)\n\t#define il __inline__ __attribute__ ((always_inline))\n\t#define rg register\n\t#define ll long long\n\t#define ull unsigned long long\n\t#define db double\n\t#define sht short\n\t#define MB template <class T>il\n\t#define Fur(i,x,y) for(int i=x;i<=y;i++)\n\t#define Fdr(i,x,y) for(int i=x;i>=y;i--)\n\t#define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n\t#define clr(x,y) memset(x,y,sizeof(x))\n\t#define cpy(x,y) memcpy(x,y,sizeof(x))\n\t#define fin(s) freopen(s\".in\",\"r\",stdin)\n\t#define fout(s) freopen(s\".out\",\"w\",stdout)\n\t#define fcin ios::sync_with_stdio(false)\n\t#define l2(n) (int(log2(n)))\n\t#define inf 0x3f3f3f3f\n\tMB T ABS(T x){return x>0?x:-x;}\n\tMB T MAX(T x,T y){return x>y?x:y;}\n\tMB T MIN(T x,T y){return x<y?x:y;}\n\tMB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n\tMB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 40000001\nint pri[N+11],tot=0;\nll phi[N+11];\nbool f[N+11];\nvoid ol(int n){\n\tphi[1]=0;\n\tFur(i,2,n){\n\t\tif(!f[i])phi[i]=i-1,pri[++tot]=i;\n\t\tFur(j,1,tot){\n\t\t\tif(pri[j]*i>n)break;\n\t\t\tf[i*pri[j]]=1;\n\t\t\tif(i%pri[j])phi[i*pri[j]]=phi[i]*phi[pri[j]];\n\t\t\telse{\n\t\t\t\tphi[i*pri[j]]=phi[i]*pri[j];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tFur(i,2,n)phi[i]+=phi[i-1];\n}\nint main(){\n\tol(N);\n\tint n;ll ans;\n\twhile(1){\n\t\tin>>n;if(!n)break;\n\t\tans=0;\n\t\tfor(int l=1,r;l<=n;l=r+1){\n\t\t\tr=n\/(n\/l);\n\t\t\tans+=phi[int(n\/l)]*(r-l+1)*(r+l)\/2;\n\t\t}\n\t\tout<<ans<<ln;\n\t}\n}\n\n```\n","link":null,"tags":["欧拉函数","整除分块","数论"],"title":"LG UVA11426 GCD--ex"},{"categories":[["刷题记录"]],"content":"\n> ## 题意\n>\n> 一棵以1为根的树,每个节点上都有1个字母,有m个询问。每次询问v对应的子树中,深度为h的这层节点的字母,能否打乱重排组成回文串。根的深度为1,每个点的深度为到根的距离。\n>\n> ## 思路\n>\n> 一层结点的字母是否能组成回文串,只需观察每个字母出现次数要么都是偶数,要么只有一个字母奇数次出现。\n>\n> ### 解法一\n>\n> > DSU\n>\n> 二进制优化,每次都异或上字母对应的二进制位,只需记录答案1位是否<2即可。\n>\n> ### 代码1\n>\n> ```c++\n> #include<bits\/stdc++.h>\n> #define M 500005\n> using namespace std;\n> struct query {\n>     int de,id;\n> };\n> int n,m;\n> vector<int>G[M];\n> vector<query>Q[M];\n> int L[M],R[M],ID[M],T;\n> int dep[M],son[M],sz[M];\n> int check[M],ans[M];\n> char A[M];\n> void dfs(int v,int d) {\n>     L[v]=++T;\n>     ID[T]=v;\n>     dep[v]=d,son[v]=0,sz[v]=1;\n>     for(int i=0; i<G[v].size(); i++) {\n>         int u=G[v][i];\n>         dfs(u,d+1);\n>         if(sz[u]>sz[son[v]])son[v]=u;\n>         sz[v]+=sz[u];\n>     }\n>     R[v]=T;\n> }\n> void Add_point(int x,int a) {\n>     int r=A[x]-'a',d=dep[x];\n>     check[d]^=(1<<r);\/\/二进制优化\n> }\n> void Add_tree(int x,int a) {\n>     for(int i=L[x]; i<=R[x]; i++)Add_point(ID[i],a);\n> }\n> void Solve(int v) {\n>     for(int i=0; i<G[v].size(); i++) {\n>         int u=G[v][i];\n>         if(u==son[v])continue;\n>         Solve(u);\n>         Add_tree(u,-1);\n>     }\n>     if(son[v])Solve(son[v]);\n>     for(int i=0; i<G[v].size(); i++) {\n>         int u=G[v][i];\n>         if(u==son[v])continue;\n>         Add_tree(u,1);\n>     }\n>     Add_point(v,1);\n>     for(int i=0; i<Q[v].size(); i++){\n>         int d=Q[v][i].de,r=check[d],id=Q[v][i].id;\n>         ans[id]=(r==(r&-r));\n>     }\n> }\n> int main() {\n>     scanf(\"%d%d\",&n,&m);\n>     for(int i=2,f; i<=n; i++) {\n>         scanf(\"%d\",&f);\n>         G[f].push_back(i);\n>     }\n>     dfs(1,1);\n>     scanf(\"%s\",A+1);\n>     for(int i=1; i<=m; i++) {\n>         int x,d;\n>         scanf(\"%d%d\",&x,&d);\n>         Q[x].push_back((query) {d,i});\n>     }\n>     Solve(1);\n>     for(int i=1; i<=m; i++)\n>         if(ans[i])puts(\"Yes\");\n>         else puts(\"No\");\n>     return 0;\n> }\n> ```\n>\n> ### 解法二\n>\n> > dfs作差\n>\n> 同样是二进制,每次进结点时记录原先的二进制数,出结点时再用更新过的数据异或上原来的即为答案。\n>\n> ### 代码二\n>\n> ```c++\n> #include<bits\/stdc++.h>\n> #define M 500005\n> using namespace std;\n> struct query{\n>     int de,id;\n> };\n> int n,m;\n> vector<int>G[M],tmp[M];\n> vector<query>Q[M];\n> int cnt[M],ans[M];\n> char A[M];\n> void dfs(int v,int d){\n>     cnt[d]^=1<<A[v]-'a';\n>     for(int i=0;i<Q[v].size();i++)\n>         tmp[v].push_back(cnt[Q[v][i].de]);\n>     for(int i=0;i<G[v].size();i++)\n>         dfs(G[v][i],d+1);\n>     for(int i=0;i<Q[v].size();i++)\n>         ans[Q[v][i].id]=(tmp[v][i]^cnt[Q[v][i].de]);\n> }\n> int main(){\n>     scanf(\"%d%d\",&n,&m);\n>     for(int i=2,f;i<=n;i++){\n>         scanf(\"%d\",&f);\n>         G[f].push_back(i);\n>     }\n>     scanf(\"%s\",A+1);\n>     for(int i=1;i<=m;i++){\n>         int x,d;\n>         scanf(\"%d%d\",&x,&d);\n>         Q[x].push_back((query){\n>             d,i\n>         });\n>     }\n>     dfs(1,1);\n>     for(int i=1;i<=m;i++)\n>         puts(ans[i]==(ans[i]&-ans[i])?\"Yes\":\"No\");\n>     return 0;\n> }\n> ```\n>\n> ### 解法三\n>\n> > 在线 异或前缀和\n>\n> 只需将每个深度的结点按照dfs序排到一个vector里,同时记录每个对应的异或前缀和,则对于一个询问x,只需在给定深度里找比L[x]大的和比R[x]小的两个端点即可,再异或一下前缀和即可。\n>\n> ### 代码三\n>\n> ```c++\n> #include<bits\/stdc++.h>\n> #define M 500005\n> using namespace std;\n> int n,m;\n> vector<int>G[M],deep[M],Xor[M];\n> int L[M],R[M],ID[M],T,mxdep;\n> int dep[M];\n> char A[M];\n> void dfs(int v,int d) {\n>     L[v]=++T;\n>     ID[T]=v,dep[v]=d;\n>     mxdep=max(mxdep,d);\n>     deep[d].push_back(L[v]);\n>     for(int i=0; i<G[v].size(); i++) {\n>         int u=G[v][i];\n>         dfs(u,d+1);\n>     }\n>     R[v]=T;\n> }\n> int main() {\n>     scanf(\"%d%d\",&n,&m);\n>     for(int i=2,f; i<=n; i++) {\n>         scanf(\"%d\",&f);\n>         G[f].push_back(i);\n>     }\n>     scanf(\"%s\",A+1);\n>     dfs(1,1);\n>     for(int i=1;i<=mxdep;i++){\n>         Xor[i].push_back(1<<(A[ID[deep[i][0]]]-'a'));\n>         for(int j=1;j<deep[i].size();j++)\/\/异或前缀和\n>             Xor[i].push_back(Xor[i][j-1]^(1<<(A[ID[deep[i][j]]]-'a')));\n>     }\n>     while(m--){\n>         int x,d,ans=0;\n>         scanf(\"%d%d\",&x,&d);\n>         int l=lower_bound(deep[d].begin(),deep[d].end(),L[x])-deep[d].begin();\n>         int r=upper_bound(deep[d].begin(),deep[d].end(),R[x])-deep[d].begin()-1;\n>         \/\/在当前深度找xdfs序之内的点\n>         if(r<0)puts(\"Yes\");\n>         else {\n>             if(l==0)ans=Xor[d][r];\/\/处理前缀和\n>             else ans=Xor[d][r]^Xor[d][l-1];\n>             if(ans==(ans&-ans))puts(\"Yes\");\n>             else puts(\"No\");\n>         }\n>     }\n>     return 0;\n> }\n> ```\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i=x;i<=y;++i)\n    #define Fdr(i,x,y) for(int i=x;i>=y;--i)\n    #define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 0x3f3f3f3f\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){clr(ch,0);if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 500011\nint n,q,head[N],cnt=0;\nstruct edge{\n    int to,nxt;\n}e[N];\nvoid add(int x,int y){\n    e[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;\n}\nchar ch[N];\nint T[N],L[N],R[N],dfn=0,d[N],siz[N],son[N];\nvoid dfs(int x){\n    L[x]=++dfn;\n    T[dfn]=x;\n    siz[x]=1;son[x]=0;\n    fl(i,x){\n        d[to]=d[x]+1;\n        dfs(to);\n        if(siz[to]>siz[son[x]])son[x]=to;\n        siz[x]+=siz[to];\n    }\n    R[x]=dfn;\n}\nint sta[N];\nstruct node{\n    int d,id;\n};\nvector<node>que[N];\nbool ans[N];\nvoid Add(int x){\n    int r=ch[x]-'a',D=d[x];\n    sta[D]^=(1<<r);\n}\nvoid upd(int x){\n    Fur(i,L[x],R[x])Add(T[i]);\n}\nvoid sol(int x){\n    fl(i,x)if(to!=son[x]){\n        sol(to);\n        upd(to);\n    }\n    if(son[x])sol(son[x]);\n    fl(i,x)if(to!=son[x])upd(to);\n    Add(x);\n    for(int i=0;i<que[x].size();++i){\n        int D=que[x][i].d,r;r=sta[D];\n        ans[que[x][i].id]=(r==(r&-r));\n    }\n}\nint main(){\n    fin(\"in\");\n    in>>n>>q;\n    int x,y;\n    Fur(i,2,n)in>>x,add(x,i);\n    in>>(ch+1);\n    d[1]=1;dfs(1);\n    Fur(i,1,q)in>>x>>y,que[x].push_back(node{y,i});\n    sol(1);\n    Fur(i,1,q)out<<(ans[i]?\"Yes\":\"No\")<<ln;\n}\n```\n","link":null,"tags":["状态压缩","静态链分治"],"title":"LG CF570D Tree Requests"},{"categories":[["刷题记录"]],"content":"\n记录每个点左边和右边第一个比它小的,就可以求出它能的贡献区间\n\n\n```cpp\n#include<cstdio>\n#include<cstring>\n#include<cctype>\n#include<algorithm>\nusing namespace std;\n#define rep(i,s,t) for(int i=s;i<=t;i++)\n#define dwn(i,s,t) for(int i=s;i>=t;i--)\n#define clr(x,c) memset(x,c,sizeof(x))\nint read(){\n    int x=0;char c=getchar();\n    while(!isdigit(c)) c=getchar();\n    while(isdigit(c)) x=x*10+c-'0',c=getchar();\n    return x;\n}\nchar sh[15];\nvoid print(int x){\n    int cnt=0;\n    while(x) sh[++cnt]=x%10,x\/=10;\n    dwn(i,cnt,1) putchar(sh[i]+48);\n    putchar(32);\n}\nconst int nmax=2e5+5;\nconst int inf=0x7f7f7f7f;\nint a[nmax],ans[nmax],l[nmax],r[nmax],q[nmax];\nvoid maxs(int &a,int b){\n    if(a<b) a=b;\n}\nint main(){\n    int n=read();rep(i,1,n) a[i]=read();\n    l[1]=1;int cur=1;q[1]=1;\n    rep(i,2,n){\n        while(a[q[cur]]>=a[i]&&cur) --cur;\n        l[i]=q[cur]+1;q[++cur]=i;\n    }\n    r[n]=n;cur=1;q[1]=n;q[0]=n+1;\n    dwn(i,n-1,1){\n        while(a[q[cur]]>=a[i]&&cur) --cur;\n        r[i]=q[cur]-1;q[++cur]=i;\n    }\n    rep(i,1,n) maxs(ans[r[i]-l[i]+1],a[i]);\n    int tmp=0;\n    dwn(i,n,1) maxs(ans[i],tmp),maxs(tmp,ans[i]);\n    rep(i,1,n) print(ans[i]);printf(\"\\n\");\n    return 0;\n}\n\n```\n","link":null,"tags":["单调栈"],"title":"51nod 1437 迈克步"},{"categories":[["刷题记录"]],"content":"\n官方：\n\n>对于一段区间l~r,其中一个数x对答案的贡献为(2x-l-r)次。\n>\n>因此我们只要求出所有数对答案的贡献并累加起来即可。\n>\n>将2x-l-r分为两部分,一部分为求2x的和,即为x左边与x右边相同的数的对数。\n>\n>另一部分为l+r,将其拆开来,并记录前缀和,对于一个数a[i],我们需要维护的是Σk,Σs[i-1],Σs[i-1]*i,以及a[i]出现的次数就可以了。\n>\n>这里我们可以在枚举的同时,记录这些信息,并更新答案,就可以了。\n>\n>复杂度为线性O(n)。\n\n更加详细：\n\nhttps:\/\/www.cnblogs.com\/zkGaia\/p\/6108204.html\n```cpp\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#define ll long long \n#define db double\n#define uint unsigned int\n#define N 3000100\n#define max(a, b) ((a) > (b) ? (a) : (b))\n#define min(a, b) ((a) < (b) ? (a) : (b))\n#define swap(T, a, b) ({T ttt = a; a = b; b = ttt;})\nint n, lrk[N], rrk[N], pre[N], next[N], pos[N];\nuint a[N], decA[N], decB[N], f[N], g[N], Ans = 0;\nvoid G(uint &w) {\n   w = 0; char c = getchar();\n   while (c > '9' || c < '0') c = getchar();\n   while (c >= '0' && c <= '9') { w = w * 10 + c - '0'; c = getchar(); }\n}\nuint Mult(uint a, uint b){\n   uint s = 0; \n   while(b){\n      if (b & 1) s += a;\n      a += a; b >>= 1;\n   }\n   return s;\n}\nint main(){\n   scanf(\"%d\", &n);\n   for (int i = 1; i <= n; i++)\n      G(a[i]);\n   memset(pos, 0, sizeof(pos));\n   for (int i = 1; i <= n; i++){\n      pre[i] = pos[a[i]]; pos[a[i]] = i;\n      lrk[i] = lrk[pre[i]] + 1;\n      decA[i] = decA[pre[i]] + pre[i];\n   }\n   memset(pos, 0, sizeof(pos)); \n   for (int i = n; i >= 1; i--){\n      next[i] = pos[a[i]]; pos[a[i]] = i;\n      rrk[i] = rrk[next[i]] + 1;\n      decB[i] = decB[next[i]] + next[i]; \n   }\n   for (int i = 1; i <= n; i++){\n      if (rrk[i] == 1){\n         next[i] = i+n; pre[i+n] = i;\n         lrk[next[i]] = lrk[i] + 1; \n         decA[i+n] = decA[i] + i;\n      }\n      if (lrk[i] == 1){\n         pre[i] = i+n*2; next[i+n*2] = i;\n         rrk[pre[i]] = rrk[i] + 1; \n         decB[i+n*2] = decB[i] + i;\n      }\n   }\n   for (int i = 1; i <= n; i++)\n      f[i] = f[i-1] + i*rrk[i] - decA[next[i-1]];\n   for (int i = n; i >= 1; i--)\n      g[i] = g[i+1] + i*lrk[i] - decB[pre[i+1]];\n   for (int i = 1; i <= n; i++)\n      f[i] = f[i] + g[i] - i*2; \n   memset(g, 0, sizeof(g));\n   memset(decA, 0, sizeof(decA));\n   for (int i = 1; i <= n; i++){\n      decA[i] = decA[pre[i]] + (pre[i] >= 1 && pre[i] <= n);\n      if (rrk[i] == 1) decA[i+n] = decA[i] + 1;\n   }\n   for (int i = 1; i <= n; i++){\n      g[i] = g[i-1] + rrk[i] - decA[next[i-1]];\n      f[i] = Mult(g[i] - 1, i) * 2 - f[i];\n      Ans += Mult(f[i], a[i]); \n   }\n   std::cout << Ans << std::endl; \n}\n\n```\n","link":null,"tags":["数论"],"title":"51nod 1712 区间求和"},{"categories":[["刷题记录"]],"content":"\n![](https:\/\/cdn.luogu.org\/upload\/pic\/70275.png)\n\n图形可以分割成一个个小矩阵\n\n![](https:\/\/s2.ax1x.com\/2019\/08\/08\/eTuDjP.gif)\n\n于是我们可以把每个矩形变成两条线段后对这些线段进行排序\n\n![如此](https:\/\/cdn.luogu.org\/upload\/pic\/70291.png)\n\n那么总共覆盖了多少长度？\n\n用**线段树**求！\n\n那管儿子节点的事干嘛,让他们自生自灭得了\n\n于是,我们想到,除左右端点$l,r$之外,在线段树的每个节点上维护两个值：该节点代表的区间被矩形覆盖的长度$len$,该节点自身被覆盖的次数$cnt$。最初,二者均为$0$.\n\n注意：\n    每个节点代表的范围是$[l,r+1]$,最后面的那个节点不算入统计\n\n对于每一个$(x,y1,y2,k)$,我们再$[val(y1),val(y2)-1]$(离散化后的区间)上执行期间修改。该区间被线段树划分成$ \\log n$个节点,我们把这些节点的$cnt$都加$k$。\n\n对于线段树中任意一个节点 $[l,r]$ ,若$cnt>0$,则$len$等于$raw(r+1)-raw(l)$(离散化前的距离),否则,该店$len$等于两个子节点的$len$之和。在一个节点的$cnt$被修改,以及线段树从下往上传递信息时,我们都按照该方法更新$len$值。根节点的$len$值就是整个扫描线上被覆盖的长度\n\n\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i=x;i<=y;i++)\n    #define Fdr(i,x,y) for(int i=x;i>=y;i--)\n    #define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) (int(log2(n)))\n    #define inf 0x3f3f3f3f\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){clr(ch,0);if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 10001\nint n,b[N];\nstruct node{\n\tint p,x,y,v;\n}a[N];\nbool cmp(node x,node y){\n\treturn (x.p==y.p)?(x.v>y.v):(x.p<y.p);\n}\nint main(){\n\tint x1,y1,x2,y2;\n\tin>>n;\n\tFur(i,1,n){\n\t\tin>>x1>>y1>>x2>>y2;\n\t\ta[i]=node{x1,y1,y2,1};\n\t\ta[i*2]=node{x2,y1,y2,-1};\n\t\tb[i]=y1;b[i*2]=y2;\n\t}\n\tsort(a+1,a+n*2+1,cmp);\n\t\n}\n\n```\n","link":null,"tags":["扫描线","排序","线段树"],"title":"LG 5490 【模板】扫描线"},{"categories":[["刷题记录"]],"content":"\n二分第$k$大平均数$w$,统计平均数大于等于它的区间的个数\n\n这样的区间满足$\\frac {s_r - s_{l-1}}{r-l+1} \\ge w$\n\n化简一下：\n$$\ns_r - s_{l-1} \\ge w(r-(l-1))\n\\\\\\\\\ns_r - wr \\ge s_{l-1} - w(l-1)\n$$\n那么我们只要用树状数组统计一下就可以了(当然你要用权值线段树也可以)\n\n因为平均数可能不是整数,所以我们要离散化一下才能统计\n\n\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n\t#pragma GCC optimize(3)\n\t#define il __inline__ __attribute__ ((always_inline))\n\t#define rg register\n\t#define ll long long\n\t#define ull unsigned long long\n\t#define db double\n\t#define sht short\n\t#define MB template <class T>il\n\t#define Fur(i,x,y) for(int i=x;i<=y;i++)\n\t#define Fdr(i,x,y) for(int i=x;i>=y;i--)\n\t#define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n\t#define clr(x,y) memset(x,y,sizeof(x))\n\t#define cpy(x,y) memcpy(x,y,sizeof(x))\n\t#define fin(s) freopen(s\".in\",\"r\",stdin)\n\t#define fout(s) freopen(s\".out\",\"w\",stdout)\n\t#define fcin ios::sync_with_stdio(false)\n\t#define l2(n) (int(log2(n)))\n\t#define inf 0x3f3f3f3f\n\tMB T ABS(T x){return x>0?x:-x;}\n\tMB T MAX(T x,T y){return x>y?x:y;}\n\tMB T MIN(T x,T y){return x<y?x:y;}\n\tMB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n\tMB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){clr(ch,0);if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 100011\n#define eps 1e-6\n#define int unsigned\nint n,k,a[N],tr[N*3],b[N];\nstruct node{\n\tdb v;\n\tint id;\n}s[N];\nbool cmp(node x,node y){\n\treturn x.v<y.v;\n}\nvoid add(int x){\n\tif(x<=0)return;\n\twhile(x<=n){\n\t\ttr[x]++;\n\t\tx+=(x&-x);\n\t}\n}\nint get(int x){\n\tif(x<=0)return 0;\n\tint ans=0;\n\twhile(x){\n\t\tans+=tr[x];\n\t\tx-=(x&-x);\n\t}\n\treturn ans;\n}\nbool chk(db w){\n\tclr(tr,0);\n\ts[0].v=0;s[0].id=0;\n\tFur(i,1,n)s[i].v=(db)s[i-1].v+w*i,s[i].id=i;\n\tsort(s,s+n+1,cmp);\n\tint t=0;\n\tFur(i,0,n){\n\t\tif(s[i].v!=s[i-1].v)t++;\n\t\tb[s[i].id]=t;\n\t}\n\tint tot=0;\n\tFur(i,0,n){\n\t\ttot+=get(b[i]);\n\t\tadd(b[i]);\n\t}\n\treturn tot>=k;\n}\nsigned main(){\n\tfin(\"in\");\n\tin>>n>>k;\n\tdb l=0,r=0,m;\n\tFur(i,1,n)in>>a[i],r=MAX(r,(db)a[i]);\n\twhile(r-l>eps){\n\t\tm=(l+r)\/2.0;\n\t\tif(chk(m))l=m;\n\t\telse r=m;\n\t}\n\tprintf(\"%.4f\\n\",m);\n}\n\n```\n","link":null,"tags":["二分","树状数组"],"title":"51nod 1711 平均数"},{"categories":[["刷题记录"]],"content":"\n我们设$f[i][k][j]$表示第$i$列状态为$j$,联通块个数为$k$的方案数\n\n我们可以列出个种状态的转移\n\n```plain\n00 | 00 | 10 | 10\n00 | 10 | 00 | 10\n\n00 | 00 | 10 | 10\n01 | 11 | 01 | 11\n\n01 | 01 | 11 | 11\n00 | 10 | 00 | 10\n\n01 | 01 | 11 | 11\n01 | 11 | 01 | 11\n```\n\n增加的联通块数(设这个矩阵为$g$):\n\n|      |      |      |      |\n| - | - | - | - |\n| 0    | 0    | 0    | 1    |\n| 1    | 0    | 2    | 1    |\n| 1    | 2    | 0    | 1    |\n| 1    | 0    | 0    | 0    |\n\n那么$f[i][k][j] = \\sum f[i-1][k-g[j][t]][t]$\n\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;rg char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\n#define N 1011\nconst int mod=998244353;\nint n,m,f[N][N*2][4],g[4][4]={\n    0,0,0,1,\n    1,0,2,1,\n    1,2,0,1,\n    1,0,0,0\n};\nsigned main(){\n    in(n,m);\n    f[1][1][0]=f[1][1][3]=f[1][2][1]=f[1][2][2]=1;\n    Fur(i,2,n)\n        Fur(k,1,2*i)\n            Fur(j,0,3)\n                Fur(t,0,3)\n                if(k-g[j][t]>0)\n                    (f[i][k][j]+=f[i-1][k-g[j][t]][t])%=mod;\n\n    ll ans=0;\n    Fur(t,0,3)(ans+=f[n][m][t])%=mod;\n    cout<<ans<<endl;\n}\n```\n","link":null,"tags":["动态规划"],"title":"LG CF1051D Bicolorings"},{"categories":[["刷题记录"]],"content":"\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i=x;i<=y;i++)\n    #define Fdr(i,x,y) for(int i=x;i>=y;i--)\n    #define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) (int(log2(n)))\n    #define inf 0x3f3f3f3f\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 10000000\nint mu[N+11],pri[N+11],tot=0,s[N+11];\nbool f[N+11];\nvoid sieve(){\n\tf[1]=mu[1]=1;\n\tFur(i,2,N){\n\t\tif(!f[i])pri[++tot]=i,mu[i]=-1;\n\t\tFur(j,1,tot){\n\t\t\tif(pri[j]*i>N)break;\n\t\t\tf[pri[j]*i]=1;\n\t\t\tif(i%pri[j])mu[i*pri[j]]=-mu[i];\n\t\t\telse break;\n\t\t}\n\t}\n\tFur(i,1,tot)\n\t\tfor(int j=1;pri[i]*j<=N;j++)\n\t\ts[j*pri[i]]+=mu[j];\n\tFur(i,1,N)s[i]+=s[i-1];\n}\nll solve(int a,int b){\n\tll ans=0;\n\tfor(int l=1,r=0;l<=a;l=r+1){\n\t\tr=MIN(a\/(a\/l),b\/(b\/l));\n\t\tans+=1ll*(s[r]-s[l-1])*(a\/l)*(b\/l);\n\t}\n\treturn ans;\n}\nint main(){\n\tfin(\"in\");\n\tint n,m,t;\n\tsieve();\n\tin>>t;\n\twhile(t--){\n\t\tin>>n>>m;\n\t\tif(n>m)SWAP(n,m);\n\t\tout<<solve(n,m)<<ln;\n\t}\n}\n\n```\n","link":null,"tags":[],"title":"LG 2257 YY的GCD"},{"categories":[["刷题记录"]],"content":"\n树形dp up and down\n\n$考虑 up$:\n\n设$s_x$为点$x$子树中所有点到$x$的距离之和\n\n$S_x = \\sum (s_{to}+siz_{to})$\n\n$考虑 down$:\n\n$s_{to} = s_{to} + (s_x-s_{to}-siz_{to}) + n - siz_{to}$\n\n\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i=x;i<=y;++i)\n    #define Fdr(i,x,y) for(int i=x;i>=y;--i)\n    #define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){clr(ch,0);if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 100011\nint n,cnt=0,head[N];\nstruct edge{\n    int to,nxt;\n}e[N*2];\nvoid add(int x,int y){\n    e[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;\n}\nint f[N],siz[N];\nll s[N];\nvoid up(int x){\n    siz[x]=1;\n    fl(i,x)if(to!=f[x]){\n        f[to]=x;\n        up(to);\n        siz[x]+=siz[to];\n        s[x]+=s[to]+siz[to];\n    }\n}\nvoid down(int x){\n    fl(i,x)if(to!=f[x])\n        s[to]+=(s[x]-(s[to]+siz[to]))+n-siz[to],\n        down(to);\n}\nint main(){\n    fin(\"in\");\n    in>>n;\n    int x,y;\n    Fur(i,1,n-1){\n        in>>x>>y;\n        add(x,y);add(y,x);\n    }\n    up(1);\n    down(1);\n    Fur(i,1,n)out<<s[i]<<ln;\n}\n```\n","link":null,"tags":["树形dp","动态规划"],"title":"51nod 1405 树的距离之和"},{"categories":[["刷题记录"]],"content":"\n树形dp 长链剖分\n\n[加强版](https:\/\/www.lydsy.com\/JudgeOnline\/problem.php?id=4543)\n\n先来考虑$1 \\le n \\le 5000$\n\n设$f[i][j]$表示在$i$的子树中与$i$距离为$j$的点数\n\n显然$f[i][j] = \\sum f[to][j-1](f[i][0] = 1)$\n\n设$g[i][j]$表示以$i$为根的子树中,点对$(x,y)$满足$x,y$到$lca(x,y)$距离都是$d$,并且$lca(x,y)$到$i$的距离为$d-j$的点对数\n\n$g[i][j] = \\sum g[to][j+1]$\n\n$ans = \\sum_{i=1}^n (g[i][0]+g[i][j] \\times f[to][j-1])$\n\n我们来考虑加强版\n\n$n \\le 100000$\n\n有点像静态链分治和树链剖分\n\n我们计算长链的时候结果不需要清空,其他儿子节点重新计算\n\n这样可以省下长链的时间\n\n长链剖分真是个毒瘤(指针毒瘤)\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i=x;i<=y;++i)\n    #define Fdr(i,x,y) for(int i=x;i>=y;--i)\n    #define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){clr(ch,0);if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\nconst int N(100011);\nint n,cnt=0,head[N];\nstruct edge{\n    int to,nxt;\n}e[N*2];\nvoid add(int x,int y){\n    e[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;\n}\nint d[N],mxd[N],son[N];\nvoid dfs(int x,int fa){\n    fl(i,x)if(to!=fa){\n        d[to]=d[x]+1;\n        dfs(to,x);\n        mxd[x]=MAX(mxd[x],mxd[to]);\n        if(mxd[to]>mxd[son[x]])son[x]=to;\n    }\n    mxd[x]=mxd[son[x]]+1;\n}\nll *f[N],*g[N],ans=0,pool[N<<2],*id=pool;\nvoid sol(int x,int fa){\n    if(son[x])f[son[x]]=f[x]+1,g[son[x]]=g[x]-1,sol(son[x],x);\n    f[x][0]=1;ans+=g[x][0];\n    fl(i,x)if(to!=fa&&to!=son[x]){\n        f[to]=id;id+=mxd[to]<<1;\n        g[to]=id;id+=mxd[to]<<1;\n        sol(to,x);\n        Fur(j,0,mxd[to]-1){\n            if(j)ans+=f[x][j-1]*g[to][j];\n            ans+=g[x][j+1]*f[to][j];\n        }\n        Fur(j,0,mxd[to]-1){\n            g[x][j+1]+=f[x][j+1]*f[to][j];\n            if(j)g[x][j-1]+=g[to][j];\n            f[x][j+1]+=f[to][j];\n        }\n    }\n}\nint main(){\n    fin(\"in\");\n    in>>n;\n    int x,y;\n    Fur(i,1,n-1)in>>x>>y,add(x,y),add(y,x);\n    dfs(1,0);\n    f[1]=id;id+=mxd[1]<<1;g[1]=id;id+=mxd[1]<<1;\n    sol(1,0);\n    out<<ans<<ln;\n}\n```\n","link":null,"tags":["树形dp","长链剖分"],"title":"LG 3565 [POI2014]HOT-Hotels"},{"categories":[["刷题记录"]],"content":"\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n\t#pragma GCC optimize(3)\n\t#define il __inline__ __attribute__ ((always_inline))\n\t#define rg register\n\t#define ll long long\n\t#define ull unsigned long long\n\t#define db double\n\t#define sht short\n\t#define MB template <class T>il\n\t#define Fur(i,x,y) for(int i=x;i<=y;i++)\n\t#define Fdr(i,x,y) for(int i=x;i>=y;i--)\n\t#define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n\t#define clr(x,y) memset(x,y,sizeof(x))\n\t#define cpy(x,y) memcpy(x,y,sizeof(x))\n\t#define fin(s) freopen(s\".in\",\"r\",stdin)\n\t#define fout(s) freopen(s\".out\",\"w\",stdout)\n\t#define fcin ios::sync_with_stdio(false)\n\t#define l2(n) (int(log2(n)))\n\t#define inf 0x3f3f3f3f\n\tMB T ABS(T x){return x>0?x:-x;}\n\tMB T MAX(T x,T y){return x>y?x:y;}\n\tMB T MIN(T x,T y){return x<y?x:y;}\n\tMB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n\tMB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 10011\nint n;\ndb f[N];\nint main(){\n\tin>>n;\n\tdb ans=0;\n\tFur(i,1,n)ans+=1.0*n\/(n-i+1);\n\tprintf(\"%.2f\\n\",ans);\n}\n```\n","link":null,"tags":[],"title":"LG 4550 收集邮票"},{"categories":[["刷题记录"]],"content":"\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;rg char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\n#define N 400011\n\/\/ #define int ll\n#define ls rt<<1\n#define rs rt<<1|1\n#define pu s[rt]=s[ls]|s[rs]\nint n,q;\nll s[N<<2],a[N],laz[N<<2];\nvoid build(int l,int r,int rt){\n    if(l==r){\n        s[rt]=(1ll<<a[l]);\n        return;\n    }\n    int m=(l+r)>>1;\n    build(l,m,ls);build(m+1,r,rs);\n    pu;\n}\nvoid pd(int rt){\n    if(laz[rt]){\n        s[ls]=s[rs]=laz[ls]=laz[rs]=laz[rt];\n        laz[rt]=0;\n    }\n}\nvoid upd(int L,int R,int v,int l,int r,int rt){\n    if(L<=l&&r<=R){\n        s[rt]=laz[rt]=(1ll<<v);\n        return;\n    }\n    int m=(l+r)>>1;\n    pd(rt);\n    if(L<=m)upd(L,R,v,l,m,ls);\n    if(R>m)upd(L,R,v,m+1,r,rs);\n    pu;\n}\nll ask(int L,int R,int l,int r,int rt){\n    if(L<=l&&r<=R)return s[rt];\n    int m=(l+r)>>1;\n    ll ans=0;\n    pd(rt);\n    if(L<=m)ans=ask(L,R,l,m,ls);\n    if(R>m)ans|=ask(L,R,m+1,r,rs);\n    return ans;\n}\nint dfn,L[N],R[N],cnt=0,head[N],c[N];\nstruct edge{\n    int to,nxt;\n}e[N*2];\nvoid add(int x,int y){e[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;}\nvoid dfs(int x){\n    L[x]=++dfn;\n    a[dfn]=c[x];\n    fl(i,x)if(!L[to])dfs(to);\n    R[x]=dfn;\n}\nsigned main(){\n    in(n,q);\n    Fur(i,1,n)in(c[i]);\n    int opt,x,y;\n    Fur(i,1,n-1)in(x,y),add(x,y),add(y,x);\n    dfs(1);\n    build(1,n,1);\n    while(q--){\n        in(opt,x);\n        if(opt==1){\n            in(y);\n            upd(L[x],R[x],y,1,n,1);\n        }\n        else{\n            ll t=ask(L[x],R[x],1,n,1),ans=0;\n            while(t)++ans,t-=(t&-t);\n            out(ans,ln);\n        }\n    }\n    flush();\n}\n```\n","link":null,"tags":["线段树","状态压缩"],"title":"LG CF620E New-Year-Tree"},{"categories":[["刷题记录"]],"content":"\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;rg char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\n#define N 100011\nint a[10][10],bl[10][10];\nbool h[10][10],l[10][10],block[10][10];\nint belong(int x,int y){\n    int p=(x-1)\/3+1,q=(y-1)\/3+1;\n    return (p-1)*3+q;\n}\nvoid add(int i,int j,int k){\n    l[i][k]^=1;\n    h[j][k]^=1;\n    block[bl[i][j]][k]^=1;\n}\nil bool chk(int x,int y,int k){\n    return !(l[x][k]||h[y][k]||block[bl[x][y]][k]);\n}\nil void op(){\n    Fur(i,1,9){\n        Fur(j,1,9)cout<<a[i][j]<<\" \";\n        cout<<endl;\n    }\n    exit(0);\n}\nvoid dfs(int x,int y){\n    if(a[x][y]){\n        if(x==9&&y==9)op();\n        if(y==9)dfs(x+1,1);\n        else dfs(x,y+1);\n    }\n    else\n    Fur(i,1,9)\n    if(chk(x,y,i)){\n        a[x][y]=i;\n        add(x,y,i);\n        if(x==9&&y==9)op();\n        if(y==9)dfs(x+1,1);\n        else dfs(x,y+1);\n        add(x,y,i);\n        a[x][y]=0;\n    }\n}\nint main(){\n    Fur(i,1,9)\n        Fur(j,1,9)\n        bl[i][j]=belong(i,j);\n\n    Fur(i,1,9)  \n        Fur(j,1,9){\n            cin>>a[i][j];\n            if(a[i][j])add(i,j,a[i][j]);\n        }\n\n    dfs(1,1);\n}\n```\n","link":null,"tags":["搜索"],"title":"LG 1784 数独"},{"categories":[["刷题记录"]],"content":"\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i=x;i<=y;i++)\n    #define Fdr(i,x,y) for(int i=x;i>=y;i--)\n    #define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) (int(log2(n)))\n    #define inf 0x3f3f3f3f\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 10000011\nint pri[N],tot=0;\nll phi[N];\nbool f[N];\nvoid ol(int n){\n    phi[1]=1;\n    Fur(i,2,n){\n        if(!f[i])phi[i]=i-1,pri[++tot]=i;\n        Fur(j,1,tot){\n            if(pri[j]*i>n)break;\n            f[i*pri[j]]=1;\n            if(i%pri[j])phi[i*pri[j]]=phi[i]*phi[pri[j]];\n            else{\n                phi[i*pri[j]]=phi[i]*pri[j];\n                break;\n            }\n        }\n    }\n    Fur(i,2,n)phi[i]+=phi[i-1];\n}\nint main(){\n\tfin(\"in\");\n    int T,n;ll ans=0;\n    in>>n;\n    ol(n);\n    Fur(i,1,tot)ans+=(phi[n\/pri[i]]*2-1);\n    out<<ans<<ln;\n}\n\n```\n","link":null,"tags":[],"title":"LG 2568 GCD"},{"categories":[["刷题记录"]],"content":"\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n\t#pragma GCC optimize(3)\n\t#define il __inline__ __attribute__ ((always_inline))\n\t#define rg register\n\t#define ll long long\n\t#define ull unsigned long long\n\t#define db double\n\t#define sht short\n\t#define MB template <class T>il\n\t#define Fur(i,x,y) for(int i=x;i<=y;i++)\n\t#define Fdr(i,x,y) for(int i=x;i>=y;i--)\n\t#define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n\t#define clr(x,y) memset(x,y,sizeof(x))\n\t#define cpy(x,y) memcpy(x,y,sizeof(x))\n\t#define fin(s) freopen(s\".in\",\"r\",stdin)\n\t#define fout(s) freopen(s\".out\",\"w\",stdout)\n\t#define fcin ios::sync_with_stdio(false)\n\t#define l2(n) (int(log2(n)))\n\t#define inf 0x3f3f3f3f\n\tMB T ABS(T x){return x>0?x:-x;}\n\tMB T MAX(T x,T y){return x>y?x:y;}\n\tMB T MIN(T x,T y){return x<y?x:y;}\n\tMB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n\tMB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 22\nint n,a[N],s=0;\nbool cmp(int x,int y){return x>y;}\nvoid dfs(){\n\n}\nint main(){\n\tfin(\"in\");\n\tin>>n;\n\tFur(i,1,n)in>>a[i],s+=a[i];\n\tsort(a+1,a+n+1,cmp);\n\n}\n```\n","link":null,"tags":[],"title":"LG 3067 [USACO12OPEN]平衡的奶牛群"},{"categories":[["刷题记录"]],"content":"\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i=x;i<=y;++i)\n    #define Fdr(i,x,y) for(int i=x;i>=y;--i)\n    #define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) (int(log2(n)))\n    #define inf 0x3f3f3f3f\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){clr(ch,0);if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 2000011\n#define base 23333\nconst int mod = 19930726;\nint n,ans=1,cnt[N];\null h[N],H[N],pw[N];\nll k;\nchar s[N];\nil ull g(int l,int r){\n    return h[r]-h[l-1]*pw[r-l+1];\n}\nil ull G(int l,int r){\n    return H[l]-H[r+1]*pw[r-l+1];\n}\nil void ask(int x){\n    int l=1,r=MIN(x,n-x);\n    while(l<=r) {\n        int m=(l+r)>>1;\n        if(g(x-m,x+m)==G(x-m,x+m))\n            l=m+1;\n        else r=m-1;\n    }\n    cnt[r<<1|1]++;\n}\nil int px(int x,ll p){\n    int ans=1;\n    while(p){\n        if(p&1)ans=(1ll*ans*x)%mod;\n        p>>=1;x=(1ll*x*x)%mod;\n    }\n    return ans;\n}\nsigned main(){\n    fin(\"in\");\n    in>>n>>k>>(s+1);\n    pw[0]=1;\n    Fur(i,1,n)\n        h[i]=h[i-1]*base+s[i],\n        pw[i]=pw[i-1]*base;\n\n    Fdr(i,n,1)H[i]=H[i+1]*base+s[i];\n    Fur(i,1,n)ask(i);\n    ll sum=0;\n    for(int i=n-!(n&1);i>=1;i-=2){\n        sum+=cnt[i];\n        if(sum<=k){\n            ans=(1ll*ans*px(i,sum))%mod;\n            k-=sum;\n        }\n        else{\n            ans=(1ll*ans*px(i,k))%mod;\n            k=0;\n            break;\n        }\n    }\n    if(k>0)ans=-1;\n    out<<ans<<ln;\n}\n```\n","link":null,"tags":["hash","马拉车"],"title":"LG 1659 [国家集训队]拉拉队排练"},{"categories":[["刷题记录"]],"content":"\n先筛选出$d_a,d_b,d_c$\n\n如果$a,b,c$的约数都不相同,那么$ans = d_a \\cdot d_b \\cdot d_c$\n\n我们来考虑要减去的部分\n\n$(a,b,c) , (b,a,c)$这样的是不符合的,减去其中一个\n\n也就是减去$d(gcd(a,b))\\times(d(gcd(a,b)-1))$\n\n同理,$(a,c,b),(c,b,a)$也要减去.\n\n这样的话会多减了一个$d(gcd(a,b,c))*(d(gcd(a,b,c))-1)$,要加回来\n\n...\n\nhttps:\/\/www.luogu.com.cn\/blog\/lingchi\/solution-cf1008d\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;rg char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\n#define N 100011\n#define int ll\nint n,d[N],pri[N],tot=0,a[N];\nbool v[N];\nvoid sieve(){\n    n=100000;\n    v[1]=1;\n    d[1]=1;\n    Fur(i,2,n){\n        if(!v[i])pri[++tot]=i,a[i]=1,d[i]=2;\n        for(int j=1;j<=tot&&i*pri[j]<=n;++j){\n            v[i*pri[j]]=1;\n            if(i%pri[j])d[i*pri[j]]=d[i]*d[pri[j]],a[i*pri[j]]=1;\n            else{\n                d[i*pri[j]]=d[i]\/(a[i]+1)*(a[i]+2);\n                a[i*pri[j]]=a[i]+1;\n                break;\n            }\n        }\n    }\n}\nil ll Qjy(ll u){return u*(u-1);}\nvoid work(){\n    int a,b,c;\n    in(a,b,c);\n    int ga=GCD(b,c),gb=GCD(a,c),gc=GCD(a,b),gg=GCD(ga,a);\nprintf(\"%lld\\n\", d[a] * d[b] * d[c]\n  - (d[a] * Qjy(d[ga]) + d[b] * Qjy(d[gb]) + d[c] * Qjy(d[gc]) >> 1)\n  + (Qjy(d[gg]) * (d[gg] - 2) \/ 3 << 1)\n  + (Qjy(d[gg]) * (d[ga] + d[gb] + d[gc] - 3 * d[gg] + 2) >> 1)\n  - (d[ga] - d[gg]) * (d[gb] - d[gg]) * (d[gc] - d[gg]));\n}\nsigned main(){\n    sieve();\n    int T;in(T);\n    while(T--)work();\n    flush();\n}\n```\n","link":null,"tags":["容斥","思维","数论","筛法","约数"],"title":"LG CF1008D Pave-the-Parallelepiped"},{"categories":[["刷题记录"]],"content":"\nD-query\ntop: 0\n\n\n就是莫队的板子题\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;rg char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\n#define N 30011\nint n,sz,Q,a[N],cnt[1000011];\nstruct que{\n    int l,r,id;\n}q[200011];\nil int bl(int x){return (x-1)\/sz+1;}\nbool cmp(que x,que y){\n    if(bl(x.l)==bl(y.l))return x.r<y.r;\n    return x.l<y.l;\n}\nint ans,ANS[200011];\nil void add(int x){if(!cnt[a[x]]++)++ans;}\nil void del(int x){if(!--cnt[a[x]])--ans;}\nint main(){\n    in(n);sz=sqrt(n);\n    Fur(i,1,n)in(a[i]);\n    in(Q);\n    Fur(i,1,Q)in(q[i].l,q[i].r),q[i].id=i;\n    sort(q+1,q+Q+1,cmp);\n    int l=0,r=0;\n    Fur(i,1,Q){\n        Fur(j,l,q[i].l-1)del(j);\n        Fdr(j,l-1,q[i].l)add(j);\n        Fur(j,r+1,q[i].r)add(j);\n        Fdr(j,r,q[i].r+1)del(j);\n        ANS[q[i].id]=ans;\n        l=q[i].l;r=q[i].r;\n    }\n    Fur(i,1,Q)out(ANS[i],ln);\n    flush();\n}\n```\n","link":null,"tags":["莫队"],"title":"LG SP3267 DQUERY"},{"categories":[["刷题记录"]],"content":"\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n\t#pragma GCC optimize(3)\n\t#define il __inline__ __attribute__ ((always_inline))\n\t#define rg register\n\t#define ll long long\n\t#define ull unsigned long long\n\t#define db double\n\t#define sht short\n\t#define MB template <class T>il\n\t#define Fur(i,x,y) for(int i=x;i<=y;i++)\n\t#define Fdr(i,x,y) for(int i=x;i>=y;i--)\n\t#define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n\t#define clr(x,y) memset(x,y,sizeof(x))\n\t#define cpy(x,y) memcpy(x,y,sizeof(x))\n\t#define fin(s) freopen(s\".in\",\"r\",stdin)\n\t#define fout(s) freopen(s\".out\",\"w\",stdout)\n\t#define fcin ios::sync_with_stdio(false)\n\t#define l2(n) (int(log2(n)))\n\t#define inf 0x3f3f3f3f\n\tMB T ABS(T x){return x>0?x:-x;}\n\tMB T MAX(T x,T y){return x>y?x:y;}\n\tMB T MIN(T x,T y){return x<y?x:y;}\n\tMB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n\tMB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 10011\nint f[N],s[N];\nvoid sl(int x){\n\twhile(x)out<<(x&1),x>>=1;out<<ln;\n}\nint main(){\n\tint n;in>>n;\n\tf[1]=1;f[3]=3;\n\tf[2]=1;\n\tFur(i,1,n){\n\t\ts[i]=s[i-1];\n\t\tif(i%2==0)f[i]=f[i>>1];\n\t\tif(i>4){\n\t\tif(i%4==1){\n\t\t\tint t=i>>2;\n\t\t\tf[i]=2*f[2*t+1]-f[t];\n\t\t}\n\t\tif(i%4==3){\n\t\t\tint t=i>>2;\n\t\t\tf[i]=3*f[2*t+1]-2*f[t];\n\t\t}\n\t\t}\n\t\tif(f[i]==i)sl(i);\n\t}\n}\n```\n","link":null,"tags":[],"title":"LG 2235 [HNOI2002]Kathy函数"},{"categories":[["刷题记录"]],"content":"\n枚举当前合法序列放了多少个$i(2i>n)$的,记数量为$x$,那么对于$i(2i\\le n)$的数量为$m-x$。\n\n对于答案的贡献为$x!\\times (m-x)!\\times {x \\times C(m-x)} \\times {C(x,\\frac{n}{2}})\\times {C({m-x},\\frac{n+1}{2}})$\n\n（因为第二类数只能放在第一类数前面,所以一共$x$个空放$m-x$个数,方案为$C({m-x},x)$\n\n选出$x$个第一类数和$vm-x$个第二类数的方案分别为$C(x,\\frac{n}{2})$和$C({m-x},\\frac{n+1}{2})$\n\n然后$x$个数和$m-x$个数的排列为$x!$和$(m-x)!$。\n\n所以就得到了这个贡献式子\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i=x;i<=y;++i)\n    #define Fdr(i,x,y) for(int i=x;i>=y;--i)\n    #define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) (int(log2(n)))\n    #define inf 0x3f3f3f3f\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){clr(ch,0);if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 1000011\nconst int mod=1000000007;\nint n,m,f[N],inv[N];\nint pw(int x,int p){\n\tint ans=1;\n\twhile(p){\n\t\tif(p&1)ans=1ll*ans*x%mod;\n\t\tp>>=1;x=1ll*x*x%mod;\n\t}\n\treturn ans;\n}\nint C(int x,int y){\n\treturn 1ll*f[x]*inv[y]%mod*inv[x-y]%mod;\n}\nint main(){\n\tcin>>n>>m;\n\tif(m>n)return out<<\"0\\n\",0;\n\tf[0]=1;Fur(i,1,1000000)f[i]=1ll*f[i-1]*i%mod;\n\tinv[1000000]=pw(f[1000000],mod-2);Fdr(i,1000000-1,0)inv[i]=1ll*inv[i+1]*(i+1)%mod;\n\tll ans=0;\n\tFur(i,(m+1)\/2,MIN((n+1)\/2,m)){\n\t\tans+=1ll*f[i]%mod*f[m-i]%mod*C(i,m-i)%mod*C((n+1)\/2,i)%mod*C(n\/2,m-i)%mod;\n\t\tans%=mod;\n\t}\n\tout<<ans<<ln;\n}\n\n```\n","link":null,"tags":[],"title":"51nod 2717 小Biu的序列"},{"categories":[["刷题记录"]],"content":"\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i=x;i<=y;++i)\n    #define Fdr(i,x,y) for(int i=x;i>=y;--i)\n    #define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) (int(log2(n)))\n    #define inf 0x3f3f3f3f\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){clr(ch,0);if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 100011\n#define int ll\nint n,f[N],c[N],v[N],w[N],q[N],t[N];\nsigned main(){\n    fin(\"in\");\n    in>>n;\n    Fur(i,1,n){\n        in>>f[i]>>w[i]>>v[i];\n        if(f[i]!=-1)c[f[i]]++;\n    }\n    int tp=0;ll ans=0;\n    Fur(i,1,n)if(!c[i])q[++tp]=i;\n    while(tp){\n        int x=q[tp--];\n        if(w[x]-t[x]>0)ans+=1ll*(w[x]-t[x])*v[x];\n        if(f[x]==-1)break;\n        t[f[x]]+=MAX(w[x],t[x]);v[f[x]]=MIN(v[f[x]],v[x]);\n        if(--c[f[x]]==0)q[++tp]=f[x];\n    }\n    out<<ans<<ln;\n}\n\n```\n","link":null,"tags":["拓扑序"],"title":"LG 3018 [USACO11MAR]树装饰Tree Decoration"},{"categories":[["刷题记录"]],"content":"\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n\t#pragma GCC optimize(3)\n\t#define il __inline__ __attribute__ ((always_inline))\n\t#define rg register\n\t#define ll long long\n\t#define ull unsigned long long\n\t#define db double\n\t#define sht short\n\t#define MB template <class T>il\n\t#define Fur(i,x,y) for(int i=x;i<=y;i++)\n\t#define Fdr(i,x,y) for(int i=x;i>=y;i--)\n\t#define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n\t#define clr(x,y) memset(x,y,sizeof(x))\n\t#define cpy(x,y) memcpy(x,y,sizeof(x))\n\t#define fin(s) freopen(s\".in\",\"r\",stdin)\n\t#define fout(s) freopen(s\".out\",\"w\",stdout)\n\t#define fcin ios::sync_with_stdio(false)\n\t#define l2(n) (int(log2(n)))\n\t#define inf 0x3f3f3f3f\n\tMB T ABS(T x){return x>0?x:-x;}\n\tMB T MAX(T x,T y){return x>y?x:y;}\n\tMB T MIN(T x,T y){return x<y?x:y;}\n\tMB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n\tMB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 5000111\nchar a[N];\nint n;\nint main(){\n\tin>>n>>(a+1);\n\t\n}\n```\n","link":null,"tags":[],"title":"LG 1709 [USACO5.5]隐藏口令Hidden-Password"},{"categories":[["刷题记录"]],"content":"\n把站位当作抵消的部分\n\n建立两棵线段树,统计$x$轴和$y$轴被覆盖的情况\n\n每次的答案就是\n\n放过的行数×行长度+放过的列数×列长度-抵消块数\n\n抵消块数就是$x$轴被覆盖行数$\\times y$轴被覆盖行数 $\\times 2$\n\n\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i=x;i<=y;i++)\n    #define Fdr(i,x,y) for(int i=x;i>=y;i--)\n    #define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) (int(log2(n)))\n    #define inf 0x3f3f3f3f\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){clr(ch,0);if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 100011\n#define ls rt<<1\n#define rs rt<<1|1\nint P[N<<2],Q[N<<2],n,m;\nvoid upd(int *s,int x,int l,int r,int rt){\n\tif(l==r){\n\t\ts[rt]^=1;\n\t\treturn;\n\t}\n\tint m=(l+r)>>1;\n\tif(x<=m)upd(s,x,l,m,ls);\n\telse upd(s,x,m+1,r,rs);\n\ts[rt]=s[ls]+s[rs];\n}\nint ask(int *s,int L,int R,int l,int r,int rt){\n\tif(L<=l&&r<=R)return s[rt];\n\tint m=(l+r)>>1,ans=0;\n\tif(L<=m)ans=ask(s,L,R,l,m,ls);\n\tif(R>m)ans+=ask(s,L,R,m+1,r,rs);\n\treturn ans;\n}\nint main(){\n\tfin(\"in\");\n\tint q;\n\tin>>n>>m>>q;\n\tint u,x,y,X,Y;\n\twhile(q--){\n\t\tin>>u>>x>>y;\n\t\tif(u==2){\n\t\t\tin>>X>>Y;\n\t\t\tint a=ask(P,x,X,1,n,1),b=ask(Q,y,Y,1,m,1);\n\t\t\tout<<(1ll*a*(Y-y+1)+1ll*b*(X-x+1)-2ll*a*b)<<ln;\n\t\t}\n\t\telse upd(P,x,1,n,1),upd(Q,y,1,m,1);\n\t}\n}\n\n```\n","link":null,"tags":["线段树","容斥"],"title":"LG 3801 红色的幻想乡"},{"categories":[["刷题记录"]],"content":"\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i=x;i<=y;++i)\n    #define Fdr(i,x,y) for(int i=x;i>=y;--i)\n    #define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){clr(ch,0);if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 100011\nint n;\nint main(){\n    \n}\n```\n","link":null,"tags":["状态压缩","动态规划","状压dp"],"title":"LG 2157 [SDOI2009]学校食堂"},{"categories":[["刷题记录"]],"content":"\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i=x;i<=y;i++)\n    #define Fdr(i,x,y) for(int i=x;i>=y;i--)\n    #define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) (int(log2(n)))\n    #define inf 0x3f3f3f3f\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){clr(ch,0);if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 1002\nint n,s[N][N],b[N][N],ans=0,as=0;\nstruct node{\n\tint x,y;\n}a[N];\nint main(){\n\tfin(\"in\");\n\tin>>n;\n\tint x,y,X,Y,tot=0;char ch;\n\tFur(i,1,n){\n\t\tin>>x>>y>>ch;\n\t\tif(ch=='H')s[x][y]=1,++tot,a[tot].x=x,a[tot].y=y;\n\t\telse b[x][y]=1;\n\t}\n\tFur(i,1,1000)\n\t\ts[0][i]+=s[0][i-1],\n\t\ts[i][0]+=s[i-1][0],\n\t\tb[0][i]+=b[0][i-1],\n\t\tb[i][0]+=b[i-1][0];\n\t\n\tFur(i,1,1001)\n\t\tFur(j,1,1001)\n\t\ts[i][j]+=s[i-1][j]+s[i][j-1]-s[i-1][j-1],\n\t\tb[i][j]+=b[i-1][j]+b[i][j-1]-b[i-1][j-1];\n\t\n\tFur(i,1,tot)\n\t\tFur(j,1,tot)\n\t\t\tFur(k,1,tot)\n\t\t\t\tFur(w,1,tot){\n\t\t\t\t\tx=MIN(MIN(a[i].x,a[j].x),MIN(a[k].x,a[w].x));\n\t\t\t\t\ty=MIN(MIN(a[i].y,a[j].y),MIN(a[k].y,a[w].y));\n\t\t\t\t\tX=MAX(MAX(a[i].x,a[j].x),MIN(a[k].x,a[w].x));\n\t\t\t\t\tY=MAX(MAX(a[i].y,a[j].y),MIN(a[k].y,a[w].y));\n\t\t\t\t\tif(b[X][Y]-b[X][y-1]-b[x-1][Y]+b[x-1][y-1])continue;\n\t\t\t\t\tint t=s[X][Y]-s[X][y-1]-s[x-1][Y]+s[x-1][y-1],tt=(X-x)*(Y-y);\n\t\t\t\t\tif(t>as)ans=tt,as=t;\n\t\t\t\t\telse if(t==as)ans=MIN(ans,tt);\n\t\t\t}\n\tout<<as<<ln<<ans<<ln;\n}\n\n```\n","link":null,"tags":[],"title":"LG 3117 [USACO15JAN]牛的矩形Cow Rectangles"},{"categories":[["刷题记录"]],"content":"\n设$f[i][k]$为第$i$位,分成$k$段\n\n$f[i][k] = MAX(f[j][k-1] + cnt[j+1][i])$\n\n这样的话肯定复杂度爆炸\n\n既然看到$MAX$,那是不是可以用线段树优化呢？\n\n记录每个点贡献的范围,更新时把这个范围的点++就可以了。\n\n相信看代码可以看懂\n\n~~其实我还加了滚动数组OwO~~\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n\t#pragma GCC optimize(3)\n\t#define il __inline__ __attribute__ ((always_inline))\n\t#define rg register\n\t#define ll long long\n\t#define ull unsigned long long\n\t#define db double\n\t#define sht short\n\t#define MB template <class T>il\n\t#define Fur(i,x,y) for(int i=x;i<=y;i++)\n\t#define Fdr(i,x,y) for(int i=x;i>=y;i--)\n\t#define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n\t#define clr(x,y) memset(x,y,sizeof(x))\n\t#define cpy(x,y) memcpy(x,y,sizeof(x))\n\t#define fin(s) freopen(s\".in\",\"r\",stdin)\n\t#define fout(s) freopen(s\".out\",\"w\",stdout)\n\t#define fcin ios::sync_with_stdio(false)\n\t#define l2(n) (int(log2(n)))\n\t#define inf 0x3f3f3f3f\n\tMB T ABS(T x){return x>0?x:-x;}\n\tMB T MAX(T x,T y){return x>y?x:y;}\n\tMB T MIN(T x,T y){return x<y?x:y;}\n\tMB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n\tMB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 35011\nint pre[N],p[N],n,k,s[N<<2],laz[N<<2],f[N];\n#define ls rt<<1\n#define rs rt<<1|1\n#define pu s[rt]=MAX(s[ls],s[rs]);\nvoid build(int l,int r,int rt){\n\tif(l==r){\n\t\ts[rt]=f[l-1];laz[rt]=0;\n\t\treturn;\n\t}\n\tint m=(l+r)>>1;\n\tbuild(l,m,ls);build(m+1,r,rs);\n\tpu;\n}\nvoid pd(int rt){\n\tif(laz[rt]){\n\t\tlaz[ls]+=laz[rt];laz[rs]+=laz[rt];\n\t\ts[ls]+=laz[rt];s[rs]+=laz[rt];\n\t\tlaz[rt]=0;\n\t}\n}\nvoid upd(int L,int R,int l,int r,int rt){\n\tif(L<=l&&r<=R){\n\t\ts[rt]++;\n\t\tlaz[rt]++;\n\t\treturn;\n\t}\n\tint m=(l+r)>>1;\n\tpd(rt);\n\tif(L<=m)upd(L,R,l,m,ls);\n\tif(R>m)upd(L,R,m+1,r,rs);\n\tpu;\n}\nint ask(int L,int R,int l,int r,int rt){\n\tif(L<=l&&r<=R)return s[rt];\n\tint m=(l+r)>>1,ans=0;\n\tpd(rt);\n\tif(L<=m)ans=ask(L,R,l,m,ls);\n\tif(R>m)ans=MAX(ans,ask(L,R,m+1,r,rs));\n\treturn ans;\n}\nint main(){\n\tin>>n>>k;\n\tint x;\n\tFur(i,1,n)\n\t\tin>>x,\n\t\tpre[i]=p[x]+1,\n\t\tp[x]=i;\n\t\t\n\tFur(i,1,k){\n\t\tclr(laz,0);clr(s,0);\n\t\tbuild(1,n,1);\n\t\tFur(j,1,n)\n\t\t\tupd(pre[j],j,1,n,1),\n\t\t\tf[j]=ask(1,j,1,n,1);\n\t}\n\tout<<f[n]<<ln;\n}\n```\n","link":null,"tags":["动态规划","线段树"],"title":"LG CF833B The-Bakery"},{"categories":[["刷题记录"]],"content":"\n离线处理,倒着添加\n\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i=x;i<=y;++i)\n    #define Fdr(i,x,y) for(int i=x;i>=y;--i)\n    #define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) (int(log2(n)))\n    #define inf 0x3f3f3f3f\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){clr(ch,0);if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 300011\nconst int mod = 317847191;\npriority_queue<int>p,dp;\npriority_queue<int,vector<int>,greater<int> >q,dq;\nint n,m,s=1;\nil int gmx(){\n    while(!dp.empty()&&p.top()==dp.top())p.pop(),dp.pop();\n    return p.top();\n}\nil int gmi(){\n    while(!dq.empty()&&q.top()==dq.top())q.pop(),dq.pop();\n    return q.top();\n}\nil int pw(int x,int p){\n    int ans=1;\n    while(p){\n        if(p&1)ans=(ans*x)%mod;\n        p>>=1;x=(x*x)%mod;\n    }\n    return ans;\n}\nint main(){\n    fin(\"in\");\n    in>>n>>m;\n    int x;char ch;\n    Fur(i,1,n)in>>x,p.push(x),q.push(x),s=(s*x)%mod;\n    while(m--){\n        in>>ch;\n        if(ch=='D'){\n            in>>x;\n            dp.push(x);dq.push(x);\n            s=(s*pw(x,mod-2)%mod+mod)%mod;\n        }\n        if(ch=='B')\n            out<<gmx()<<ln;\n        if(ch=='S')\n            out<<gmi()<<ln;\n        if(ch=='M')\n            out<<pw(gmx(),gmi())<<ln;\n        if(ch=='T')\n            out<<s<<ln;\n    }\n}\n```\n","link":null,"tags":["离线","堆"],"title":"LG 2174 小Z的神奇数列"},{"categories":[["刷题记录"]],"content":"\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i=x;i<=y;++i)\n    #define Fdr(i,x,y) for(int i=x;i>=y;--i)\n    #define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) (int(log2(n)))\n    #define inf 0x3f3f3f3f\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){clr(ch,0);if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 300011\nint n,m,a[N],mi[N];\nint main(){\n    fin(\"in\");\n    in>>n>>m;\n    a[0]=(1<<30);mi[0]=0;\n    Fur(i,1,n){\n        in>>a[i];\n        mi[i]=(a[mi[i-1]]<=a[i])?mi[i-1]:i;\n    }\n    mi[n+1]=mi[n];\n    int x,p=n+1;\n    while(m--){\n        in>>x;\n        if(a[mi[p]]<x){\n            while(a[mi[p]]<x)p=mi[p]-1;\n        }\n        else p--;\n    }\n    if(p<0)out<<\"0\\n\";\n    else out<<p<<ln;\n}\n```\n","link":null,"tags":["模拟"],"title":"LG 3434 [POI2006]KRA-The Disks"},{"categories":[["刷题记录"]],"content":"\n构造$1 \\times n$的矩阵$X$\n\n矩阵满足\n\n$\\because A \\times B = C$\n\n$\\therefore X \\times A \\times B = X \\times C$\n\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n\t#pragma GCC optimize(3)\n\t#define il __inline__ __attribute__ ((always_inline))\n\t#define rg register\n\t#define ll long long\n\t#define ull unsigned long long\n\t#define db double\n\t#define sht short\n\t#define MB template <class T>il\n\t#define Fur(i,x,y) for(int i=x;i<=y;i++)\n\t#define Fdr(i,x,y) for(int i=x;i>=y;i--)\n\t#define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n\t#define clr(x,y) memset(x,y,sizeof(x))\n\t#define cpy(x,y) memcpy(x,y,sizeof(x))\n\t#define fin(s) freopen(s\".in\",\"r\",stdin)\n\t#define fout(s) freopen(s\".out\",\"w\",stdout)\n\t#define fcin ios::sync_with_stdio(false)\n\t#define l2(n) (int(log2(n)))\n\t#define inf 0x3f3f3f3f\n\tMB T ABS(T x){return x>0?x:-x;}\n\tMB T MAX(T x,T y){return x>y?x:y;}\n\tMB T MIN(T x,T y){return x<y?x:y;}\n\tMB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n\tMB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){clr(ch,0);if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 511\nint a[N][N],b[N][N],X[1][N],n,c[N][N],C[N][N];\nbool t=0;\nvoid times(int a[N][N], int b[N][N]){\n\tclr(c,0);\n\tFur(i,1,n)\n\t\tFur(j,1,n)\n\t\t\tFur(k,1,n)\n\t\t\t\tc[i][j] += a[i][k] * b[k][j];\n\n\tif(t)cpy()\n}\nint main(){\n\tsrand((int)time(NULL));\n\tin>>n;\n\tFur(i,1,n)\n\t\tFur(j,1,n)\n\t\t\tin>>a[i][j];\n\n\tFur(i,1,n)\n\t\tFur(j,1,n)\n\t\t\tin>>b[i][j];\n\n\tFur(i,1,n)\n\t\tFur(j,1,n)\n\t\t\tin>>c[i][j];\n\t\n\tFur(i,1,n)X[1][n] = rand()%17;\n\n\ttimes(X,a,c);times(C,b,C);times(c,X,c);\n\n\tbool f = 1;\n\tFur(i,1,n)\n\tif(f)\n\t\tFur(j,1,n)\n\t\tif(c[i][j] != C[i][j]){\n\t\t\tf = 0;\n\t\t\tbreak;\n\t\t}\n\tif(f) out << \"Yes\\n\";\n\telse out << \"No\\n\";\n}\n```\n","link":null,"tags":[],"title":"51nod 1140 矩阵相乘结果的判断"},{"categories":[["刷题记录"]],"content":"\n我们可以发现$gcd(a_l,...,a_r)$是单调递减的,而$or(a_l,...,a_r)$是单调递增的\n\n所以我们可以两次二分来找到合法区间\n\n至于求$gcd(a_l,...,a_r),or(a_l,...,a_r)$我们可以用$rmq$来求\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;rg char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\n#define N 500011\nint n,k,a[N],f[21][N],g[21][N];\nvoid st(){\n    Fur(i,1,n)f[0][i]=g[0][i]=a[i];\n    Fur(i,1,20)\n        Fur(j,1,n-(1<<i)+1){\n            f[i][j]=f[i-1][j]|f[i-1][j+(1<<(i-1))];\n            g[i][j]=GCD(g[i-1][j],g[i-1][j+(1<<(i-1))]);\n        }\n}\nint g1(int l,int r){\n    int sz=l2(r-l+1);\n    return f[sz][l]|f[sz][r-(1<<sz)+1];\n}\nint g2(int l,int r){\n    int sz=l2(r-l+1);\n    return GCD(g[sz][l],g[sz][r-(1<<sz)+1]);\n}\nll ans=0;\nint find(int s,int x,int l,int r){\n    int as;\n    while(l<=r){\n        int m=(l+r)>>1,z=g2(s,m);\n        if(x==z)as=m,l=m+1;\n        else r=m-1;\n    }\n    return as;\n}\nvoid solve(int s,int x,int l,int r){\n    int L=l,R=r,num=0,Num=-1; \n    while(l<=r){\n        int m=(l+r)>>1,z=g1(s,m);\n        if(x==z)r=m-1,num=m; \n        else if(x<z)r=m-1;\n        else if(x>z)l=m+1;\n    }\n    while(L<=R){\n        int m=(L+R)>>1,z=g1(s,m);\n        if(x==z)L=m+1,Num=m;\n        else if(x<z)R=m-1;\n        else if(x>z)L=m+1;\n    }\n    ans+=Num-num+1;\n}\nint main(){\n    in(n,k);\n    Fur(i,1,n)in(a[i]);\n    st();\n    Fur(i,1,n)\n        Fur(j,i,n){\n            int t=g2(i,j),p=find(i,t,j,n);\n            solve(i,t^k,j,p);\n            j=p;\n        }\n    printf(\"%lld\\n\",ans);\n}\n```\n","link":null,"tags":["rmq","二分"],"title":"LG 3794 签到题IV"},{"categories":[["刷题记录"]],"content":"\n数位dp模板题\n\n我们先不考虑前导$0$,那么满i位所有数字出现的次数是相同的\n\n设$f_i$为满$i$位数字出现的个数(因为相同就不需要再加一维了)\n\n那么$f_i = f_{i-1} \\times 10 + 10^{i-1}$\n\n($(0-9)+(0-9.....)$)\n\n($0-9:10^{i-1},(0-9.....):f_{i-1} \\times 10$)\n\n\n\n我们来想想$ABCD$的答案\n\n先考虑$A000$中的$000$,每种数据出现的次数是$A \\times f_3$(因为$A$后面有$3$位)\n\n那么$0$~$A-1$出现的次数还要加上$10^{i-1}$($X xxx(xxx:0-999)$)\n\n\n\n接着考虑$ABCD$中的$BCD$,$A$出现的次数加上$BCD+1(000-BCD)$\n\n\n\n最后减去前导$0$,也就是$0001,0002,...0101,0102,...,0999$这些,那么$0$出现的次数减去$10^{i-1}$\n\n\n\n答案就是$solve(r)-solve(l-1)$\n\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n\t#pragma GCC optimize(3)\n\t#define il __inline__ __attribute__ ((always_inline))\n\t#define rg register\n\t#define ll long long\n\t#define ull unsigned long long\n\t#define db double\n\t#define sht short\n\t#define MB template <class T>il\n\t#define Fur(i,x,y) for(int i=x;i<=y;i++)\n\t#define Fdr(i,x,y) for(int i=x;i>=y;i--)\n\t#define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n\t#define clr(x,y) memset(x,y,sizeof(x))\n\t#define cpy(x,y) memcpy(x,y,sizeof(x))\n\t#define fin(s) freopen(s\".in\",\"r\",stdin)\n\t#define fout(s) freopen(s\".out\",\"w\",stdout)\n\t#define fcin ios::sync_with_stdio(false)\n\t#define l2(n) (int(log2(n)))\n\t#define inf 0x3f3f3f3f\n\tMB T ABS(T x){return x>0?x:-x;}\n\tMB T MAX(T x,T y){return x>y?x:y;}\n\tMB T MIN(T x,T y){return x<y?x:y;}\n\tMB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n\tMB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 10011\nll f[N],a,b,A[10],B[10],ten[N];\nvoid solve(ll x,ll *cnt){\n\tint num[20]={0},len=0;\n\tll t=x;\n\twhile(x){\n\t\tnum[++len]=x%10,x\/=10;\n\t}\n\tFdr(i,len,1){\n\t\tFur(j,0,9)cnt[j]+=f[i-1]*num[i];\n\t\tFur(j,0,num[i]-1)cnt[j]+=ten[i-1];\n\t\tt%=ten[i-1];\n\t\tcnt[num[i]]+=t+1;\n\t\tcnt[0]-=ten[i-1];\t\t\n\t}\n}\nint main(){\n\tin>>a>>b;\n\tten[0]=1;\n\tFur(i,1,12)\n\t\tf[i]=f[i-1]*10+ten[i-1],\n\t\tten[i]=ten[i-1]*10;\n\t\t\n\tsolve(a-1,A);solve(b,B);\n\tFur(i,0,9)out<<B[i]-A[i]<<\" \";\n}\n```\n","link":null,"tags":["数位dp"],"title":"LG 2602 [ZJOI2010]数字计数"},{"categories":[["刷题记录"]],"content":"\n~~一看就是树剖~~\n\n先设所有情报员开始搜索情报的时间(我们假设给这个情报员赋值)是$q$,即询问个数\n\n对于第$i$个询问如果是查询,则查找值比$i-c$小的情报员有多少个(树剖)\n\n参与传递的人数显然是$d_x+d_y-2 \\times d_{LCA(x,y)} + 1$\n\n如果是让某个情报员开始搜集,则把这个情报员赋值为$i$\n\n### 解法一：\n\n套个主席树应该就可以了(请参见楼下)\n\n### 解法二：\n\n离线按照权值排序添加,然后用线段树或树状数组统计就可以了)\n\n```cpp\n#include<bits\/stdc++.h>\n#pragma GCC optimize(3)\n#define il __inline__ __attribute__ ((always_inline))\n#define Fur(i,x,y) for(int i=x;i<=y;++i)\n#define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\nil void SWAP(int &x,int &y){int t=x;x=y;y=t;}\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 200011\nint n,cnt=0,head[N],RT;\nstruct edge{\n    int to,nxt;\n}e[N];\nil void add(int x,int y){\n    e[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;\n}\nint top[N],f[N],siz[N],d[N],id[N],sz=0;\nvoid dfs(int x){\n    siz[x]=1;\n    fl(i,x){\n        f[to]=x;d[to]=d[x]+1;\n        dfs(to);siz[x]+=siz[to];\n    }\n}\nvoid bt(int x,int tp){\n    id[x]=++sz;top[x]=tp;int k=0;\n    fl(i,x)if(siz[to]>siz[k])k=to;\n    if(!k)return;bt(k,tp);\n    fl(i,x)if(to!=k)bt(to,to);\n}\nint s[N];\nil void upd(int x){\n    while(x<=n)++s[x],x+=(x&-x);\n}\nil int ask(int x){\n    int ans=0;\n    while(x)ans+=s[x],x^=(x&-x);\n    return ans;\n}\nint a1[N],a2[N];\nstruct que{\n    int x,y,c,id;\n    il bool operator<(que a){\n        return c<a.c;\n    }\n}Q[N];\nvoid work(int x,int y,int ID){\n    int ox=x,oy=y,lca,ans=0;\n    while(top[x]!=top[y]){\n        if(d[top[x]]<d[top[y]])SWAP(x,y);\n        ans+=ask(id[x])-ask(id[top[x]]-1);x=f[top[x]];\n    }\n    if(id[x]>id[y])SWAP(x,y);\n    lca=x;\n    ans+=ask(id[y])-ask(id[x]-1);\n    a1[ID]=d[ox]+d[oy]-d[lca]*2+1;\n    a2[ID]=ans;\n}\nstruct node{\n    int x,i;\n}b[N];\nint main(){\n    int opt,x,y,c,q;\n    in>>n;\n    Fur(i,1,n){\n        in>>x;\n        if(!x)RT=i;\n        else add(x,i);\n    }\n    dfs(RT);bt(RT,RT);\n    in>>q;\n    int tot=0,TOT=0;\n    Fur(i,1,q){\n        in>>opt>>x;\n        if(opt==1){\n            in>>y>>c;\n            c=i-c;\n            Q[++TOT]=que{x,y,c,TOT};\n        }\n        else b[++tot]=node{x,i};\n    }\n    std::sort(Q+1,Q+TOT+1);\n    int d=1;\n    Fur(i,1,TOT){\n        while(d<=tot&&b[d].i<Q[i].c)upd(id[b[d++].x]);\n        work(Q[i].x,Q[i].y,Q[i].id);\n    }\n    Fur(i,1,TOT)out<<a1[i]<<\" \"<<a2[i]<<ln;\n}\n```\n\n~~### 解法三：~~\n\n~~在每个重链的顶端搞个$pbds$,平衡树~~\n\n### TLE\n\n\n\n```cpp\n#include<bits\/stdc++.h>\n#include<bits\/extc++.h>\nusing namespace __gnu_pbds;\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i=x;i<=y;++i)\n    #define Fdr(i,x,y) for(int i=x;i>=y;--i)\n    #define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 0x3f3f3f3f\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){clr(ch,0);if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 200011\nint n,cnt=0,head[N],RT;\nstruct edge{\n    int to,nxt;\n}e[N];\nvoid add(int x,int y){\n    e[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;\n}\nint top[N],f[N],siz[N],d[N],sz=0;\nvoid dfs(int x){\n    siz[x]=1;\n    fl(i,x){\n        f[to]=x;d[to]=d[x]+1;\n        dfs(to);siz[x]+=siz[to];\n    }\n}\nvoid bt(int x,int tp){\n    top[x]=tp;int k=0;\n    fl(i,x)if(siz[to]>siz[k])k=to;\n    if(!k)return;bt(k,tp);\n    fl(i,x)if(to!=k)bt(to,to);\n}\nint a[N];\ntree<int,null_type,less<int>,rb_tree_tag,tree_order_statistics_node_update>T[N];\nvoid upd(int x,int i){\n    a[x]=i;T[top[x]].insert(i);\n}\nint ask(int x,int y,int c){\n    int ans=0;\n    while(x!=y){\n        if(a[x]<c)++ans;\n        x=f[x];\n    }\n    ans+=(a[y]<c);\n    return ans;\n}\nvoid work(int x,int y,int c){\n    int ox=x,oy=y,lca,ans=0;\n    ans+=ask(x,top[x],c);x=f[top[x]];\n    ans+=ask(y,top[y],c);y=f[top[y]];\n    while(top[x]!=top[y]){\n        if(d[top[x]]<d[top[y]])SWAP(x,y);\n        ans+=T[top[x]].order_of_key(c)-1;\n        x=f[top[x]];\n    }\n    if(d[x]>d[y])SWAP(x,y);\n    lca=x;\n    ans+=ask(x,y,c);\n    out<<d[ox]+d[oy]-d[lca]*2+1<<\" \"<<ans<<ln;\n}\nint main(){\n    int opt,x,y,c,q;\n    in>>n;\n    Fur(i,1,n){\n        in>>x;\n        if(!x)RT=i;\n        else add(x,i);\n    }\n    dfs(RT);bt(RT,RT);\n    in>>q;\n    Fur(i,1,q)a[i]=q;\n    Fur(i,1,q){\n        in>>opt>>x;\n        if(opt==1){\n            in>>y>>c;\n            work(x,y,i-c);\n        }\n        else upd(x,i);\n    }\n}\n```\n","link":null,"tags":["树链剖分","主席树"],"title":"LG 4216 [SCOI2015]情报传递"},{"categories":[["刷题记录"]],"content":"\n$\\sum_{i=1}^k a_i = x^x \\mod 1000  (a_i \\in \\N^*)$\n\n$\\because$ 总和一定为$x^x \\mod 1000$,并且分为$k$个数,\n\n设$n = x^x \\mod 1000$\n\n这样相当于在$n-1$个空位中插$k-1$块隔板\n\n$\\therefore ans = C(n-1,k-1)$\n\n$\\because k \\le 100,n\\le 1000$\n\n$\\therefore$我们用杨辉三角(用滚动数组,否则可能re)就可以了,但是要高精度\n\n当然如果直接计算组合数更快\n\n杨辉三角版:\n\n```cpp\n#include<bits\/stdc++.h>\n#pragma GCC optimize(3)\n#define il __inline__ __attribute__ ((always_inline))\n#define Fur(i,x,y) for(int i=x;i<=y;i++)\n#define clr(x,y) memset(x,y,sizeof(x))\nusing namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){clr(ch,0);if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 1011\nint k,t;\nil int pw(int x,int p){\n    int ans=1;\n    while(p){\n        if(p&1)ans=1ll*ans*x%1000;\n        p>>=1;x=1ll*x*x%1000;\n    }\n    return ans;\n}\n#define M 1000\nstruct node{\n    node(){clr(a,0);len=0;};\n    unsigned short a[M],len;\n    void operator = (int x){\n        while(x){\n            a[++len]=x%10;\n            x\/=10;\n        }\n        reverse(a+1,a+len+1);\n    }\n    il void op(){\n        Fdr(i,len,1)out<<a[i];\n        out<<ln;\n    }\n}c[2][101];\nnode operator + (node a,node b){\n    node c;\n    int len=MAX(a.len,b.len);\n    Fur(i,1,len)\n        c.a[i]=a.a[i]+b.a[i];\n    Fur(i,1,len-1)\n        if(c.a[i]>9)c.a[i+1]+=c.a[i]\/10,c.a[i]%=10;\n    while(c.a[len]>9){\n        c.a[len+1]+=c.a[len]\/10;\n        c.a[len]%=10;\n        ++len;\n    }\n    c.len=len;\n    return c;\n}\nvoid work(int n,int m){\n    c[0][0]=1;\n    c[1][0]=1;\n    Fur(i,1,n)\n        Fur(j,1,m)\n        c[i&1][j]=c[!(i&1)][j-1]+c[!(i&1)][j];\n    c[n&1][m].op();\n}\nint main(){\n    in>>k>>t;t%=1000;\n    t=pw(t,t);\n    work(t-1,k-1);\n}\n```\n\n组合数版：\n\n\n```cpp\n#include<bits\/stdc++.h>\n#pragma GCC optimize(3)\n#define il __inline__ __attribute__ ((always_inline))\n#define Fur(i,x,y) for(int i=x;i<=y;++i)\n#define Fdr(i,x,y) for(int i=x;i>=y;--i)\n#define clr(x,y) memset(x,y,sizeof(x))\nusing namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){clr(ch,0);if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 1011\nint k,t;\nil int pw(int x,int p){\n    int ans=1;\n    while(p){\n        if(p&1)ans=1ll*ans*x%1000;\n        p>>=1;x=1ll*x*x%1000;\n    }\n    return ans;\n}\nint len=1,c[1000];\nvoid work(int n,int m){\n    len=1;c[1]=1;\n    Fur(t,1,m){\n        Fur(i,1,len)c[i]*=(n-t+1);\n        Fur(i,1,len-1)c[i+1]+=c[i]\/10,c[i]%=10;\n        while(c[len]>9)c[len+1]+=c[len]\/10,c[len]%=10,++len;\n        \n        int y=0;\n        Fdr(i,len,1){\n            y=y*10+c[i];\n            c[i]=y\/t,y%=t;\n        }\n        while(!c[len]&&len>1)--len;\n    }\n    Fdr(i,len,1)out<<c[i];out<<ln;\n}\nint main(){\n    in>>k>>t;t%=1000;\n    t=pw(t,t);\n    work(t-1,k-1);\n}\n```\n","link":null,"tags":["组合数","高精度"],"title":"LG 1771 方程的解_NOI导刊2010提高（01）"},{"categories":[["刷题记录"]],"content":"\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n\t#pragma GCC optimize(3)\n\t#define il __inline__ __attribute__ ((always_inline))\n\t#define rg register\n\t#define ll long long\n\t#define ull unsigned long long\n\t#define db double\n\t#define sht short\n\t#define MB template <class T>il\n\t#define Fur(i,x,y) for(int i=x;i<=y;i++)\n\t#define Fdr(i,x,y) for(int i=x;i>=y;i--)\n\t#define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n\t#define clr(x,y) memset(x,y,sizeof(x))\n\t#define cpy(x,y) memcpy(x,y,sizeof(x))\n\t#define fin(s) freopen(s\".in\",\"r\",stdin)\n\t#define fout(s) freopen(s\".out\",\"w\",stdout)\n\t#define fcin ios::sync_with_stdio(false)\n\t#define l2(n) (int(log2(n)))\n\t#define inf 0x3f3f3f3f\n\tMB T ABS(T x){return x>0?x:-x;}\n\tMB T MAX(T x,T y){return x>y?x:y;}\n\tMB T MIN(T x,T y){return x<y?x:y;}\n\tMB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n\tMB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 2000011\nint n,F,D,m,st=N-1,ed=N-2,cnt=1;\nint head[N],d[N],q[N];\nstruct edge{int to,nxt,w;}e[N];\nvoid add(int x,int y,int w){\n    e[++cnt].to=y;e[cnt].w=w;e[cnt].nxt=head[x];head[x]=cnt;\n    e[++cnt].to=x;e[cnt].w=0;e[cnt].nxt=head[y];head[y]=cnt;\n}\nbool bfs(){\n    int h=0,t=1,x;\n    clr(d,0);d[q[h]=st]=1;\n    while(h<t){\n        x=q[h++];if(x==ed)return 1;\n        fl(i,x)if(e[i].w&&!d[to]){\n            d[to]=d[x]+1;\n            q[t++]=to;\n        }\n    }\n    return 0;\n}\nint dfs(int x,int mf){\n    if(x==ed)return mf;\n    int us=0,w;\n    fl(i,x)\n    if(e[i].w&&d[to]==d[x]+1){\n        w=dfs(to,MIN(mf-us,e[i].w));\n        e[i].w-=w;e[i^1].w+=w;\n        us+=w;\n        if(us==mf)return mf;\n    }\n    if(!us)d[x]=-1;\n    return us;\n}\nint main(){\n\tin>>n>>F>>D;\n\tFur(i,1,F)add(st,i,inf),add(i,i+F,1);\n\tFur(i,1,D)add(2*F+i,2*F+D+i,1),add(2*F+D+i,ed,inf);\n\tFur(i,1,n)add(2*(F+D)+i,2*(F+D)+n+i,1);\n\tFur(i,1,n){\n\t\tint x,a,b;\n\t\tin>>a>>b;\n\t\tFur(j,1,a)in>>x,add(x+F,2*(F+D)+i,1);\n\t\tFur(j,1,b)in>>x,add(2*(F+D)+n+i,2*F+x,1);\n\t}\n\tint ans=0;\n\twhile(bfs())ans+=dfs(st,inf);\n\tout<<ans<<ln;\n}\n```\n","link":null,"tags":[],"title":"LG 2891 [USACO07OPEN]吃饭Dining"},{"categories":[["刷题记录"]],"content":"\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i=x;i<=y;++i)\n    #define Fdr(i,x,y) for(int i=x;i>=y;--i)\n    #define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) (int(log2(n)))\n    #define inf 0x3f3f3f3f\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){clr(ch,0);if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 1000011\nint st[N],top,n,cnt[N],f[N];\nchar s[N];\nint main(){\n    in>>(s+1);\n    n=strlen(s+1);\n    for(int i=1;i<=n;++i)\n        if(s[i]=='(')st[++top]=i;\n        else if(top)++cnt[f[i]=i-st[top]+1+f[st[top]-1]],--top;\n    cnt[0]=1;\n    Fdr(i,n,0)\n        if(cnt[i])\n            return out<<i<<\" \"<<cnt[i]<<ln,0;\n    return 0;\n}\n```\n","link":null,"tags":[],"title":"LG CF5C Longest Regular Bracket Sequence"},{"categories":[["刷题记录"]],"content":"\n期望 记忆化搜索\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n\t#pragma GCC optimize(3)\n\t#define il __inline__ __attribute__ ((always_inline))\n\t#define rg register\n\t#define ll long long\n\t#define ull unsigned long long\n\t#define db double\n\t#define sht short\n\t#define MB template <class T>il\n\t#define Fur(i,x,y) for(int i=x;i<=y;i++)\n\t#define Fdr(i,x,y) for(int i=x;i>=y;i--)\n\t#define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n\t#define clr(x,y) memset(x,y,sizeof(x))\n\t#define cpy(x,y) memcpy(x,y,sizeof(x))\n\t#define fin(s) freopen(s\".in\",\"r\",stdin)\n\t#define fout(s) freopen(s\".out\",\"w\",stdout)\n\t#define fcin ios::sync_with_stdio(false)\n\t#define l2(n) (int(log2(n)))\n\t#define inf 0x3f3f3f3f\n\tMB T ABS(T x){return x>0?x:-x;}\n\tMB T MAX(T x,T y){return x>y?x:y;}\n\tMB T MIN(T x,T y){return x<y?x:y;}\n\tMB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n\tMB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 111\nint A,B,C;\ndb f[N][N][N];\ndb F(int a,int b,int c){\n\tif(f[a][b][c])return f[a][b][c];\n\tif(a>A||b>B||c>C)return 0;\n\tif(b||c)\n\t\tf[a][b][c]=F(a+1,b,c)*((a+1)*c)\/((b*c)+(a+1)*(b+c));\n\tif(a||c)\n\t\tf[a][b][c]+=F(a,b+1,c)*(a*(b+1))\/(a*c+(b+1)*(a+c));\n\tif(a||b)\n\t\tf[a][b][c]+=F(a,b,c+1)*(b*(c+1))\/(a*b+(c+1)*(a+b));\n\treturn f[a][b][c];\n}\nint main(){\n\tdb ans=0;\n\tin>>A>>B>>C;\n\tf[A][B][C]=1;\n\tFur(i,1,A)ans+=F(i,0,0);\n\tprintf(\"%.12lf \",ans);\n\tans=0;\n\tFur(i,1,B)ans+=F(0,i,0);\n\tprintf(\"%.12lf \",ans);\n\tans=0;\n\tFur(i,1,C)ans+=F(0,0,i);\n\tprintf(\"%.12lf\\n\",ans);\n}\n```\n","link":null,"tags":[],"title":"LG CF540D Bad-Luck-Island"},{"categories":[["刷题记录"]],"content":"\n解释见代码\n```cpp\n#include<bits\/stdc++.h>\n#define il inline\nusing namespace std;\nil int max(int x,int y){return x>y?x:y;}\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;rg char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\n#define N 100011\nint n,q[N],tp=0,a[N],mx[N];\nchar s[N];\nint main(){\n    in(s+1);\n    int len=strlen(s+1);\n    for(int i=1;i<=len;++i){\n        if(s[i]=='(')a[++tp]=0,mx[tp]=0; \/\/ 如果是'('则进入下一层\n        else if(s[i]==')')--tp,a[tp]+=mx[tp+1];\/\/ 如果是')'返回上一层,上一层加上当前答案\n        else if(s[i]=='|')a[tp]=0;\n        else ++a[tp];\n        mx[tp]=max(mx[tp],a[tp]);\/\/去当前合并后的长度\n    }\n    printf(\"%d\\n\",mx[0]);\n}\n```\n","link":null,"tags":["栈"],"title":"LG 3719 [AHOI2017初中组]rexp"},{"categories":[["刷题记录"]],"content":"\n此题与网络流24题中的骑士共存问题一致\n\n最大流=最小割\n\n用点数-去可以攻击的最大匹配\n\n可以使用网络流或二分图\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n\t#pragma GCC optimize(3)\n\t#define il __inline__ __attribute__ ((always_inline))\n\t#define rg register\n\t#define ll long long\n\t#define ull unsigned long long\n\t#define db double\n\t#define sht short\n\t#define MB template <class T>il\n\t#define Fur(i,x,y) for(int i=x;i<=y;i++)\n\t#define Fdr(i,x,y) for(int i=x;i>=y;i--)\n\t#define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n\t#define clr(x,y) memset(x,y,sizeof(x))\n\t#define cpy(x,y) memcpy(x,y,sizeof(x))\n\t#define fin(s) freopen(s\".in\",\"r\",stdin)\n\t#define fout(s) freopen(s\".out\",\"w\",stdout)\n\t#define fcin ios::sync_with_stdio(false)\n\t#define l2(n) (int(log2(n)))\n\t#define inf 0x3f3f3f3f\n\tMB T ABS(T x){return x>0?x:-x;}\n\tMB T MAX(T x,T y){return x>y?x:y;}\n\tMB T MIN(T x,T y){return x<y?x:y;}\n\tMB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n\tMB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 233\nint n,head[N*N],d[N*N],q[N*N],cnt=1,st,ed;\nint dx[8] = {-2, -1, 1, 2, 2, 1, -1, -2},dy[8] = {-1, -2, -2, -1, 1, 2, 2, 1}; \nbool b[N][N];\nstruct edge{\n\tint to,nxt,w;\n}e[N*N*2];\nvoid add(int x,int y,int w){\n\te[++cnt].to=y;e[cnt].w=w;e[cnt].nxt=head[x];head[x]=cnt;\n\te[++cnt].to=x;e[cnt].w=0;e[cnt].nxt=head[y];head[y]=cnt;\n}\nbool bfs(){\n\tint h=0,t=1;\n\tclr(d,0);\n\td[q[h]=st]=1;\t\n\twhile(h<t){\n\t\tint x=q[h++];\n\t\tif(x==ed)return 1;\n\t\tfl(i,x)if(e[i].w&&!d[to]){\n\t\t\td[to]=d[x]+1;\n\t\t\tq[t++]=to;\n\t\t}\n\t}\n\treturn 0;\n}\nint dfs(int x,int mf){\n\tif(x==ed)return mf;\n\tint us=0,w;\n\tfl(i,x)\n\tif(e[i].w&&d[to]==d[x]+1){\n\t\tw=dfs(to,MIN(mf-us,e[i].w));\n\t\te[i].w-=w;e[i^1].w+=w;\n\t\tus+=w;\n\t\tif(us==mf)return mf;\n\t}\n\tif(!us)d[x]=-1;\n\treturn us;\n}\nint dinic(){\n\tint ans=0;\n\twhile(bfs())ans+=dfs(st,inf);\n\treturn ans;\n}\n#define id(x,y) ((x-1)*n+y)\nint main(){\n\tin>>n;\n\tst=n*n+1;ed=n*n+2;\n\tint tt=0;\n\tchar ch[N];\n\tFur(i,1,n){\n\t\tin>>(ch+1);\n\t\tFur(j,1,n)\n\t\ttt+=(b[i][j]=ch[j]-48);\n\t}\n\tFur(i,1,n)\n\t\tFur(j,1,n)\n\t\tif(!b[i][j]){\n\t\t\tif((i+j)&1){\n\t\t\t\tadd(st,id(i,j),1);\n\t\t\t\tFur(k,0,7){\n\t\t\t\t\tint nx=i+dx[k],ny=j+dy[k];\n\t\t\t\t\tif(nx<1||nx>n||ny<1||ny>n||b[nx][ny])continue;\n\t\t\t\t\tadd(id(i,j),id(nx,ny),inf);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse add(id(i,j),ed,1);\n\t\t}\n\tout<<n*n-tt-dinic()<<ln;\n}\n```\n","link":null,"tags":["网络流","二分图"],"title":"LG 4304 [TJOI2013]攻击装置"},{"categories":[["刷题记录"]],"content":"\n我们可以把每一行的$SG$异或\n\n每一行只有20个,所以可以用状态压缩\n\n可以通过$DP$或记忆化搜索的方式处理出每种状态的$SG$值\n\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i=x;i<=y;++i)\n    #define Fdr(i,x,y) for(int i=x;i>=y;--i)\n    #define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 0x3f3f3f3f\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){clr(ch,0);if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 100011\nint n,f[1<<20],a[22];\n#define lb(x) ((x)&(-(x)))\nint dfs(int x){\n    if (f[x]!=-1)return f[x];\n    int t=(x+1)-lb(x+1),k=lb(t),cnt=0,tmp;\n    while (k){\n        t^=k;tmp=k;\n        for(;(x^k)<x;k>>=1);\n        a[cnt++]=dfs(x^k^tmp);\n        k=lb(t);\n    }\n    sort(a,a+cnt);\n    if(a[0])return f[x]=0;\n    for (int i=1;i<cnt;i++)\n        if (a[i]-a[i-1]>1) return f[x]=a[i-1]+1;\n    return f[x]=a[cnt-1]+1;\n}\nint main(){\n    fin(\"in\");\n    clr(f,-1);\n    Fur(i,1,20)f[(1<<i)-1]=0;\n    Fur(i,1,(1<<20)-1)f[i]=dfs(i);\n    int T;in>>T;\n    while(T--){\n        int n,m,x,s=0,sg=0;\n        in>>n;\n        Fur(i,1,n){\n            s=0;\n            in>>m;\n            while(m--)in>>x,s|=(1<<(20-x));\n            sg^=f[s];\n        }\n        if(sg)out<<\"YES\\n\";\n        else out<<\"NO\\n\";\n    }\n}\n```\n","link":null,"tags":["博弈论","状态压缩"],"title":"LG 2575 高手过招"},{"categories":[["刷题记录"]],"content":"\n好题！\n\n重新排序后能变成回文串,出现次数为奇数的字母最多只能有一种\n\n因为只有$22$种字符所以我们可以用状态压缩来记录每种字母出现的次数是奇数或者偶数\n\n设路径端点的两端为$x,y$,$d_x$表示1~x所有状态的异或值,$D_x$表示$x$的深度\n\n那么如果这条路径满足条件,则$d_x \\oplus d_y$在二进制下最多只有一个$1$\n\n它的长度为$D_x + D_y - 2 \\times D_{lca(x,y)}$\n\n我们可以开一个桶来记录每种状态出现的最深的位置是哪里\n\n设$sta$为满足条件的状态\n\n用每个店更新答案的时候就$ans=\\max(ans,b[sta \\oplus d_x] + D_x - 2 \\times D_{lca})$\n\n接下来就按静态链分治的套路操作就可以了\n\n复杂度: $\\Theta( n \\log n)$\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i=x;i<=y;++i)\n    #define Fdr(i,x,y) for(int i=x;i>=y;--i)\n    #define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 0x3f3f3f3f\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){clr(ch,0);if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 500011\nint n,d[N],siz[N],son[N],D[N];\nint cnt=0,head[N];\nstruct edge{\n    int to,nxt,w;\n}e[N];\nvoid add(int x,int y,int w){\n    e[++cnt].to=y;e[cnt].w=w;e[cnt].nxt=head[x];head[x]=cnt;\n}\nvoid dfs(int x){\n    siz[x]=1;\n    fl(i,x){\n        d[to]=d[x]^e[i].w;D[to]=D[x]+1;\n        dfs(to);siz[x]+=siz[to];\n        if(siz[to]>siz[son[x]])son[x]=to;\n    }\n}\nint b[1<<22],ans=0,sta[23],lca;\nvoid Add(int x){\n    Fur(i,0,22)\n        ans=MAX(ans,D[x]+b[sta[i]^d[x]]-2*D[lca]);\n    b[d[x]]=MAX(b[d[x]],D[x]);\n}\nvoid upd(int x){\n    Add(x);\n    fl(i,x)upd(to);\n}\nvoid dde(int x){\n    b[d[x]]=-inf;\n    fl(i,x)dde(to);\n}\nint ANS[N];\nvoid sol(int x){\n    fl(i,x)if(to!=son[x]){\n        sol(to);\n        \/\/ dde(to);\n        clr(b,128);\n        ans=0;\n        ANS[x]=MAX(ANS[x],ANS[to]);\n    }\n    if(son[x])sol(son[x]),ANS[x]=MAX(ANS[x],ANS[son[x]]);\n    lca=x;\n    Add(x);\n    fl(i,x)if(to!=son[x])upd(to);\n    ANS[x]=MAX(ANS[x],ans);\n}\nint main(){\n    fin(\"in\");\n    in>>n;\n    int x;char w;\n    Fur(i,2,n)in>>x>>w,add(x,i,(1<<(w-'a')));\n    dfs(1);\n    sta[0]=0;\n    Fur(i,1,22)sta[i]=(1<<(i-1));\n    sol(1);\n    Fur(i,1,n)out<<ANS[i]<<\" \";\n}\n```\n","link":null,"tags":["静态链分治","状态压缩","桶"],"title":"LG CF741D Arpa’s letter-marked tree and Mehrdad’s Dokhtar-kosh paths"},{"categories":[["刷题记录"]],"content":"\nEasy\ntop: 0\n\n\nSolution：\n　　期望题总是贼有意思。\n\n　　本题期望$combo$为$o$的期望连续长度的平方,所以我们设$f_i$表示到了第$i$位的总期望$combo$,$g_i$表示到了第$i$位结尾的连续$o$的期望长度,那么分情况讨论：\n\n1. $s_i == o$\n2. $s_i == x$\n3. $s_i ==\\ ?$\n\n\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n\t#pragma GCC optimize(3)\n\t#define il __inline__ __attribute__ ((always_inline))\n\t#define rg register\n\t#define ll long long\n\t#define ull unsigned long long\n\t#define db double\n\t#define sht short\n\t#define MB template <class T>il\n\t#define Fur(i,x,y) for(int i=x;i<=y;i++)\n\t#define Fdr(i,x,y) for(int i=x;i>=y;i--)\n\t#define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n\t#define clr(x,y) memset(x,y,sizeof(x))\n\t#define cpy(x,y) memcpy(x,y,sizeof(x))\n\t#define fin(s) freopen(s\".in\",\"r\",stdin)\n\t#define fout(s) freopen(s\".out\",\"w\",stdout)\n\t#define fcin ios::sync_with_stdio(false)\n\t#define l2(n) (int(log2(n)))\n\t#define inf 0x3f3f3f3f\n\tMB T ABS(T x){return x>0?x:-x;}\n\tMB T MAX(T x,T y){return x>y?x:y;}\n\tMB T MIN(T x,T y){return x<y?x:y;}\n\tMB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n\tMB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 10011\ndb f[2],g[2];\nint n;\nchar ch;\nint main(){\n\tin>>n;\n\tint k=1;\n\tFur(i,1,n){\n\t\tin>>ch;\n\t\tif(ch=='o')f[k]=f[!k]+g[!k]*2+1,g[k]=g[!k]+1;\n\t\tif(ch=='x')f[k]=f[!k],g[k]=0;\n\t\tif(ch=='?')f[k]=f[!k]+g[!k]+0.5,g[k]=g[!k]\/2+0.5;\n\t\tk^=1;\n\t}\n\tprintf(\"%.4f\\n\",f[!k]);\n}\n```\n","link":null,"tags":["期望","动态规划"],"title":"LG 1365 WJMZBMR打osu!"},{"categories":[["刷题记录"]],"content":"\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i=x;i<=y;++i)\n    #define Fdr(i,x,y) for(int i=x;i>=y;--i)\n    #define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 0x3f3f3f3f\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){clr(ch,0);if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 400011\n#define int ll\nstruct edge{\n    int to,nxt,w;\n}e[N*2];\nint n,m,cnt=0,head[N],B=0,sz=0;\nvoid add(int x,int y,int w){\n    e[++cnt].to=y;e[cnt].w=w;e[cnt].nxt=head[x];head[x]=cnt;\n}\nint fa[N];\nstruct node{\n    int x,y,w,id;\n    bool v=0;\n}E[N];\nbool cmp(node x,node y){\n    return x.w<y.w;\n}\nbool CMP(node x,node y){\n    return x.id<y.id;\n}\nint gf(int x){return (fa[x]==x)?x:(fa[x]=gf(fa[x]));}\nvoid kru(){\n    Fur(i,1,n)fa[i]=i;\n    sort(E+1,E+m+1,cmp);\n    int x,y,w;\n    Fur(i,1,m){\n        x=E[i].x,y=E[i].y,w=E[i].w;\n        if(gf(x)!=gf(y)){\n            E[i].v=1;\n            fa[fa[x]]=fa[y];\n            add(x,y,w);add(y,x,w);\n            B+=w;\n        }\n    }\n    sort(E+1,E+m+1,CMP);\n}\nint top[N],siz[N],f[N],v[N],s[N<<2],id[N],d[N],a[N];\nvoid dfs(int x){\n    siz[x]=1;id[x]=++sz;a[id[x]]=v[x];\n    fl(i,x)if(to!=f[x]){\n        f[to]=x;d[to]=d[x]+1;v[to]=e[i].w;\n        dfs(to);siz[x]+=siz[to];\n    }\n}\nvoid bt(int x,int tp){\n    top[x]=tp;int k=0;\n    fl(i,x)if(to!=f[x]&&siz[to]>siz[k])k=to;\n    if(!k)return;bt(k,tp);\n    fl(i,x)if(!top[to])bt(to,to);\n}\n#define ls rt<<1\n#define rs rt<<1|1\nvoid build(int l,int r,int rt){\n    if(l==r){\n        s[rt]=a[l];\n        return;\n    }\n    int m=(l+r)>>1;\n    build(l,m,ls);\n    build(m+1,r,rs);\n    s[rt]=MAX(s[ls],s[rs]);\n}\nint ask(int L,int R,int l=1,int r=n,int rt=1){\n    if(L<=l&&r<=R)return s[rt];\n    int m=(l+r)>>1,ans=0;\n    if(L<=m)ans=ask(L,R,l,m,ls);\n    if(R>m)ans=MAX(ans,ask(L,R,m+1,r,rs));\n    return ans;\n}\nint fh(int x,int y){\n    int ans=0;\n    while(top[x]!=top[y]){\n        if(d[top[x]]<d[top[y]])SWAP(x,y);\n        ans=MAX(ans,ask(id[top[x]],id[x]));x=f[top[x]];\n    }\n    if(id[x]>id[y])SWAP(x,y);\n    return MAX(ans,ask(id[x]+1,id[y]));\n}\nsigned main(){\n    fin(\"in\");\n    in>>n>>m;\n    int x,y;\n    Fur(i,1,m)in>>E[i].x>>E[i].y>>E[i].w,E[i].id=i;\n    kru();\n    dfs(1);\n    bt(1,1);\n    build(1,n,1);\n    Fur(i,1,m)\n        if(E[i].v)out<<B<<ln;\n        else out<<(ll)B+E[i].w-fh(E[i].x,E[i].y)<<ln;\n}\n```\n","link":null,"tags":["树链剖分","最小生成树"],"title":"LG CF160D Edges in MST"},{"categories":[["刷题记录"]],"content":"\n在每条重链上搞一个set\n\n或者用线段树+二分\n```cpp\n\/\/ luogu-judger-enable-o2\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i=x;i<=y;i++)\n    #define Fdr(i,x,y) for(int i=x;i>=y;i--)\n    #define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) (int(log2(n)))\n    #define inf 0x3f3f3f3f\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 100011\n#define ls rt<<1\n#define rs rt<<1|1\nint head[N],n,q,sz=0,cnt=0;\nint top[N],d[N],f[N],siz[N],id[N],dfn[N];\nbool ff[N];\nset<int>mi[N]; \nstruct edge{\n    int to,nxt;\n}e[N*2];\nvoid add(int x,int y){\n    e[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;\n}\nvoid dfs(int x){\n    siz[x]=1;\n    fl(i,x)if(to!=f[x]){\n        f[to]=x;d[to]=d[x]+1;\n        dfs(to);siz[x]+=siz[to];\n    }\n}\nvoid bt(int x,int tp){\n    top[x]=tp;dfn[id[x]=++sz]=x;\n    int k=0;\n    fl(i,x)if(to!=f[x]&&siz[to]>siz[k])k=to;\n    if(!k)return;bt(k,tp);\n    fl(i,x)if(!top[to])bt(to,to);\n}\nint main(){\n    in>>n>>q;\n    int x,y,u,ans;\n    Fur(i,1,n-1)in>>x>>y,add(x,y),add(y,x);\n    dfs(1);bt(1,1);\n    while(q--){\n        in>>u>>x;\n        if(u==0){\n            if(ff[x])mi[top[x]].erase(id[x]);\n            else mi[top[x]].insert(id[x]);\n            ff[x]^=1;\n        }\n        else{\n            ans=-1;\n            while(x){\n                int k=*mi[top[x]].begin();\n                if(mi[top[x]].size()&&d[dfn[k]]<=d[x])ans=dfn[k];\n                x=f[top[x]];\n            }\n            out<<ans<<ln;\n        }\n    }\n}\n\n```\n","link":null,"tags":["树链剖分","set","二分"],"title":"LG 4116 Qtree3"},{"categories":[["刷题记录"]],"content":"\n首先二分出最大一段的最小值,然后$dp$找出方案数\n\n设$f[i][j]$表示前$j$个分成$i$组的方案数,求出的最小值为$x$\n\n$f[i][j] = \\sum(f[i-1][k])(S_j-S_k \\le x,k \\le j-1)$\n\n$\\Theta(n^3m)$当然会$TLE$\n\n我们发现只要找到最小的$k$之后$[k,j-1]$都是合法的\n\n这时我们就可以前缀和优化$dp$\n\n设$sum[i][j] = \\sum_{k=0}^j f[i][k]$\n\n$f[i][j]=sum[i-1][j-1] - sum[i-1][k-1]$\n\n可是$\\Theta(n^2m)$还是$TLE$\n\n我们可以先预处理出第一个$S_j-S_k \\le x$的$k$\n\n因为$S_i$具有单调性,所以$k$不需要每次都重新枚举\n\n~~还没结束~~\n\n因为$f[i][j]$每次更新的时候只需要用到$f[i-1][...]$这一维,我们可以用滚动数组滚掉数组的一维\n\n但是$\\Theta(nm+n \\log \\sum L_i)$的复杂度还是觉得很悬\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i=x;i<=y;++i)\n    #define Fdr(i,x,y) for(int i=x;i>=y;--i)\n    #define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){clr(ch,0);if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 50011\n#define mod 10007\nint n,m,a[N];\nil int mo(int x){\n    if(x>=mod)x-=mod;\n    return x;\n}\nil bool chk(int w){\n    int s=0,t=0;\n    Fur(i,1,n){\n        s+=a[i];\n        if(s>w){\n            s=a[i],++t;\n            if(t>m+1)return 0;\n        }\n    }\n    if(s)++t;\n    if(t>m+1)return 0;\n    return 1;\n}\nint f[N],s[N],S[N],pre[N];\nint main(){\n    fin(\"in\");\n    in>>n>>m;\n    int l=0,r=0,ans=0;\n    Fur(i,1,n)\n        in>>a[i],\n        l=MAX(l,a[i]),\n        S[i]=S[i-1]+a[i];\n    \n    r=S[n];\n    while(l<=r){\n        int mid=(l+r)>>1;\n        if(chk(mid))ans=mid,r=mid-1;\n        else l=mid+1;\n    }\n    out<<ans<<\" \";\n\n    int k=0,res=(S[n]<=ans);\n    Fur(i,1,n){\n        while(S[i]-S[k]>ans)++k;\n        pre[i]=k;\n    }\n    Fur(j,1,n)\n        f[j]=(S[j]<=ans),\n        s[j]=mo(s[j-1]+f[j]);\n\n    Fur(i,2,m+1){\n        Fur(j,1,n){\n            f[j]=s[j-1];\n            if(pre[j]-1>=0)f[j]=mo(f[j]-s[pre[j]-1]+mod);\n        }\n        Fur(j,1,n)\n            s[j]=mo(s[j-1]+f[j]);\n        res=mo(res+f[n]);\n    }\n    \n    out<<res<<ln;\n}\n```\n","link":null,"tags":["二分","动态规划","前缀和"],"title":"LG 2511 [HAOI2008]木棍分割"},{"categories":[["刷题记录"]],"content":"\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i=x;i<=y;++i)\n    #define Fdr(i,x,y) for(int i=x;i>=y;--i)\n    #define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) (int(log2(n)))\n    #define inf 0x3f3f3f3f\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){clr(ch,0);if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 3011\nint n,m,h[N],sta[N],v[N],tp;\nbool a[N][N];\nint main(){\n\tfin(\"in\");\n\tin>>n>>m;\n\tFur(i,1,n)\n\t\tFur(j,1,m)\n\t\tin>>a[i][j];\n\tll ans=0;\n\ttp=0;\n\tFur(i,1,n){\n\t\tFur(j,1,m){\n\t\t\tif(!a[i][j])h[j]=i;\n\t\t\twhile(tp&&h[sta[tp]]<h[j])tp--;\n\t\t\tsta[++tp]=j;\n\t\t\tv[tp]=v[tp-1]+(i-h[sta[tp]])*(sta[tp]-sta[tp-1]);\n\t\t\tans+=v[tp];\n\t\t}\n\t\ttp=0;\n\t}\n\tout<<ans<<ln;\n}\n\n```\n","link":null,"tags":["单调栈"],"title":"LG 3400 仓鼠窝"},{"categories":[["刷题记录"]],"content":"\n说实话,我觉得我是太傻吊了,一道动动脑筋就可以写的题我能写成麻烦的$dp$\n\n\n\ndalao的代码：(直接扫描一遍就可以过了)\n\n```cpp\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\nchar s[100050];\nint main(){\n\tint n,ans=0;\n\tscanf(\"%d\",&n);\n\tscanf(\"%s\",s+1);\n\tfor (int i=1;i<=n;i++)\n\tif (s[i]!=s[i-1]) ans++;\n\tprintf(\"%d\\n\",min(n,ans+2));\n\treturn 0;\n}\n```\n\n我的代码：(居然能写成动态规划)\n\n(详见下面)\n\n\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i=x;i<=y;i++)\n    #define Fdr(i,x,y) for(int i=x;i>=y;i--)\n    #define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) (int(log2(n)))\n    #define inf 0x3f3f3f3f\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){clr(ch,0);if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 100011\nint n,f[N][2],g[N][2],p[N][2];\nchar a[N];\nint main(){\n\tfin(\"in\");\n\tin>>n>>(a+1);\n\tf[1][a[1]-48]++;\n\tg[1][0]=g[1][1]=p[1][0]=p[1][1]=1;\n\tFur(i,2,n){\n\t\tf[i][0]=f[i-1][0];\n\t\tf[i][1]=f[i-1][1];\n\t\tint k=a[i]-48;\n\t\tf[i][k]=MAX(f[i][k],f[i-1][!k]+1);\n\t\t\n\t\tg[i][0]=g[i-1][0];g[i][1]=g[i-1][1];\n\t\tg[i][k]=MAX(g[i][k],MAX(f[i-1][k],g[i-1][!k])+1);\n\t\t\n\t\tp[i][0]=p[i-1][0];p[i][0]=p[i-1][0];\n\t\tp[i][k]=MAX(p[i][k],MAX(g[i-1][k],p[i-1][!k])+1);\n\t}\n\tout<<MAX(p[n][0],p[n][1])<<ln;\n}\n\n```\n","link":null,"tags":["线性"],"title":"51nod 1658 01交替子序列"},{"categories":[["刷题记录"]],"content":"\n先求个异或前缀和,然后就变成求$k$对最大异或和\n\n因为(i^j) = (j^i)\n\n所以我们设$2k$对,到答案在除以2就可以了\n\n我们先找出每个点能得到的最大异或和,然后放堆里\n\n每次取出堆顶,求出它能得到的第$rk+1$大的异或和\n\n如果$rk+1 \\le n$,那就放到堆里\n\n(因为一个点最多用$n$次,要不就重复了)\n\n记得$long\\ long$\n\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n\t#pragma GCC optimize(3)\n\t#define il __inline__ __attribute__ ((always_inline))\n\t#define rg register\n\t#define ll long long\n\t#define ull unsigned long long\n\t#define db double\n\t#define sht short\n\t#define MB template <class T>il\n\t#define Fur(i,x,y) for(int i=x;i<=y;i++)\n\t#define Fdr(i,x,y) for(int i=x;i>=y;i--)\n\t#define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n\t#define clr(x,y) memset(x,y,sizeof(x))\n\t#define cpy(x,y) memcpy(x,y,sizeof(x))\n\t#define fin(s) freopen(s\".in\",\"r\",stdin)\n\t#define fout(s) freopen(s\".out\",\"w\",stdout)\n\t#define fcin ios::sync_with_stdio(false)\n\t#define l2(n) (int(log2(n)))\n\t#define inf 0x3f3f3f3f\n\tMB T ABS(T x){return x>0?x:-x;}\n\tMB T MAX(T x,T y){return x>y?x:y;}\n\tMB T MIN(T x,T y){return x<y?x:y;}\n\tMB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n\tMB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 50000011\nint n,k,siz[N],c[N][2],cnt=0;\nll s[N],a[N];\nvoid ins(ll v){\n\tint x=0;\n\tFdr(i,31,0){\n\t\tint t=(v>>i)&1;siz[x]++;\n\t\tif(!c[x][t])c[x][t]=++cnt;\n\t\tx=c[x][t];\n\t}\n\tsiz[x]++;\n}\nll ask(ll v,int rk){\n\tint x=0;ll ans=0;\n\tFdr(i,31,0){\n\t\tint t=(v>>i)&1;\n\t\tif(!c[x][!t])x=c[x][t];\n\t\telse if(rk<=siz[c[x][!t]])x=c[x][!t],ans|=1ll<<i;\n\t\telse rk-=siz[c[x][!t]],x=c[x][t];\n\t}\n\treturn ans;\n}\nstruct node{\n\tll v;\n\tint rk,id;\n\tbool operator<(const node&y)const{\n\t\treturn v<y.v;\n\t}\n};\npriority_queue<node>q;\nint main(){\n\tin>>n>>k;k<<=1;\n\tll ans=0,x;\n\tins(s[0]);\n\tFur(i,1,n)in>>x,s[i]=s[i-1]^x,ins(s[i]);\n\tFur(i,0,n)q.push(node{ask(s[i],1),1,i});\n\tFur(i,1,k){\n\t\tnode t=q.top();q.pop();\n\t\tans+=t.v;\n\t\tif(t.rk<n)q.push(node{ask(s[t.id],t.rk+1),t.rk+1,t.id});\n\t}\n\tout<<(ans>>1)<<ln;\n}\n```\n","link":null,"tags":["trie","堆","异或"],"title":"LG 5283 [十二省联考2019]异或粽子"},{"categories":[["刷题记录"]],"content":"\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n\t#pragma GCC optimize(3)\n\t#define il __inline__ __attribute__ ((always_inline))\n\t#define rg register\n\t#define ll long long\n\t#define ull unsigned long long\n\t#define db double\n\t#define sht short\n\t#define MB template <class T>il\n\t#define Fur(i,x,y) for(int i=x;i<=y;i++)\n\t#define Fdr(i,x,y) for(int i=x;i>=y;i--)\n\t#define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n\t#define clr(x,y) memset(x,y,sizeof(x))\n\t#define cpy(x,y) memcpy(x,y,sizeof(x))\n\t#define fin(s) freopen(s\".in\",\"r\",stdin)\n\t#define fout(s) freopen(s\".out\",\"w\",stdout)\n\t#define fcin ios::sync_with_stdio(false)\n\t#define l2(n) (int(log2(n)))\n\t#define inf 0x3f3f3f3f\n\tMB T ABS(T x){return x>0?x:-x;}\n\tMB T MAX(T x,T y){return x>y?x:y;}\n\tMB T MIN(T x,T y){return x<y?x:y;}\n\tMB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n\tMB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 5011\nint n,m,f[N][N],t[N];\nchar a[N][N];\nint main(){\n\tin>>n>>m;\n\tFur(i,1,n)in>>(a[i]+1);\n\tFur(i,1,n)\n\t\tFdr(j,m,1)\n\t\tif(a[i][j]==49)f[i][j]=f[i][j+1]+1;\n\t\n\tint ans=0;\n\tFur(j,1,m){\n\t\tFur(i,1,n)t[i]=f[i][j];\n\t\tsort(t+1,t+n+1);\n\t\tFur(i,1,n)ans=MAX(ans,t[i]*(n-i+1));\n\t}\n\tout<<ans<<ln;\n}\n```\n","link":null,"tags":["枚举","预处理"],"title":"LG CF375B Maximum-Submatrix-2"},{"categories":[["刷题记录"]],"content":"\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n\t#pragma GCC optimize(3)\n\t#define il __inline__ __attribute__ ((always_inline))\n\t#define rg register\n\t#define ll long long\n\t#define ull unsigned long long\n\t#define db double\n\t#define sht short\n\t#define MB template <class T>il\n\t#define Fur(i,x,y) for(int i=x;i<=y;i++)\n\t#define Fdr(i,x,y) for(int i=x;i>=y;i--)\n\t#define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n\t#define clr(x,y) memset(x,y,sizeof(x))\n\t#define cpy(x,y) memcpy(x,y,sizeof(x))\n\t#define fin(s) freopen(s\".in\",\"r\",stdin)\n\t#define fout(s) freopen(s\".out\",\"w\",stdout)\n\t#define fcin ios::sync_with_stdio(false)\n\t#define l2(n) (int(log2(n)))\n\t#define inf 0x3f3f3f3f\n\tMB T ABS(T x){return x>0?x:-x;}\n\tMB T MAX(T x,T y){return x>y?x:y;}\n\tMB T MIN(T x,T y){return x<y?x:y;}\n\tMB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n\tMB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 300011\nint n;\nstruct node{\n\tint l,r;\n}a[N];\nbool cmp(node x,node y){\n\treturn x.l<y.l;\n}\nint main(){\n\tint x=0,t,ans=0;\n\tin>>n;\n\tchar ch;\n\tFur(i,1,n){\n\t\tin>>t>>ch;\n\t\tif(ch=='L')a[i]=(node){x-t,x},x-=t;\n\t\telse a[i]=(node){x,x+t},x+=t;\n\t}\n\tsort(a+1,a+n+1,cmp);\n\tint la=-inf;\n\tx=a[1].r;\n\tFur(i,2,n)\n\tif(x>=a[i].l){\n\t\tif(MIN(a[i].r,x)-MAX(la,a[i].l)>0)\n\t\t\tans+=MIN(a[i].r,x)-MAX(la,a[i].l),\n\t\t\tla=MIN(a[i].r,x);\n\t\tx=MAX(x,a[i].r);\n\t}\n\telse x=MAX(x,a[i].r);\n\tout<<ans<<ln;\n\t\n}\n```\n","link":null,"tags":["前缀和","差分"],"title":"LG 2070 刷墙"},{"categories":[["刷题记录"]],"content":"\n开一个桶$f$记录每个数出现次数,然后$f[i]=\\sum_{i|d}f[d]$\n\n求出所有$i$的倍数可能组成的四元组,这时$\\gcd$一定是$i,2i,3i,\\cdots$,然后减去$\\gcd$是$2i,3i,\\cdots$的四元组个数。即$f[i]={cnt\\choose 4}-\\sum_{i|d,i\\neq d}f[d]$\n\n\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i=x;i<=y;i++)\n    #define Fdr(i,x,y) for(int i=x;i>=y;i--)\n    #define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) (int(log2(n)))\n    #define inf 0x3f3f3f3f\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){clr(ch,0);if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 10001\n#define M 10000\n#define int ll\nint n,f[N];\nsigned main(){\n\tfin(\"in\");\nwhile(1){\n\tin>>n;\n\tif(in._)break;\n\tint x;\n\tclr(f,0);\n\tFur(i,1,n)in>>x,f[x]++;\n\tFur(i,1,M)\n\t\tfor(int j=i*2;j<=M;j+=i)\n\t\t\tf[i]+=f[j];\n\t\n\tFdr(i,M,1){\n\t\tf[i]=f[i]*(f[i]-1)*(f[i]-2)*(f[i]-3)\/24;\n\t\tfor(int j=i*2;j<=M;j+=i)f[i]-=f[j];\n\t}\n\tout<<f[1]<<ln;\n}\n}\n\n```\n","link":null,"tags":["数论"],"title":"51nod 2714 四元组统计"},{"categories":[["刷题记录"]],"content":"\n因为有两条不同的路径,而且没有重边,所以这两个点就在同一个强连通分量里,直接tarjan一遍就可以\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i=x;i<=y;i++)\n    #define Fdr(i,x,y) for(int i=x;i>=y;i--)\n    #define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) (int(log2(n)))\n    #define inf 0x3f3f3f3f\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){clr(ch,0);if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 25110\nint n,m,cnt=0,sz=0,dfn[N],low[N],bl[N],head[N],z[N*2],tp=0;\nstruct edge{\n\tint to,nxt;\n}e[100011];\nvoid add(int x,int y){\n\te[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;\n}\nbool v[N];\nvoid dfs(int x,int f){\n\tdfn[x]=low[x]=++sz;\n\tz[++tp]=x;v[x]=1;\n\tfl(i,x)\n\t\tif(!dfn[to])dfs(to,x),low[x]=MIN(low[x],low[to]);\n\t\telse if(v[to]&&to!=f)low[x]=MIN(low[x],dfn[to]);\n\t\n\tif(low[x]==dfn[x]){\n\t\tint y;\n\t\tdo{\n\t\t\ty=z[tp--];\n\t\t\tbl[y]=x;\n\t\t\tv[y]=0;\n\t\t}while(y!=x);\n\t}\n}\nint main(){\n\tfin(\"in\");\n\tin>>n>>m;\n\tint x,y;\n\tFur(i,1,m)in>>x>>y,add(x,y),add(y,x);\n\tFur(i,1,n)if(!dfn[i])dfs(i,0);\n\tint q;\n\tin>>q;\n\twhile(q--){\n\t\tin>>x>>y;\n\t\tif(x!=y&&bl[x]&&bl[y]&&bl[x]==bl[y])out<<\"Yes\\n\";\n\t\telse out<<\"No\\n\";\n\t}\n}\n\n```\n","link":null,"tags":["tarjan"],"title":"51nod 1076 2条不相交的路径"},{"categories":[["刷题记录"]],"content":"\nGCD-Extreme\ntop: 0\n\n\n设$g(n) = \\sum_{i=1}^{n-1} \\gcd(i,n)$\n\n$$\n\n\\sum_{i=1}^{n-1} \\sum_{j=i+1}^n \\gcd(i,j)\n\n\\\\\\\\\n\n= \\sum_{i=1}^n g(i)\n\n$$\n\n$$\n\ng(n) = \\sum_{i=1}^{n-1} \\gcd(i,n)\n\n\\\\\\\\\n\n= \\sum_{d|n}d \\sum_{i=1}^{n-1}[gcd(i,n)=d]\n\n\\\\\\\\\n\n= \\sum_{d|n}d \\sum_{i=1}^{\\frac nd - 1}[gcd(i,n)=1]\n\n\\\\\\\\\n\n= \\sum_{d|n}d \\times \\varphi(\\frac nd);\n\n$$\n\n求出$g$的前缀和\n\n可以用筛的方式求$g$\n\n$O(n \\sqrt n + T);$\n\n不能用之前的套路,否则会tle\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n\t#pragma GCC optimize(3)\n\t#define il __inline__ __attribute__ ((always_inline))\n\t#define rg register\n\t#define ll long long\n\t#define ull unsigned long long\n\t#define db double\n\t#define sht short\n\t#define MB template <class T>il\n\t#define Fur(i,x,y) for(int i=x;i<=y;i++)\n\t#define Fdr(i,x,y) for(int i=x;i>=y;i--)\n\t#define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n\t#define clr(x,y) memset(x,y,sizeof(x))\n\t#define cpy(x,y) memcpy(x,y,sizeof(x))\n\t#define fin(s) freopen(s\".in\",\"r\",stdin)\n\t#define fout(s) freopen(s\".out\",\"w\",stdout)\n\t#define fcin ios::sync_with_stdio(false)\n\t#define l2(n) (int(log2(n)))\n\t#define inf 0x3f3f3f3f\n\tMB T ABS(T x){return x>0?x:-x;}\n\tMB T MAX(T x,T y){return x>y?x:y;}\n\tMB T MIN(T x,T y){return x<y?x:y;}\n\tMB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n\tMB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 1000011\nint phi[N],pri[N],tot=0;\nll ans[N];\nbool f[N];\nvoid ol(int n){\n\tphi[1]=0;\n\tFur(i,2,n){\n\t\tif(!f[i])phi[i]=i-1,pri[++tot]=i;\n\t\tFur(j,1,tot){\n\t\t\tif(pri[j]*i>n)break;\n\t\t\tf[pri[j]*i]=1;\n\t\t\tif(i%pri[j])phi[i*pri[j]]=phi[i]*phi[pri[j]];\n\t\t\telse{\n\t\t\t\tphi[i*pri[j]]=phi[i]*pri[j];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tFur(i,1,n)ans[i]=phi[i];\n\tint len=sqrt(n);\n\tFur(i,2,len){\n\t\tans[i*i]+=phi[i]*i;\n\t\tfor(int j=i+1;i*j<=n;j++)\n\t\tans[i*j]+=phi[i]*j+phi[j]*i;\n\t}\n\tans[1]=0;\n\tFur(i,2,n)ans[i]+=ans[i-1];\n}\nint main(){\n\tol(1000000);\n\tint n;in>>n;\n\twhile(n){\n\t\tout<<ans[n]<<ln;\n\t\tin>>n;\n\t}\n}\n```\n","link":null,"tags":["数论","前缀和","欧拉函数"],"title":"LG SP3871 GCDEX"},{"categories":[["刷题记录"]],"content":"\n先把所有区间按右端点排序。\n\n因为$m \\le 10$,所以直接枚举$k$值就可以了\n\n假设当前位置为$i$,现在要找位置$j$满足$|b_i-b_j|$等于当前$k$值,可以是$b_i-b_j$,即$b_i > k$,也可以是$b_j - b_i = k$\n\n即$b_i+k = b_j, b_i+k\\le n$我们事先用$p_x$记录值为$x$在$b$数组中的哪个位置($b_i$互不相同,也就是$b$数组是$1$~$n$的组合)\n\n用线段树维护位置$i$可以达到的最大的值就可以了,因为已经按右端点排序好了,不会超过当前区间的右端点\n\n\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i=x;i<=y;i++)\n    #define Fdr(i,x,y) for(int i=x;i>=y;i--)\n    #define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) (int(log2(n)))\n    #define inf 0x3f3f3f3f\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){clr(ch,0);if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 100011\nint n,m,Q,a[N],b[N],k[N],ans[N],p[N],s[N<<2];\n#define ls rt<<1\n#define rs rt<<1|1\n#define pu s[rt]=MAX(s[ls],s[rs])\nvoid upd(int x,int c,int l=1,int r=n,int rt=1){\n\tif(l==r){\n\t\ts[rt]=MAX(s[rt],c);\n\t\treturn;\n\t}\n\tint m=(l+r)>>1;\n\tif(x<=m)upd(x,c,l,m,ls);\n\telse upd(x,c,m+1,r,rs);\n\tpu;\n}\nint ask(int L,int R,int l=1,int r=n,int rt=1){\n\tif(L<=l&&r<=R)return s[rt];\n\tint m=(l+r)>>1,ans=-(1<<30);\n\tif(L<=m)ans=ask(L,R,l,m,ls);\n\tif(R>m)ans=MAX(ans,ask(L,R,m+1,r,rs));\n\treturn ans;\n}\nstruct que{\n\tint l,r,id;\n}q[N];\nbool cmp(que x,que y){\n\treturn x.r<y.r;\n}\nint main(){\n\tin>>n>>Q>>m;\n\tFur(i,1,n)in>>a[i];\n\tFur(i,1,n)in>>b[i],p[b[i]]=i;\n\tFur(i,1,m)in>>k[i];\n\tFur(i,1,Q)in>>q[i].l>>q[i].r,q[i].id=i;\n\tsort(q+1,q+Q+1,cmp);\n\tint x=0;\n\tFur(i,1,Q){\n\t\twhile(x<q[i].r){\n\t\t\tx++;\n\t\t\tFur(j,1,m){\n\t\t\t\tif(b[x]>k[j]&&p[b[x]-k[j]]<=x)\n\t\t\t\t\tupd(p[b[x]-k[j]],a[x]+a[p[b[x]-k[j]]]);\n\t\t\t\tif(b[x]+k[j]<=n&&p[k[j]+b[x]]<=x)\n\t\t\t\t\tupd(p[k[j]+b[x]],a[x]+a[p[k[j]+b[x]]]);\n\t\t\t}\n\t\t}\n\t\tans[q[i].id]=ask(q[i].l,q[i].r);\n\t}\n\tFur(i,1,Q)out<<ans[i]<<ln;\n}\n\n```\n","link":null,"tags":[],"title":"51nod 1463 找朋友"},{"categories":[["刷题记录"]],"content":"\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n\t#pragma GCC optimize(3)\n\t#define il __inline__ __attribute__ ((always_inline))\n\t#define rg register\n\t#define ll long long\n\t#define ull unsigned long long\n\t#define db double\n\t#define sht short\n\t#define MB template <class T>il\n\t#define Fur(i,x,y) for(int i=x;i<=y;i++)\n\t#define Fdr(i,x,y) for(int i=x;i>=y;i--)\n\t#define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n\t#define clr(x,y) memset(x,y,sizeof(x))\n\t#define cpy(x,y) memcpy(x,y,sizeof(x))\n\t#define fin(s) freopen(s\".in\",\"r\",stdin)\n\t#define fout(s) freopen(s\".out\",\"w\",stdout)\n\t#define fcin ios::sync_with_stdio(false)\n\t#define l2(n) (int(log2(n)))\n\t#define inf 0x3f3f3f3f\n\tMB T ABS(T x){return x>0?x:-x;}\n\tMB T MAX(T x,T y){return x>y?x:y;}\n\tMB T MIN(T x,T y){return x<y?x:y;}\n\tMB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n\tMB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 10011\nint n,m,c[N],u[N],q[N],tp=0,r[N];\nstruct edge{\n\tint to,nxt,w;\n}e[N];\nint head[N],cnt=0;\nvoid add(int x,int y,int w){\n\te[++cnt].to=y;e[cnt].w=w;e[cnt].nxt=head[x];head[x]=cnt;\n}\nint main(){\n\tin>>n>>m;\n\tFur(i,1,n)\n\t\tin>>c[i]>>u[i];\n\tint x,y,w;\n\tFur(i,1,m)in>>x>>y>>w,add(x,y,w),r[y]++;\n\tFur(i,1,n)\n\t\tif(!r[i]&&c[i])q[++tp]=i;\n\twhile(tp){\n\t\tx=q[tp--];\n\t\tfl(i,x){\n\t\t\tr[to]--;c[to]+=e[i].w*c[x]-u[to];\n\t\t\tif(!r[to]&&c[to])q[++tp]=to;\n\t\t}\n\t}\n\tFur(i,1,n)if(!head[i]&&c[i])out<<i<<\" \"<<c[i]<<ln;\n}\n```\n","link":null,"tags":[],"title":"LG 1038 神经网络"},{"categories":[["刷题记录"]],"content":"\n$\\sum_{x=1}^n \\sum_{y=1}^n [gcd(x,y)=1][a_{b_x}=b_{a_y}]$\n\n可以直接记录$v[a_{b_x}]$然后统计,用莫比乌斯容斥\n```cpp\n#include <bits\/stdc++.h>\nusing namespace std;\n#define N 100011\n#define ll long long\nint a[N],b[N];\nint viss[N];\nint n;\nbool vis[N+10];  \nint prime[N+10],mu[N+10];  \nint cnt;\nvoid Init(){\n    memset(prime,0,sizeof(prime));  \n    memset(mu,0,sizeof(mu));  \n    memset(vis,0,sizeof(vis));  \n    mu[1] = 1;  \n    cnt = 0;  \n    for(int i=2; i<N; i++){  \n        if(!vis[i]){  \n            prime[cnt++] = i;  \n            mu[i] = -1;  \n        }  \n        for(int j=0; j<cnt&&i*prime[j]<N; j++){  \n            vis[i*prime[j]] = 1;  \n            if(i%prime[j]) mu[i*prime[j]] = -mu[i];  \n            else{  \n                mu[i*prime[j]] = 0;  \n                break;  \n            }  \n        }  \n    }\n}\n\nll cal(int x){\n    ll res=0;\n    for(int i=x;i<=n;i+=x)\n        viss[a[b[i]]]++;\n    for(int i=x;i<=n;i+=x)\n        res+=viss[b[a[i]]];\n    for(int i=x;i<=n;i+=x)\n        viss[a[b[i]]]--;\n    return res;\n}\nint main(){\n    Init();\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++)\n        scanf(\"%d\",&a[i]);\n    for(int i=1;i<=n;i++)\n        scanf(\"%d\",&b[i]);\n    ll res=0;\n    for(int i=1;i<=n;i++)\n        res+=1ll*mu[i]*cal(i);\n    printf(\"%lld\\n\",res );\n}\n\n```\n","link":null,"tags":["莫比乌斯"],"title":"51nod 1675 序列变换"},{"categories":[["刷题记录"]],"content":"\n看了看数据范围,可以知道是状态压缩+区间dp\n\n我们设$f[i][j][t]$表示$[i,j]$合并后状态为$t$获得的分数\n\n$f[i][j][t] = f[i][k][t'] + f[k+1][j][t''] (t'|t'' = t)$\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i=x;i<=y;++i)\n    #define Fdr(i,x,y) for(int i=x;i>=y;--i)\n    #define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){clr(ch,0);if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 311\n#define inf (1ll<<60)\nint n,k,c[1<<8],a[N];\nll f[N][N][1<<8],w[1<<8];\nint main(){\n    fin(\"in\");\n    in>>n>>k;\n    Fur(i,1,n)in>>a[i];\n    Fur(i,0,(1<<k)-1)in>>c[i]>>w[i];\n    clr(f,254);\n    Fdr(l,n,1)\n        Fur(r,l,n){\n            if(l==r){\n                f[l][r][a[l]]=0;\n                continue;\n            }\n            int len=(r-l)%(k-1);\n            if(!len)len=k-1;\n            for(int j=r;j>l;j-=k-1)\n                Fur(t,0,(1<<len)-1){\n                f[l][r][t<<1]=MAX(f[l][r][t<<1],f[l][j-1][t]+f[j][r][0]);\n                f[l][r][t<<1|1]=MAX(f[l][r][t<<1|1],f[l][j-1][t]+f[j][r][1]);\n            }\n            if(len==k-1){\n                ll g[2]={-inf,-inf};\n                Fur(t,0,(1<<k)-1)\n                    g[c[t]]=MAX(g[c[t]],f[l][r][t]+w[t]);\n                f[l][r][0]=g[0];\n                f[l][r][1]=g[1];\n            }\n        }\n    \n    ll ans=-inf;\n    Fur(i,0,(1<<k)-1)ans=MAX(ans,f[1][n][i]);\n    out<<ans<<ln;\n}\n```\n","link":null,"tags":["状态压缩","动态规划","区间dp"],"title":"LG 3736 [HAOI2016]字符合并"},{"categories":[["刷题记录"]],"content":"\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n\t#pragma GCC optimize(3)\n\t#define il __inline__ __attribute__ ((always_inline))\n\t#define rg register\n\t#define ll long long\n\t#define ull unsigned long long\n\t#define db double\n\t#define sht short\n\t#define MB template <class T>il\n\t#define Fur(i,x,y) for(int i=x;i<=y;i++)\n\t#define Fdr(i,x,y) for(int i=x;i>=y;i--)\n\t#define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n\t#define clr(x,y) memset(x,y,sizeof(x))\n\t#define cpy(x,y) memcpy(x,y,sizeof(x))\n\t#define fin(s) freopen(s\".in\",\"r\",stdin)\n\t#define fout(s) freopen(s\".out\",\"w\",stdout)\n\t#define fcin ios::sync_with_stdio(false)\n\t#define l2(n) (int(log2(n)))\n\t#define inf 0x3f3f3f3f\n\tMB T ABS(T x){return x>0?x:-x;}\n\tMB T MAX(T x,T y){return x>y?x:y;}\n\tMB T MIN(T x,T y){return x<y?x:y;}\n\tMB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n\tMB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 10011\nint n,cnt=0,m,k,tmp,ans[N],head[N],X[N],Y[N],D[N],d[N],que[N];\nbool v[N];\nstruct edge{\n\tint to,nxt;\n}e[N];\nvoid add(int x,int y){\n\te[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;\n}\nint q[N];\nvoid bfs(int *D){\n\tint h=0,t=1,x;\n\tq[h]=1;D[1]=0;\n\twhile(h<t){\n\t\tx=q[h++];\n\t\tfl(i,x)\n\t\tif(!D[to]){\n\t\t\tD[to]=D[x]+1;\n\t\t\tq[t++]=to;\n\t\t}\n\t}\n}\nvoid dfs(int x,int f){\n\tfl(i,x)\n\tif(to!=f&&D[to]==d[x]+1&&D[to]!=d[to]){\n\t\td[to]=d[x]+1;tmp++;\n\t\tdfs(to,x);\n\t}\n}\nint main(){\n\tin>>n>>m>>k;\n\tint x,y;\n\tFur(i,1,m)in>>X[i]>>Y[i],add(X[i],Y[i]);\n\tbfs(D);\n\tclr(head,0);cnt=0;\n\tFur(i,1,k)in>>que[i],v[que[i]]=1;\n\tFur(i,1,k)if(!v[i])add(X[i],Y[i]),add(Y[i],X[i]);\n\tbfs(d);\n\tFdr(i,k,1){\n\t\tx=X[que[i]];y=Y[que[i]];tmp=0;\n\t\tif(D[x]==d[x]&&d[y]==d[x]+1&&d[y]!=D[y])tmp++,d[y]=d[y],dfs(y,x);\n\t\tSWAP(x,y);\n\t\tif(D[x]==d[x]&&d[y]==d[x]+1&&d[y]!=D[y])tmp++,d[y]=d[y],dfs(y,x);\n\t\tadd(x,y),add(y,x);\n\t\tans[i]=tmp;\n\t}\n\tFur(i,1,k)ans[i]+=ans[i-1],out<<ans[i]<<ln;\n}\n```\n","link":null,"tags":[],"title":"LG 1710 地铁涨价"},{"categories":[["刷题记录"]],"content":"\n咋一看：\n\n$f[i][j] = MAX(f[i-1][j-1]+a[j]*i,f[i][j-1]+a[j]*j)$\n\n但$n \\le 3 \\times 10^5$,。。。\n\n。。。\n\n那么其实这不是dp题,而是思维题\n\n我们发现：\n\n$(s[r]-s[l])\\times k +(s[r']-s[l'])\\times(k-1)+...+s[r''']$\n\n$s$表示前缀和,$g$表示后缀和\n\n相当于：\n\n$g[x_1]+g[x_2]+g[x_3]+...$\n\n那我们给后缀和排个序就可以了\n\n### 注意：\n\n答案里必须要有$g_1$,这就是为什么要g1加(1ll<<50)再答案减(1ll<<50)的原因\n\n\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n\t#pragma GCC optimize(3)\n\t#define il __inline__ __attribute__ ((always_inline))\n\t#define rg register\n\t#define ll long long\n\t#define ull unsigned long long\n\t#define db double\n\t#define sht short\n\t#define MB template <class T>il\n\t#define Fur(i,x,y) for(int i=x;i<=y;i++)\n\t#define Fdr(i,x,y) for(int i=x;i>=y;i--)\n\t#define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n\t#define clr(x,y) memset(x,y,sizeof(x))\n\t#define cpy(x,y) memcpy(x,y,sizeof(x))\n\t#define fin(s) freopen(s\".in\",\"r\",stdin)\n\t#define fout(s) freopen(s\".out\",\"w\",stdout)\n\t#define fcin ios::sync_with_stdio(false)\n\t#define l2(n) (int(log2(n)))\n\t#define inf 0x3f3f3f3f\n\tMB T ABS(T x){return x>0?x:-x;}\n\tMB T MAX(T x,T y){return x>y?x:y;}\n\tMB T MIN(T x,T y){return x<y?x:y;}\n\tMB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n\tMB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 300011\nll n,k,g[N],a[N],ans=0;\nint main(){\n\tin>>n>>k;\n\tFur(i,1,n)in>>a[i];\n\tFdr(i,n,1)g[i]=g[i+1]+a[i];g[1]+=1ll<<50;\n\tsort(g+1,g+n+1);\n\tFdr(i,n,n-k+1)ans+=g[i];\n\tans-=1ll<<50;\n\tout<<ans<<ln;\n}\n```\n","link":null,"tags":["前缀和","排序"],"title":"LG CF1175D Array-Splitting"},{"categories":[["刷题记录"]],"content":"\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;rg char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\n#define N 100011\nint n,f[N];\nset<int>T[N];\nvoid gf(int x){\n\n}\nvoid mg(int x,int y){\n    \n}\nint main(){\n    \n}\n```\n","link":null,"tags":["并查集","set"],"title":"51nod 1515 明辨是非"},{"categories":[["刷题记录"]],"content":"\n先预处理出以$i$结尾最长多少个连续\n\n然后$rmq$预处理\n\n查询的时候要先查以左端点开始最长多少,然后再求剩下的那段区间\n\n*注意多组数据*\n\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i=x;i<=y;++i)\n    #define Fdr(i,x,y) for(int i=x;i>=y;--i)\n    #define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 0x3f3f3f3f\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){clr(ch,0);if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 100011\nint n,q,a[N],f[18][N];\nint ask(int l,int r){\n    if(l>r)return 0;\n    int k=l2(r-l+1);\n    return MAX(f[k][l],f[k][r-(1<<k)+1]);\n}\nint main(){\n    fin(\"in\");\nwhile(1){\n    clr(a,0);clr(f,0);\n    in>>n;\n    if(!n)break;\n    in>>q;\n    Fur(i,1,n)in>>a[i];\n    Fur(i,1,n)f[0][i]=((a[i]==a[i-1])?f[0][i-1]+1:1);\n    Fur(k,1,17)\n        Fur(i,1,n-(1<<k)+1)\n        f[k][i]=MAX(f[k-1][i],f[k-1][i+(1<<(k-1))]);\n    int x,y,ans;\n    while(q--){\n        in>>x>>y;\n        ans=1;\n        while(a[x]==a[x+1]&&x<y)++x,++ans;\n        ++x;\n        out<<MAX(ans,ask(x,y))<<ln;\n    }\n}\n}\n```\n","link":null,"tags":["rmq"],"title":"LG SP1684 FREQUENT - Frequent values"},{"categories":[["刷题记录"]],"content":"\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i=x;i<=y;i++)\n    #define Fdr(i,x,y) for(int i=x;i>=y;i--)\n    #define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) (int(log2(n)))\n    #define inf 0x3f3f3f3f\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){clr(ch,0);if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 40011\n#define int ll\n#define ls rt<<1\n#define rs rt<<1|1\nint n,W,H,s[N<<2],val[N],laz[N<<2];\nstruct node{\n\tint p,x,y,v;\n}a[N];\nstruct NODE{\n    int x,id,f;\n}b[N];\nil bool cmp(node x,node y){\n\treturn (x.p==y.p)?(x.v>y.v):(x.p<y.p);\n}\nil bool cmp2(NODE x,NODE y){\n    return x.x<y.x;\n}\nvoid pd(int rt){\n\tif(laz[rt]){\n\t\tlaz[ls]+=laz[rt];laz[rs]+=laz[rt];\n\t\ts[ls]+=laz[rt];s[rs]+=laz[rt];\n\t\tlaz[rt]=0;\n\t}\n}\nvoid upd(int L,int R,int v,int l,int r,int rt){\n    if(L<=l&&r<=R){\n        s[rt]+=v;laz[rt]+=v;\n        return;\n    }\n    int m=(l+r)>>1;\n\tpd(rt);\n    if(L<=m)upd(L,R,v,l,m,ls);\n    if(R>m)upd(L,R,v,m+1,r,rs);\n\ts[rt]=MAX(s[ls],s[rs]);\n}\nsigned main(){\nint T;in>>T;\nwhile(T--){\n\tint x,y,v;\n\tclr(s,0),clr(laz,0);\n\tclr(a,0);clr(b,0);clr(val,0);\n\tin>>n>>W>>H;\n\tFur(i,1,n){\n\t\tin>>x>>y>>v;\n\t\ta[i]=node{x,y,y+H-1,v};\n\t\ta[i+n]=node{x+W-1,y,y+H-1,-v};\n\t\tb[i]=NODE{y,i,0};b[i+n]=NODE{y+H-1,i,1};\n\t}\n\tsort(b+1,b+n*2+1,cmp2);\n    int d=0;\n    Fur(i,1,n*2){\n        if(b[i].x!=b[i-1].x)d++;\n        val[d]=b[i].x;\n        if(b[i].f)a[b[i].id].y=a[b[i].id+n].y=d;\n        else a[b[i].id].x=a[b[i].id+n].x=d;\n    }\n\tsort(a+1,a+n*2+1,cmp);\n    int ans=0;\n    Fur(i,1,n*2){\n        upd(a[i].x,a[i].y-1,a[i].v,1,n*2,1);\n        ans=MAX(ans,s[1]);\n    }\n    out<<ans<<ln;\n}\n}\n```\n","link":null,"tags":["扫描线"],"title":"LG 1502 窗口的星星"},{"categories":[["刷题记录"]],"content":"\nhttps:\/\/www.cnblogs.com\/dplearning\/p\/4719375.html\n\n\n$f[i][0]$：不包含$62$和$4$,\n\n$f[i][1]$:$2$开头幸运数,\n\n$f[i][2]$:含$4$或$62$,\n\n$f[0][0]=1,f[0][1]=f[0][2]=1$.\n\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n\t#pragma GCC optimize(3)\n\t#define il __inline__ __attribute__ ((always_inline))\n\t#define rg register\n\t#define ll long long\n\t#define ull unsigned long long\n\t#define db double\n\t#define sht short\n\t#define MB template <class T>il\n\t#define Fur(i,x,y) for(int i=x;i<=y;i++)\n\t#define Fdr(i,x,y) for(int i=x;i>=y;i--)\n\t#define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n\t#define clr(x,y) memset(x,y,sizeof(x))\n\t#define cpy(x,y) memcpy(x,y,sizeof(x))\n\t#define fin(s) freopen(s\".in\",\"r\",stdin)\n\t#define fout(s) freopen(s\".out\",\"w\",stdout)\n\t#define fcin ios::sync_with_stdio(false)\n\t#define l2(n) (int(log2(n)))\n\t#define inf 0x3f3f3f3f\n\tMB T ABS(T x){return x>0?x:-x;}\n\tMB T MAX(T x,T y){return x>y?x:y;}\n\tMB T MIN(T x,T y){return x<y?x:y;}\n\tMB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n\tMB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 10011\nint f[8][3];\nint solve(int x){\n\tint num[11],n=0,ans=0,t=x;\n\twhile(x){\n\t\tnum[++n]=x%10;\n\t\tx\/=10;\n\t}\n\tbool ff=0;\n\tFdr(i,n,1){\n\t\tans+=num[i]*f[i-1][2];\n\t\tif(ff)ans+=num[i]*f[i-1][0];\n\t\telse{\n\t\t\tif(num[i]>4)\n\t\t\t\tans+=f[i-1][0];\n\t\t\tif(num[i]>6)\n\t\t\t\tans+=f[i-1][1];\n\t\t\tif(num[i+1]==6&&num[i]>2)\n\t\t\t\tans+=f[i][1];\n\t\t}\n\t\tif(num[i]==4||(num[i+1]==6&&num[i]==2))\n\t\t\tff=1;\n\t}\n\treturn t-ans;\n}\nint main(){\n\tclr(f,0);\n\tf[0][0]=1;\n\tFur(i,1,7)\n\t\tf[i][0]=f[i-1][0]*9-f[i-1][1],\n\t\tf[i][1]=f[i-1][0],\n\t\tf[i][2]=f[i-1][2]*10+f[i-1][0]+f[i-1][1];\n\t\n\tint l,r;\n\twhile(1){\n\t\tin>>l>>r;\n\t\tif(!l&&!r)break;\n\t\tout<<(solve(r+1)-solve(l))<<ln;\n\t}\n}\n```\n","link":null,"tags":["数位dp"],"title":"HDU 2089 不要62"},{"categories":[["刷题记录"]],"content":"\n先将$b$数组从小到大排序\n\n设选中了$x$对$a > b$,由总对数为$n$,由$x-(n-x)=k$,可以知道$x=\\frac{n+k}2$\n\n我们设$f(i,j)$为前$i$个$a$中选中了$j$组$a > b$的方案数\n\n那么$f(i,j)=f(i-1,j)+f(i-1,j-1)\\times(l_i-j+1)$\n\n($l_i$表示$b$中小于$a_i$的最后一个位置)\n\n但是还有剩下的$n-x$对\n\n我们可以设$g_i$表示$a>b$对数$\\ge i$的方案数\n\n那么$g_i = f(n,i) \\times (n-i)!$(相当于剩下的随便排列组合)\n\n我们设$f_i$表示$a>b$对数恰好为$i$对的方案数\n\n那么$g_k = \\sum_{i=k}^n f_i \\times {i\\choose k}$\n (相当于从恰好$i$个方案中选$k$对出来)\n\n经过二项式反演可以知道:\n\n$f(k)=\\sum_{i=k}^n(-1)^{i-k}{i\\choose k}g(i)$\n\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;rg char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\n#define N 4011\nconst int mod = 1000000009;\nint n,k,f[N][N],a[N],b[N],l[N],fac[N],inv[N],g[N];\nil int pw(int x,int p){\n    int ans=1;\n    while(p){\n        if(p&1)ans=1ll*ans*x%mod;\n        p>>=1;x=1ll*x*x%mod;\n    }\n    return ans;\n}\nint C(int a,int b){\n    return 1ll*fac[a]*inv[b]%mod*inv[a-b]%mod;\n}\nsigned main(){\n    in(n,k);\n    if((n+k)&1){puts(\"0\");return 0;};\n    k=(n+k)>>1;\n    Fur(i,1,n)in(a[i]);\n    Fur(i,1,n)in(b[i]);\n    fac[0]=inv[0]=1;\n    Fur(i,1,n)fac[i]=1ll*fac[i-1]*i%mod;\n    inv[n]=pw(fac[n],mod-2);\n    Fdr(i,n-1,0)inv[i]=1ll*inv[i+1]*(i+1)%mod;\n    sort(a+1,a+n+1);\n    sort(b+1,b+n+1);\n    int p=0;\n    Fur(i,1,n){\n        while(p<n&&b[p+1]<a[i])++p;\n        l[i]=p;\n    }\n    f[0][0]=1;\n    Fur(i,1,n){\n        f[i][0]=1;\n        Fur(j,1,i)\n            f[i][j]=(f[i-1][j]+1ll*f[i-1][j-1]*MAX(0,l[i]-j+1)%mod)%mod;\n    }\n    Fur(i,0,n)g[i]=1ll*f[n][i]*fac[n-i]%mod;\n    int ans=0;\n    Fur(i,k,n)\n        if((i-k)&1)ans=(ans-1ll*C(i,k)*g[i]%mod+mod)%mod;\n        else ans=(ans+1ll*C(i,k)*g[i]%mod)%mod;\n    \n    printf(\"%d\\n\",ans);\n}\n```\n","link":null,"tags":["动态规划","容斥"],"title":"LG 4859 已经没有什么好害怕的了"},{"categories":[["刷题记录"]],"content":"\n设选区间$[l,r]$,要穿$x$号的人数为$f(x)$\n\n必须满足 $\\sum_{i=l}^{r}f(i) \\le (r-l+1+d) \\times k$\n\n$\\sum_{i=l}^{r}(f(i)-k) \\le kd$\n\n那么用线段树维护全局最大子段和就可以了\n\n\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n\t#pragma GCC optimize(3)\n\t#define il __inline__ __attribute__ ((always_inline))\n\t#define rg register\n\t#define ll long long\n\t#define ull unsigned long long\n\t#define db double\n\t#define sht short\n\t#define MB template <class T>il\n\t#define Fur(i,x,y) for(int i=x;i<=y;i++)\n\t#define Fdr(i,x,y) for(int i=x;i>=y;i--)\n\t#define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n\t#define clr(x,y) memset(x,y,sizeof(x))\n\t#define cpy(x,y) memcpy(x,y,sizeof(x))\n\t#define fin(s) freopen(s\".in\",\"r\",stdin)\n\t#define fout(s) freopen(s\".out\",\"w\",stdout)\n\t#define fcin ios::sync_with_stdio(false)\n\t#define l2(n) (int(log2(n)))\n\t#define inf 0x3f3f3f3f\n\tMB T ABS(T x){return x>0?x:-x;}\n\tMB T MAX(T x,T y){return x>y?x:y;}\n\tMB T MIN(T x,T y){return x<y?x:y;}\n\tMB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n\tMB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 500011\n#define int ll\n#define ls rt<<1\n#define rs rt<<1|1\nint n,m,k,d,s[N<<2],S[N<<2],sl[N<<2],sr[N<<2];\nvoid pu(int rt){\n\tS[rt]=S[ls]+S[rs];\n\ts[rt]=MAX(MAX(s[ls],s[rs]),sr[ls]+sl[rs]);\n\tsl[rt]=MAX(sl[ls],S[ls]+sl[rs]);\n\tsr[rt]=MAX(sr[rs],S[rs]+sr[ls]);\n}\nvoid build(int l,int r,int rt){\n\tif(l==r){\n\t\ts[rt]=sl[rt]=sr[rt]=S[rt]=-k;\n\t\treturn;\n\t}\n\tint m=(l+r)>>1;\n\tbuild(l,m,ls);build(m+1,r,rs);\n\tpu(rt);\n}\nvoid upd(int x,int v,int l,int r,int rt){\n\tif(l==r){\n\t\ts[rt]=sl[rt]=sr[rt]=S[rt]=s[rt]+v;\n\t\treturn;\n\t}\n\tint m=(l+r)>>1;\n\tif(x<=m)upd(x,v,l,m,ls);\n\telse upd(x,v,m+1,r,rs);\n\tpu(rt);\n}\nsigned main(){\n\tin>>n>>m>>k>>d;\n\tint x,y;\n\tbuild(1,n,1);\n\twhile(m--){\n\t\tin>>x>>y;\n\t\tupd(x,y,1,n,1);\n\t\tif(s[1]<=k*d)out<<\"TAK\\n\";\n\t\telse out<<\"NIE\\n\";\n\t}\n}\n```\n","link":null,"tags":["线段树"],"title":"LG 3488 [POI2009]LYZ-Ice-Skates"},{"categories":[["刷题记录"]],"content":"\n设$E_x$为$x$到$n$的期望时间\n\n$E_x = \\sum_i E_i \\times p_{xi}\\prod_{j=1}^{i-1}(1-p_{xj})$\n\n我们可以用类似`dij`的思想来更新\n\n每次取出$E_x$最小的$x$来更新\n\n要注意我们现在求出来的还没算上$1$需要先停留在原地的概率,\n\n除掉一个$1-\\prod p$才是最终的期望\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;rg char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\n#define N 1011\nint n;\ndb g[N][N],p[N],E[N];\nbool v[N];\nint main(){\n    in(n);\n    int x;\n    Fur(i,1,n)Fur(j,1,n)in(x),g[i][j]=x\/100.0;\n    if(n==1)return puts(\"0\"),0;\n    Fur(i,1,n)E[i]=1,p[i]=1-g[i][n];\n    E[n]=0;v[n]=1;\n    Fur(i,1,n){\n        x=0;db mx=1e18;\n        Fur(j,1,n)\n        if(!v[j]&&E[j]\/(1-p[j])<mx)\n            mx=E[j]\/(1-p[j]),x=j;\n        v[x]=1;\n        if(x==1)return printf(\"%.10f\\n\",E[1]\/(1-p[1])),0;\n        Fur(j,1,n)\n            E[j]+=(E[x]\/(1-p[x]))*g[j][x]*p[j],p[j]*=(1-g[j][x]);\n    }\n}\n```\n","link":null,"tags":["期望","动态规划"],"title":"LG CF605E Intergalaxy-Trips"},{"categories":[["刷题记录"]],"content":"\n用$link\\ cut\\ tree$维护最小生成树\n\n直接在线很难,我们可以离线加边\n\n先把所有边(后来断掉的不算)跑一遍最小生成树\n\n接着每次加边,设加$x$到$y$,边长为$w$\n\n先求出$x$到$y$路径上最长的边\n\n如果比要加的边长,则删掉这条边,加上新边\n\n这样就可以$lct$维护最小生成树\n\n因为$lct$不能直接维护点,所以我们可以把边看成点\n\n$x\\rightarrow边\\rightarrow y$\n\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n\t#pragma GCC optimize(3)\n\t#define il __inline__ __attribute__ ((always_inline))\n\t#define rg register\n\t#define ll long long\n\t#define ull unsigned long long\n\t#define db double\n\t#define sht short\n\t#define MB template <class T>il\n\t#define Fur(i,x,y) for(int i=x;i<=y;i++)\n\t#define Fdr(i,x,y) for(int i=x;i>=y;i--)\n\t#define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n\t#define clr(x,y) memset(x,y,sizeof(x))\n\t#define cpy(x,y) memcpy(x,y,sizeof(x))\n\t#define fin(s) freopen(s\".in\",\"r\",stdin)\n\t#define fout(s) freopen(s\".out\",\"w\",stdout)\n\t#define fcin ios::sync_with_stdio(false)\n\t#define l2(n) (int(log2(n)))\n\t#define inf 0x3f3f3f3f\n\tMB T ABS(T x){return x>0?x:-x;}\n\tMB T MAX(T x,T y){return x>y?x:y;}\n\tMB T MIN(T x,T y){return x<y?x:y;}\n\tMB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n\tMB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 300011\n#define ls c[x][0]\n#define rs c[x][1]\nint st[N],f[N],c[N][2],v[N],s[N];\nbool rev[N];\nbool irt(int x){return c[f[x]][0]!=x&&c[f[x]][1]!=x;}\nvoid pu(int x){s[x]=MAX(MAX(s[ls],s[rs]),v[x]);}\nvoid pr(int x){\n\tSWAP(ls,rs);\n\trev[x]^=1;\n}\nvoid pd(int x){\n\tif(rev[x]){\n\t\tif(ls)pr(ls);\n\t\tif(rs)pr(rs);\n\t\trev[x]=0;\n\t}\n}\nbool g(int x){return c[f[x]][1]==x;}\nvoid turn(int x){\n\tint y=f[x],z=f[y],l=g(x),r=!l,w=c[x][r];\n\tif(!irt(y))c[z][g(y)]=x;\n\tc[x][r]=y;c[y][l]=w;\n\tif(w)f[w]=y;\n\tf[x]=z;f[y]=x;\n\tpu(y);pu(x);\n}\nvoid splay(int x){\n\tint y=x,z=0;\n\tst[++z]=y;\n\twhile(!irt(y))st[++z]=y=f[y];\n\twhile(z)pd(st[z--]);\n\twhile(!irt(x)){\n\t\ty=f[x],z=f[y];\n\t\tif(!irt(y))\n\t\t\tturn(((c[y][0]==x)^(c[z][0]==y))?x:y);\n\t\tturn(x);\n\t}\n\tpu(x);\n}\nvoid access(int x){\n\tfor(int y=0;x;x=f[y=x])\n\t\tsplay(x),rs=y,pu(x);\n}\nvoid mrt(int x){\n\taccess(x);splay(x);\n\tpr(x);\n}\nint frt(int x){\n\taccess(x);splay(x);\n\twhile(ls)pd(x),x=ls;\n\tsplay(x);\n\treturn x;\n}\nvoid sl(int x,int y){\n\tmrt(x);access(y);splay(y);\n}\nvoid link(int x,int y){\n\tmrt(x);\n\tif(frt(y)!=x)f[x]=y;\n}\nvoid cut(int x,int y){\n\tmrt(x);\n\tif(frt(y)==x&&f[y]==x&&!c[y][0]){\n\t\tc[x][1]=f[y]=0;\n\t\tpu(x);\n\t}\n}\nint find(int x,int k){\n\tif(v[x]==k)return x;\n\tif(s[ls]==k)return find(ls,k);\n\treturn find(rs,k);\n}\nint n,m,q;\nstruct edge{\n\tedge(){b=1;}\n\tint x,y,w,b;\n}e[N];\nstruct que{\n\tint u,x,y;\n}Q[N];\nint id[5011][5011],ff[N],ans[N],cnt=0;\nbool cmp(edge x,edge y){\n\treturn x.w<y.w;\n}\nint gf(int x){return x==ff[x]?x:(ff[x]=gf(ff[x]));}\nint main(){\n\tfin(\"in\");\n\tin>>n>>m>>q;\n\tint x,y,w,u,t;\n\tFur(i,1,m)in>>e[i].x>>e[i].y>>e[i].w;\n\tsort(e+1,e+m+1,cmp);\n\tFur(i,1,m){\n\t\tx=e[i].x,y=e[i].y;w=e[i].w;\n\t\tid[x][y]=id[y][x]=i;\n\t\tv[n+i]=w;\n\t}\n\tFur(i,1,q){\n\t\tin>>u>>x>>y;\n\t\tif(u==2)e[id[x][y]].b=0;\n\t\tQ[i]=(que){u,x,y};\n\t}\n\t\n\tFur(i,1,n)ff[i]=i;\n\tFur(i,1,m)if(e[i].b){\n\t\tx=e[i].x,y=e[i].y;\n\t\tif(gf(x)!=gf(y)){\n\t\t\tff[gf(x)]=gf(y);\n\t\t\tlink(x,n+i);link(y,n+i);\n\t\t}\n\t}\n\tFdr(i,q,1){\n\t\tu=Q[i].u;x=Q[i].x;y=Q[i].y;\n\t\tsl(x,y);\n\t\tif(u==1)ans[++cnt]=s[y];\n\t\telse\n\t\t\tif(s[y]>v[n+id[x][y]])\n\t\t\t\tt=find(y,s[y]),\n\t\t\t\tcut(e[t-n].x,t),\n\t\t\t\tcut(e[t-n].y,t),\n\t\t\t\tlink(x,n+id[x][y]),\n\t\t\t\tlink(y,n+id[x][y]);\n\t}\n\tFdr(i,cnt,1)out<<ans[i]<<ln;\n}\n```\n","link":null,"tags":["lct","最小生成树","并查集"],"title":"LG 4172 [WC2006]水管局长"},{"categories":[["刷题记录"]],"content":"\n可以用带权并查集维护\n\n设$s_x$表示$x$到父亲的异或值\n\n当合并的时候\n\n先$l=l-1$\n\n设$fl,fr$分别为$l,r$的父亲\n\n合并后应该是:$s_r \\bigoplus s_l = x$\n\n$\\because s_r' = x \\bigoplus s_l, s_r' = s_r \\bigoplus s_{fr}'$,\n\n$\\therefore s_{fr}' = x \\bigoplus s_l \\bigoplus s_r$\n\n我们又看到$0 \\leq i < 2^{30}$\n\n我们可以用hash或map离散化\n\n注意$l,r$可以为$0$,所以实际操作时应该`++r`\n\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;rg char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\n#define N 400022\n#include<bits\/extc++.h>\nusing namespace __gnu_pbds;\nmap<int,int>f,s;\nint q;\nint gf(int x){\n    if(!f.count(x))return x;\n    int t=gf(f[x]);\n    s[x]^=s[f[x]];\n    return f[x]=t;\n}\nint main(){\n    in(q);\n    int la=0;\n    while(q--){\n        int opt,l,r,x;\n        in(opt,l,r);\n        l^=la;r^=la;\n        if(l>r)SWAP(l,r);\n        --l;\n        if(opt==1){\n            in(x);x^=la;\n            int fl=gf(l),fr=gf(r);\n            if(fl!=fr){\n                f[fr]=fl;\n                s[fr]=x^s[l]^s[r];\n            }\n        }\n        else{\n            if(gf(l)!=gf(r))out(\"-1\\n\"),la=1;\n            else{\n                la=s[r]^s[l];\n                out(la,ln);\n            }\n        }\n    }\n    flush();\n}\n```\n","link":null,"tags":["位运算","并查集"],"title":"LG CF1044D Deduction-Queries"},{"categories":[["刷题记录"]],"content":"\n## 题意：\n\n给出一个矩阵,要求每行只能选一个节点,每列选的节点不能超过所有选的节点的一半,不能不选,\n给出每个节点的选择方案数,求总方案数\n\n## 解法\n\n考虑到限制是每列选择的不能超过一半,我们可以想到不合法的最多只有一列 \n\n我们可以用总方案数减去不符合的\n\n$s_i=\\sum_{j=1}^m a_{ij}$\n\n总方案数：$\\prod_{i=1}^n (s_i+1) - 1$\n\n$\\because k=\\frac {tot}2$\n\n所以我们有一个很妙的方法:\n\n设选中目标行之外的权值+1,不选+0,选中目标行权值位+2\n\n最后只要权值$> n$,那么目标行一定被选了超过$\\frac n2$次\n\n设$f(i,k)$表示总共选了$i$次(也就是选到第$i$行)权值为$k$的方案数 \n\n\n$f(i,k) += f(i-1,k)*(s_i-a_{ij})$(当前行不选目标列\n\n$f(i,k+1) += f(i-1,k)$(当前行完全不选\n\n$f(i,k+2) += f(i-1,k)\\times a_{ij}$(当前行选中目标列\n\n$ans = \\prod_{i=1}^n (s_i+1) - 1 - \\sum_{i=n+1}^{2n} f(n,i)$\n```cpp\n#include<bits\/stdc++.h>\nusing namespace std;\n#define N 111\ntypedef long long ll;\nconst int mod=998244353;\nint a[N][2011],n,m;\nll f[N][2011],s[N];\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;++i)\n\t\tfor(int j=1;j<=m;++j)\n\t\t\tscanf(\"%d\",&a[i][j]),\n            s[i]=(s[i]+a[i][j])%mod;\n\t\t\t\n\tll ans=1; \n\tfor(int i=1;i<=n;++i)\n\t\tans=(ans*(s[i]+1))%mod;\n\t\n    --ans;\n\tfor(int j=1;j<=m;++j){\n        memset(f,0,sizeof f);\n        f[0][0]=1;\n        for(int i=1;i<=n;++i)\n            for(int k=0;k<=n*2;++k){\n                f[i][k]=(f[i][k]+f[i-1][k]*(s[i]-a[i][j]))%mod;\n                f[i][k+1]=(f[i][k+1]+f[i-1][k])%mod;\n                f[i][k+2]=(f[i][k+2]+f[i-1][k]*a[i][j])%mod;\n            }\n        for(int i=n+1;i<=n*2;++i)\n            ans=(ans-f[n][i])%mod;\n    }\n    printf(\"%lld\\n\",(ans+mod)%mod);\n}\n```\n","link":null,"tags":["容斥","动态规划"],"title":"LG 5664 Emiya-家今天的饭"},{"categories":[["刷题记录"]],"content":"\n保证这个数不会超过$500000$\n\n那么就是背包了\n\n买卖股票有3种方法:\n\n1. 买,第二天卖了\n   \n2. 不买(相当于买了然后卖了)\n   \n3. 买了,过几天再卖(相当于买了了,接下来卖了再买了)\n\n跑$d-1$次背包即可\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;rg char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\n#define N 500011\nint n,m,V,a[51][51],f[N];\nint main(){\n    in(n,m,V);\n    Fur(i,1,n)\n        Fur(j,1,m)\n        in(a[i][j]);\n    int ans=V,mx;\n    Fur(i,2,m){\n        mx=0;\n        clr(f,0);\n        Fur(j,1,n)\n            Fur(k,a[j][i-1],ans){\n                f[k]=MAX(f[k],f[k-a[j][i-1]]+a[j][i]-a[j][i-1]);\n                mx=MAX(mx,f[k]);\n            }\n        ans+=mx;\n    }\n    printf(\"%d\\n\",ans);\n}\n```\n","link":null,"tags":["动态规划","背包"],"title":"LG 2938 [USACO09FEB]股票市场Stock-Market"},{"categories":[["刷题记录"]],"content":"\n## 题目大意：\n\n给定一个长度为 $n\\leq 500000$ 的序列 $a_1, a_2, \\cdots, a_n$ ,要求对于每一个 $1 \\leq r \\leq n$ ,找到最小的非负整数 $f_{r}$ 满足\n\n$$\\forall l\\in\\left[1,n\\right]:a_l \\leq a_r + f_{r} - \\sqrt{|r-l|}$$\n\n## 解法\n\n考虑$l<r,r>l$的将序列翻转后再来一次就可以了\n\n$$f_r= \\max(a_l+\\sqrt{r-l})-a_r(l\\in[1,r])$$\n\n可以证明$f_r$的最优决策点是递增的\n\n~~可以打表~~\n\n### 分治解法\n\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define db double\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;rg char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\n#define N 500011\nint n;\nll a[N];\nlong db f1[N],f2[N];\nvoid work(int L,int R,int l,int r,long db *f){\n    if(L>R)return;\n    int m=(L+R)>>1,k=0;\n    f[m]=a[m];\n    long db t=0;\n    Fur(i,l,MIN(r,m)){\n        t=a[i]+sqrt(db(m-i));\n        if(t>f[m])k=i,f[m]=t;\n    }\n    f[m]-=a[m];\n    if(!k)k=m;\n    work(L,m-1,l,k,f);\n    work(m+1,R,k,r,f);\n}\nint main(){\n    in(n);\n    Fur(i,1,n)in(a[i]);\n    work(1,n,1,n,f1);\n    reverse(a+1,a+n+1);\n    work(1,n,1,n,f2);\n    Fur(i,1,n)out((ll)ceil(MAX(f1[i],f2[n-i+1])),ln);\n    flush();\n}\n```\n\n### 队列实现决策二分栈\n\n对于每个$j$,把$a_j+\\sqrt{i-j}$看成关于$i$的函数$f_j$。\n\n我们要做的就是在所有$j\\leq i$的函数中找到最值\n\n队列实现决策二分栈,按$j$从小到大依次维护这些函数。\n\n对于其中任意两个相邻的函数$f_t,f_{t+1}$ ,它们都有一个临界值$k_{t,t+1}$\n\n显然序列中的$k_{1,2},k_{2,3}...$也要严格递增。\n\n否则,如果$k_{t,t+1}\\ge k_{t+1,t+2}$,$f_{t+1}$根本没有用。\n\n每次加入$f_i$的时候：\n\n设队尾为$t$,如果当前$i$比$t$优($calc(k_{t-1},i)\\ge calc(k_{t-1},t)$),那么弹出$t$\n\n现在来考虑队头$h$\n\n若$k_h\\le i$那么把$h$弹出\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define register\n    #define ll long long\n    #define db double\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\n#define N 500011\nint n,a[N],q[N],k[N];\ndb p[N],sq[N];\nil db calc(int i,int j){return a[j]+sq[i-j];}\/\/函数值\nil int bound(int x,int y){\n    int l=y,r=(k[x]?k[x]:n),m,ret=r+1;\n    while(l<=r){\n        m=(l+r)>>1;\n        if(calc(m,x)<=calc(m,y))\n            ret=m,r=m-1;\n        else l=m+1;\n    }\n    return ret;\n}\nvoid work(){\n    int h=1,t=0;\n    Fur(i,1,n){\n        while(h<t&&calc(k[t-1],q[t])<calc(k[t-1],i))--t;\n        \/\/保持k单调\n        k[t]=bound(q[t],i);\n        \/\/二分出临界点\n        q[++t]=i;\n        while(h<t&&k[h]<=i)++h;\n        \/\/不优的出队\n        p[i]=MAX(p[i],calc(i,q[h]));\n        \/\/两遍取max\n    }\n}\nint main(){\n    in(n);\n    Fur(i,1,n)in(a[i]),sq[i]=sqrt(i);\n    work();\n\n    \/\/翻转序列\n    reverse(a+1,a+n+1);\n    reverse(p+1,p+n+1);\n    memset(k,0,(n+1)<<2);\n    work();\n\n    \/\/翻转后需要倒序输出\n    Fdr(i,n,1)out(MAX(int(ceil(p[i]))-a[i],0),ln);\n    flush();\n}\n```\n","link":null,"tags":["四边形不等式","动态规划","单调队列","决策单调性"],"title":"LG 3515 [POI2011]Lightning-Conductor"},{"categories":[["刷题记录"]],"content":"\n```cpp\n#include<bits\/stdc++.h>\nusing namespace std;\nint n,c[1000005],ans[1000005],m,ansl;\nvector<int>a[1000005];\nint cun[1000005],tot;\nint main(){\n    cin>>n;\n    for(int i=1;i<=n;i++)\n        cin>>c[i],a[c[i]].push_back(i),m=max(m,c[i]);\n    for(int i=1;i<=m;i++)\n        if(a[i].size()!=0)cun[++tot]=i;\n    for(int i=1;i<=tot;i++){\n        int now=cun[i],last=cun[i-1],nxt=cun[i+1];\n        ans[i]=a[now].size();\n        if(i!=1)\n            if(a[now].front()>a[last].back())ans[i]+=ans[i-1];\n            else{\n                int aa=lower_bound(a[last].begin(),a[last].end(),a[now].front())-a[last].begin();\n                ans[i]+=aa;\n            }\n        if(i!=tot)\n            if(a[now].back()>a[nxt].front()){\n                int aa=lower_bound(a[nxt].begin(),a[nxt].end(),a[now].back())-a[nxt].begin();\n                ans[i]+=(a[nxt].size()-aa);\n            }\n        ansl=max(ansl,ans[i]);\n    }\n    cout<<n-ansl<<endl;\n}\n\n```\n","link":null,"tags":[],"title":"LG 3411 序列变换"},{"categories":[["刷题记录"]],"content":"\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;rg char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\n#define N 25011\n#define FL(i,x) for(int i(HEAD[x]),to;to=E[i].to,i;i=E[i].nxt)\nint n,cnt=0,head[N],R,P,S;\nint CNT=0,HEAD[N];\nstruct edge{\n    int to,nxt,w;\n}e[100011],E[50011];\nil void add(int x,int y,int w){\n    e[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;e[cnt].w=w;\n}\nil void ADD(int x,int y,int w){\n    E[++CNT].to=y;E[CNT].nxt=HEAD[x];HEAD[x]=CNT;E[CNT].w=w;\n}\nvector<int>T[N];\nint bl[N],tt=0,d[N],deg[N];\nvoid dfs(int x,int y){\n    bl[x]=y;T[y].push_back(x);\n    fl(i,x)if(!bl[to])dfs(to,y);\n}\nstruct cmp{il bool operator()(int x,int y){return d[x]>d[y];}};\nbool v[N];\nil void spfa(int X){\n    priority_queue<int,vector<int>,cmp>p;\n    for(auto t:T[X])\n    if(d[t]!=inf)p.push(t),v[t]=1;\n    while(!p.empty()){\n        int x=p.top();p.pop();v[x]=0;\n        fl(i,x)if(d[x]+e[i].w<d[to]){\n            d[to]=d[x]+e[i].w;\n            if(!v[to])p.push(to);\n        }\n        FL(i,x)d[to]=MIN(d[to],d[x]+E[i].w);\n    }\n}\nint main(){\n    fin(\"in\");\n    in(n,R,P,S);\n    int x,y,w;\n    Fur(i,1,R){\n        in(x,y,w);\n        add(x,y,w);add(y,x,w);\n    }\n    Fur(i,1,n)if(!bl[i])dfs(i,++tt);\n    Fur(i,1,P){\n        in(x,y,w);\n        ADD(x,y,w);++deg[bl[y]];\n    }\n    clr(d,126);\n    d[S]=0;\n    queue<int>q;\n    Fur(i,1,tt)if(!deg[i])q.push(i);\n    while(!q.empty()){\n        x=q.front();q.pop();\n        spfa(x);\n        for(auto t:T[x])\n            FL(i,t)\n            if(--deg[bl[to]]==0)\n                q.push(bl[to]);\n    }\n    Fur(i,1,n)\n        if(d[i]==inf)out(\"NO PATH\\n\");\n        else out(d[i],ln);\n    flush();\n}\n\n```\n","link":null,"tags":["拓扑排序","最短路"],"title":"LG 3008 [USACO11JAN]道路和飞机Roads and Planes"},{"categories":[["刷题记录"]],"content":"\n蒟蒻懒得学马拉车,于是就用hash写了。\n\n预处理出每个点作为回文串的左端点和右端点时回文串最长为多少\n\n然后枚举断点,统计答案就可以了\n\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i=x;i<=y;i++)\n    #define Fdr(i,x,y) for(int i=x;i>=y;i--)\n    #define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) (int(log2(n)))\n    #define inf 0x3f3f3f3f\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){clr(ch,0);if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 100011\nchar s[N];\null h1[N],h2[N],p[N];\nint n,ans=0;\nint L[N],R[N];\null gh1(int l,int r){\n    return h1[r]-h1[l-1]*p[r-l+1];\n}\null gh2(int l,int r){\n    return h2[l]-h2[r+1]*p[r-l+1];\n}\nvoid a1(int x){\n    int l=1,r=MIN(x,n-x);\n    while(l<=r){\n        int m=(l+r)>>1;\n        if(gh1(x-m,x+m)==gh2(x-m,x+m))\n            l=m+1;\n        else r=m-1;\n    }\n    L[x+r]=MAX(L[x+r],r*2+1);\n    R[x-r]=MAX(R[x-r],r*2+1);\n}\nvoid a2(int x){\n    int l=1,r=MIN(x,n-x);\n    while(l<=r){\n        int m=(l+r)>>1;\n        if(gh1(x-m+1,x+m)==gh2(x-m+1,x+m))\n            l=m+1;\n        else r=m-1;\n    }\n    L[x+r]=MAX(L[x+r],r*2);\n    R[x-r+1]=MAX(R[x-r+1],r*2);\n}\n#define base 233\nint main(){\n    in>>(s+1);\n    p[0]=1;\n    n=strlen(s+1);\n    Fur(i,1,n){\n        L[i]=R[i]=1;\n        h1[i]=h1[i-1]*base+s[i];\n        p[i]=p[i-1]*base;\n    }\n    Fdr(i,n,1)\n        h2[i]=h2[i+1]*base+s[i];\n    \n    Fur(i,1,n)a1(i),a2(i);\n\n    Fur(i,1,n)R[i]=MAX(R[i],R[i-1]-2);\n    Fdr(i,n,1)L[i]=MAX(L[i],L[i+1]-2);\n\n    Fur(i,1,n-1)ans=MAX(ans,L[i]+R[i+1]);\n    out<<ans<<ln;\n}\n\n```\n","link":null,"tags":["马拉车","hash"],"title":"LG 4555 [国家集训队]最长双回文串"},{"categories":[["刷题记录"]],"content":"\n[这个题解棒棒哒](https:\/\/www.luogu.org\/blog\/user29936\/solution-p1641)\n\n答案就是$C(n+m,m)-C(n+m,m-1)$\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i=x;i<=y;++i)\n    #define Fdr(i,x,y) for(int i=x;i>=y;--i)\n    #define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){clr(ch,0);if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 2000011\n#define mod 20100403\nint n,m,f[N],inv[N];\nint pw(int x,int p){\n    int ans=1;\n    while(p){\n        if(p&1)ans=1ll*ans*x%mod;\n        p>>=1;x=1ll*x*x%mod;\n    }\n    return ans;\n}\nint C(int a,int b){\n    return 1ll*f[a]*inv[b]%mod*inv[a-b]%mod;\n}\nint main(){\n    cin>>n>>m;\n    f[0]=1;Fur(i,1,n+m)f[i]=1ll*f[i-1]*i%mod;\n    inv[n+m]=pw(f[n+m],mod-2);\n    Fdr(i,n+m-1,0)inv[i]=1ll*inv[i+1]*(i+1)%mod;\n    out<<((C(n+m,m)-C(n+m,m-1)+mod)%mod)<<ln;\n}\n```\n","link":null,"tags":["逆元","组合数"],"title":"LG 1641 [SCOI2010]生成字符串"},{"categories":[["刷题记录"]],"content":"\n设$f_x$表示在$x$放置且$x$的子树都被覆盖最少多少\n\n设$g_x$表示不在$x$放置且$x$的子树都被覆盖最少多少($x$可以不被覆盖)\n\n设$s_x$表示在$x$放置且$x$的子树都被覆盖最少多少($x$一定被覆盖)\n\n$f_u = \\sum min(f_v,s_v,g_v)$\n\n$g_u = \\sum min(f_v,s_v)$\n\n$s_u = (\\sum \\min(f_v,s_v)) - max(0,min(f_v-s_v))$\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i=x;i<=y;++i)\n    #define Fdr(i,x,y) for(int i=x;i>=y;--i)\n    #define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){clr(ch,0);if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 1511\nint n,a[N],cnt=0,head[N],ind[N];\nstruct edge{\n    int to,nxt;\n}e[N];\nvoid add(int x,int y){\n    e[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;\n}\nint f[N],g[N],s[N];\nvoid dfs(int x){\n    f[x]=a[x];\n    s[x]=g[x]=0;\n    bool ff=1;\n    int tt=inf;\n    fl(i,x){\n        dfs(to);\n        f[x]+=MIN(MIN(g[to],s[to]),f[to]);\n        g[x]+=MIN(f[to],s[to]);\n        if(f[to]<=s[to])s[x]+=f[to],ff=0;\n        else s[x]+=s[to],tt=MIN(tt,f[to]-s[to]);\n    }\n    if(ff)s[x]+=tt;\n}\nint main(){\n    fin(\"in\");\n    in>>n;\n    int x,y,t;\n    Fur(i,1,n){\n        in>>x;in>>a[x];\n        in>>t;\n        while(t--)in>>y,add(x,y),ind[y]++;\n    }\n    int rt;\n    Fur(i,1,n)if(!ind[i]){rt=i;break;}\n    dfs(rt);\n    out<<MIN(f[rt],s[rt]);\n}\n```\n","link":null,"tags":["树形dp","动态规划"],"title":"LG 2458 [SDOI2006]保安站岗"},{"categories":[["刷题记录"]],"content":"\n没想到kmp也可以这么秒\n\n从n到1想一下\n\n算出next数组之后可以直接递推\n```cpp\n#include <iostream>\n#include <cstring>\nusing namespace std;\nconst int N = 1e5 + 10;\nchar str[N];\nint len;\nint nt[N];\nint res[N];\nvoid getNext(){\n    nt[0] = -1;\n    int i = 0, j = -1;\n    while (i <= len){\n        if (j == -1 || str[i] == str[j])\n            nt[++i] = ++j;\n        else\n            j = nt[j];\n    }\n}\n\nint main(){\n    scanf(\"%s\", str);\n    len = (int)strlen(str);\n    getNext();\n    for (int i = len; i >= 1; i--){\n        res[i]++;\n        res[nt[i]] += res[i];\n    }\n    long long ans = 0;\n    for (long long i = 1; i <= len; i++)\n        ans = max(i * res[i], ans);\n    printf(\"%lld\\n\", ans);\n}\n```\n","link":null,"tags":["kmp"],"title":"51nod 1277 字符串中的最大值"},{"categories":[["刷题记录"]],"content":"\n区间$[i,j]$如果满足要求,则$S_{j-1}-S_i = 0$且$ch[i] = ch[j]$\n\n那么先记录前缀和,然后倒着枚举,统计$[i+1,n]$有多少个满足要求的位置\n\n记得开$long\\ long$\n\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i=x;i<=y;++i)\n    #define Fdr(i,x,y) for(int i=x;i>=y;--i)\n    #define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 0x3f3f3f3f\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){clr(ch,0);if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 100011\nint n,a[26];\nll s[N];\nmap<ll,int>k[26];\nchar ch[N];\nint main(){\n    fin(\"in\");\n    Fur(i,0,25)in>>a[i];\n    in>>(ch+1);\n    n=strlen(ch+1);\n    Fur(i,1,n)s[i]=s[i-1]+a[ch[i]-'a'];\n    ll ans=0;\n    Fdr(i,n,1){\n        ans+=k[ch[i]-'a'][s[i]+a[ch[i]-'a']];\n        k[ch[i]-'a'][s[i]]++;\n    }\n    out<<ans<<ln;\n}\n```\n","link":null,"tags":["前缀和"],"title":"LG CF519D A and B and Interesting Substrings"},{"categories":[["刷题记录"]],"content":"\n先把所有$($替换成$)$,然后每次遇到$($cnt++,否则$cnt--$,如果$cnt<0$,那么从前面的问号中挑一个从$)$改成$($费用最小的替换掉\n\n如果最后没法使$cnt=0$,那么就输出$-1$\n\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n\t#pragma GCC optimize(3)\n\t#define il __inline__ __attribute__ ((always_inline))\n\t#define rg register\n\t#define ll long long\n\t#define ull unsigned long long\n\t#define db double\n\t#define sht short\n\t#define MB template <class T>il\n\t#define Fur(i,x,y) for(int i=x;i<=y;i++)\n\t#define Fdr(i,x,y) for(int i=x;i>=y;i--)\n\t#define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n\t#define clr(x,y) memset(x,y,sizeof(x))\n\t#define cpy(x,y) memcpy(x,y,sizeof(x))\n\t#define fin(s) freopen(s\".in\",\"r\",stdin)\n\t#define fout(s) freopen(s\".out\",\"w\",stdout)\n\t#define fcin ios::sync_with_stdio(false)\n\t#define l2(n) (int(log2(n)))\n\t#define inf 0x3f3f3f3f\n\tMB T ABS(T x){return x>0?x:-x;}\n\tMB T MAX(T x,T y){return x>y?x:y;}\n\tMB T MIN(T x,T y){return x<y?x:y;}\n\tMB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n\tMB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){clr(ch,0);if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 50011\nchar s[N];\nint a[N],b[N];\npriority_queue<int>q;\nint main(){\n\tin>>(s+1);\n\tint n=strlen(s+1);\n\tll ans=0;\n\tFur(i,1,n)if(s[i]=='?')in>>a[i]>>b[i],ans+=b[i];\n\tint cnt=0;\n\tFur(i,1,n){\n\t\tif(s[i]=='(')cnt++;\n\t\telse cnt--;\n\t\tif(s[i]=='?')q.push(b[i]-a[i]);\n\t\tif(cnt<0){\n\t\t\tif(q.empty())return out<<-1,0;\n\t\t\tans-=q.top();q.pop();\n\t\t\tcnt+=2;\n\t\t}\n\t}\n\tif(cnt)return out<<-1,0;\n\tout<<ans<<ln;\n}\n```\n","link":null,"tags":["贪心","堆"],"title":"51nod 1476 括号序列的最小代价"},{"categories":[["刷题记录"]],"content":"\n设$f[st][sta]$表示起点是$st$,当前节点是否访问过的状态二进制下是$sta$\n\n顺便记录$d[st][sta]$表示$f[st][sta]$最小时每个节点距离$st$的距离\n\n我们可以用填表法向前推进\n\n$f[st][sta'] = \\min(f[st][sta'],f[st][sta]+(d[st][sta][x]+1)\\times L) (sta' = sta | 2^{to-1})$\n\n最坏情况下复杂度: $\\Theta(n \\times 2^n \\times n^2）$\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i=x;i<=y;++i)\n    #define Fdr(i,x,y) for(int i=x;i>=y;--i)\n    #define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 0x3f3f3f3f\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){clr(ch,0);if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 13\nint n,m,head[N],cnt=0;\nstruct edge{\n    int to,nxt,w;\n}e[2011];\nvoid add(int x,int y,int w){\n    e[++cnt].to=y;e[cnt].w=w;e[cnt].nxt=head[x];head[x]=cnt;\n}\nint f[N][1<<N],d[N][1<<N][N];\nvoid init(){\n    in>>n>>m;\n    int x,y,w;\n    Fur(i,1,m){\n        in>>x>>y>>w;\n        add(x,y,w),add(y,x,w);\n    }\n    Fur(st,1,n)\n        Fur(sta,0,(1<<n)-1)\n            f[st][sta]=inf;\n    Fur(st,1,n)\n        Fur(sta,0,(1<<n)-1)\n            Fur(i,1,n)\n            d[st][sta][i]=inf;\n    \n    Fur(st,1,n){\n        f[st][1<<(st-1)]=0;\n        d[st][1<<(st-1)][st]=1;\n    }\n}\n#define chk(x) (sta&(1<<(x-1)))\nint main(){\n    init();\n    Fur(st,1,n)\n        Fur(sta,1,(1<<n)-1)\n        if(f[st][sta]!=inf){\n            Fur(x,1,n)\n            if(chk(x)){\n                fl(i,x)\n                if(!chk(to)){\n                    int ne=sta|(1<<(to-1));\n                    if(f[st][sta]+d[st][sta][x]*e[i].w<f[st][ne]){\n                        f[st][ne]=f[st][sta]+d[st][sta][x]*e[i].w;\n                        Fur(j,1,n)\n                            d[st][ne][j]=d[st][sta][j];\n                        d[st][ne][to]=d[st][sta][x]+1;\n                    }\n                }\n            }\n        }\n    int ans=inf;\n    Fur(st,1,n)ans=MIN(ans,f[st][(1<<n)-1]);\n    out<<ans<<ln;\n}\n```\n","link":null,"tags":["状态压缩","动态规划","状压dp"],"title":"LG 3959 宝藏"},{"categories":[["刷题记录"]],"content":"\n直接求很难\n\n突然看到二分的标签\n\n那我们二分$k$的值,判断排名不就可以了\n\n如何判断排名：\n\n如果区间$[l,r]$满足要求,那么左端点换成$[1,l-1]$中的任何一个也都满足要求\n\n那我们只要枚举右端点,然后用双指针法就可以了\n\n求众数可以用莫队的思想\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n\t#pragma GCC optimize(3)\n\t#define il __inline__ __attribute__ ((always_inline))\n\t#define rg register\n\t#define ll long long\n\t#define ull unsigned long long\n\t#define db double\n\t#define sht short\n\t#define MB template <class T>il\n\t#define Fur(i,x,y) for(int i=x;i<=y;i++)\n\t#define Fdr(i,x,y) for(int i=x;i>=y;i--)\n\t#define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n\t#define clr(x,y) memset(x,y,sizeof(x))\n\t#define cpy(x,y) memcpy(x,y,sizeof(x))\n\t#define fin(s) freopen(s\".in\",\"r\",stdin)\n\t#define fout(s) freopen(s\".out\",\"w\",stdout)\n\t#define fcin ios::sync_with_stdio(false)\n\t#define l2(n) (int(log2(n)))\n\t#define inf 0x3f3f3f3f\n\tMB T ABS(T x){return x>0?x:-x;}\n\tMB T MAX(T x,T y){return x>y?x:y;}\n\tMB T MIN(T x,T y){return x<y?x:y;}\n\tMB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n\tMB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){clr(ch,0);if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 100011\n#define int ll\nint n,k,a[N];\nstruct node{\n\tint p,v;\n}b[N];\nbool cmp(node x,node y){return x.v<y.v;}\nint mx=0,cnt[N],tot[N];\nvoid add(int x){\n\ttot[cnt[a[x]]]--;tot[++cnt[a[x]]]++;\n\tmx=MAX(mx,cnt[a[x]]);\n}\nvoid del(int x){\n\tif(mx==cnt[a[x]]&&--tot[cnt[a[x]]]==0)mx--;\n\ttot[--cnt[a[x]]]++;\n}\nbool chk(int w){\n\tclr(cnt,0);clr(tot,0);\n\tmx=0;\n\tint l=1,ans=0;\n\tFur(i,1,n){\n\t\tif(mx<w)add(i);\n\t\twhile(l<=i&&mx>=w)del(l++);\n\t\tans+=(l-1);\n\t}\n\treturn ans>=k;\n}\nsigned main(){\n\tin>>n>>k;\n\tFur(i,1,n)in>>b[i].v,b[i].p=i;\n\tsort(b+1,b+n+1,cmp);\n\tint t=0;\n\tFur(i,1,n){\n\t\tif(b[i].v!=b[i-1].v)t++;\n\t\ta[b[i].p]=t;\n\t}\n\tint l=1,r=n,ans,m;\n\twhile(l<=r){\n\t\tm=(l+r)>>1;\n\t\tif(chk(m))ans=m,l=m+1;\n\t\telse r=m-1;\n\t}\n\tout<<ans<<ln;\n}\n```\n","link":null,"tags":[],"title":"51nod 1686 第K大区间"},{"categories":[["刷题记录"]],"content":"\n线段树裸题\n```cpp\n#include<bits\/stdc++.h>\n#define int ll\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{\n    const int str=1<<20;\n    \/\/in\n    static char in_buf[str],*in_s,*in_t;\n    bool __=0;\n    il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}\n    template<typename T>\n    il int in(T &x){\n        if(__)return 0;\n        rg char c=gc();\n        bool f=0;\n        while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();\n        if(c==EOF){__=1;return 0;}\n        x=0;\n        while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();\n        if(c==EOF)__=1;\n        if(f)x=-x;\n        if(c==' ')return 1;\n        return 0;\n    }\n    template<typename T,typename ... arr>\n    il void in(T &x,arr & ... y){in(x),in(y...);}\n\n    \/\/out\n    const char ln='\\n';\n    static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;\n    il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}\n    il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}\n    template<typename T>\n    il void out(T x){\n        if(!x){pt('0');return;}\n        if(x<0)pt('-'),x=-x;\n        char a[60],t=0;\n        while(x)a[t++]=x%10,x\/= 10;\n        while(t--)pt(a[t]+'0');\n    }\n}using namespace IO;\n#define N 200011\n#define ls rt<<1\n#define rs rt<<1|1\n#define pu s[rt]=MIN(s[ls],s[rs]);\nint n,s[N<<2],laz[N<<2];\nvoid build(int l,int r,int rt){\n    if(l==r){\n        in(s[rt]);\n        return;\n    }\n    int m=(l+r)>>1;\n    build(l,m,ls);build(m+1,r,rs);\n    pu;\n}\nil void pd(int rt){\n    if(laz[rt]){\n        laz[ls]+=laz[rt];laz[rs]+=laz[rt];\n        s[ls]+=laz[rt];s[rs]+=laz[rt];\n        laz[rt]=0;\n    }\n}\nvoid upd(int L,int R,int v,int l,int r,int rt){\n    if(L<=l&&r<=R){\n        s[rt]+=v;\n        laz[rt]+=v;\n        return;\n    }\n    int m=(l+r)>>1;\n    pd(rt);\n    if(L<=m)upd(L,R,v,l,m,ls);\n    if(R>m)upd(L,R,v,m+1,r,rs);\n    pu;\n}\nint ask(int L,int R,int l,int r,int rt){\n    if(L<=l&&r<=R)return s[rt];\n    int m=(l+r)>>1,ans=inf;\n    pd(rt);\n    if(L<=m)ans=ask(L,R,l,m,ls);\n    if(R>m)ans=MIN(ans,ask(L,R,m+1,r,rs));\n    return ans;\n}\nsigned main(){\n    in(n);\n    build(1,n,1);\n    int q,l,r,v,ans;\n    in(q);\n    while(q--){\n        in(l);\n        bool ff=0;\n        ff=in(r);\n        ++l,++r;\n\n        if(ff){\n            in(v);\n            if(l<=r)upd(l,r,v,1,n,1);\n            else upd(l,n,v,1,n,1),upd(1,r,v,1,n,1);\n        }\n        else{\n            if(l<=r)ans=ask(l,r,1,n,1);\n            else ans=MIN(ask(l,n,1,n,1),ask(1,r,1,n,1));\n            out(ans);pt('\\n');\n        }\n    }\n    flush();\n}\n```\n","link":null,"tags":["线段树"],"title":"LG CF52C Circular-RMQ"},{"categories":[["刷题记录"]],"content":"\n自己写了个莫队,结果$51nod$跑的太慢,然后$TLE(MLE)$了\n\n题解妙极了：\n\n> 离线之后,从左向右扫一遍,让每个值存储“当前已扫过的部分中,右边第一个与自己相等的点到自己的距离”,然后如果当前扫到的点是询问的右端点的话,就回答这个询问。\n>\n>  这里面有个很巧妙的地方就是在询问的时候按r的大小从左往右询问,每次更新的时候更新的是和这个点最近的左边的点。因为只有更新到第r个点时才能能查询 l - r 的区间例如：1 2 3 4 1  只有在 r 等于 5 时才能询问 L - 5的区间,此时更新第一个1的值为4,如果L > 1的话区间并未更新所以查询线段树中L- 5的最小值还是INF\n\n\n\n\n\n\n```cpp\n\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define INF 0x3f3f3f3f\n#define space putchar(' ')\n#define enter putchar('\\n')\nusing namespace std;\ntypedef long long ll;\ntemplate <class T>\nbool read(T &x){\n    char c;\n    bool op = 0;\n    while(c = getchar(), c < '0' || c > '9')\n        if(c == '-') op = 1;\n        else if(c == EOF) return 0;\n    x = c - '0';\n    while(c = getchar(), c >= '0' && c <= '9')\n        x = x * 10 + c - '0';\n    if(op) x = -x;\n    return 1;\n}\ntemplate <class T>\nvoid write(T x){\n    if(x < 0) putchar('-'), x = -x;\n    if(x >= 10) write(x \/ 10);\n    putchar('0' + x % 10);\n}\n \nconst int N = 500005;\nint n, m, q, a[N], s[N], last[N], left[N], data[4*N], ans[N];\nstruct Query {\n    int id, l, r;\n    bool operator < (const Query &b) const{\n        return r < b.r;\n    }\n} Q[N];\n \nvoid build(int k, int l, int r){\n    if(l == r) return (void)(data[k] = INF);\n    int mid = (l + r) >> 1;\n    build(k << 1, l, mid);\n    build(k << 1 | 1, mid + 1, r);\n    data[k] = INF;\n}\n \nvoid change(int k, int l, int r, int p, int x){\n    if(l == r) return (void)(data[k] = x);\n    int mid = (l + r) >> 1;\n    if(p <= mid) change(k << 1, l, mid, p, x);\n    else change(k << 1 | 1, mid + 1, r, p, x);\n    data[k] = min(data[k << 1], data[k << 1 | 1]);\n}\n \nint query(int k, int l, int r, int ql, int qr){\n    if(ql <= l && qr >= r) return data[k];\n    int mid = (l + r) >> 1, ret = INF;\n    if(ql <= mid) ret = min(ret, query(k << 1, l, mid, ql, qr));\n    if(qr > mid) ret = min(ret, query(k << 1 | 1, mid + 1, r, ql, qr));\n    return ret;\n}\n \nint main(){\n \n    read(n), read(q);\n    for(int i = 1; i <= n; i++)\n        read(a[i]), s[i] = a[i];\n    sort(s + 1, s + n + 1);\n    int m = unique(s + 1, s + n + 1) - s - 1;\n    \n    for(int i = 1; i <= n; i++){\n        a[i] = lower_bound(s + 1, s + m + 1, a[i]) - s;\n        left[i] = last[a[i]];\n        last[a[i]] = i;\n    }\n \n    build(1, 1, n);\n    \n    for(int i = 1; i <= q; i++)\n        Q[i].id = i, read(Q[i].l), read(Q[i].r);\n    sort(Q + 1, Q + q + 1);\n \n    for(int i = 1, j = 1; i <= n && j <= q; i++){\n    \n        if(left[i]) change(1, 1, n, left[i], i - left[i]);\n    \n        while(j <= q && i == Q[j].r){\n    \n            ans[Q[j].id] = query(1, 1, n, Q[j].l, Q[j].r);\n            j++;\n        }\n    }\n    for(int i = 1; i <= q; i++)\n        write(ans[i] < INF ? ans[i] : -1), enter;\n}\n\n```\n","link":null,"tags":["线段树","离线"],"title":"51nod 1571 最近等对"},{"categories":[["刷题记录"]],"content":"\n二分\n\n判断的时候枚举区间,用rmq或单调队列来求最值,~~还可以用堆(看题解的)~~\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n\t#pragma GCC optimize(3)\n\t#define il __inline__ __attribute__ ((always_inline))\n\t#define rg register\n\t#define ll long long\n\t#define ull unsigned long long\n\t#define db double\n\t#define sht short\n\t#define MB template <class T>il\n\t#define Fur(i,x,y) for(int i=x;i<=y;i++)\n\t#define Fdr(i,x,y) for(int i=x;i>=y;i--)\n\t#define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n\t#define clr(x,y) memset(x,y,sizeof(x))\n\t#define cpy(x,y) memcpy(x,y,sizeof(x))\n\t#define fin(s) freopen(s\".in\",\"r\",stdin)\n\t#define fout(s) freopen(s\".out\",\"w\",stdout)\n\t#define fcin ios::sync_with_stdio(false)\n\t#define l2(n) (int(log2(n)))\n\t#define inf 0x3f3f3f3f\n\tMB T ABS(T x){return x>0?x:-x;}\n\tMB T MAX(T x,T y){return x>y?x:y;}\n\tMB T MIN(T x,T y){return x<y?x:y;}\n\tMB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n\tMB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 100011\nint n,d,f[17][N],g[17][N];\nstruct node{int x,y;}a[N];\nbool cmp(node x,node y){return x.x<y.x;}\nint ask(int l,int r){\n\tint k=l2(r-l+1);\n\treturn MAX(f[k][l],f[k][r-(1<<k)+1])-MIN(g[k][l],g[k][r-(1<<k)+1]);\n}\nbool chk(int w){\n\tint r=1;\n\tFur(i,1,n){\n\t\twhile(a[r].x-a[i].x<=w&&r<=n)r++;\n\t\tr--;\n\t\tif(ask(i,r)>=d)return 1;\n\t}\n\treturn 0;\n}\nint main(){\n\tin>>n>>d;\n\tFur(i,1,n)in>>a[i].x>>a[i].y;\n\t\n\tsort(a+1,a+n+1,cmp);\n\t\n\tFur(i,1,n)f[0][i]=g[0][i]=a[i].y;\n\tFur(k,1,17)\n\t\tFur(i,1,n-(1<<k)+1)\n\t\tf[k][i]=MAX(f[k-1][i],f[k-1][i+(1<<(k-1))]),\n\t\tg[k][i]=MIN(g[k-1][i],g[k-1][i+(1<<(k-1))]);\n\t\n\tint l=0,r=1000000,ans=-1;\n\twhile(l<=r){\n\t\tint m=(l+r)>>1;\n\t\tif(chk(m))ans=m,r=m-1;\n\t\telse l=m+1;\n\t}\n\tout<<ans<<ln;\n}\n```\n","link":null,"tags":["二分","rmq","单调队列","堆"],"title":"LG 2698 [USACO12MAR]花盆Flowerpot"},{"categories":[["刷题记录"]],"content":"\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n\t#pragma GCC optimize(3)\n\t#define il __inline__ __attribute__ ((always_inline))\n\t#define rg register\n\t#define ll long long\n\t#define ull unsigned long long\n\t#define db double\n\t#define sht short\n\t#define MB template <class T>il\n\t#define Fur(i,x,y) for(int i=x;i<=y;i++)\n\t#define Fdr(i,x,y) for(int i=x;i>=y;i--)\n\t#define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n\t#define clr(x,y) memset(x,y,sizeof(x))\n\t#define cpy(x,y) memcpy(x,y,sizeof(x))\n\t#define fin(s) freopen(s\".in\",\"r\",stdin)\n\t#define fout(s) freopen(s\".out\",\"w\",stdout)\n\t#define fcin ios::sync_with_stdio(false)\n\t#define l2(n) (int(log2(n)))\n\t#define inf 0x3f3f3f3f\n\tMB T ABS(T x){return x>0?x:-x;}\n\tMB T MAX(T x,T y){return x>y?x:y;}\n\tMB T MIN(T x,T y){return x<y?x:y;}\n\tMB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n\tMB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 1011\nint n,m,a[N],s[N],f[N][111];\nint main(){\n\tin>>n>>m;\n\tFur(i,1,n)in>>a[i],s[i]=s[i-1]^a[i],f[i][1]=s[i];\n\tFur(k,2,m)\n\t\tFur(i,k,n)\n\t\t\tFur(j,k-1,i-1)\n\t\t\tf[i][k]=MAX(f[i][k],f[j][k-1]+(s[i]^s[j]));\n\t\n\tout<<f[n][m]<<ln;\n}\n```\n","link":null,"tags":[],"title":"LG 5144 蜈蚣"},{"categories":[["刷题记录"]],"content":"\n我们可以看成$n$对石子堆的博弈论\n\n那么我们把$n$对石子堆的$SG$值异或一下就可以了\n\n那怎么求每对石子堆的$SG$值呢？\n\n$SG(x,y) = mex({SG(x',y')})(x'+y' = x 或 x'+y' = y)$\n\n~~打表之后可以发现~~:\n\n每一对$(i,j)$,直接求$(i-1)\\mid(j-1)$二进制的最低的0所在的二进制位\n\n\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i=x;i<=y;++i)\n    #define Fdr(i,x,y) for(int i=x;i>=y;--i)\n    #define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 0x3f3f3f3f\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){clr(ch,0);if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 100011\nint main(){\n    fin(\"in\");\n    int T,n;\n    in>>T;\n    while(T--){\n        in>>n;n>>=1;\n        int x,y,s=0;\n        Fur(i,1,n){\n            in>>x>>y;\n            int t=((x-1)|(y-1)),c=0;\n            while(t&1)++c,t>>=1;\n            s^=c;\n        }\n        out<<(s?\"YES\":\"NO\")<<ln;\n    }\n}\n```\n","link":null,"tags":["博弈论"],"title":"LG 2148 [SDOI2009]E and D"},{"categories":[["刷题记录"]],"content":"\n先根据原来的边建树\n\n一条新边$(x,y)$能影响的边有树上$x \\rightarrow y$路径上的边\n\n那么这道题就转化成了树剖+线段树维护最值\n\n\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i=x;i<=y;++i)\n    #define Fdr(i,x,y) for(int i=x;i>=y;--i)\n    #define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){clr(ch,0);if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 50011\n#define ls rt<<1\n#define rs rt<<1|1\n#define pu s[rt]=MIN(s[ls],s[rs])\nint n,m;\nint s[N<<2],laz[N<<2];\nvoid pd(int rt){\n    if(laz[rt]!=inf){\n        s[ls]=MIN(s[ls],laz[rt]);\n        s[rs]=MIN(s[rs],laz[rt]);\n        laz[ls]=MIN(laz[ls],laz[rt]);\n        laz[rs]=MIN(laz[rs],laz[rt]);\n        laz[rt]=inf;\n    }\n}\nvoid upd(int L,int R,int v,int l=1,int r=n,int rt=1){\n    if(L<=l&&r<=R){\n        s[rt]=MIN(s[rt],v);\n        laz[rt]=MIN(laz[rt],v);\n        return;\n    }\n    int m=(l+r)>>1;\n    pd(rt);\n    if(L<=m)upd(L,R,v,l,m,ls);\n    if(R>m)upd(L,R,v,m+1,r,rs);\n    pu;\n}\nint get(int x,int l=1,int r=n,int rt=1){\n    if(l==r)return s[rt];\n    int m=(l+r)>>1;\n    pd(rt);\n    if(x<=m)return get(x,l,m,ls);\n    else return get(x,m+1,r,rs);\n}\nstruct edge{\n    int to,nxt,id;\n}e[N*2];\nint head[N],cnt=0;\nvoid add(int x,int y,int id){\n    e[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;\n    e[cnt].id=id;\n}\nint siz[N],d[N],f[N],top[N],id[N],sz=0,pte[N];\nvoid dfs(int x){\n    siz[x]=1;\n    fl(i,x)if(to!=f[x]){\n        d[to]=d[x]+1;f[to]=x;pte[to]=e[i].id;\n        dfs(to);\n        siz[x]+=siz[to];\n    }\n}\nvoid bt(int x,int tp){\n    id[x]=++sz;top[x]=tp;int k=0;\n    fl(i,x)if(to!=f[x]&&siz[to]>siz[k])k=to;\n    if(!k)return;bt(k,tp);\n    fl(i,x)if(!top[to])bt(to,to);\n}\nvoid ul(int x,int y,int v){\n    while(top[x]!=top[y]){\n        if(d[top[x]]<d[top[y]])SWAP(x,y);\n        upd(id[top[x]],id[x],v);x=f[top[x]];\n    }\n    if(id[x]>id[y])SWAP(x,y);\n    upd(id[x]+1,id[y],v);\n}\nint etp[N];\nint main(){\n    fin(\"in\");\n    in>>n>>m;\n    int x,y,w;\n    Fur(i,1,n-1){\n        in>>x>>y;\n        add(x,y,i);add(y,x,i);\n    }\n\n    dfs(1);bt(1,1);\n    clr(laz,126);clr(s,126);\n    Fur(i,1,m)\n        in>>x>>y>>w,ul(x,y,w);\n    \n    Fur(i,2,n)etp[pte[i]]=i;\n    Fur(i,1,n-1){\n        int t=get(id[etp[i]]);\n        if(t==inf)t=-1;\n        out<<t<<ln;\n    }\n}\n```\n","link":null,"tags":["树链剖分"],"title":"LG 4374 [USACO18OPEN]Disruption"},{"categories":[["刷题记录"]],"content":"\n把所有路径上的最大值的和 和 所有路径上的最小值的和 分开算\n\n我们按最大值的计算考虑（最小值就是反过来）\n\n我们考虑一个点能贡献多少次\n\n从它的各个子树中拿出来组合\n\n我们可以按权值从小到大的顺序添加节点\n\n这样就只要和当前要添加的节点联通的点都符合要求\n\n这样的话我们可以用并查集来维护连通块大小\n\n\n```cpp\n#include<iostream>\n#include<vector>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nstruct edge{\n    int to,next;\n}e[400040];\nint eid=0,head[200010];\nvoid insert(int u,int v){\n    eid++;\n    e[eid].to=v;\n    e[eid].next=head[u];\n    head[u]=eid;\n}\nint a[200010];\nint n;\nint fa[200010];\nint dp[200010];\/\/某一个点的美丽值 \nvector<int>v[200010];\/\/存储每一个点的美丽值的可能值 \nint gcd(int a,int b){\n    if(b==0)return a;\n    return gcd(b,a%b);\n}\nvoid dfs(int x,int pre){\n    for(int i=head[x];i+1;i=e[i].next){\n        int k=e[i].to;\n        if(k==pre)continue;\n        dp[k]=gcd(dp[x],a[k]);\n        v[k].push_back(dp[x]);\n        for(int j=0;j<v[x].size();j++){\n            v[k].push_back(gcd(v[x][j],a[k]));\n        }\n        sort(v[k].begin(),v[k].end());\/\/排序+去重,保证最后面的元素最优 \n        v[k].erase(unique(v[k].begin(),v[k].end()),v[k].end());\n        dfs(k,x);\n    }\n}\nint main(){\n    memset(head,-1,sizeof(head));\n    cin>>n;\n    for(int i=1;i<=n;i++){\n        cin>>a[i];\n    }\n    for(int i=1;i<n;i++){\n        int x,y;\n        cin>>x>>y;\n        insert(x,y);\n        insert(y,x);\n        fa[y]=x;\n    }\n    fa[1]=0;\n    dp[1]=a[1];\n    v[1].push_back(0);\n    dfs(1,0);\n    for(int i=1;i<=n;i++){\n        dp[i]=max(dp[i],v[i].back());\/\/用vector里面的最优答案更新结果 \n    }\n    for(int i=1;i<=n;i++){\n        cout<<dp[i];\n        if(i!=n)cout<<\" \";\n        else cout<<endl;\n    }\n}\n```\n","link":null,"tags":["并查集"],"title":"LG CF842C Ilya And The Tree"},{"categories":[["刷题记录"]],"content":"\n设$f_i$为前$i$个任务的费用,$t_i$为前$i$个任务时间的总和,$w_i$为前$i$个任务费用的总和\n\n$$\nf_i=\\min_{j=0}^{i-1}(f_j+s\\times(w_n-w_j)+t_i\\times(w_i-w_j))\n$$\n\n设任意$0\\le j<k<i$从$j$转移比从$k$转移优,那么\n\n$$\nf_j+s\\times(w_n-w_j)+t_i\\times(w_i-w_j)\n\\le\nf_k+s\\times(w_n-w_k)+t_i\\times(w_i-w_k)\n\\\\\nt_i(w_k-w_j)\\le f_k-f_j+s(w_j-w_k)\n\\\\\nt_i\\le \\frac{f_k-f_j+s(w_j-w_k)}{w_k-w_j}\n\\\\\nt_i+s\\le \\frac{f_k-f_j}{w_k-w_j}\n$$\n\n维护个下凸壳就可以了\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\n#define N 300011\nint s,n,q[N];\nll f[N],t[N],w[N];\n#define ld long double\nld S(int i,int j){\n    return (ld)(f[j]-f[i])\/(ld)(w[j]-w[i]);\n}\nsigned main(){\n    in(n,s);\n    Fur(i,1,n)\n        in(t[i],w[i]),\n        t[i]+=t[i-1],\n        w[i]+=w[i-1];\n    int H=1,T=1;q[1]=0;\n    Fur(i,1,n){\n        while(H<T&&S(q[H],q[H+1])<=t[i]+s)++H;\n        f[i]=f[q[H]]+1ll*s*(w[n]-w[q[H]])+1ll*t[i]*(w[i]-w[q[H]]);\n        while(H<T&&S(q[T-1],q[T])>=S(q[T-1],i))--T;\n        q[++T]=i;\n    }\n    cout<<f[n]<<endl;\n}\n```\n","link":null,"tags":["斜率优化","动态规划"],"title":"LG 2365 任务安排"},{"categories":[["刷题记录"]],"content":"\n先把血统编号离散化\n\n两个点之前最多只能有$k$种血统的牛,所以我们考虑使用$two\\ pointers$\n\n$O(n)$\n\n\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i=x;i<=y;++i)\n    #define Fdr(i,x,y) for(int i=x;i>=y;--i)\n    #define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) (int(log2(n)))\n    #define inf 0x3f3f3f3f\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){clr(ch,0);if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 100011\nint n,k,a[N],cnt[N];\nstruct node{\n\tint v,id;\n\tfriend bool operator<(node &x,node &y){\n\t\treturn x.v<y.v;\n\t}\n}b[N];\nint main(){\n\tin>>n>>k;\n\tb[0].v=-1;\n\tFur(i,1,n)in>>b[i].v,b[i].id=i;\n\tsort(b+1,b+n+1);\n\tint d=0;\n\tFur(i,1,n){\n\t\tif(b[i].v!=b[i-1].v)d++;\n\t\ta[b[i].id]=d;\n\t}\n\tint l=0,ans=0,t=0;\n\tFur(i,1,n){\n\t\tif(!cnt[a[i]])++t;\n\t\t++cnt[a[i]];\n\t\twhile(t>k+1)t-=!(--cnt[a[++l]]);\n\t\tans=MAX(ans,cnt[a[i]]);\n\t}\n\tout<<ans<<ln;\n}\n\n```\n","link":null,"tags":["双指针","离散化"],"title":"LG 3069 [USACO13JAN]牛的阵容Cow Lineup"},{"categories":[["刷题记录"]],"content":"\nRainbow-Ride\ntop: 0\n\n\n用并查集合并联通块,然后背包\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;rg char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\n#define N 100011\nint n,c,val[N],f[N],siz[N],s[N];\nint gf(int x){\n    return f[x]==x?x:(f[x]=gf(f[x]));\n}\nint main(){\n    in(n,c);\n    while(n&&c){\n        Fur(i,1,n)in(val[i]),f[i]=i,siz[i]=1;\n        Fur(i,1,n){\n            int k,x;in(k);\n            Fur(j,1,k){\n                in(x);\n                int fi=gf(i),fx=gf(x);\n                if(fi!=fx){\n                    f[fx]=fi;\n                    siz[fi]+=siz[fx];siz[fx]=0;\n                    val[fi]+=val[fx];\n                }\n            }\n        }\n        Fur(i,1,c)s[i]=0;\n        Fur(i,1,n)if(f[i]==i)\n            Fdr(j,c,val[i])\n            s[j]=MAX(s[j],s[j-val[i]]+siz[i]);\n        out(s[c],ln);\n        in(n,c);\n    }\n    flush();\n}\n```\n","link":null,"tags":["并查集","背包"],"title":"LG SP3724 RAINBOW"},{"categories":[["刷题记录"]],"content":"\n设$S_i$为$[1,i]$中$\\ge w$的数的个数\n\n如果一个区间要满足中位数$\\ge w$,那么$\\frac {S_r-S_{l-1}}{\\frac {r-l+1}2} \\ge w$\n\n化简一下：$2S_r-r > 2S_{l-1}-(l-1)$\n\n那么二分$w$然后用树状数组统计之后判断排名是否$\\ge k$就可以了\n\n\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n\t#pragma GCC optimize(3)\n\t#define il __inline__ __attribute__ ((always_inline))\n\t#define rg register\n\t#define ll long long\n\t#define ull unsigned long long\n\t#define db double\n\t#define sht short\n\t#define MB template <class T>il\n\t#define Fur(i,x,y) for(int i=x;i<=y;i++)\n\t#define Fdr(i,x,y) for(int i=x;i>=y;i--)\n\t#define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n\t#define clr(x,y) memset(x,y,sizeof(x))\n\t#define cpy(x,y) memcpy(x,y,sizeof(x))\n\t#define fin(s) freopen(s\".in\",\"r\",stdin)\n\t#define fout(s) freopen(s\".out\",\"w\",stdout)\n\t#define fcin ios::sync_with_stdio(false)\n\t#define l2(n) (int(log2(n)))\n\t#define inf 0x3f3f3f3f\n\tMB T ABS(T x){return x>0?x:-x;}\n\tMB T MAX(T x,T y){return x>y?x:y;}\n\tMB T MIN(T x,T y){return x<y?x:y;}\n\tMB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n\tMB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){clr(ch,0);if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 100011\n#define int unsigned\nint n,k,a[N],s[N],tr[N*3][2];\nvoid add(int x,int k){\n\tif(x<=0)return;\n\twhile(x<=n*3){\n\t\ttr[x][k]++;\n\t\tx+=(x&-x);\n\t}\n}\nint get(int x,int k){\n\tif(x<=0)return 0;\n\tint ans=0;\n\twhile(x){\n\t\tans+=tr[x][k];\n\t\tx-=(x&-x);\n\t}\n\treturn ans;\n}\nbool chk(int w){\n\tclr(tr,0);\n\tFur(i,1,n)s[i]=s[i-1]+(a[i]>=w);\n\tFur(i,1,n)s[i]=2*s[i]-i+n;\n\tadd(n,0);\n\tint tot=0;\n\tFur(i,1,n){\n\t\ttot+=get(s[i],!(i&1));\n\t\tadd(s[i],(i&1));\n\t}\n\treturn tot>=k;\n}\nsigned main(){\n\tfin(\"in\");\n\tin>>n>>k;\n\tint l=0,r=0,m,ans;\n\tFur(i,1,n)in>>a[i],r=MAX(r,a[i]);\n\twhile(l<=r){\n\t\tm=(l+r)>>1;\n\t\tif(chk(m))ans=m,l=m+1;\n\t\telse r=m-1;\n\t}\n\tout<<ans<<ln;\n}\n\n```\n","link":null,"tags":["树状数组","二分"],"title":"51nod 1686 第K大区间2"},{"categories":[["刷题记录"]],"content":"\n按每个点考虑\n\n先把它的子树按(分剩下的节点)最大深度排序\n\n把相邻两个加起来小于$k$的分成一块,其他的单独分一块\n\n[luogu写的比我还好的题解](https:\/\/www.luogu.org\/blog\/user9012\/solution-cf1042f)\n\n\n> 难道这就是你AK的借口?\n> \n> 如果让你重新来过,\n> \n> 你会不会爆零?\n> \n> 卡常让人拥有快乐\n> \n> 也会带来折磨\n> \n> 曾经和你一起走过\n> \n> 传说中的oj\n> \n> 已经被我RE淹没\n> \n> 变成痛苦的WA\n\n\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;rg char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\n#define N 1000011\nint n,k,cnt=0,ans=0,head[N];\nstruct edge{\n    int to,nxt;\n}e[N*2];\nvoid add(int x,int y){\n    e[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;\n}\nint dfs(int x,int f){\n    if(!e[head[x]].nxt)return 0;\n    vector<int>t;\n    fl(i,x)if(to!=f)t.push_back(dfs(to,x)+1);\n    sort(t.begin(),t.end());\n    for(int i=t.size()-1;i>=1;--i){\n        if(t[i]+t[i-1]<=k)return t[i];\n        ++ans;\n    }\n    return t[0];\n}\nint main(){\n    in(n,k);\n    int x,y;\n    Fur(i,1,n-1)in(x,y),add(x,y),add(y,x);\n    Fur(i,1,n)if(e[head[i]].nxt){dfs(i,0);break;}\n    printf(\"%d\\n\",ans+1);\n}\n```\n","link":null,"tags":["贪心","dfs"],"title":"LG CF1042F Leaf-Sets"},{"categories":[["刷题记录"]],"content":"\n还是lct维护最小生成树\n\n先按$a$变排序,然后$b$边的处理类似[WC2006水管局长](https:\/\/www.luogu.org\/problem\/P4172)\n\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n\t#pragma GCC optimize(3)\n\t#define il __inline__ __attribute__ ((always_inline))\n\t#define rg register\n\t#define ll long long\n\t#define ull unsigned long long\n\t#define db double\n\t#define sht short\n\t#define MB template <class T>il\n\t#define Fur(i,x,y) for(int i=x;i<=y;i++)\n\t#define Fdr(i,x,y) for(int i=x;i>=y;i--)\n\t#define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n\t#define clr(x,y) memset(x,y,sizeof(x))\n\t#define cpy(x,y) memcpy(x,y,sizeof(x))\n\t#define fin(s) freopen(s\".in\",\"r\",stdin)\n\t#define fout(s) freopen(s\".out\",\"w\",stdout)\n\t#define fcin ios::sync_with_stdio(false)\n\t#define l2(n) (int(log2(n)))\n\t#define inf 0x3f3f3f3f\n\tMB T ABS(T x){return x>0?x:-x;}\n\tMB T MAX(T x,T y){return x>y?x:y;}\n\tMB T MIN(T x,T y){return x<y?x:y;}\n\tMB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n\tMB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 300011\nbool rev[N];\nint  v[N],f[N],st[N],c[N][2],s[N];\n#define ls c[x][0]\n#define rs c[x][1]\nbool irt(int x){return c[f[x]][0]!=x&&c[f[x]][1]!=x;}\nvoid pu(int x){\n\ts[x]=MAX(MAX(s[ls],s[rs]),v[x]);\n}\nvoid pr(int x){\n\tSWAP(ls,rs);\n\trev[x]^=1;\n}\nvoid pd(int x){\n\tif(rev[x]){\n\t\tif(ls)pr(ls);\n\t\tif(rs)pr(rs);\n\t\trev[x]=0;\n\t}\n}\nint g(int x){return c[f[x]][1]==x;}\nvoid turn(int x){\n\tint y=f[x],z=f[y],l=g(x),r=!l,w=c[x][r];\n\tif(!irt(y))c[z][g(y)]=x;\n\tc[x][r]=y;c[y][l]=w;\n\tif(w)f[w]=y;\n\tf[x]=z;f[y]=x;\n\tpu(y);pu(x);\n}\nvoid splay(int x){\n\tint y=x,z=0;\n\tst[++z]=y;\n\twhile(!irt(y))st[++z]=y=f[y];\n\twhile(z)pd(st[z--]);\n\twhile(!irt(x)){\n\t\ty=f[x];z=f[y];\n\t\tif(!irt(y))\n\t\t\tturn((c[y][0]==x)^(c[z][0]==y)?x:y);\n\t\tturn(x);\n\t}\n\tpu(x);\n}\nvoid access(int x){\n\tfor(int y=0;x;x=f[y=x])\n\t\tsplay(x),rs=y,pu(x);\n}\nvoid mrt(int x){\n\taccess(x);splay(x);pr(x);\n}\nint frt(int x){\n\taccess(x);splay(x);\n\twhile(ls)pd(x),x=ls;\n\tsplay(x);\n\treturn x;\n}\nvoid sl(int x,int y){\n\tmrt(x);access(y);splay(y);\n}\nvoid link(int x,int y){\n\tmrt(x);\n\tif(frt(y)!=x)f[x]=y;\n}\nvoid cut(int x,int y){\n\tmrt(x);\n\tif(frt(y)==x&&f[y]==x&&!c[y][0]){\n\t\tf[y]=c[x][1]=0;\n\t\tpu(x);\n\t}\n}\nint find(int x,int k){\n\tif(v[x]==k)return x;\n\tif(s[ls]==k)return find(ls,k);\n\treturn find(rs,k);\n}\nstruct edge{\n\tint x,y,a,b;\n}e[N];\nbool cmp(edge x,edge y){\n\treturn (x.a==y.a)?(x.b<y.b):(x.a<y.a);\n}\nint n,m,ff[N];\nint gf(int x){return x==ff[x]?x:(ff[x]=gf(ff[x]));}\nint main(){\n\tin>>n>>m;\n\tFur(i,1,n)ff[i]=i;\n\tFur(i,1,m)in>>e[i].x>>e[i].y>>e[i].a>>e[i].b;\n\tsort(e+1,e+m+1,cmp);\n\tint x,y,ans=inf;\n\tFur(i,1,m){\n\t\tx=e[i].x,y=e[i].y;\n\t\tif(gf(x)!=gf(y)){\n\t\t\tv[n+i]=e[i].b;\n\t\t\tlink(x,n+i);link(y,n+i);\n\t\t\tff[gf(x)]=gf(y);\n\t\t}\n\t\telse{\n\t\t\tsl(x,y);\n\t\t\tif(e[i].b<s[y]){\n\t\t\t\tint t=find(y,s[y]);\n\t\t\t\tcut(e[t-n].x,t);\n\t\t\t\tcut(e[t-n].y,t);\n\t\t\t\tv[n+i]=e[i].b;\n\t\t\t\tlink(x,n+i);\n\t\t\t\tlink(y,n+i);\n\t\t\t}\n\t\t}\n\t\tif(gf(1)==gf(n)){\n\t\t\tsl(1,n);\n\t\t\tans=MIN(ans,s[n]+e[i].a);\n\t\t}\n\t}\n\tif(ans==inf)ans=-1;\n\tout<<ans<<ln;\n}\n```\n","link":null,"tags":["lct","并查集"],"title":"LG 2387 [NOI2014]魔法森林"},{"categories":[["刷题记录"]],"content":"\n记录$S_i$表示$[1,i]$中大于等于$T$的个数\n\n当$[L,R]$满足要求时,$S_R - S_{L-1} \\ge k$\n\n如果$[L,R]$满足要求$[1...L,R]$都满足要求\n\n于是我们就可以用$two\\ pointer$\n\n\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i=x;i<=y;i++)\n    #define Fdr(i,x,y) for(int i=x;i>=y;i--)\n    #define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) (int(log2(n)))\n    #define inf 0x3f3f3f3f\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){clr(ch,0);if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 10000011\n#define int ll\nint n,s[N],T,k,b,c,p,a;\nsigned main(){\n\tcin>>n>>k>>T>>a>>b>>c>>p;\n\tFur(i,1,n){\n\t\ta=(a*b+c)%p; \n\t\ts[i]=s[i-1]+(a>=T);\n\t}\n\tint l=1,r=k,ans=0;\n\twhile(1){\n\t\twhile(r<=n&&s[r]-s[l-1]<k)++r;\n\t\tif(r>n)break;\n\t\tans+=n-r+1;\n\t\t++l;\n\t}\n\t\n\tout<<ans<<ln;\n}\n\n```\n","link":null,"tags":["双指针"],"title":"51nod 1495 中国好区间"},{"categories":[["刷题记录"]],"content":"\n```cpp\n#include <bits\/stdc++.h>\nusing namespace std;\nconst int maxn=5000110;\nint n;\nchar s[maxn];\nint Mini(int l){    \n    int i,j,k;  \n    i=0;j=1;k=0;  \n    while(i<l&&j<l)  \n    {  \n        k=0;  \n        while(s[(i+k)%l]==s[(j+k)%l]&&k<l) k++;  \n        if(k==l) return (i<j)?i:j;  \n        if(s[(i+k)%l]>s[(j+k)%l])i=i+k+1;\n        else j=j+k+1;\n        if(i==j)j++;\n    } \n    return (i<j)?i:j;\n}     \nint main(){\n    cin>>n;\n    for(int i=0;i<n;i++)cin>>s[i];\n    int l=Mini(n);\n    cout<<l<<endl;\n}\n```\n","link":null,"tags":[],"title":"LG 3028 [USACO10OCT]汽水机Soda-Machine"},{"categories":[["刷题记录"]],"content":"\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i=x;i<=y;i++)\n    #define Fdr(i,x,y) for(int i=x;i>=y;i--)\n    #define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 0x3f3f3f3f\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){clr(ch,0);if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 1000001\ndb f[N];\nint main(){\n    int n,k,t;\nin>>t;\nFur(T,1,t){\n    in>>n>>k;\n    db s=0;clr(f,0);\n    Fur(i,1,k+1)f[i]=1;\n    Fur(i,k+2,n){\n        s+=f[i-k-1];\n        f[i]=1+2.0*s\/i;\n    }\n    printf(\"Case #%d: %.5f\\n\",T,f[n]);\n}\n}\n```\n","link":null,"tags":["期望"],"title":"LG UVA12730 Skyrks-Bar"},{"categories":[["刷题记录"]],"content":"\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;rg char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\n#define N 200011\nint n,m,a[N],b[N];\n\nbool chk(int l,int r){\n    if(l>r)return 1;\n    if(l==r)return 1;\n    if(a[l]==a[r])return chk(l+1,r-1);\n    if(chk(l+1,r))return 1;\n    if(chk(l,r-1))return 1;\n\n    return 0;\n}\nint main(){\n    in(n,m);\n    int d=0;\n    Fur(i,1,n){\n        in(a[i]);b[++d]=a[i];\n        if(!a[i]||a[i]==a[i-1])--i,--n;\n        if(a[i]>m)return printf(\"NO\\n\"),0;\n    }\n    if(!chk(1,n))return printf(\"NO\\n\"),0;\n    Fur(i,2,n)if(!b[i]&&b[i-1])b[i]=b[i-1];\n    Fdr(i,n-1,1)if(!b[i]&&b[i+1])b[i]=b[i+1];\n    printf(\"YES\\n\");\n    Fur(i,1,d)printf(\"%d \",b[i]);\n}\n```\n","link":null,"tags":["set"],"title":"LG CF1023D Array-Restoration"},{"categories":[["刷题记录"]],"content":"\n其实下面给出的$a$数组没什么鸟用\n\n列出方程：\n\n$E = \\sum_{i=0}^{n-1} \\frac 1n \\times ( i+ flag \\times E)$\n\n解方程：\n$$\nE = \\sum_{i=0}^{n-1} \\frac 1n \\times ( i+ flag \\times E)\n\\\\\\\\\nE = \\sum_{i=0}^{n-1} \\frac in + (1 - \\frac mn)E \n\\\\\\\\\n\\frac mnE = \\frac {\\frac 12n(n-1)}n\n\\\\\\\\\nE = \\frac {n(n-1)}{2m}\n$$\n\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i=x;i<=y;i++)\n    #define Fdr(i,x,y) for(int i=x;i>=y;i--)\n    #define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) (int(log2(n)))\n    #define inf 0x3f3f3f3f\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nint n,m;\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tprintf(\"%.6f\\n\",(double)n*(n-1)\/2\/m);\n}\n\n```\n","link":null,"tags":["\\uFEFF期望"],"title":"51nod 1765 谷歌的恐龙"},{"categories":[["刷题记录"]],"content":"\n就bfs\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n\t#pragma GCC optimize(3)\n\t#define il __inline__ __attribute__ ((always_inline))\n\t#define rg register\n\t#define ll long long\n\t#define ull unsigned long long\n\t#define db double\n\t#define sht short\n\t#define MB template <class T>il\n\t#define Fur(i,x,y) for(int i=x;i<=y;i++)\n\t#define Fdr(i,x,y) for(int i=x;i>=y;i--)\n\t#define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n\t#define clr(x,y) memset(x,y,sizeof(x))\n\t#define cpy(x,y) memcpy(x,y,sizeof(x))\n\t#define fin(s) freopen(s\".in\",\"r\",stdin)\n\t#define fout(s) freopen(s\".out\",\"w\",stdout)\n\t#define fcin ios::sync_with_stdio(false)\n\t#define l2(n) (int(log2(n)))\n\t#define inf 0x3f3f3f3f\n\tMB T ABS(T x){return x>0?x:-x;}\n\tMB T MAX(T x,T y){return x>y?x:y;}\n\tMB T MIN(T x,T y){return x<y?x:y;}\n\tMB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n\tMB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 101\nint n,m,k;\nchar a[N][N];\n\nint main(){\n\tin>>n>>m>>k;\n\tFur(i,1,n)in>>(a[i]+1);\n\tFur(i,1,n)Fur(j,1,n)\n}\n```\n","link":null,"tags":["bfs"],"title":"LG 1778 万圣节后的早晨"},{"categories":[["刷题记录"]],"content":"\n连续和相当于区间和,题目的意思是求所有$S_i-S_j$的异或和\n\n一般位运算的题我们都拆成二进制下32位来解决\n\n考虑每一位\n\n枚举$k$\n\n如何统计有多少个$((S_i-S_j)>>k)\\&1$呢？\n\n可以开两个权值树状数组来统计$0$和$1$的数量\n\n如果当前$S_i$的第$k$位为$1$,如果$S_j\\&(1<<k) = 0$且$S_i+S_j$在二进制下进位不会影响到第$k$位的都符合条件\n\n也就是$S_j\\&((1<<k)-1) \\not = (S_i\\&((1<<k)-1))$\n\n$\\&((1<<k)-1)$也就是取前$k$位\n```cpp\n#include<bits\/stdc++.h>\nusing namespace std;\n#define ll long long\nconst int N=100011,M=1000011;\nint n,lim,s[N];\nll res;\nstruct tr{\n    ll T[2*M];\n    void c(int x,ll t){\n        x+=1;\n        for(;x<=lim+1;x+=x&(-x))T[x]+=t;\n    }\n    ll q(int x){\n        x+=1;\n        ll r=0;\n        for(;x>0;x-=x&(-x))r+=T[x];\n        return r;\n    }\n    ll s(int l,int r){return q(r)-q(l);}\n    void clear(){for(int i=0;i<=lim+1;i++)T[i]=0;}\n}T1,T0;\nint main(){\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++){\n        scanf(\"%d\",&s[i]);\n        s[i]+=s[i-1];\n    }\n    for(int k=0;(1<<k)<=s[n];k++){\n        lim=(1<<k)-1;ll ret=0;\n        for(int i=0;i<=n;i++){\n            int lst=s[i]&lim;\n            if((s[i]>>k)&1){\n                ret+=T0.s(-1,lst)+T1.s(lst,lim);\n                T1.c(lst,1);\n            }\n            else{\n                ret+=T1.s(-1,lst)+T0.s(lst,lim);\n                T0.c(lst,1);\n            } \n        }\n        if(ret&1)res+=(1<<k);\n        T1.clear();T0.clear();\n    }\n    printf(\"%lld\",res);\n}\n```\n","link":null,"tags":["前缀和","位运算","树状数组"],"title":"LG 3760 [TJOI2017]异或和"},{"categories":[["刷题记录"]],"content":"\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i=x;i<=y;i++)\n    #define Fdr(i,x,y) for(int i=x;i>=y;i--)\n    #define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) (int(log2(n)))\n    #define inf 0x3f3f3f3f\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 10000011\nint pri[N],tot=0;\nll phi[N];\nbool f[N];\nvoid ol(int n){\n    phi[1]=1;\n    Fur(i,2,n){\n        if(!f[i])phi[i]=i-1,pri[++tot]=i;\n        Fur(j,1,tot){\n            if(pri[j]*i>n)break;\n            f[i*pri[j]]=1;\n            if(i%pri[j])phi[i*pri[j]]=phi[i]*phi[pri[j]];\n            else{\n                phi[i*pri[j]]=phi[i]*pri[j];\n                break;\n            }\n        }\n    }\n    Fur(i,2,n)phi[i]+=phi[i-1];\n}\nint main(){\n\tfin(\"in\");\n    ol(10000000);\n    int T,n;ll ans;\n    in>>T;\n    while(T--){\n        in>>n;ans=0;\n        for(int l=1,r;l<=n;l=r+1){\n            r=n\/(n\/l);\n            ans+=(phi[r]-phi[l-1])*(2*phi[(n\/l)]-1);\n        }\n        out<<ans<<ln;\n    }\n}\n\n```\n","link":null,"tags":[],"title":"BZ 4804 欧拉心算"},{"categories":[["刷题记录"]],"content":"\n和网络流24题中的骑士共存问题和[TJOI2013]攻击装置相似\n\n不过不能直接把所有点拆成两种\n\n我们还是可以借助思路\n\n据说这又叫“网络流的最小路径覆盖”\n\n为了使每个点指经过一次,我们把点拆成两个\n\n从源点向每个点的入点连一条边权为$1$的边\n\n从每个点的出点与汇点连一条边权为$1$的边\n\n每个点的入点向能到达的点的出点连一条边权为1的边\n\n然后拿可以放的节点数-最大流\n\n\n\n~~据说还可以用按照有上下界网络流套路建图后求s到t的最小流做？？？~~\n\n\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n\t#pragma GCC optimize(3)\n\t#define il __inline__ __attribute__ ((always_inline))\n\t#define rg register\n\t#define ll long long\n\t#define ull unsigned long long\n\t#define db double\n\t#define sht short\n\t#define MB template <class T>il\n\t#define Fur(i,x,y) for(int i=x;i<=y;i++)\n\t#define Fdr(i,x,y) for(int i=x;i>=y;i--)\n\t#define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n\t#define clr(x,y) memset(x,y,sizeof(x))\n\t#define cpy(x,y) memcpy(x,y,sizeof(x))\n\t#define fin(s) freopen(s\".in\",\"r\",stdin)\n\t#define fout(s) freopen(s\".out\",\"w\",stdout)\n\t#define fcin ios::sync_with_stdio(false)\n\t#define l2(n) (int(log2(n)))\n\t#define inf 0x3f3f3f3f\n\tMB T ABS(T x){return x>0?x:-x;}\n\tMB T MAX(T x,T y){return x>y?x:y;}\n\tMB T MIN(T x,T y){return x<y?x:y;}\n\tMB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n\tMB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 233\nint n,head[N*N],d[N*N],q[N*N],cnt=1,st,ed,r,c,m;\nbool b[N][N];\nstruct edge{\n\tint to,nxt,w;\n}e[N*N*2];\nvoid add(int x,int y,int w){\n\te[++cnt].to=y;e[cnt].w=w;e[cnt].nxt=head[x];head[x]=cnt;\n\te[++cnt].to=x;e[cnt].w=0;e[cnt].nxt=head[y];head[y]=cnt;\n}\nbool bfs(){\n\tint h=0,t=1;\n\tclr(d,0);\n\td[q[h]=st]=1;    \n\twhile(h<t){\n\t\tint x=q[h++];\n\t\tif(x==ed)return 1;\n\t\tfl(i,x)if(e[i].w&&!d[to]){\n\t\t\td[to]=d[x]+1;\n\t\t\tq[t++]=to;\n\t\t}\n\t}\n\treturn 0;\n}\nint dfs(int x,int mf){\n\tif(x==ed)return mf;\n\tint us=0,w;\n\tfl(i,x)\n\tif(e[i].w&&d[to]==d[x]+1){\n\t\tw=dfs(to,MIN(mf-us,e[i].w));\n\t\te[i].w-=w;e[i^1].w+=w;\n\t\tus+=w;\n\t\tif(us==mf)return mf;\n\t}\n\tif(!us)d[x]=-1;\n\treturn us;\n}\nint dinic(){\n\tint ans=0;\n\twhile(bfs())ans+=dfs(st,inf);\n\treturn ans;\n}\n#define id(x,y) ((x-1)*m+y)\nint main(){\n\tin>>n>>m>>r>>c;\n\tst=n*m*2+1;ed=n*m*2+2;\n\tint tt=0;\n\tchar ch[N];\n\tFur(i,1,n){\n\t\tin>>(ch+1);\n\t\tFur(j,1,m)\n\t\tb[i][j]=(ch[j]=='x');\n\t}\n\tint tot=4;\n\tif(r==c)tot=2;\n\tint dx[]={r,r,c,c},\n\t\tdy[]={c,-c,r,-r};\n\t\n\tFur(i,1,n)\n\t\tFur(j,1,m)\n\t\tif(!b[i][j]){\n\t\t\ttt++;\n\t\t\tadd(st,id(i,j),1);\n\t\t\tadd(id(i,j)+n*m,ed,1);\n\t\t\tFur(k,0,tot-1){\n\t\t\t\tint nx=i+dx[k],ny=j+dy[k];\n\t\t\t\tif(nx<1||nx>n||ny<1||ny>m||b[nx][ny])continue;\n\t\t\t\tadd(id(i,j),id(nx,ny)+n*m,1);\n\t\t\t}\n\t\t}\n\tout<<tt-dinic()<<ln;\n}\n```\n","link":null,"tags":["网络流"],"title":"LG 2172 [国家集训队]部落战争"},{"categories":[["刷题记录"]],"content":"\n一开始看到题面是懵逼的\n\n突然发现$1 \\le a \\le 10$\n\n直接在每个重链顶端和节点上放个$vector$\n\n\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i=x;i<=y;++i)\n    #define Fdr(i,x,y) for(int i=x;i>=y;--i)\n    #define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 0x3f3f3f3f\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){clr(ch,0);if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 100011\nint n,m,q,cnt=0,head[N];\nstruct edge{\n    int to,nxt;\n}e[N];\nvoid add(int x,int y){\n    e[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;\n}\nvector<int>c[N];\nint f[N],d[N],siz[N],top[N];\nvoid dfs(int x){\n    siz[x]=1;\n    fl(i,x)if(to!=f[x]){\n        d[to]=d[x]+1;f[to]=x;\n        dfs(to);siz[x]+=siz[to];\n    }\n}\nvoid bt(int x,int tp){\n    top[x]=tp;\n}\nint main(){\n    in>>n>>m>>q;\n    int x,y;\n    Fur(i,1,n-1)in>>x>>y,add(x,y),add(y,x);\n    Fur(i,1,m){\n        in>>x;\n        c[x].push_back(i);\n    }\n\n    while(q--){\n\n    }\n}\n```\n","link":null,"tags":["树链剖分"],"title":"LG CF587C Duff in the Army"},{"categories":[["刷题记录"]],"content":"\n`fhq treap` or `splay`\n\n记录区间最小值\n\n直接模拟即可\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;rg char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\n#define N 100011\n#define ls c[rt][0]\n#define rs c[rt][1]\nint sz[N],val[N],rnd[N],rev[N],c[N][2],RT,cnt,n,s[N];\nvoid pu(int rt){\n    sz[rt]=sz[ls]+sz[rs]+1;\n    s[rt]=MIN(val[rt],MIN(s[ls],s[rs]));\n}\nvoid pd(int rt){\n    if(rev[rt]){\n        SWAP(ls,rs);\n        rev[ls]^=1;rev[rs]^=1;\n        rev[rt]=0;\n    }\n}\nint ne(int v){val[++cnt]=v;s[cnt]=v;sz[cnt]=1;rnd[cnt]=rand();return cnt;}\nvoid sl(int rt,int k,int &x,int &y){\n    if(!rt){x=y=0;return;}\n    pd(rt);\n    if(sz[ls]>=k)y=rt,sl(ls,k,x,ls);\n    else x=rt,sl(rs,k-sz[ls]-1,rs,y);\n    pu(rt);\n}\nint mg(int x,int y){\n    if(!x||!y)return x+y;\n    pd(x);pd(y);\n    if(rnd[x]<rnd[y]){\n        c[x][1]=mg(c[x][1],y);\n        pu(x);\n        return x;\n    }\n    else{\n        c[y][0]=mg(x,c[y][0]);\n        pu(y);\n        return y;\n    }\n}\nint get(int rt){\n    pd(rt);\n    if(s[ls]==s[rt])return get(ls);\n    if(val[rt]==s[rt])return sz[ls]+1;\n    return sz[ls]+1+get(rs);\n}\nstruct node{\n    int v,p;\n    bool operator<(node t){if(v!=t.v)return v<t.v;return p<t.p;}\n}a[N];\nint b[N];\nint main(){\n    in(n);\n    Fur(i,1,n)in(a[i].v),a[i].p=i;\n    sort(a+1,a+n+1);\n    Fur(i,1,n)b[a[i].p]=i;\n    int x,y,z,t;\n    s[0]=inf;sz[0]=0;\n    Fur(i,1,n)RT=mg(RT,ne(b[i]));\n    Fur(i,1,n){\n        sl(RT,i-1,x,y);\n        int p=get(y);\n        out(p+i-1,\" \");\n        sl(y,p,y,z);\n        rev[y]^=1;\n        RT=mg(x,mg(y,z));\n    }\n    flush();\n}\n```\n","link":null,"tags":["平衡树"],"title":"LG 3165 [CQOI2014]排序机械臂"},{"categories":[["刷题记录"]],"content":"\n```cpp\n#include<bits\/stdc++.h>\nusing namespace std;\n#define N 10011\nint n;\nint main(){\n\tdouble ans=0,a=0,b=0,x;\n\tscanf(\"%d\",&n);\n\twhile(n--){\n\t\tscanf(\"%lf\",&x);\n\t\tans=ans+x*(3*a+3*b+1);\n\t\ta=(a+b*2+1)*x;\n\t\tb=(b+1)*x;\n\t}\n\tprintf(\"%.1f\\n\",ans);\n}\n```\n","link":null,"tags":["期望"],"title":"LG 1654 OSU!"},{"categories":[["刷题记录"]],"content":"\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;rg char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\n#define N 100011\nint n;\nint main(){\n    \n}\n```\n","link":null,"tags":["博弈论","贪心"],"title":"LG CF1038C Gambling"},{"categories":[["刷题记录"]],"content":"\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i=x;i<=y;++i)\n    #define Fdr(i,x,y) for(int i=x;i>=y;--i)\n    #define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) (int(log2(n)))\n    #define inf 0x3f3f3f3f\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){clr(ch,0);if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 5011\nint n,cnt=1,d[N],head[N],q[N],f[N],mx,link[N],ans=inf;\nstruct edge{\n\tint to,nxt,w;\n}e[N*100];\nbool b[N*100],v[N];\nvoid add(int x,int y,int w){\n\te[++cnt].to=y;e[cnt].nxt=head[x];e[cnt].w=w;head[x]=cnt;\n}\nvoid bfs(int x){\n\tclr(d,0);clr(f,0);clr(v,0);\n\tint h=0,t=1;mx=x;\n\tq[0]=x;\n\twhile(h<t){\n\t\tx=q[h++];v[x]=1;\n\t\tfl(i,x)\n\t\tif(!b[i]&&!v[to]){\n\t\t\td[to]=d[x]+e[i].w;\n\t\t\tf[to]=i^1;\n\t\t\tq[t++]=to;v[to]=1;\n\t\t\tif(d[to]>d[mx])mx=to;\n\t\t}\n\t}\n}\nint work(int w){\n\tint tmp=0,x,y,t;\n\tbfs(1);bfs(mx);tmp=d[mx];\n\/\/\tout<<w<<\":\\n\";\n\tx=mx;t=(d[x]+1)\/2;\n\twhile(t>0)t-=e[f[x]].w,x=e[f[x]].to;\n\/\/\tout<<x<<\" \"<<d[mx]<<ln;\n\tFur(i,1,n)if(!v[i]){\n\t\tbfs(i);bfs(mx);\n\t\ttmp=MAX(tmp,d[mx]);\n\t\ty=mx;t=(d[y]+1)\/2;\n\t\twhile(t>0)t-=e[f[y]].w,y=e[f[y]].to;\n\/\/\t\tout<<y<<\" \"\t\t<<d[mx]<<ln;\n\t\tbreak;\n\t}\n\tadd(x,y,w),add(y,x,w);\n\tbfs(1);\n\tbfs(mx);\n\/\/\tout<<mx<<\" \"<<d[mx]<<ln;\n\tb[cnt]=b[cnt-1]=1;\n\ttmp=MAX(tmp,d[mx]);\n\treturn tmp;\n}\nint main(){\n\tin>>n;\n\tint x,y,w;\n\tFur(i,1,n-1){\n\t\tin>>x>>y>>w;\n\t\tadd(x,y,w),add(y,x,w);\n\t}\n\tbfs(1);\n\tbfs(x=mx);y=mx;\n\tint d=0;\n\tfor(int i=y;i!=x;i=e[f[i]].to)link[++d]=f[i];\n\/\/\tout<<i<<\" \";out<<x<<ln;\n\tFur(i,1,d){\n\t\tb[link[i]]=b[(link[i]^1)]=1;\n\t\tans=MIN(ans,work(e[link[i]].w));\n\t\tb[link[i]]=b[(link[i]^1)]=0;\n\t}\n\tout<<ans<<ln;\n}\n\n```\n","link":null,"tags":["树的直径"],"title":"LG 3761 [TJOI2017]城市"},{"categories":[["刷题记录"]],"content":"\n就是直接求中位数作那个点\n\n\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i=x;i<=y;i++)\n    #define Fdr(i,x,y) for(int i=x;i>=y;i--)\n    #define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) (int(log2(n)))\n    #define inf 0x3f3f3f3f\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){clr(ch,0);if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 10001\nstruct node{\n\tint p,w;\n}a[N];\nbool cmp(node x,node y){\n\treturn x.p<y.p;\n}\nint n,s=0;\nint main(){\n\tfin(\"in\");\n\tin>>n;\n\tFur(i,1,n)in>>a[i].p>>a[i].w,s+=a[i].w;\n\tsort(a+1,a+n+1,cmp);\n\tint t=0;\n\tFur(i,1,n){\n\t\tt+=a[i].w;\n\t\tif(t*2>=s){\n\t\t\tll ans=0;\n\t\t\tFur(j,1,n)ans+=(1ll*ABS(a[j].p-a[i].p)*a[j].w);\n\t\t\tout<<ans<<ln;\n\t\t\treturn 0;\n\t\t}\n\t}\n}\n\n```\n","link":null,"tags":["排序","中位数"],"title":"51nod 1110 距离之和最小 V3"},{"categories":[["刷题记录"]],"content":"\n二分最大值,然后树型dp\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n\t#pragma GCC optimize(3)\n\t#define il __inline__ __attribute__ ((always_inline))\n\t#define rg register\n\t#define ll long long\n\t#define ull unsigned long long\n\t#define db double\n\t#define sht short\n\t#define MB template <class T>il\n\t#define Fur(i,x,y) for(int i=x;i<=y;i++)\n\t#define Fdr(i,x,y) for(int i=x;i>=y;i--)\n\t#define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n\t#define clr(x,y) memset(x,y,sizeof(x))\n\t#define cpy(x,y) memcpy(x,y,sizeof(x))\n\t#define fin(s) freopen(s\".in\",\"r\",stdin)\n\t#define fout(s) freopen(s\".out\",\"w\",stdout)\n\t#define fcin ios::sync_with_stdio(false)\n\t#define l2(n) (int(log2(n)))\n\t#define inf 0x3f3f3f3f\n\tMB T ABS(T x){return x>0?x:-x;}\n\tMB T MAX(T x,T y){return x>y?x:y;}\n\tMB T MIN(T x,T y){return x<y?x:y;}\n\tMB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n\tMB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){clr(ch,0);if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 111\n#define eps 1e-4\nint n,k,cnt=0,head[N],a[N],b[N],sz[N];\ndb t[N],f[N][N];\nstruct edge{\n\tint to,nxt;\n}e[N*2];\nvoid add(int x,int y){\n\te[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;\n}\nvoid dfs(int x,int fa){\n\tsz[x]=1;\n\tf[x][0]=0;\n\tfl(i,x)if(to!=fa){\n\t\tdfs(to,x);\n\t\tsz[x]+=sz[to];\n\t\tFdr(j,MIN(k,sz[x]),0)\n\t\t\tFur(p,0,MIN(j,sz[to]))\n\t\t\tf[x][j]=MAX(f[x][j],f[x][j-p]+f[to][p]);\n\t}\n\tFdr(i,MIN(k,sz[x]),1)f[x][i]=f[x][i-1]+t[x];\n}\nbool chk(db w){\n\tFur(i,1,n)\n\t\tFur(j,0,k)\n\t\tf[i][j]=-inf;\n\tFur(i,1,n)t[i]=(db)a[i]-w*(db)b[i];\n\tdfs(1,0);\n\tFur(i,1,n)\n\t\tif(f[i][k]>-eps)return 1;\n\treturn 0;\n}\nint main(){\n\tin>>n>>k;k=n-k;\n\tFur(i,1,n)in>>a[i];\n\tFur(i,1,n)in>>b[i];\n\tint x,y;\n\tFur(i,1,n-1)\n\t\tin>>x>>y,add(x,y),add(y,x);\n\n\tdb l=0,r=10000,m;\n\twhile(r-l>eps){\n\t\tm=(l+r)\/2.0;\n\t\tif(chk(m))l=m;\n\t\telse r=m;\n\t}\n\tprintf(\"%.1f\\n\",m);\n}\n```\n","link":null,"tags":["01分数规划","树型dp","动态规划"],"title":"LG 1642 规划"},{"categories":[["刷题记录"]],"content":"\n有趣的题\n\n我们可以发现只有一组相邻两数只能求差的绝对值,其他数都可以取绝对值求和\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;rg char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\n#define N 500011\nint n;\nll a[N],b[N];\nint main(){\n    in(n);\n    Fur(i,1,n)in(a[i]);\n    if(n==1)return cout<<a[1]<<endl,0;\n    ll ans=0,s=0;\n    Fur(i,1,n)b[i]=ABS(a[i]),s+=b[i];\n    Fur(i,1,n-1)\n        ans=MAX(ans,s-(b[i]+b[i+1])+ABS(a[i]-a[i+1]));\n    cout<<ans<<endl;\n}\n```\n","link":null,"tags":["数论","构造","贪心"],"title":"LG CF1038D Slime"},{"categories":[["刷题记录"]],"content":"\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i=x;i<=y;++i)\n    #define Fdr(i,x,y) for(int i=x;i>=y;--i)\n    #define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 0x3f3f3f3f\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){clr(ch,0);if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 1000011\nint n,b[N],a[N],cnt=0,head[N];\nbool cmp(int x,int y){return a[x]>a[y];}\nbool cmp2(int x,int y){return a[x]<a[y];}\nstruct edge{\n    int to,nxt;\n}e[N*2];\nvoid add(int x,int y){\n    e[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;\n}\nint f[N],sz[N];\nint gf(int x){\n    return (x==f[x])?x:(f[x]=gf(f[x]));\n}\nbool v[N];\nint main(){\n    fin(\"in\");\n    in>>n;\n    Fur(i,1,n)in>>a[i],b[i]=i;\n    sort(b+1,b+n+1,cmp2);\n    int x,y;\n    Fur(i,1,n-1)in>>x>>y,add(x,y),add(y,x);\n    ll ans=0;\n    Fur(i,1,n)f[i]=i,sz[i]=1;\n    Fur(i,1,n){\n        x=b[i];v[x]=1;\n        int t=0;\n        fl(i,x)if(v[to]){\n            ans+=1ll*sz[x]*sz[gf(to)]*a[x];\n            sz[x]+=sz[gf(to)];\n            f[gf(to)]=x;\n        }\n    }\n    clr(v,0);\n    Fur(i,1,n)f[i]=i,sz[i]=1;\n    sort(b+1,b+n+1,cmp);\n    Fur(i,1,n){\n        x=b[i];v[x]=1;\n        int t=0;\n        fl(i,x)if(v[to]){\n            ans-=1ll*sz[x]*sz[gf(to)]*a[x];\n            sz[x]+=sz[gf(to)];\n            f[gf(to)]=x;\n        }\n    }\n    out<<ans<<ln;\n}\n```\n","link":null,"tags":[],"title":"LG CF915F Imbalance Value of a Tree"},{"categories":[["刷题记录"]],"content":"\n可以看到$n\\le 15$,我们很容易想到状压\n\n### 状压解法：\n\n设$f[i][j]$表示到了第$i$位,匹配的状态为$j$\n\n代码：\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\n#define N 111\n#define mod 1000003\n#define M(x) ((x>=mod)?(x)%=mod:x)\nint mt[N][30];\nll f[N][1<<15];\nchar ch[N][N];\nil void work(){\n    clr(mt,0);\n    clr(f,0);\n    int n,k,len;\n    in(n,k);\n    Fur(i,1,n)in(ch[i]);\n    len=strlen(ch[1]);\n    Fur(i,0,len-1)\n        for(char t='a';t<='z';++t)\n            Fur(j,1,n)\n            if(ch[j][i]=='?'||ch[j][i]==t)\n                mt[i][t-'a']|=(1<<(j-1));\/\/更新比较当前位的影响\n    f[0][(1<<n)-1]=1;\n    Fur(i,0,len-1)\n        Fur(j,0,(1<<n)-1)\n        if(f[i][j])\n            Fur(t,0,26)\n                M(f[i+1][j&mt[i][t]]+=f[i][j]);\n    ll ans=0;\n    Fur(i,0,(1<<n)-1){\n        int t=i,tt=0;\n        while(t)tt+=(t&1),t>>=1;\n        if(tt==k)M(ans+=f[len][i]);\n    }\n    out(ans,ln);\n}\nint main(){\n    int T;in(T);\n    while(T--)work();\n    flush();\n}\n```\n\n此题还有容斥解法：\n\n看到恰好$k$个,我们就可以想到容斥套路\n\n找出至少匹配$k$个的方案数$g(k)$,设$f(k)$为恰好$k$个的方案数\n\n然后还是按套路就可以了\n\n$$\ng(n) = \\sum_{i=k}^n {n\\choose i}f(i)\n\n\\leftrightarrow \n\nf(n) = \\sum_{i=k}^n {n\\choose i}g(i) (-1)^{i-k}\n$$\n\n问题转换为如何求至少匹配$k$个的方案数\n\n我们可以使用dfs来统计,~~这样比起状压思维难度可能降低了许多,只需要枚举排列组合(当然枚举二进制状态也可以)~~\n\n状压需要处理全部状态\n\ndfs只需要统计$k～n$的部分\n\n最后统计的时间可忽略不计\n\n状压：$492ms$\n\n容斥: $100ms$\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\n#define N 111\n#define mod 1000003\nchar ch[N][N];\nint len,n,k,cnt,c[N][N],up,tot=0,las,a[N];\nvoid dfs(int x,int now){\n    if(x==n+1){\n        if(now!=up) return;\n        ll lp=1;\n        Fur(j,1,len){\n            las=-1;\n            Fur(i,1,up)\n                if(ch[a[i]][j]!='?'){\n                    if(las==-1)\n                        las=ch[a[i]][j]-'a';\n                    else if(las!=ch[a[i]][j]-'a')return;\n                }\n            if(las==-1)lp=(lp*26)%mod;\n        }\n        (tot+=lp)%=mod;\n        return;\n    }\n    if(now<up){\n        a[++cnt]=x;\n        dfs(x+1,now+1);\n        a[cnt--]=0;\n    }\n    if(n-x>=up-now)dfs(x+1,now);\n}\nll g[N];\nil void work(){\n    clr(g,0);\n    in(n,k);\n    Fur(i,1,n)in(ch[i]+1);\n    len=strlen(ch[1]+1);\n    Fur(i,k,n){\n        up=i;\n        tot=0;\n        dfs(1,0);\n        g[i]=tot;\n    }\n    ll ans=0;\n    Fur(i,k,n)\n        if((i-k)&1)ans=(ans-1ll*c[i][k]*g[i]%mod+mod)%mod;\n        else ans=(ans+1ll*c[i][k]*g[i]%mod)%mod;\n    out(ans,ln);\n}\nint main(){\n    Fur(i,0,20){\n        c[i][0]=1;\n        Fur(j,1,i)\n            c[i][j]=c[i-1][j]+c[i-1][j-1];\n    }\n    int T;in(T);\n    while(T--)work();\n    flush();\n}\n```\n","link":null,"tags":["动态规划","状态压缩","容斥"],"title":"LG 2167 [SDOI2009]Bill的挑战"},{"categories":[["刷题记录"]],"content":"\n开$n$个小根堆,然后启发式合并即可\n\n可以用并茶几判断一个人所在的团\n\n唉唉,过了,stl开$o2$\n\n~~等等,居然是左偏树~~\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n\t#pragma GCC optimize(3)\n\t#define il __inline__ __attribute__ ((always_inline))\n\t#define rg register\n\t#define ll long long\n\t#define ull unsigned long long\n\t#define db double\n\t#define sht short\n\t#define MB template <class T>il\n\t#define Fur(i,x,y) for(int i=x;i<=y;i++)\n\t#define Fdr(i,x,y) for(int i=x;i>=y;i--)\n\t#define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n\t#define clr(x,y) memset(x,y,sizeof(x))\n\t#define cpy(x,y) memcpy(x,y,sizeof(x))\n\t#define fin(s) freopen(s\".in\",\"r\",stdin)\n\t#define fout(s) freopen(s\".out\",\"w\",stdout)\n\t#define fcin ios::sync_with_stdio(false)\n\t#define l2(n) (int(log2(n)))\n\t#define inf 0x3f3f3f3f\n\tMB T ABS(T x){return x>0?x:-x;}\n\tMB T MAX(T x,T y){return x>y?x:y;}\n\tMB T MIN(T x,T y){return x<y?x:y;}\n\tMB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n\tMB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 1000011\nint n,q,a[N],f[N];\nbool v[N];\nstruct cmp{\n\tbool operator()(int x,int y){return a[x]>a[y];}\n};\npriority_queue<int,vector<int>,cmp>t[N];\nint gf(int x){return f[x]==x?x:(f[x]=gf(f[x]));}\nint main(){\n\tin>>n;\n\tFur(i,1,n)in>>a[i],f[i]=i,t[i].push(i);\n\tin>>q;\n\tchar ch;\n\tint x,y;\n\twhile(q--){\n\t\tin>>ch;\n\t\tif(ch=='M'){\n\t\t\tin>>x>>y;\n\t\t\tif(v[x]||v[y]||gf(x)==gf(y))continue;\n\t\t\tif(t[gf(x)].size()>t[gf(y)].size())SWAP(x,y);\n\t\t\tint fx=gf(x),fy=gf(y);\n\t\t\twhile(!t[fx].empty()){\n\t\t\t\tt[fy].push(t[fx].top());\n\t\t\t\tt[fx].pop();\n\t\t\t}\n\t\t\tf[fx]=fy;\n\t\t}\n\t\telse{\n\t\t\tin>>x;\n\t\t\tif(v[x]){\n\t\t\t\tout<<\"0\\n\";\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint fx=gf(x);\n\t\t\tx=t[fx].top();\n\t\t\tout<<a[x]<<ln;\n\t\t\tv[x]=1;\n\t\t\tt[fx].pop();\n\t\t}\n\t}\n}\n```\n","link":null,"tags":["堆","可并堆"],"title":"LG 2713 罗马游戏"},{"categories":[["刷题记录"]],"content":"\n用`LG 4824 [USACO15FEB]Censoring\"`的做法hash,kmp什么的因为数据水所以跑不满可以水过去\n\n还是练一下AC自动机吧\n\n解释见代码\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;rg char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\n#define N 100011\nint n,c[N][26],cnt=0,ed[N];\nchar s[N],ch[N];\nil void ins(){\n    int now=0,len=strlen(ch+1);\n    Fur(i,1,len){\n        int x=ch[i]-'a';\n        if(!c[now][x])c[now][x]=++cnt;\n        now=c[now][x];\n    }\n    ed[now]=len;\n}\nint q[N],fail[N];\nil void ac(){\n    int h=0,t=0;\n    Fur(i,0,25)\n        if(c[0][i])q[t++]=c[0][i];\n    while(h<t){\n        int now=q[h++];\n        Fur(i,0,25){\n            if(!c[now][i])\n                c[now][i]=c[fail[now]][i];\n            else\n                fail[c[now][i]]=c[fail[now]][i],\n                q[t++]=c[now][i];\n        }\n    }\n}\nint p[N];\nint main(){\n    in(s+1);\n    in(n);\n    Fur(i,1,n){\n        in(ch+1);\n        ins();\/\/插入trie中\n    }\n    ac();\/\/ AC 自动机\n    int tp=0,now=0,len=strlen(s+1);\n    Fur(i,1,len){\n        int x=s[i]-'a';\n        now=c[now][x];\n        q[++tp]=i;\n        p[tp]=now;\n        if(ed[now]){\n            tp-=ed[now];\n            if(!tp)now=0;\n            else now=p[tp];\n            \/\/跳回之前\n        }\n    }\n    Fur(i,1,tp)pt(s[q[i]]);\n    flush();\n}\n```\n","link":null,"tags":["AC自动机","栈","kmp","hash"],"title":"LG 3121 [USACO15FEB]审查（黄金）Censoring-"},{"categories":[["刷题记录"]],"content":"\n我们可以发现如果$p\\le x$,那么$x\\mod p \\le \\frac x2$\n\n所以取模最多$\\log x$次\n\n记录区间最大值,如果小于$p$那么直接返回\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;rg char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\n#define N 100011\n#define int ll\nint n,q,s[N<<2],mx[N<<2];\n#define ls rt<<1\n#define rs rt<<1|1\n#define pu s[rt]=s[ls]+s[rs],mx[rt]=MAX(mx[ls],mx[rs])\nvoid build(int l,int r,int rt){\n    if(l==r)return (void)(in(s[rt]),mx[rt]=s[rt]);\n    int m=(l+r)>>1;\n    build(l,m,ls);build(m+1,r,rs);\n    pu;\n}\nvoid upd(int x,int v,int l,int r,int rt){\n    if(l==r){\n        s[rt]=mx[rt]=v;\n        return;\n    }\n    int m=(l+r)>>1;\n    if(x<=m)upd(x,v,l,m,ls);\n    else upd(x,v,m+1,r,rs);\n    pu;\n}\nvoid UPD(int L,int R,int v,int l,int r,int rt){\n    if(mx[rt]<v)return;\n    if(l==r){\n        s[rt]=(mx[rt]%=v);\n        return;\n    }\n    int m=(l+r)>>1;\n    if(L<=m)UPD(L,R,v,l,m,ls);\n    if(R>m)UPD(L,R,v,m+1,r,rs);\n    pu;\n}\nint ask(int L,int R,int l,int r,int rt){\n    if(L<=l&&r<=R)return s[rt];\n    int m=(l+r)>>1,ans=0;\n    if(L<=m)ans=ask(L,R,l,m,ls);\n    if(R>m)ans+=ask(L,R,m+1,r,rs);\n    return ans;\n}\nsigned main(){\n    in(n,q);\n    build(1,n,1);\n    while(q--){\n        int opt,l,r,v;\n        in(opt,l,r);\n        if(opt==1)out(ask(l,r,1,n,1),ln);\n        if(opt==2)in(v),UPD(l,r,v,1,n,1);\n        if(opt==3)upd(l,r,1,n,1);\n    }\n    flush();\n}\n```\n","link":null,"tags":["线段树","数论"],"title":"LG CF438D The-Child-and-Sequence"},{"categories":[["刷题记录"]],"content":"\n记录$up[i][j]$表示位置$(i,j)$可以向上多少个`#`\n\n$s[i][j]$表示位置$(i,j)$作为三角形中心可以向左多少个`#`\n\n$S[i][j]$表示位置$(i,j)$作为三角形中心可以向右多少个`#`\n\n$ans = \\sum_{i=1}^n\\sum_{j=1}^n \\min(s[i][j],S[i][j])$\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i=x;i<=y;++i)\n    #define Fdr(i,x,y) for(int i=x;i>=y;--i)\n    #define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 0x3f3f3f3f\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){clr(ch,0);if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 2011\nint n,up[N][N],s[N][N],S[N][N];\nchar ch[N][N];\nbool b[N][N];\nint main(){\n    fin(\"in\");\n    in>>n;\n    Fur(i,1,n)in>>(ch[i]+1);\n    Fur(i,1,n)\n        Fur(j,1,n)\n        b[i][j]=(ch[i][j]=='#');\n    Fur(i,1,n)\n        Fur(j,1,n)\n        if(b[i][j])up[i][j]=up[i-1][j]+1;\n    \n    Fur(i,1,n)\n        Fur(j,1,n)\n        if(b[i][j])s[i][j]=MIN(up[i][j],s[i][j-1]+1);\n\n    Fur(i,1,n)\n        Fdr(j,n,1)\n        if(b[i][j])S[i][j]=MIN(up[i][j],S[i][j+1]+1);\n    \n    ll ans=0;\n    Fur(i,1,n)Fur(j,1,n)if(b[i][j])ans+=MIN(s[i][j],S[i][j]);\n    out<<ans<<ln;\n}\n```\n","link":null,"tags":["前缀和","思维"],"title":"LG 4813 [CCO 2014]Troy 与三角形"},{"categories":[["刷题记录"]],"content":"\n设$f[i][sta]$表示以第$i$只奶牛结尾,状态为$sta$的情况下有多少种\n\n$f[i][sta] = \\sum f[i-1][sta']$\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;rg char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\n#define N 17\nint n,k,a[N];\nll f[N][1<<N];\nint main(){\n    in(n,k);\n    Fur(i,1,n)in(a[i]);\n    Fur(i,1,n)f[i][1<<(i-1)]=1;\n    Fur(sta,1,(1<<n)-1)\n        Fur(i,1,n)\n        if((sta&(1<<(i-1)))&&!f[i][sta]){\n            int STA=sta^(1<<(i-1));\n            Fur(j,1,n)\n            if(i!=j&&(STA&(1<<(j-1)))&&(ABS(a[i]-a[j])>k))\n                f[i][sta]+=f[j][STA];\n        }\n    ll ans=0;\n    Fur(i,1,n)ans+=f[i][(1<<n)-1];\n    cout<<ans<<endl;\n}\n```\n","link":null,"tags":["状态压缩","动态规划"],"title":"LG 2915 [USACO08NOV]奶牛混合起来Mixed-Up-Cows"},{"categories":[["刷题记录"]],"content":"\n第一问：\n\n数列中肯定有些是合法的,有些是不合法的\n\n如果$a_i-a_j < j-i$就无法同时保留两者\n\n那么$a_i-a_j \\ge j-i$\n\n所以$a_i-i < a_j-j$\n\n设$b_i = a_i -i$\n\n$b$的最长不下降子序列长度就是最多能保留个数\n\n第二问：\n\n把$a$变成严格单调上升等同于把$b$变成单调不降\n\n唉,实在不会\n\nhttps:\/\/pan.baidu.com\/share\/link?uk=2651016602&shareid=1490516411\n```cpp\n#include<bits\/stdc++.h>\n#define inf 1000000000\n#define ll long long\nusing namespace std;\nint gi(){\n\tint x=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nint n,L,cnt;\nint a[35005],mn[35005];\nint f[35005],last[35005];\nll g[35005],s1[35005],s2[35005];\nstruct list{int to,next;}e[35005];\nvoid insert(int u,int v){\n\te[++cnt].to=v;e[cnt].next=last[u];last[u]=cnt;\n}\nvoid dp(){\n\tmemset(mn,127,sizeof(mn));\n\tmn[0]=-1<<30;\n\tfor(int i=1;i<=n;i++){\n\t\tint t=upper_bound(mn+1,mn+L+1,a[i])-mn;\n\t\tf[i]=t;\n\t\tL=max(L,t);\n\t\tmn[t]=min(mn[t],a[i]);\n\t}\n}\nvoid solve(){\n\tfor(int i=n;i>=0;i--){\n\t\tinsert(f[i],i);\n\t\tg[i]=1LL<<60;\n\t}\n\tg[0]=0;a[0]=-1<<30;\n\tfor(int x=1;x<=n;x++)\n\t\tfor(int i=last[f[x]-1];i;i=e[i].next){\n\t\t\tint p=e[i].to;\n\t\t\tif(p>x)break;\n\t\t\tif(a[p]>a[x])continue;\n\t\t\tfor(int j=p;j<=x;j++)\n\t\t\t\ts1[j]=abs(a[p]-a[j]),s2[j]=abs(a[x]-a[j]);\n\t\t\tfor(int j=p+1;j<=x;j++)\n\t\t\t\ts1[j]+=s1[j-1],s2[j]+=s2[j-1];\n\t\t\tfor(int j=p;j<x;j++)\n\t\t\t\tg[x]=min(g[x],g[p]+s1[j]-s1[p]+s2[x]-s2[j]);\n\t\t}\n}\nint main(){\n\tn=gi();\n\tfor(int i=1;i<=n;i++)a[i]=gi()-i;\n\ta[++n]=1<<30;\n\tdp();\n\tsolve();\n\tprintf(\"%d\\n%lld\\n\",n-f[n],g[n]);\n\treturn 0;\n}\n```\n","link":null,"tags":["动态规划"],"title":"LG 2501 [HAOI2006]数字序列"},{"categories":[["刷题记录"]],"content":"\n树形dp中的$\\text{up and down}$\n\n还有一点期望\n\n设每个点能够通电的概率为$P_i$\n\n那么$ans = \\sum_{i=1}^n P_i$\n\n**我们先考虑$up$(只考虑子树))**\n\n分成两种情况：\n\n1. 直接通电 : $q_i$\n   \n2. 被子节点通电 : \n   \n   $(1-q_i) \\times P_{to}(\\text{子节点}) \\times e_i.w(\\text{连接的边导电的概率})$\n   \n**我们再考虑$down$(考虑子树外))**\n\n我们可以通过父节点的答案来更新子节点\n\n父节点的答案是包括当前子节点的\n\n可以把这部分除去然后按照$up$的方法更新\n\n$P_x= P_x' (1-P_x')*(P_{to}*e_i.w)$($P_x'$指根节点除去当前子节点的贡献的答案)\n\n整理得：\n$$P_x'=\\frac{P_x-(P_{to} \\times e_i.w)}{1-(P_{to} \\times e_i.w)}$$\n\n(这里有个坑点:当$1-(P_{to} \\times e_i.w) = 0$时这个式子就没有意义了)\n\n$\\therefore P_{to} = P_{to} + (1-P_{to}) \\times P_x' \\times e_i.w$\n\n所以在下推的时候要特判一下\n\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i=x;i<=y;++i)\n    #define Fdr(i,x,y) for(int i=x;i>=y;--i)\n    #define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 0x3f3f3f3f\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){clr(ch,0);if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 500011\nint n,cnt=0,head[N],d[N];\nstruct edge{\n    int to,nxt;\n    db w;\n}e[N*2];\nil void add(int x,int y,db w){\n    e[++cnt].to=y;e[cnt].w=w;e[cnt].nxt=head[x];head[x]=cnt;\n}\ndb s[N],ans=0;\nvoid up(int x){\n    fl(i,x)if(!d[to]){\n        d[to]=d[x]+1;\n        up(to);\n        db t=s[to]*e[i].w;\n        s[x]+=(1-s[x])*t;\n    }\n}\n#define eps 1e-7\nil bool chk(db x){return x+eps>1.0&&x-eps<1.0;}\nvoid down(int x){\n    ans+=s[x];\n    fl(i,x)if(d[to]>d[x]){\n        if(!chk(s[to]*e[i].w)){\n            db t=(s[x]-s[to]*e[i].w)\/(1.0-s[to]*e[i].w)*e[i].w;\n            s[to]+=(1-s[to])*t;\n        }\n        down(to);\n    }\n}\nint main(){\n    fin(\"in\");\n    in>>n;\n    int x,y,w;\n    Fur(i,1,n-1)in>>x>>y>>w,add(x,y,(db)w*0.01),add(y,x,(db)w*0.01);\n    Fur(i,1,n)in>>x,s[i]=(db)x*0.01;\n    d[1]=1;\n    up(1);\n    down(1);\n    printf(\"%.6f\\n\",ans);\n}\n```\n","link":null,"tags":["树形dp","期望"],"title":"LG 4284 [SHOI2014]概率充电器"},{"categories":[["刷题记录"]],"content":"\n```cpp\n#include<bits\/stdc++.h>\n#include<ext\/pb_ds\/assoc_container.hpp>\n#include<ext\/pb_ds\/tree_policy.hpp>\n#define il inline\n#define ll long long\n#define RE register\n#define For(i,a,b) for(RE int (i)=(a);(i)<=(b);(i)++)\n#define Bor(i,a,b) for(RE int (i)=(b);(i)>=(a);(i)--)\nusing namespace std;\nusing namespace __gnu_pbds;\n#define N 500005;\nint n,val[N],cnt,tot;\nmap<string,int> mp;\nstring ss[N];\nstruct node{\n    int v,id;\n    bool operator < (const node &x) const {return v==x.v?id<x.id:v>x.v;}\n};\ntree<node,null_type,less<node>,rb_tree_tag,tree_order_statistics_node_update> T;\nil bool isdig(char x){return x>='0'&&x<='9';}\nint main(){\n    ios::sync_with_stdio(0);\n    cin>>n;char c;string s;int x,tp;\n    while(n--){\n        cin>>c>>s;\n        if(c=='+'){\n            if(mp[s]){\n            tp=mp[s],T.erase(node{val[tp],tp});tot--;\n        }\n        mp[s]=++cnt,cin>>val[cnt],T.insert(node{val[cnt],cnt});tot++;\n            ss[cnt]=s;\n        }\n        else if(c=='?'&&!isdig(s[0])){\n            x=mp[s];cout<<T.order_of_key(node{val[x],x})+1<<endl;\n        }\n        else{\n            x=0;\n            For(i,0,s.size()-1) x=(x<<3)+(x<<1)+(s[i]^48);\n            tp=min(tot,x+9);\n            For(i,x-1,tp-1)cout<<ss[T.find_by_order(i)->id]<<' ';cout<<endl;\n        }\n    }\n} \n```\n","link":null,"tags":["平衡树","hash"],"title":"LG 4291 [HAOI2008]排名系统"},{"categories":[["刷题记录"]],"content":"\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i=x;i<=y;i++)\n    #define Fdr(i,x,y) for(int i=x;i>=y;i--)\n    #define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) (int(log2(n)))\n    #define inf 0x3f3f3f3f\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){clr(ch,0);if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 100011\nint n,a[N];\nbool v[N];\nint main(){\n\tfin(\"in\");\nint T;in>>T;\nwhile(T--){\n\tin>>n;\n\tclr(v,0);\n\tFur(i,1,n)in>>a[i];\n\tbool ff=1;\n\tFur(i,1,n)\n\tif(!v[i]){\n\t\tbool f=1;\n\t\tFur(j,i+1,n)\n\t\tif(!v[j]&&a[j]==a[i]){\n\t\t\tv[j]=1,f=0;\n\t\t\tbreak;\n\t\t}\n\t\tif(f){\n\t\t\tff=0;\n\t\t\tout<<\"What a pity!\\n\";\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(ff)out<<\"Good job!!\\n\";\n}\n}\n\n```\n","link":null,"tags":[],"title":"51nod 1400 序列分解"},{"categories":[["刷题记录"]],"content":"\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i=x;i<=y;i++)\n    #define Fdr(i,x,y) for(int i=x;i>=y;i--)\n    #define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) (int(log2(n)))\n    #define inf 0x3f3f3f3f\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){clr(ch,0);if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 10001\nstruct edge{\n    int to,nxt;\n}e[N];\nint n,cnt=0,head[N],s,k;\nil void add(int x,int y){\n    e[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;\n}\nvoid dfs(int x,int f){\n    \n}\nint main(){\n    in>>n>>s>>k;\n    int x,y;\n    Fur(i,1,n-1)in>>x>>y,add(x,y),add(y,x);\n    dfs(1,0);\n}\n\n```\n","link":null,"tags":["dfs","树型dp"],"title":"LG 3479 [POI2009]GAS-Fire-Extinguishers"},{"categories":[["刷题记录"]],"content":"\n## 解法1:\n\n贪心\n\n把深度大于2的都加到堆中\n\n每次取出深度最大的点\n\n从根结点往它父亲连边\n\n然后把周围的节点标记为已经覆盖\n\n## 解法2:\n\n树形dp\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;rg char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\n#define N 200011\nint n,d[N],head[N],cnt=0;\nstruct edge{\n    int to,nxt;\n}e[N*2];\nvoid add(int x,int y){\n    e[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;\n}\nint f[N];\nvoid dfs(int x){\n    fl(i,x)if(to!=f[x]){\n        d[to]=d[x]+1;f[to]=x;\n        dfs(to);\n    }\n}\nstruct cmp{\n    bool operator()(int x,int y){return d[x]<d[y];}\n};\npriority_queue<int,vector<int>,cmp>q;\nbool v[N];\nint main(){\n    in(n);\n    int x,y,ans=0;\n    Fur(i,1,n-1)in(x,y),add(x,y),add(y,x);\n    dfs(1);\n    Fur(i,1,n)if(d[i]>2)q.push(i);\n    while(!q.empty()){\n        x=q.top();q.pop();\n        if(v[x])continue;\n        x=f[x];v[x]=1;\n\n        ++ans;\n        fl(i,x)v[to]=1;\n    }\n    cout<<ans<<endl;\n}\n```\n","link":null,"tags":["贪心","树形dp","动态规划"],"title":"LG CF1029E Tree-with-Small-Distances"},{"categories":[["刷题记录"]],"content":"\n## 题目大意：\n\n给定一个长度为 $n\\leq 500000$ 的序列 $a_1, a_2, \\cdots, a_n$ ,要求对于每一个 $1 \\leq r \\leq n$ ,找到最小的非负整数 $f_{r}$ 满足\n\n$$\\forall l\\in\\left[1,n\\right]:a_l \\leq a_r + f_{r} - \\sqrt{|r-l|}$$\n\n## 解法\n\n考虑$l<r,r>l$的将序列翻转后再来一次就可以了\n\n$$f_r= \\max(a_l+\\sqrt{r-l})-a_r(l\\in[1,r])$$\n\n可以证明$f_r$的最优决策点是递增的\n\n~~可以打表~~\n\n### 分治解法\n\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define db double\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;rg char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\n#define N 500011\nint n;\nll a[N];\nlong db f1[N],f2[N];\nvoid work(int L,int R,int l,int r,long db *f){\n    if(L>R)return;\n    int m=(L+R)>>1,k=0;\n    f[m]=a[m];\n    long db t=0;\n    Fur(i,l,MIN(r,m)){\n        t=a[i]+sqrt(db(m-i));\n        if(t>f[m])k=i,f[m]=t;\n    }\n    f[m]-=a[m];\n    if(!k)k=m;\n    work(L,m-1,l,k,f);\n    work(m+1,R,k,r,f);\n}\nint main(){\n    in(n);\n    Fur(i,1,n)in(a[i]);\n    work(1,n,1,n,f1);\n    reverse(a+1,a+n+1);\n    work(1,n,1,n,f2);\n    Fur(i,1,n)out((ll)ceil(MAX(f1[i],f2[n-i+1])),ln);\n    flush();\n}\n```\n\n### 队列实现决策二分栈\n\n对于每个$j$,把$a_j+\\sqrt{i-j}$看成关于$i$的函数$f_j$。\n\n我们要做的就是在所有$j\\leq i$的函数中找到最值\n\n队列实现决策二分栈,按$j$从小到大依次维护这些函数。\n\n对于其中任意两个相邻的函数$f_t,f_{t+1}$ ,它们都有一个临界值$k_{t,t+1}$\n\n显然序列中的$k_{1,2},k_{2,3}...$也要严格递增。\n\n否则,如果$k_{t,t+1}\\ge k_{t+1,t+2}$,$f_{t+1}$根本没有用。\n\n每次加入$f_i$的时候：\n\n设队尾为$t$,如果当前$i$比$t$优($calc(k_{t-1},i)\\ge calc(k_{t-1},t)$),那么弹出$t$\n\n现在来考虑队头$h$\n\n若$k_h\\le i$那么把$h$弹出\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define db double\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;rg char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\n#define N 500011\nint n,a[N],q[N],k[N];\ndb p[N],sq[N];\nil db calc(int i,int j){return a[j]+sq[i-j];}\/\/函数值\nil int bound(int x,int y){\n    int l=y,r=(k[x]?k[x]:n),m,ret=r+1;\n    while(l<=r){\n        m=(l+r)>>1;\n        if(calc(m,x)<=calc(m,y))\n            ret=m,r=m-1;\n        else l=m+1;\n    }\n    return ret;\n}\nvoid work(){\n    int h=1,t=0;\n    Fur(i,1,n){\n        while(h<t&&calc(k[t-1],q[t])<calc(k[t-1],i))--t;\n        \/\/保持k单调\n        k[t]=bound(q[t],i);\n        \/\/二分出临界点\n        q[++t]=i;\n        while(h<t&&k[h]<=i)++h;\n        \/\/不优的出队\n        p[i]=MAX(p[i],calc(i,q[h]));\n        \/\/两遍取max\n    }\n}\nint main(){\n    in(n);\n    Fur(i,1,n)in(a[i]),sq[i]=sqrt(i);\n    work();\n\n    \/\/翻转序列\n    reverse(a+1,a+n+1);\n    reverse(p+1,p+n+1);\n    memset(k,0,(n+1)<<2);\n    work();\n\n    \/\/翻转后需要倒序输出\n    Fdr(i,n,1)out(MAX(int(ceil(p[i]))-a[i],0),ln);\n    flush();\n}\n```\n","link":null,"tags":["动态规划","单调队列","四边形不等式","决策单调性"],"title":"LOJ 2157 Lightning-Conductor"},{"categories":[["刷题记录"]],"content":"\n思路很妙\n\n我们可以先求出$n$到每个点的距离\n\n如果直接枚举$k$个干草堆,然后判断每个点是否可行,$\\Theta(nk)$的复杂度显然TLE\n\n因为一定要经过干草堆,所以可以新建一个节点$n+1$,向所有干草堆连单向边(边权为这个干草堆的影响)\n\n在从$n+1$跑一遍最短路就可以了\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;rg char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\n#define N 50011\n#define int ll\nint n,m,k,head[N],cnt=0;\nstruct edge{\n    int to,nxt,w;\n}e[300011];\nil void add(int x,int y,int w){\n    e[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;\n    e[cnt].w=w;\n}\nint d[N],s[N];\nstruct cmp{\n    bool operator()(int x,int y){return d[x]>d[y];}\n};\npriority_queue<int,vector<int>,cmp>q;\nbool v[N];\nvoid dij(int st){\n    Fur(i,1,n+1)d[i]=(1ll<<50);\n    d[st]=0;q.push(st);\n    while(!q.empty()){\n        int x=q.top();q.pop();\n        v[x]=0;\n        fl(i,x)if(d[x]+e[i].w<d[to]){\n            d[to]=d[x]+e[i].w;\n            if(!v[to])q.push(to),v[to]=1;\n        }\n    }\n}\nsigned main(){\n    in(n,m,k);\n    int x,y,w;\n    Fur(i,1,m)in(x,y,w),add(x,y,w),add(y,x,w);\n    dij(n);cpy(s,d);\n    Fur(i,1,k){\n        in(x,w);\n        add(n+1,x,s[x]-w);\n    }\n    dij(n+1);\n    Fur(i,1,n-1)if(d[i]<=s[i])out(1,ln);\n    else out(0,ln);\n    flush();\n}\n```\n","link":null,"tags":["最短路"],"title":"LG 5122 [USACO18DEC]Fine-Dining"},{"categories":[["刷题记录"]],"content":"\n```cpp\n#include<cstdio>\n#include<ctype.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #pragma GCC target(\"sse,sse2\")\n    #define il inline\n    #define rg register\n    #define ll long long\n    #define db double\n    #define sht short\n    #define MB template <class T>\n    #define Fur(i,x,y) for(rg int i=x;i<=y;i++)\n    #define Fdr(i,x,y) for(rg int i=x;i>=y;i--)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define l2(n) (int(log2(n)))\n    #define inf 2000000000\n    #define fl(i,x) for(rg int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n    #define fcin ios::sync_with_stdio(false)\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>=y?x:y;}\n    MB T MIN(T x,T y){return x<=y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    void SWAP(int &x,int &y){x^=y;y^=x;x^=y;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 50011\nint n,q,s[N<<2],S[N<<2],L[N<<2],R[N<<2];\nstruct tr{int s,S,L,R;}t[N<<2];\n#define Z int m=(l+r)>>1\n#define ls rt<<1\n#define rs rt<<1|1\nvoid pu(int rt){\n    t[rt].s=t[ls].s+t[rs].s;\n    t[rt].S=MAX(MAX(MAX(t[ls].R,t[rs].L),t[ls].R+t[rs].L),MAX(t[ls].S,t[rs].S));\n    t[rt].L=MAX(t[ls].L,t[ls].s+t[rs].L);t[rt].R=MAX(t[rs].R,t[rs].s+t[ls].R);\n}\nvoid build(int l,int r,int rt){\n    if(l==r){\n        in>>t[rt].s;t[rt].L=t[rt].R=t[rt].S=t[rt].s;\n        return;\n    }\n    Z;\n    build(l,m,ls);build(m+1,r,rs);\n    pu(rt);\n}\nvoid upd(int x,int v,int l,int r,int rt){\n    if(l==r){t[rt].s=t[rt].S=t[rt].R=t[rt].L=v;return;}\n    Z;\n    if(x<=m)upd(x,v,l,m,ls);\n    else upd(x,v,m+1,r,rs);\n    pu(rt);\n}\ntr ask(int x,int y,int l,int r,int rt){\n    if(x<=l&&r<=y)return t[rt];\n    Z;\n    if(x>m)return ask(x,y,m+1,r,rs);\n    if(y<=m)return ask(x,y,l,m,ls);\n    tr ans,a=ask(x,y,l,m,ls),b=ask(x,y,m+1,r,rs);\n    ans.s=a.s+b.s;\n    ans.S=MAX(MAX(MAX(a.R,b.L),a.R+b.L),MAX(a.S,b.S));\n    ans.L=MAX(a.L,a.s+b.L);ans.R=MAX(b.R,b.s+a.R);\n    return ans;\n}\nint main(){\n    fin(\"in\");\n    in>>n>>q;\n    build(1,n,1);\n    while(q--){\n        int u,l,r;in>>u>>l>>r;\n        if(l>r)SWAP(l,r);\n        if(u==1)out<<ask(l,r,1,n,1).S<<ln;\n        else upd(l,r,1,n,1);\n    }\n}\n```\n","link":null,"tags":[],"title":"LG 4513 小白逛公园"},{"categories":[["刷题记录"]],"content":"\n可以参考线段树或分块维护区间加和区间减的思路\n\n看一下数据范围,每次操作只能$O(1)$的复杂度。\n\n点的位置可以离散化一下\n\n记得先乘后加\n```cpp\n#include<bits\/stdc++.h>\n#include<unordered_map>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i=x;i<=y;++i)\n    #define Fdr(i,x,y) for(int i=x;i>=y;--i)\n    #define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) (int(log2(n)))\n    #define inf 0x3f3f3f3f\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){clr(ch,0);if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 100007\nconst int mod=10000019;\nint n,Q,add=0,mul=1,ans=0,s=0,v[N],ti[N],la,inv[mod+1];\nstruct que{\n    int u,x,y;\n}q[N];\nvoid work(int i,int k){\n    int u=q[i].u,x=q[i].x,y=q[i].y;\n    if(u==6)ans=(ans+s)%mod;\n    else if(u==2)s=(s+1ll*n*x%mod)%mod,add=(add+x)%mod;\n    else if(u==3)s=1ll*s*x%mod,add=1ll*add*x%mod,mul=1ll*mul*x%mod;\n    else if(u==4)s=1ll*n*x%mod,add=0,mul=1,v[0]=x,la=k;\n    else if(u==5){\n        if(ti[x]<=la)ans=(ans+1ll*mul*v[0]%mod+add)%mod;\n        else ans=(ans+1ll*mul*v[x]%mod+add)%mod;\n    }\n    else{\n        if(ti[x]<=la)s=(s-1ll*mul*v[0]%mod-add+(mod<<1))%mod;\n        else s=(s-1ll*mul*v[x]%mod-add+(mod<<1))%mod;\n        s=(s+y)%mod;ti[x]=k;v[x]=1ll*(y-add+mod)*inv[mul]%mod;\n    }\n}\nunordered_map<int,int>mp;\nint a[N],b[N];\nint main(){\n    in>>n>>Q;\n    inv[1]=1;\n    Fur(i,2,mod)inv[i]=1ll*(mod-mod\/i)*inv[mod%i]%mod;\n    int u,x,d=0;\n    Fur(i,1,Q){\n        in>>q[i].u;\n        if(q[i].u!=6)in>>q[i].x;\n        if(q[i].u==1){\n            in>>q[i].y,q[i].y=(q[i].y%mod+mod)%mod;\n            if(!mp[q[i].x])mp[q[i].x]=++d;\n        }\n        else if(q[i].u<=4)q[i].x=(q[i].x%mod+mod)%mod;\n        if(q[i].u==3&&q[i].x==0)q[i].u=4;\n    }\n    Fur(i,1,Q)if(q[i].u==1||q[i].u==5)q[i].x=mp[q[i].x];\n    mul=1;\n    int t;in>>t;\n    Fur(i,1,t)in>>a[i]>>b[i];\n    Fur(i,1,t*Q){\n        int x=(i-1)\/Q+1,y=(i-1)%Q+1;\n        work((a[x]+1ll*y*b[x])%Q+1,i);\n    }\n    out<<ans<<ln;\n}\n```\n","link":null,"tags":["打标记"],"title":"LG 5358 [SDOI2019]快速查询"},{"categories":[["刷题记录"]],"content":"\n缩点后跑最长路\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i=x;i<=y;++i)\n    #define Fdr(i,x,y) for(int i=x;i>=y;--i)\n    #define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 0x3f3f3f3f\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){clr(ch,0);if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 1000111\nint n,m,cnt=2,head[N],ST;\nstruct edge{\n    int x,to,nxt;\n}e[N];\nvoid add(int x,int y){\n    e[++cnt].to=y;e[cnt].x=x;e[cnt].nxt=head[x];head[x]=cnt;\n}\nint c[N];\nbool jiu[N],v[N],JIU[N];\nint dfn[N],low[N],sta[N],tp=0,sz=0,bl[N];\nvoid tarjan(int x){\n    dfn[x]=low[x]=++sz;\n    v[x]=1;sta[++tp]=x;\n    fl(i,x)\n    if(!dfn[to]){\n        tarjan(to);\n        low[x]=MIN(low[x],low[to]);\n    }\n    else if(v[to])low[x]=MIN(low[x],dfn[to]);\n    if(low[x]==dfn[x]){\n        while(int k=sta[tp--]){\n            v[k]=0;\n            bl[k]=x;\n            if(k==x)break;\n            c[x]+=c[k];\n        }\n    }\n}\nint d[N],q[N];\nint main(){\n    fin(\"in\");\n    in>>n>>m;\n    int x,y;\n    Fur(i,1,m)in>>x>>y,add(x,y);\n    Fur(i,1,n)in>>c[i];\n    in>>ST>>y;\n    while(y--)in>>x,jiu[x]=1;\n    Fur(i,1,n)if(!dfn[i])tarjan(i);\n    Fur(i,1,n)if(jiu[i])JIU[bl[i]]=1;\n    int t=cnt;\n    cnt=0;clr(head,0);\n    Fur(i,3,t){\n        x=bl[e[i].x];y=bl[e[i].to];\n        if(x!=y)add(x,y);\n    }\n    \/\/ Fur(i,1,cnt)out<<e[i].x<<\" \"<<e[i].to<<ln;\n    \/\/ Fur(i,1,n)if(i==bl[i])out<<i<<\": \"<<c[i]<<ln;\n    clr(d,128);clr(v,0);\n    d[bl[ST]]=c[bl[ST]];\n    int h=0;t=1;\n    q[0]=bl[ST];\n    v[bl[ST]]=1;\n    while(h^t){\n        x=q[h++];v[x]=0;\n        fl(i,x)if(d[x]+c[to]>d[to]){\n            d[to]=d[x]+c[to];\n            if(!v[to])q[t++]=to,v[to]=1;\n        }\n    }\n    int ans=0;\n    Fur(i,1,n)if(i==bl[i]&&JIU[i])ans=MAX(ans,d[i]);\n    out<<ans<<ln;\n}\n```\n","link":null,"tags":["tarjan","最短路"],"title":"LG 3627 [APIO2009]抢掠计划"},{"categories":[["刷题记录"]],"content":"\n枚举哪些行和哪些列要变成回文\n\n处理:\n\n行:点$(i,j)$对应点$(i,m-j+1)$\n\n列:点$(i,j)$对应点$(n-i+1,j)$\n\n我们可以用并查集合并这些点\n\n然后求每个块中0还是1多\n\n\n```cpp\n#include<bits\/stdc++.h>\n#define il inline\n#define clr(x,y) memset(x,y,sizeof x)\n#define Fur(i,x,y) for(int i(x);i<=y;++i)\nusing namespace std;\nil int min(int x,int y){return x<y?x:y;}\n#define N 20\nint fr[N][N],fc[N][N];\nint row[N],col[N],f[N*N],cnt0[N*N],cnt1[N*N];\nint r,c,n,m,ans;\nchar ch[N][N];\nint gf(int x){return (x==f[x])?x:(f[x]=gf(f[x]));}\nil void mg(int x,int y){\n    int fx=gf(x),fy=gf(y);\n    if(fx!=fy){\n        f[fy]=fx;\n        cnt0[fx]+=cnt0[fy];\n        cnt1[fx]+=cnt1[fy];\n    }\n}\nil int id(int i,int j){return (i-1)*m+j;}\nvoid solve(){\n    clr(fr,0);clr(fc,0);\n    Fur(i,1,r)\n        Fur(j,1,m)\n            fr[row[i]][j]=1;\n\n    Fur(i,1,n)\n        Fur(j,1,c)\n            fc[i][col[j]]=1;\n\n    Fur(i,1,n)\n        Fur(j,1,m)\n        if(fr[i][j]||fc[i][j]){\n            f[id(i,j)]=id(i,j);\n            if(ch[i][j]=='0')cnt0[id(i,j)]=1,cnt1[id(i,j)]=0;\n            else cnt0[id(i,j)]=0,cnt1[id(i,j)]=1;\n        }\n    Fur(i,1,n)\n        Fur(j,1,m){\n            if(fr[i][j])mg(id(i,j),id(i,m-j+1));\n            if(fc[i][j])mg(id(i,j),id(n-i+1,j));\n        }\n    int sum=0;\n    Fur(i,1,n)\n        Fur(j,1,m)\n        if((fr[i][j]||fc[i][j])&&f[id(i,j)]==id(i,j))\n            sum+=min(cnt0[id(i,j)],cnt1[id(i,j)]);\n\n    ans=min(ans,sum);\n}\nvoid dfs2(int cnt,int pre){\n    if(cnt==c+1)return (void)solve();\n    Fur(i,pre+1,m){\n        col[cnt]=i;\n        dfs2(cnt+1,i);\n    }\n}\nvoid dfs(int cnt,int pre){\n    if(cnt==r+1)return (void)dfs2(1,0);\n    Fur(i,pre+1,n){\n        row[cnt]=i;\n        dfs(cnt+1,i);\n    }\n} \nint main(){\n    scanf(\"%d%d%d\",&r,&c,&n);\n    Fur(i,1,n)\n        scanf(\"%s\",ch[i]+1);\n    m=strlen(ch[1]+1);\n    ans=(1<<30);\n    dfs(1,0);\n    printf(\"%d\\n\",ans);\n}\n```\n","link":null,"tags":["搜索","并查集"],"title":"51nod 1316 回文矩阵"},{"categories":[["刷题记录"]],"content":"\n设$f_i$为前$i$个任务的费用,$t_i$为前$i$个任务时间的总和,$w_i$为前$i$个任务费用的总和\n\n$$\nf_i=\\min_{j=0}^{i-1}(f_j+s\\times(w_n-w_j)+t_i\\times(w_i-w_j))\n$$\n\n设任意$0\\le j<k<i$从$j$转移比从$k$转移优,那么\n\n$$\nf_j+s\\times(w_n-w_j)+t_i\\times(w_i-w_j)\n\\le\nf_k+s\\times(w_n-w_k)+t_i\\times(w_i-w_k)\n\\\\\nt_i(w_k-w_j)\\le f_k-f_j+s(w_j-w_k)\n\\\\\nt_i\\le \\frac{f_k-f_j+s(w_j-w_k)}{w_k-w_j}\n$$\n\n维护了个下凸壳交了上去,结果听取$\\color{red}\\text{WA}$声一片\n\n仔细看了看$|T_i|\\le 2^8$\n\n这也就意味着我们每次截取的直线的斜率不再单调递增,单调队列不能再满足需要\n\n为了保证决策状态的有序性,我们还是选择用一个单调栈维护下凸包。\n\n因为决策集合已经有序,对于任意直线,我们只用在队列中二分出使截距最小的交点\n\n由于出题人十分毒瘤,我们要把斜率大小的判断从相除改成十字相乘\n\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\n#define N 300011\n#define int ll\nint s,n,q[N],tp=0;\nll f[N],t[N],w[N];\nbool chk(int i,int j,int I,int J){\n    return (f[j]-f[i]+s*(w[i]-w[j]))*(w[J]-w[I])>(f[J]-f[I]+s*(w[I]-w[J]))*(w[j]-w[i]);\n}\nbool CHK(int i,int j,int v){\n    return f[j]-f[i]+s*(w[i]-w[j])>v*(w[j]-w[i]);\n}\nint solve(int v){\n    int l=0,r=tp-1,ans=-1;\n    while(l<=r){\n        int m=(l+r)>>1;\n        if(CHK(q[m],q[m+1],v))ans=m,r=m-1;\n        else l=m+1;\n    }\n    if(~ans)return q[ans];\n    else return q[tp];\n}\nsigned main(){\n    in(n,s);\n    Fur(i,1,n)\n        in(t[i],w[i]),\n        t[i]+=t[i-1],\n        w[i]+=w[i-1];\n\n    clr(f,0x7f);\n    f[0]=q[0]=0;\n    Fur(i,1,n){\n        int j=solve(t[i]);\n        f[i]=f[j]+s*(w[n]-w[j])+t[i]*(w[i]-w[j]);\n        while(tp&&chk(q[tp-1],q[tp],q[tp],i))--tp;\n        q[++tp]=i;\n    }\n    cout<<f[n]<<endl;\n}\n```\n","link":null,"tags":["动态规划","单调队列","二分查找","斜率优化"],"title":"LG 5785 [SDOI2012]任务安排"},{"categories":[["刷题记录"]],"content":"\n找祖先\ntop: 0\n\n\n\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n\t#pragma GCC optimize(3)\n\t#define il __inline__ __attribute__ ((always_inline))\n\t#define rg register\n\t#define ll long long\n\t#define ull unsigned long long\n\t#define db double\n\t#define sht short\n\t#define MB template <class T>il\n\t#define Fur(i,x,y) for(int i=x;i<=y;i++)\n\t#define Fdr(i,x,y) for(int i=x;i>=y;i--)\n\t#define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n\t#define clr(x,y) memset(x,y,sizeof(x))\n\t#define cpy(x,y) memcpy(x,y,sizeof(x))\n\t#define fin(s) freopen(s\".in\",\"r\",stdin)\n\t#define fout(s) freopen(s\".out\",\"w\",stdout)\n\t#define fcin ios::sync_with_stdio(false)\n\t#define l2(n) (int(log2(n)))\n\t#define inf 0x3f3f3f3f\n\tMB T ABS(T x){return x>0?x:-x;}\n\tMB T MAX(T x,T y){return x>y?x:y;}\n\tMB T MIN(T x,T y){return x<y?x:y;}\n\tMB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n\tMB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){clr(ch,0);if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 10011\n#define mod 1000000007\nint head[N],cnt=0,n,rt,m,sz[N],f[N],ans[N];\nstruct edge{\n\tint to,nxt;\n}e[N*2];\nvoid add(int x,int y){\n\te[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;\n}\nvoid dfs(int x){\n\tsz[x]=1;\n\tfl(i,x)if(to!=f[x])\n\t\tf[to]=x,dfs(to),sz[x]+=sz[to];\n\tans[x]=sz[x]*sz[x]%mod;\n\tfl(i,x)if(to!=f[x])\n\t\tans[x]=(ans[x]-sz[to]*sz[to]+mod)%mod;\n}\nsigned main(){\n\tin>>n>>rt>>m;\n\tint x,y;\n\tFur(i,1,n-1)in>>x>>y,add(x,y),add(y,x);\n\tdfs(rt);\n\twhile(m--)in>>x,out<<ans[x]<<ln;\n}\n```\n","link":null,"tags":[],"title":"LG 5002 专心OI"},{"categories":[["刷题记录"]],"content":"\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i=x;i<=y;i++)\n    #define Fdr(i,x,y) for(int i=x;i>=y;i--)\n    #define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 0x3f3f3f3f\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){clr(ch,0);if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 10001\nint main(){\n\n}\n\n```\n","link":null,"tags":[],"title":"LG 2964 [USACO09NOV]硬币的游戏A-Coin-Game"},{"categories":[["刷题记录"]],"content":"\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i=x;i<=y;++i)\n    #define Fdr(i,x,y) for(int i=x;i>=y;--i)\n    #define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) (int(log2(n)))\n    #define inf 0x3f3f3f3f\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){clr(ch,0);if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 100011\nint n,k,a[N],L[N],R[N];\nset<int>T;\nint main(){\n    fin(\"in\");\n    in>>n>>k;\n    Fur(i,1,n)in>>a[i];\n    int l=0,ans=0,tot=1;\n    Fur(i,1,n){\n        T.insert(a[i]);\n        while(*(--T.end())-*T.begin()>k)T.erase(a[++l]);\n        if(i-l>ans)ans=i-l,tot=1,L[1]=l+1,R[1]=i;\n        else if(i-l==ans)L[++tot]=l+1,R[tot]=i;\n    }\n    out<<ans<<\" \"<<tot<<ln;\n    Fur(i,1,tot)\n        out<<L[i]<<\" \"<<R[i]<<ln;\n}\n\n```\n","link":null,"tags":[],"title":"LG CF6E Exposition"},{"categories":[["刷题记录"]],"content":"\n离散化 建图 最短路\n\n~~烦死了~~\n\n```cpp\n#include <bits\/stdc++.h>\n#define r(x) scanf(\"%d\",&x)\nconst int I=50;\nusing namespace std;\nset<int>s;\nint w,st,p,c;\nint l[I*2],x[I],y[I];\nint d[I*2][I*2];\nint F(int b,int e){\n    if(b==e)return 0;\n    if(s.count(b))return 0x3fffffff;\n    int k=e;\n  for(int i=1;i<=p;i++)\n      if(b<x[i]&&x[i]<k&&(x[i]-b)%st==0)k=x[i];\n  while(k!=e&&s.count(k))k--;\n  if(k==b)return 0x3fffffff;\n  return F(k,e)+(k-b+st-1)\/st;\n}\nint Q(int x) {\n  return lower_bound(l+1,l+c+1,x)-l;\n}\nvoid Floyd(){\n  for(int k=1;k<=c;k++)\n  for(int i=1;i<=c;i++)\n  for(int j=1;j<=c;j++)\n      d[i][j]=min(d[i][j],d[i][k]+d[k][j]);\n}\nint main(){\n  r(w);\n  while(w!=0){\n      r(st);r(p);\n      s.clear();\n      memset(l,0,sizeof l);\n      memset(x,0,sizeof x);\n      memset(y,0,sizeof y);\n      c=0;\n      l[++c]=0;l[++c]=w;\n      for(int i=1;i<=p;i++)\n          r(x[i]),r(y[i]),s.insert(x[i]),l[++c]=x[i],l[++c]=y[i];\n      sort(l+1,l+c+1);\n      c=unique(l+1,l+c+1)-l-1;\n      memset(d,0x3f,sizeof d);\n      for(int i=1;i<=p;i++)\n          d[Q(x[i])][Q(y[i])]=0;\n      for(int i=1;i<c;i++)\n      for(int j=i+1;j<=c;j++)   \n          d[i][j]=min(d[i][j],F(l[i],l[j]));\n      Floyd();\n      cout<<d[1][c]<<endl;\n      r(w);\n  }\n}\n```\n","link":null,"tags":["最短路"],"title":"LG 2620 虫洞"},{"categories":[["刷题记录"]],"content":"\n只用一个矩形的当然很容易求\n\n用两个矩形的话：\n\n先把所有点按$x$坐标排序,提前记录从前数和从后面数的最大的坐标和最小的坐标($x,y$都要)\n\n枚举断开的位置,记录最小值\n\n计算按$y$轴方向断开的方式一样,把$x,y$交换后如法炮制就可以了\n\ntip:\n\n记录坐标最小值时要把坐标初始化为$- \\infty$,要开$long\\ long$,要不然会出锅\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i=x;i<=y;i++)\n    #define Fdr(i,x,y) for(int i=x;i>=y;i--)\n    #define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) (int(log2(n)))\n    \/\/ #define inf 0x3f3f3f3f\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){clr(ch,0);if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 100011\n#define int ll\n#define inf (1ll<<60)\nstruct node{\n    int x,y;\n}a[N];\nil bool cmp(node x,node y){\n    return (x.x==y.x)?(x.y<y.y):(x.x<y.x);\n}\n\nint n,x=inf,X=-inf,y=inf,Y=-inf,a1;\nint xx[N],XX[N],yy[N],YY[N];\nint xxx[N],XXX[N],yyy[N],YYY[N];\nint work(){\n    sort(a+1,a+n+1,cmp);\n    xx[0]=inf,XX[0]=-inf;\n    yy[0]=inf,YY[0]=-inf;\n    Fur(i,1,n){\n        xx[i]=MIN(xx[i-1],a[i].x);\n        yy[i]=MIN(yy[i-1],a[i].y);\n        XX[i]=MAX(XX[i-1],a[i].x);\n        YY[i]=MAX(YY[i-1],a[i].y);\n    }\n    xxx[n+1]=inf,XXX[n+1]=-inf;\n    yyy[n+1]=inf,YYY[n+1]=-inf;\n    Fdr(i,n,1){\n        xxx[i]=MIN(xxx[i+1],a[i].x);\n        yyy[i]=MIN(yyy[i+1],a[i].y);\n        XXX[i]=MAX(XXX[i+1],a[i].x);\n        YYY[i]=MAX(YYY[i+1],a[i].y);\n    }\n    int a2=inf;\n    Fur(i,1,n-1)if(a[i].x!=a[i+1].x)a2=MIN(a2,(XX[i]-xx[i])*(YY[i]-yy[i])+(XXX[i+1]-xxx[i+1])*(YYY[i+1]-yyy[i+1]));\n    return a2;\n}\nsigned main(){\n    in>>n;\n    Fur(i,1,n){\n        in>>a[i].x>>a[i].y;\n        x=MIN(x,a[i].x);\n        y=MIN(y,a[i].y);\n        X=MAX(X,a[i].x);\n        Y=MAX(Y,a[i].y);\n    }\n    a1=(X-x)*(Y-y);\n    int a2=work();\n    Fur(i,1,n)SWAP(a[i].x,a[i].y);\n    a2=MIN(a2,work());\n    a1-=a2;\n    out<<a1<<ln;\n}\n\n```\n","link":null,"tags":["计算几何","枚举","排序"],"title":"LG 3145 [USACO16OPEN]分割田地Splitting-the-Field"},{"categories":[["刷题记录"]],"content":"\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i=x;i<=y;++i)\n    #define Fdr(i,x,y) for(int i=x;i>=y;--i)\n    #define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 0x3f3f3f3f\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){clr(ch,0);if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 100011\nint n,m,b[N];\nint v[N];\nmap<string,int>mp;\nint main(){\n    fcin;\n    cin>>n;\n    string ch;\n    Fur(i,1,n)cin>>ch,mp[ch]=i;\n    cin>>m;\n    int tot=0;\n    Fur(i,1,m){\n        cin>>ch;\n        if(mp.count(ch)){\n            int t=mp[ch];\n            if(!v[t])++tot;\n            v[t]=1;b[i]=t;\n        }\n        else b[i]=0;\n    }\n    out<<tot<<ln;\n    int L=0,s=0,ans=inf;\n    clr(v,0);\n    v[0]=inf;\n    Fur(i,1,m){\n        if(!v[b[i]])++s;\n        ++v[b[i]];\n        if(s==tot){\n            while(s==tot&&L<=i)if(--v[b[++L]]==0)--s;\n            ans=MIN(ans,i-L+1);\n        }\n    }\n    out<<ans<<ln;\n}\n```\n","link":null,"tags":["双指针"],"title":"LG 1381 单词背诵"},{"categories":[["刷题记录"]],"content":"\n$f_{k,i}$:第$i$位,改变$k$次\n\n显然$f_{k,i} = MIN(f_{k-1,j}+res(i,j))$\n\n那这个$res$要怎么求呢？\n\n$res=MAX(a_i,..,a_j)-\\sum_{t=j-1}^i a_t$\n\n\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n\t#pragma GCC optimize(3)\n\t#define il __inline__ __attribute__ ((always_inline))\n\t#define rg register\n\t#define ll long long\n\t#define ull unsigned long long\n\t#define db double\n\t#define sht short\n\t#define MB template <class T>il\n\t#define Fur(i,x,y) for(int i=x;i<=y;i++)\n\t#define Fdr(i,x,y) for(int i=x;i>=y;i--)\n\t#define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n\t#define clr(x,y) memset(x,y,sizeof(x))\n\t#define cpy(x,y) memcpy(x,y,sizeof(x))\n\t#define fin(s) freopen(s\".in\",\"r\",stdin)\n\t#define fout(s) freopen(s\".out\",\"w\",stdout)\n\t#define fcin ios::sync_with_stdio(false)\n\t#define l2(n) (int(log2(n)))\n\t#define inf 0x3f3f3f3f\n\tMB T ABS(T x){return x>0?x:-x;}\n\tMB T MAX(T x,T y){return x>y?x:y;}\n\tMB T MIN(T x,T y){return x<y?x:y;}\n\tMB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n\tMB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 411\n#define int ll\nint n,k,f[N][N],a[N],s[N];\nsigned main(){\n\tin>>n>>k;\n\tclr(f,127);\n\tFur(i,1,n)in>>a[i],s[i]=a[i]+s[i-1];\n\tk++;\n\tf[0][0]=0;\n\tFur(i,1,n)\n\t\tFur(j,1,MIN(k,i)){\n\t\t\tint mx=a[i];\n\t\t\tFdr(t,i-1,0){\n\t\t\t\tf[j][i]=MIN(f[j][i],f[j-1][t]+mx*(i-t)-s[i]+s[t]);\n\t\t\t\tmx=MAX(mx,a[t]);\n\t\t\t}\n\t\t}\n\tint ans=inf;\n\tFur(i,0,k)ans=MIN(ans,f[i][n]);\n\tout<<ans<<ln;\n}\n```\n","link":null,"tags":["动态规划","前缀和"],"title":"LG 5424 [USACO19OPEN]Snakes"},{"categories":[["刷题记录"]],"content":"\ntarjan找出强连通分量之后树形dp\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i=x;i<=y;++i)\n    #define Fdr(i,x,y) for(int i=x;i>=y;--i)\n    #define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){clr(ch,0);if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 151\n#define M 511\nint n,m,f[N][M];\nint W[N],V[N],D[N];\nint cnt=0,head[N];\nstruct edge{\n    int to,nxt;\n}e[N*2];\nvoid add(int x,int y){\n    e[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;\n}\nint dfn[N],low[N],sz=0,tp=0,st[N],bl[N],tt=0,w[N],vv[N];\nbool v[N];\nvoid tarjan(int x){\n    dfn[x]=low[x]=++sz;v[x]=1;\n    st[++tp]=x;\n    fl(i,x)\n    if(!dfn[to])tarjan(to),low[x]=MIN(low[x],low[to]);\n    else if(v[to])low[x]=MIN(low[x],dfn[to]);\n\n    if(low[x]==dfn[x]){\n        ++tt;\n        while(int k=st[tp--]){\n            bl[k]=tt;v[k]=0;\n            w[tt]+=W[k];vv[tt]+=V[k];\n            if(k==x)break;\n        }\n    }\n}\nint ind[N];\nvoid sol(int x){\n    Fur(i,w[x],m)f[x][i]=vv[x];\n    fl(i,x){\n        sol(to);\n        int k=m-w[x];\n        Fdr(i,k,0)\n            Fur(j,0,i)\n            f[x][i+w[x]]=MAX(f[x][i+w[x]],f[to][j]+f[x][i+w[x]-j]);\n    }\n}\nint main(){\n    fin(\"in\");\n    in>>n>>m;\n    Fur(i,1,n)in>>W[i];\n    Fur(i,1,n)in>>V[i];\n    Fur(i,1,n){\n        in>>D[i];\n        if(D[i])add(D[i],i);\n    }\n    Fur(i,1,n)if(!dfn[i])tarjan(i);\n    clr(head,0);cnt=0;\n    Fur(i,1,n)\n    if(bl[D[i]]!=bl[i]){\n        add(bl[D[i]],bl[i]);\n        \/\/ out<<bl[D[i]]<<\" \"<<bl[i]<<ln;\n        ind[bl[i]]++;\n    }\n    Fur(i,1,n)if(!ind[i])add(0,i);\n    sol(0);\n    out<<f[0][m]<<ln;\n}\n```\n","link":null,"tags":["tarjan","树形dp","动态规划"],"title":"LG 2515 [HAOI2010]软件安装"},{"categories":[["刷题记录"]],"content":"\n$n\\le 100$,每个点都只能经过一次\n\n当然直接dfs了\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;rg char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\n#define N 111\nint n,a[N][N],sx,sy;\nbool v[N][N];\nint dx[4]={0,1,0,-1},dy[4]={1,0,-1,0},ans=0;\nvoid dfs(int x,int y,int d){\n    ans=MAX(ans,d);\n    v[x][y]=1;\n    Fur(i,0,3){\n        int nx=x+dx[i],ny=y+dy[i],t=1;\n        while(1<=nx&&nx<=n&&1<=ny&&ny<=n){\n            if(a[nx][ny])nx+=dx[i],ny+=dy[i],++t;\n            else{\n                if(t>1&&!v[nx][ny])dfs(nx,ny,d+t);\n                break;\n            }            \n        }\n    }\n    v[x][y]=0;\n}\nint main(){\n    in(n,sx,sy);\n    Fur(i,1,n)\n        Fur(j,1,n)\n        in(a[i][j]);\n\n    dfs(sx,sy,0);\n    printf(\"%d\\n\",ans);\n}\n```\n","link":null,"tags":["dfs"],"title":"LG 3848 [TJOI2007]跳棋"},{"categories":[["刷题记录"]],"content":"\n$cnt$数组记录每种数字出现的次数\n\n我们只需要考虑$add(x),del(x)$,其他的交给莫队\n\n我们考虑当前数原本的答案是$a_x \\times cnt_x^2$\n\n现在变成$a_x \\times (cnt_x+1)^2$\n\n设$cnt_x =y$\n\n$(y+1)^2  = y^2 + 2y +1$\n\n所以更新的时候$ans +=  a_x \\times (cnt_x \\times 2 + 1)$\n\n\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;rg char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\n#define N 200011\nint n,Q,a[N],sz;\nstruct que{\n    int l,r,id;\n}q[N];\nil int bl(int x){return (x-1)\/sz+1;}\nil bool cmp(que x,que y){\n    if(bl(x.l)==bl(y.l))return x.r<y.r;\n    else return x.l<y.l;\n}\nint cnt[1000001];\nll ans=0,ANS[N];\nil void add(int x){\n    ans+=1ll*a[x]*(cnt[a[x]]<<1|1);\n    ++cnt[a[x]];\n}\nil void del(int x){\n    ans-=1ll*a[x]*(cnt[a[x]]*2-1);\n    --cnt[a[x]];\n}\nint main(){\n    in(n,Q);\n    sz=sqrt(n);\n    Fur(i,1,n)in(a[i]);\n    Fur(i,1,Q)in(q[i].l,q[i].r),q[i].id=i;\n    sort(q+1,q+Q+1,cmp);\n    int l=0,r=0;\n    Fur(i,1,Q){\n        Fur(j,l,q[i].l-1)del(j);\n        Fur(j,r+1,q[i].r)add(j);\n        Fdr(j,l-1,q[i].l)add(j);\n        Fdr(j,r,q[i].r+1)del(j);\n        ANS[q[i].id]=ans;\n        l=q[i].l;r=q[i].r;\n    }\n    Fur(i,1,Q)out(ANS[i],ln);\n    flush();\n}\n```\n","link":null,"tags":["莫队"],"title":"LG CF86D Powerful-array"},{"categories":[["刷题记录"]],"content":"\n一段区间检查后能不被吃掉的汉堡满足**其他汉堡的能量值都是它的倍数**。\n\n那我们就求出区间$\\gcd$. 而这个汉堡的能量值必须等于区间$gcd$,所以它的能量值也是区间最小值。\n\n那我们就再记录区间最小值并且记录数量\n\n那么满足这个复杂度而且最方便的当然是线段树了\n\n\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i=x;i<=y;++i)\n    #define Fdr(i,x,y) for(int i=x;i>=y;--i)\n    #define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) (int(log2(n)))\n    #define inf 0x3f3f3f3f\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){clr(ch,0);if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 100001\n#define ls rt<<1\n#define rs rt<<1|1\nint n;\nstruct node{\n\tint s,g,t;\n}s[N<<2];\nnode operator + (node x,node y){\n\tnode c;\n\tc.g=MIN(x.g,y.g);\n\tc.s=GCD(x.s,y.s);\n\tif(x.g==y.g)c.t=x.t+y.t;\n\telse c.t=(x.g<y.g)?x.t:y.t;\n\tif(c.s!=c.g)c.t=0;\n\treturn c;\n}\nvoid build(int l,int r,int rt){\n\tif(l==r){\n\t\tin>>s[rt].s;s[rt].g=s[rt].s;s[rt].t=1;\n\t\treturn;\n\t}\n\tint m=(l+r)>>1;\n\tbuild(l,m,ls);\n\tbuild(m+1,r,rs);\n\ts[rt]=s[ls]+s[rs];\n}\nnode ask(int L,int R,int l,int r,int rt){\n\tif(L<=l&&r<=R)return s[rt];\n\tint m=(l+r)>>1;\n\tnode c;\n\tif(L>m)return ask(L,R,m+1,r,rs);\n\telse if(R<=m)return ask(L,R,l,m,ls);\n\treturn ask(L,R,l,m,ls)+ask(L,R,m+1,r,rs);\n}\nint main(){\n\tfin(\"in\");\n\tin>>n;\n\tbuild(1,n,1);\n\tint q;in>>q;\n\twhile(q--){\n\t\tint x,y;\n\t\tin>>x>>y;\n\t\tout<<y-x+1-ask(x,y,1,n,1).t<<ln;\n\t}\n}\n\n```\n","link":null,"tags":["线段树","gcd"],"title":"51nod 1793 吃汉堡"},{"categories":[["刷题记录"]],"content":"\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i=x;i<=y;++i)\n    #define Fdr(i,x,y) for(int i=x;i>=y;--i)\n    #define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 0x3f3f3f3f\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){clr(ch,0);if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 100011\n#define int ll\n#define ls rt<<1\n#define rs rt<<1|1\nint n,m,s[N<<2],S[N<<2];\nvoid pu(int rt,int ln,int rn){\n    s[rt]=s[ls]+s[rs];\n    S[rt]=S[rs]+s[ls]*rn+S[ls];\n}\nvoid build(int l,int r,int rt){\n    if(l==r){\n        in>>s[rt];\n        S[rt]=s[rt];\n        return;\n    }\n    int m=(l+r)>>1;\n    build(l,m,ls);build(m+1,r,rs);\n    pu(rt,m-l+1,r-m);\n}\nvoid upd(int x,int v,int l,int r,int rt){\n    if(l==r){\n        s[rt]=S[rt]=v;\n        return;\n    }\n    int m=(l+r)>>1;\n    if(x<=m)upd(x,v,l,m,ls);\n    else upd(x,v,m+1,r,rs);\n    pu(rt,m-l+1,r-m);\n}\nstruct node{\n    int s,S;\n};\nnode ask(int R,int l,int r,int rt){\n    if(r<=R)return node{s[rt],S[rt]};\n    int m=(l+r)>>1;\n    if(R<=m)return ask(R,l,m,ls);\n    node a=ask(R,l,m,ls),b=ask(R,m+1,r,rs);\n    return node{a.s+b.s,b.S+a.s*(R-m)+a.S};\n}\nsigned main(){\n    fin(\"in\");\n    in>>n>>m;\n    build(1,n,1);\n    char ch[10];int x,v;\n    while(m--){\n        in>>ch>>x;\n        if(ch[0]=='Q')out<<ask(x,1,n,1).S<<ln;\n        else in>>v,upd(x,v,1,n,1);\n    }\n}\n```\n","link":null,"tags":["线段树","树状数组"],"title":"LG 4868 Preprefix sum"},{"categories":[["刷题记录"]],"content":"\n集合hash\n\n1. 两个点不认识\n\n   两个点是相似关系说明他们的所有朋友都相同,可以把一个点的朋友当成集合$hash$一下,然后就可以统计了\n\n2. 两个点认识\n\n   两个点是相似关系说明他们的所有朋友加上对方都相同,可以把一个点的朋友加上它自己当成集合$hash$一下,然后就可以统计了\n\n\n\n\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i=x;i<=y;i++)\n    #define Fdr(i,x,y) for(int i=x;i>=y;i--)\n    #define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) (int(log2(n)))\n    #define inf 0x3f3f3f3f\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){clr(ch,0);if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 1000001\nint n,m;\nstruct node{\n\tull v;\n\tint id;\n}s[N];\nbool cmp(node x,node y){\n\treturn x.v<y.v;\n}\nint main(){\n\tfin(\"in\");\n\tin>>n>>m;\n\tint x,y;\n\tull ans=0;\n\tFur(i,1,n)s[i].id=i;\n\tFur(i,1,m){\n\t\tin>>x>>y;\n\t\ts[x].v+=1ull*y*y*y;\n\t\ts[y].v+=1ull*x*x*x;\n\t}\n\tsort(s+1,s+n+1,cmp);\n\ty=0;\n\tFur(i,1,n){\n\t\tif(s[i].v!=s[i-1].v)y=0;\n\t\ty++;\n\t\tans+=y-1;\n\t}\n\tFur(i,1,n)s[i].v+=1ull*s[i].id*s[i].id*s[i].id;\n\tsort(s+1,s+n+1,cmp);\n\tFur(i,1,n){\n\t\tif(s[i].v!=s[i-1].v)y=0;\n\t\ty++;\n\t\tans+=y-1;\n\t}\n\tout<<ans<<ln;\n}\n\n```\n","link":null,"tags":["hash"],"title":"51nod 1761 相似关系"},{"categories":[["刷题记录"]],"content":"\n```cpp\n#include<stdio.h>\n#include<string.h>\n#define clr(x,y) memset(x,y,sizeof(x))\n#define Fur(i,x,y) for(int i=x;i<=y;i++)\n#define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\nint MAX(int x,int y){return x>y?x:y;}\n#define SWAP(A, B)   \\\n    {                \\\n        int __T = A; \\\n        A = B;       \\\n        B = __T;     \\\n    }\n#define N 20011\n#define ls rt<<1\n#define rs rt<<1|1\n#define pu s[rt]=MAX(s[ls],s[rs])\nint head[N],n,sz=0,cnt=0;\nint top[N],d[N],f[N],siz[N],id[N],val[N],a[N],s[N<<2];\nstruct edge{\n    int to,nxt,w;\n}e[N*2];\nvoid add(int x,int y,int w){\n    e[++cnt].to=y;e[cnt].w=w;e[cnt].nxt=head[x];head[x]=cnt;\n}\nvoid dfs(int x){\n    siz[x]=1;\n    fl(i,x)if(to!=f[x]){\n        f[to]=x;d[to]=d[x]+1;val[to]=e[i].w;\n        dfs(to);siz[x]+=siz[to];\n    }\n}\nvoid bt(int x,int tp){\n    top[x]=tp;a[id[x]=++sz]=val[x];\n    int k=0;\n    fl(i,x)if(to!=f[x]&&siz[to]>siz[k])k=to;\n    if(!k)return;bt(k,tp);\n    fl(i,x)if(!top[to])bt(to,to);\n}\nvoid build(int l,int r,int rt){\n    if(l==r){\n        s[rt]=a[l];\n        return;\n    }\n    int m=(l+r)>>1;\n    build(l,m,ls);build(m+1,r,rs);\n    pu;\n}\nint ask(int L,int R,int l,int r,int rt){\n    if(L<=l&&r<=R)return s[rt];\n    int m=(l+r)>>1,ans=0;\n    if(L<=m)ans=ask(L,R,l,m,ls);\n    if(R>m)ans=MAX(ans,ask(L,R,m+1,r,rs));\n    return ans;\n}\nvoid upd(int x,int v,int l,int r,int rt){\n    if(l==r){\n        s[rt]=v;\n        return;\n    }\n    int m=(l+r)>>1;\n    if(x<=m)upd(x,v,l,m,ls);\n    else upd(x,v,m+1,r,rs);\n    pu;\n}\nint fh(int x,int y){\n    int ans=0;\n    while(top[x]!=top[y]){\n        if(d[top[x]]<d[top[y]]){SWAP(x,y);}\n        ans=MAX(ans,ask(id[top[x]],id[x],1,n,1));\n        x=f[top[x]];\n    }\n    if(id[x]>id[y])SWAP(x,y);\n    return MAX(ans,ask(id[x]+1,id[y],1,n,1));\n}\nint main(){\nint T;scanf(\"%d\",&T);\nwhile(T--){\n    scanf(\"%d\",&n);\n    int x,y,w;\n    char ch[20];\n    cnt=sz=0;\n    clr(head,0);clr(s,0);clr(f,0);clr(a,0);clr(top,0);clr(d,0);\n    Fur(i,1,n-1)scanf(\"%d%d%d\",&x,&y,&w),add(x,y,w),add(y,x,w);\n    dfs(1);bt(1,1);build(1,n,1);\n    while(1){\n        scanf(\"%s\",ch);\n        if(ch[0]=='D')break;\n        scanf(\"%d%d\",&x,&y);\n        if(ch[0]=='C'){\n            x*=2;\n            x=(d[e[x].to]>d[e[x-1].to])?e[x].to:e[x-1].to;\n            upd(id[x],y,1,n,1);\n        }\n        else printf(\"%d\\n\",fh(x,y));\n    }\n}\n}\n\n```\n","link":null,"tags":[],"title":"LG SP375 Query on a tree"},{"categories":[["刷题记录"]],"content":"\n两点之间距离为$MAX(|x-x'|,|y-y'|)$\n\n这种距离好像叫做切比雪夫距离\n\n> 套路：\n>\n> 将一个点 $\\color{Blue}{(x,y)(x,y)}$ 的坐标变为 $\\color{Blue}{(x+y,x-y)(x+y,x−y)}$后,原坐标系中的曼哈顿距离 = 新坐标系中的切比雪夫距离\n> \n> 那么：\n> 将一个点 $\\color{Blue}{(x,y)(x,y)}$ 的坐标变为 $\\color{Blue}{(\\frac{x+y}{2},\\frac{x-y}{2})}$后,原坐标系中的切比雪夫距离 = 新坐标系中的曼哈顿距离!\n\n假设当前所有松鼠来$x$\n\n设$\\Delta X(a,b) = |a_x - b_x| , \\Delta Y(a,b) = |a_y-b_y|$\n\n$$\nans =\\sum_{i=1}^n d(i,x)\n\\\\\\\\\n= \\sum_{i=1}^n\\Delta X(i,x) + \\sum_{i=1}^n \\Delta Y(i,x)\n\n$$\n\n假定$x$,和$y$都是有序的。\n\n那是不是可以用前缀和呢？\n\n$lowerbound$一下,前后反过来就可以了\n\n最后:记得加 $\\color{red}{long\\ long}$ !\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n\t#pragma GCC optimize(3)\n\t#define il __inline__ __attribute__ ((always_inline))\n\t#define rg register\n\t#define ll long long\n\t#define ull unsigned long long\n\t#define db double\n\t#define sht short\n\t#define MB template <class T>il\n\t#define Fur(i,x,y) for(int i=x;i<=y;i++)\n\t#define Fdr(i,x,y) for(int i=x;i>=y;i--)\n\t#define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n\t#define clr(x,y) memset(x,y,sizeof(x))\n\t#define cpy(x,y) memcpy(x,y,sizeof(x))\n\t#define fin(s) freopen(s\".in\",\"r\",stdin)\n\t#define fout(s) freopen(s\".out\",\"w\",stdout)\n\t#define fcin ios::sync_with_stdio(false)\n\t#define l2(n) (int(log2(n)))\n\t#define inf 0x3f3f3f3f\n\tMB T ABS(T x){return x>0?x:-x;}\n\tMB T MAX(T x,T y){return x>y?x:y;}\n\tMB T MIN(T x,T y){return x<y?x:y;}\n\tMB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n\tMB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 100011\nstruct node{\n\tint x,y;\n}a[N];\nint x[N],y[N],n;\nll sx[N],sy[N];\nint main(){\n\tin>>n;\n\tint p,q;\n\tFur(i,1,n){\n\t\tin>>p>>q;\n\t\tx[i]=a[i].x=p+q;\n\t\ty[i]=a[i].y=p-q;\n\t}\n\tsort(x+1,x+n+1);\n\tsort(y+1,y+n+1);\n\tFur(i,1,n)\n\t\tsx[i]=sx[i-1]+x[i],\n\t\tsy[i]=sy[i-1]+y[i];\n\tll ans=1ll<<62,res;\n\tFur(i,1,n){\n\t\tres=0;\n\t\tint p=lower_bound(x+1,x+n+1,a[i].x)-x;\n\t\tres+=sx[n]-sx[p]-1ll*a[i].x*(n-p)+1ll*a[i].x*p-sx[p];\n\t\t\n\t\tp=lower_bound(y+1,y+n+1,a[i].y)-y;\n\t\tres+=sy[n]-sy[p]-1ll*a[i].y*(n-p)+1ll*a[i].y*p-sy[p];\n\t\t\n\t\tans=MIN(ans,res);\n\t}\n\tout<<(ll)(ans\/2ll)<<ln;\n}\n```\n","link":null,"tags":["枚举","前缀和"],"title":"LG 3964 [TJOI2013]松鼠聚会"},{"categories":[["刷题记录"]],"content":"\n那个只要有\n10000……\n11000……\n……\n就可以一直搞下去\n直到为0\n\n但是也有特殊情况：\n\n比如$k \\le 4$\n\n不过这种情况特判和dfs都可以解决\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i=x;i<=y;i++)\n    #define Fdr(i,x,y) for(int i=x;i>=y;i--)\n    #define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) (int(log2(n)))\n    #define inf 0x3f3f3f3f\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\n#define N 10001\nll l,r;\nint k;\nvoid work(){\n\tll t=1ll<<l2(l);\n\tif(r>=(t+(t<<1)))cout<<0;\n\telse cout<<1;\n}\nll ans;\nvoid dfs(ll x,ll y){\n\tif(x>r){\n\t\tans=MIN(ans,y);\n\t\treturn;\n\t}\n\tdfs(x+1,y);dfs(x+1,y^x);\n}\nint main(){\n\tcin>>l>>r>>k;\n\tif(k==1)return cout<<l,0;\n\tif(k==2){\n\t\tif(r-l<=1)cout<<MIN(l,l^r);\n\t\telse cout<<1;\n\t\treturn 0;\n\t}\n\tif(k==3)work();\n\tif(k>3){\n\t\tif(r-l+1==4){\n\t\t\tans=1;\n\t\t\tdfs(l+1,l);\n\t\t\tdfs(l+2,l+1);\n\t\t\tdfs(l+3,l+2);\n\t\t\tdfs(l+4,l+3);\n\t\t\tcout<<ans;\n\t\t}\n\t\telse cout<<0;\n\t}\n\t\n}\n\n```\n","link":null,"tags":["位运算"],"title":"51nod 1496 最小异或和"},{"categories":[["刷题记录"]],"content":"\n```cpp\n#include<bits\/stdc++.h>\nusing namespace std;\n#define N 10011\nint n;\nint main(){\n\tdouble ans=0,t=0,x;\n\tscanf(\"%d\",&n);\n\twhile(n--){\n\t\tscanf(\"%lf\",&x);\n\t\tans=ans+x*(2*t+1);\n\t\tt=(t+1)*x;\n\t}\n\tprintf(\"%.10f\\n\", ans);\n}\n```\n","link":null,"tags":["期望"],"title":"LG CF235B Lets-Play-Osu"},{"categories":[["刷题记录"]],"content":"\n直接bfs\n\n\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n\t#pragma GCC optimize(3)\n\t#define il __inline__ __attribute__ ((always_inline))\n\t#define rg register\n\t#define ll long long\n\t#define ull unsigned long long\n\t#define db double\n\t#define sht short\n\t#define MB template <class T>il\n\t#define Fur(i,x,y) for(int i=x;i<=y;i++)\n\t#define Fdr(i,x,y) for(int i=x;i>=y;i--)\n\t#define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n\t#define clr(x,y) memset(x,y,sizeof(x))\n\t#define cpy(x,y) memcpy(x,y,sizeof(x))\n\t#define fin(s) freopen(s\".in\",\"r\",stdin)\n\t#define fout(s) freopen(s\".out\",\"w\",stdout)\n\t#define fcin ios::sync_with_stdio(false)\n\t#define l2(n) (int(log2(n)))\n\t#define inf 0x3f3f3f3f\n\tMB T ABS(T x){return x>0?x:-x;}\n\tMB T MAX(T x,T y){return x>y?x:y;}\n\tMB T MIN(T x,T y){return x<y?x:y;}\n\tMB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n\tMB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 10011\nint n,m;\nvoid bfs(){\n\t\n}\nint main(){\n\t\n}\n```\n","link":null,"tags":["bfs","技巧"],"title":"LG 1039 侦探推理"},{"categories":[["刷题记录"]],"content":"\n左右都$hash$一遍\n\n然后二分每个位置可以组成回文串的长度(判断奇数和偶数长度)\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i=x;i<=y;i++)\n    #define Fdr(i,x,y) for(int i=x;i>=y;i--)\n    #define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) (int(log2(n)))\n    #define inf 0x3f3f3f3f\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){clr(ch,0);if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 1001\nchar s[N];\null h1[N],h2[N],p[N],ans=0;\nint n;\null gh1(int l,int r){\n\treturn h1[r]-h1[l-1]*p[r-l+1];\n}\null gh2(int l,int r){\n\treturn h2[l]-h2[r+1]*p[r-l+1];\n}\null a1(int x){\n\tint l=1,r=MIN(x,n-x);\n\twhile(l<=r){\n\t\tint m=(l+r)>>1;\n\t\tif(gh1(x-m,x+m)==gh2(x-m,x+m))\n\t\t\tl=m+1;\n\t\telse r=m-1;\n\t}\n\treturn r;\n}\null a2(int x){\n\tint l=1,r=MIN(x,n-x);\n\twhile(l<=r){\n\t\tint m=(l+r)>>1;\n\t\tif(gh1(x-m+1,x+m)==gh2(x-m+1,x+m))\n\t\t\tl=m+1;\n\t\telse r=m-1;\n\t}\n\treturn r;\n}\n#define base 233\nint main(){\n\tin>>(s+1);\n\tp[0]=1;\n\tn=strlen(s+1);\n\tFur(i,1,n){\n\t\th1[i]=h1[i-1]*base+s[i];\n\t\tp[i]=p[i-1]*base;\n\t}\n\tFdr(i,n,1)\n\t\th2[i]=h2[i+1]*base+s[i];\n\t\t\n\tFur(i,1,n)ans+=a1(i)+a2(i);\n\tout<<ans+n<<ln;\n}\n\n```\n","link":null,"tags":["hash","二分"],"title":"LG SP7586 NUMOFPAL - Number of Palindromes"},{"categories":[["刷题记录"]],"content":"\n区间dp\n\n显然设$f[i][j]$表示$[i,j]$最小的表示方法\n\n普通情况: \n\n$f[i][j] = \\min(f[i][k]+f[k+1][j])$\n\n当我们找到循环节：\n\n$f[i][j] = \\min(f[i][j],f[i][k] + 2 + \\text{<循环节个数>})$\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i=x;i<=y;++i)\n    #define Fdr(i,x,y) for(int i=x;i>=y;--i)\n    #define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){clr(ch,0);if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 111\n#define base 1331\nint n,f[N][N];\nchar s[N];\null h[N],pw[N];\null get(int l,int r){\n    return h[r]-h[l-1]*pw[r-l+1];\n}\nbool chk(int x,int y,int a,int b){\n    int p=y-x+1,q=b-a+1;\n    Fur(i,1,q\/p)\n        if(get(x,y)!=get(a+p*(i-1),a+p*i-1))return 0;\n    return 1;\n}\nint le(int x){\n    int t=0;\n    while(x)++t,x\/=10;\n    return t;\n}\nint main(){\n    in>>(s+1);\n    n=strlen(s+1);\n    pw[0]=1;Fur(i,1,n)h[i]=h[i-1]*base+s[i],pw[i]=pw[i-1]*base;\n    clr(f,126);\n    Fur(i,1,n)f[i][i]=1;\n    Fur(i,2,n)\n        Fur(l,1,n-i+1){\n            int r=l+i-1;\n            f[l][r]=r-l+1;\n            Fur(x,l,r-1){\n                f[l][r]=MIN(f[l][r],f[l][x]+f[x+1][r]);\n                if((r-x)%(x-l+1)==0){\n                    if(chk(l,x,x+1,r))\n                    f[l][r]=MIN(f[l][r],f[l][x]+2+le((r-l+1)\/(x-l+1)));\n                }\n            }\n        }\n    out<<f[1][n]<<ln;\n}\n```\n","link":null,"tags":["区间dp","动态规划"],"title":"LG 4302 [SCOI2003]字符串折叠"},{"categories":[["刷题记录"]],"content":"\n先预处理出所有幸运数字\n\n当前要求的是$[l,r]$中的幸运数字\n\n我们可以使用容斥,用$[1,r]-[1,l-1]$\n\n假设当前幸运数字为$x$,$[l,r]$中是$x$的倍数的有$\\left \\lfloor \\frac rx \\right \\rfloor - \\left \\lfloor \\frac lx \\right \\rfloor +1$\n\n$[1,r],[1,l-1]$中的幸运数字的倍数可能有交集\n\n继续容斥:\n\n选1个-选2个的lcm+选3个的lcm-...\n\n剪枝：\n\n1. 可以发现,一个数是另一个合法倍数的倍数,那么这个数字相当于没用(因为被前面的统计过了),可以删掉\n\n2. 如果将幸运数字从大到小排序,搜索时可以更快突破边界\n\n3. 现在因为所有数都不满足是另外一个数的倍数,所以合并任意两个数的时候,$lcm$的最小情况就是乘上一个$3$。\n   \n   所以对于所有$>r\/3$的合法数字,显然不能够和任何一个数合并了,所以这一部分可以拿出来直接提前算好\n\n剩下的直接暴搜\n```cpp\n#include<bits\/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define N 100011\nint tot=0,t=0;\nll ans=0,l,r,a[N];\nbool v[N];\ninline void init(){\n    int h=0;\n    while(h<=tot){\n        ll x=a[h++]*10;\n        if(x+6<=r)a[++tot]=x+6;\n        if(x+8<=r)a[++tot]=x+8;\n    }\n}\nconst int mod=1000000007;\ninline bool chk(ll a,ll b){\n    int A=a\/mod,B=b\/mod;\n    if(A*B)return 1;\n    return a*b>r;\n}\nvoid calc(int x,ll s,int k){\n    if(x>tot){\n        if(s!=1){\n            if(k&1)ans+=r\/s-l\/s;\n            else ans-=r\/s-l\/s;\n        }\n        return;\n    }\n    calc(x+1,s,k);\n    ll d=a[x]\/__gcd(s,a[x]);\n    if(!chk(s,d))calc(x+1,s*d,k+1);\n}\ninline void work(){\n    sort(a+1,a+tot+1);\n    for(int i=1;i<=tot;++i)\n        for(int j=1;j<i;++j)\n        if(a[i]%a[j]==0){v[i]=1;break;}\n    \n    for(int i=1;i<=tot;++i)\n    if(!v[i]){\n        if(a[i]<=r\/3)a[++t]=a[i];\n        else ans+=r\/a[i]-l\/a[i];\n    }\n    tot=t;\n    reverse(a+1,a+tot+1);\n    calc(1,1,0);\n    printf(\"%lld\\n\",ans);\n}\nint main(){\n    cin>>l>>r;\n    --l;\n    init();\/\/找出所有\"幸运号码\"\n    work();\n}\n```\n","link":null,"tags":["容斥","dfs","剪枝"],"title":"LG 2567 [SCOI2010]幸运数字"},{"categories":[["刷题记录"]],"content":"\n动态规划\n\n逆向思维\n\n用所有的减去不合法的\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i=x;i<=y;i++)\n    #define Fdr(i,x,y) for(int i=x;i>=y;i--)\n    #define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) (int(log2(n)))\n    #define inf 0x3f3f3f3f\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){clr(ch,0);if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 1000001\n#define mod 1000000007\nll n,m,k,f[N],sum,ans=1;\nint main(){\n\tfin(\"in\");\n\tin>>n>>m>>k;\n\tFur(i,1,n)ans=ans*m%mod;\n\tf[0]=1;\n\tFur(i,1,k-1)\n\t\tf[i]=f[i-1]*m%mod,\n\t\tsum=(sum+f[i])%mod;\n\t\n\tFur(i,k,n)\n\t\tf[i]=sum*(m-1)%mod,\n\t\tsum=(sum+f[i]-f[i-k+1])%mod;\n\t\n\tout<<(ans-f[n]+mod)%mod<<ln;\n}\n\n```\n","link":null,"tags":["动态规划"],"title":"LG 4187 [USACO18JAN]Stamp Painting"},{"categories":[["刷题记录"]],"content":"\n$$\n\\frac{1}{n}\\sum_{i=1}^{n}(a_i-\\bar a)^2\n\n\\\\\\\\\n\n= \\frac 1n \\sum_{i=1}^{n}(a_i^2-2\\bar a\\times a_i+{\\bar a}^2)\n\n\\\\\\\\\n\n= \\frac 1n (\\sum_{i=1}^na_i^2 - 2\\bar a\\sum_{i=1}^n a_i + n \\bar a^2)\n\n\\\\\\\\\n\n= \\frac 1n \\sum_{i=1}^n a_i^2 - \\bar a^2\n$$\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n\t#pragma GCC optimize(3)\n\t#define il __inline__ __attribute__ ((always_inline))\n\t#define rg register\n\t#define ll long long\n\t#define ull unsigned long long\n\t#define db double\n\t#define sht short\n\t#define MB template <class T>il\n\t#define Fur(i,x,y) for(int i=x;i<=y;i++)\n\t#define Fdr(i,x,y) for(int i=x;i>=y;i--)\n\t#define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n\t#define clr(x,y) memset(x,y,sizeof(x))\n\t#define cpy(x,y) memcpy(x,y,sizeof(x))\n\t#define fin(s) freopen(s\".in\",\"r\",stdin)\n\t#define fout(s) freopen(s\".out\",\"w\",stdout)\n\t#define fcin ios::sync_with_stdio(false)\n\t#define l2(n) (int(log2(n)))\n\t#define inf 0x3f3f3f3f\n\tMB T ABS(T x){return x>0?x:-x;}\n\tMB T MAX(T x,T y){return x>y?x:y;}\n\tMB T MIN(T x,T y){return x<y?x:y;}\n\tMB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n\tMB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 100011\n#define int ll\n#define mod 1000000007\n#define ls rt<<1\n#define rs rt<<1|1\n#define pu s[rt]=(s[ls]+s[rs])%mod,g[rt]=(g[ls]+g[rs])%mod\nint n,q,s[N<<2],g[N<<2];\nvoid build(int l,int r,int rt){\n\tif(l==r){\n\t\tin>>s[rt];g[rt]=(s[rt]*s[rt])%mod;\n\t\treturn;\n\t}\n\tint m=(l+r)>>1;\n\tbuild(l,m,ls);build(m+1,r,rs);\n\tpu;\n}\nvoid upd(int x,int c,int l,int r,int rt){\n\tif(l==r){\n\t\tc%=mod;\n\t\ts[rt]=c;g[rt]=(c*c)%mod;\n\t\treturn;\n\t}\n\tint m=(l+r)>>1;\n\tif(x<=m)upd(x,c,l,m,ls);\n\telse upd(x,c,m+1,r,rs);\n\tpu;\n}\nint rev(int x){\n\tint ans=1,p=mod-2;\n\twhile(p){\n\t\tif(p&1)ans=(ans*x)%mod;\n\t\tx=(x*x)%mod;\n\t\tp>>=1;\n\t}\n\treturn ans;\n}\nint ask(int L,int R,int v,int l=1,int r=n,int rt=1){\n\tif(L<=l&&r<=R)return (v?g[rt]:s[rt])%mod;\n\tint m=(l+r)>>1,ans=0;\n\tif(L<=m)ans=ask(L,R,v,l,m,ls);\n\tif(R>m)ans+=ask(L,R,v,m+1,r,rs);\n\treturn ans%mod;\n}\nsigned main(){\n\tin>>n>>q;\n\tbuild(1,n,1);\n\tint u,x,y;\n\twhile(q--){\n\t\tin>>u>>x>>y;\n\t\tif(u==1)upd(x,y,1,n,1);\n\t\telse{\n\t\t\tint a=ask(x,y,0),A=ask(x,y,1),inv=rev(y-x+1);\n\t\t\ta=1ll*a*inv%mod;a=1ll*a*a%mod;\n\t\t\tout<<((1ll*A*inv%mod+mod)%mod-a+mod)%mod<<ln;\n\t\t}\n\t}\n}\n```\n","link":null,"tags":["线段树","数论"],"title":"LG 5142 区间方差"},{"categories":[["刷题记录"]],"content":"\n先把所有0合成1个,所有正数合成一个,把负数(除了最大的那个负数之外的(如果负数个数为奇数)))合成一个\n\n1.如果全是0\n\n2.没有0\n\n3.没有负数\n\n4.没有正数\n```cpp\n#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <cstdio>\n#include <cmath>\nusing namespace std;\nint cnt,cnt1,cnt2,n,x;\nstruct ahah\n{\n    int x,pos;\n} a[200006],b[200006],c[200006];\nbool cmp(ahah a,ahah b){ return abs(a.x)<abs(b.x); }\nint main()\n{\n    scanf(\"%d\",&n);\n    for(int i=1; i<=n; i++)\n    {\n        scanf(\"%d\",&x);\n        if(x==0)c[++cnt].pos=i;\n        if(x<0)a[++cnt1].x=x,a[cnt1].pos=i;\n        if(x>0)b[++cnt2].x=x,b[cnt2].pos=i;\n    }\n    sort(a+1,a+1+cnt1,cmp);\n    sort(b+1,b+1+cnt2,cmp);\n    int v=-1;\n    if(cnt!=0)\n    {\n        v=c[1].pos;\n        for(int i=2; i<=cnt; i++)\n        {\n            printf(\"1 %d %d\\n\",v,c[i].pos);\n            v=c[i].pos;\n        }\n    }\n    if(cnt==n)return 0;\n    if(cnt1%2==0)\n    {\n        if(v!=-1)printf(\"2 %d\\n\",v),v=-1;\n        if(cnt1!=0)\n        {\n            if(v==-1)v=a[1].pos;\n            else printf(\"1 %d %d\\n\",v,a[1].pos),v=a[1].pos;\n            for(int i=2; i<=cnt1; i++)\n            {\n                printf(\"1 %d %d\\n\",v,a[i].pos);\n                v=a[i].pos;\n            }\n        }\n        if(cnt2!=0)\n        {\n            if(v==-1)v=b[1].pos;\n            else printf(\"1 %d %d\\n\",v,b[1].pos),v=b[1].pos;\n            for(int i=2; i<=cnt2; i++)\n            {\n                printf(\"1 %d %d\\n\",v,b[i].pos);\n                v=b[i].pos;\n            }\n        }\n    }\n    else\n    {\n        if(v==-1)v=a[1].pos;\n        else printf(\"1 %d %d\\n\",v,a[1].pos),v=a[1].pos;\n        if(cnt+1!=n)printf(\"2 %d\\n\",v),v=-1;\n        else return 0;\n        if(cnt1>1)\n        {\n            v=a[2].pos;\n            for(int i=3; i<=cnt1; i++)\n            {\n                printf(\"1 %d %d\\n\",v,a[i].pos);\n                v=a[i].pos;\n            }\n        }\n        if(cnt2>0)\n        {\n            if(v==-1)v=b[1].pos;\n            else printf(\"1 %d %d\\n\",v,b[1].pos),v=b[1].pos;\n            for(int i=2; i<=cnt2; i++)\n            {\n                printf(\"1 %d %d\\n\",v,b[i].pos);\n                v=b[i].pos;\n            }\n        }\n    }\n}\n```\n","link":null,"tags":["贪心","排序"],"title":"LG CF1042C Array Product"},{"categories":[["刷题记录"]],"content":"\n直接树剖即可\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;rg char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\n#define N 500011\nint n;\nstruct edge{\n    int to,nxt;\n}e[N*2];\nint cnt=0,head[N],d[N],top[N],f[N],siz[N],id[N],sz=0;\nvoid add(int x,int y){\n    e[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;\n}\nvoid dfs(int x){\n    siz[x]=1;\n    fl(i,x)if(to!=f[x]){\n        f[to]=x;d[to]=d[x]+1;\n        dfs(to);siz[x]+=siz[to];\n    }\n}\nvoid bt(int x,int tp){\n    top[x]=tp;\n    id[x]=++sz;\n    int k=0;\n    fl(i,x)if(to!=f[x]&&siz[to]>siz[k])k=to;\n    if(!k)return;bt(k,tp);\n    fl(i,x)if(!top[to])bt(to,to);\n}\nstruct seg{\n    #define ls rt<<1\n    #define rs rt<<1|1\n    #define pu s[rt]=s[ls]|s[rs]\n    int s[N<<2],laz[N<<2];\n    seg(){clr(laz,-1);}\n    void pd(int rt){\n        if(~laz[rt]){\n            laz[ls]=laz[rs]=s[ls]=s[rs]=laz[rt];\n            laz[rt]=-1;\n        }\n    }\n    void upd(int L,int R,int v,int l,int r,int rt){\n        if(L<=l&&r<=R){\n            s[rt]=laz[rt]=v;\n            return;\n        }\n        int m=(l+r)>>1;\n        pd(rt);\n        if(L<=m)upd(L,R,v,l,m,ls);\n        if(R>m)upd(L,R,v,m+1,r,rs);\n        pu;\n    }\n    int get(int x,int l,int r,int rt){\n        if(!s[rt])return 0;\n        if(l==r)return s[rt];\n        int m=(l+r)>>1;\n        pd(rt);\n        if(x<=m)return get(x,l,m,ls);\n        else return get(x,m+1,r,rs);\n    }\n}T;\nint main(){\n    in(n);\n    int x,y,q,opt;\n    Fur(i,1,n-1){\n        in(x,y);\n        add(x,y);add(y,x);\n    }\n    dfs(1);bt(1,1);\n    in(q);\n    while(q--){\n        in(opt,x);\n        if(opt==1)\n            T.upd(id[x],id[x]+siz[x]-1,1,1,n,1);\n        \n        if(opt==2){\n            while(top[x]!=1){\n                T.upd(id[top[x]],id[x],0,1,n,1);\n                x=f[top[x]];\n            }\n            T.upd(1,id[x],0,1,n,1);\n        }\n        if(opt==3)pt(T.get(id[x],1,n,1)?'1':'0'),pt('\\n');\n    }\n    flush();\n}\n```\n","link":null,"tags":["树链剖分","线段树"],"title":"LG CF343D Water-Tree"},{"categories":[["刷题记录"]],"content":"\n```cpp\n#include<iostream>\n#include<cstdlib>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\nconst int maxn=1000010;\nint n,t[maxn],root,cnt,sum,ans[5];\nint ver[2*maxn],head[maxn*2],nxt[maxn*2],tem[maxn],tot;\nvoid add(int x,int y){\n    tot++;\n    ver[tot]=y;\n    nxt[tot]=head[x];\n    head[x]=tot;\n}\nvoid dfs(int x,int y){\n    tem[x]=t[x];\n    for(int i=head[x];i;i=nxt[i]){\n        int v=ver[i];\n        if(v!=y){\n            dfs(v,x);\n            tem[x]+=tem[v];\n        }\n    }\n    if(tem[x]==sum) ans[++cnt]=x,tem[x]=0;\n}\nint main(){\n    int a;\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++) {\n        scanf(\"%d %d\",&a,&t[i]);\n        if(a) add(a,i),add(i,a);\n        else root=i;\n        sum+=t[i];\n    }\n    if(sum%3){\n        puts(\"-1\");\n        return 0;\n    }\n    sum\/=3;\n    dfs(root,0);\n    if(cnt<=2) puts(\"-1\");\n    else printf(\"%d %d\\n\",ans[1],ans[2]);\n    return 0;\n}\n```\n","link":null,"tags":["树形dp","动态规划"],"title":"LG CF767C Garland"},{"categories":[["刷题记录"]],"content":"\n1. 如果个数中没有奇数,那么答案就是所有数字的$gcd$,然后构造答案就是输出$\\frac {gcd}2$个回文串\n\n2. 如果个数中只有一个奇数,那么答案也是所有数字的$gcd$,然后构造答案就是输出$gcd$个回文串,个数为奇数的颜色放在回文串的中间\n\n3. 如果个数中有两个或以上的奇数,那么答案就是$0$,因为两个奇数就已经构造不出有优美$cut$的环来了\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n\t#pragma GCC optimize(3)\n\t#define il __inline__ __attribute__ ((always_inline))\n\t#define ll long long\n\t#define MB template <class T>il\n\t#define Fur(i,x,y) for(int i=x;i<=y;i++)\n\t#define Fdr(i,x,y) for(int i=x;i>=y;i--)\n\t#define fcin ios::sync_with_stdio(false)\n\tMB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n}using namespace ZDY;using namespace std;\n#define N 10011\nint n,a[30];\nint main(){\n\tfcin;\n\tcin>>n;\n\tint f=0,x;\n\tFur(i,1,n){cin>>a[i];if(a[i]&1)x=i,f++;}\n\tint ans=a[1];\n\tFur(i,2,n)ans=GCD(ans,a[i]);\n\tif(f>1)ans=0;\n\tcout<<ans<<endl;\n\tif(f>1){\n\t\tFur(i,1,n)while(a[i]--)cout<<char('a'-1+i);\n\t\treturn 0;\n\t}\n\tif(f){\n\t\tFur(i,1,ans)\n\t\t\tFur(j,1,n)\n\t\t\tif(j!=x)\n\t\t\t\tFur(k,1,a[j]\/ans\/2)cout<<char('a'-1+j);\n\t\tFur(j,1,a[x]\/ans)cout<<char('a'-1+x);\n\t\tFdr(j,n,1)\n\t\tif(j!=x)\n\t\t\tFur(k,1,a[j]\/ans\/2)cout<<char('a'-1+j);\n\t}\n\telse{\n\t\tFur(i,1,ans\/2){\n\t\t\tFur(j,1,n)\n\t\t\t\tFur(k,1,a[j]\/ans)cout<<char('a'-1+j);\n\t\t\tFdr(j,n,1)\n\t\t\t\tFur(k,1,a[j]\/ans)cout<<char('a'-1+j);\n\t\t}\n\t}\n}\n```\n","link":null,"tags":["gcd","构造","思维"],"title":"LG CF613C Necklace"},{"categories":[["刷题记录"]],"content":"\nhash正着来一遍和倒着来一遍就可以了\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i=x;i<=y;++i)\n    #define Fdr(i,x,y) for(int i=x;i>=y;--i)\n    #define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 0x3f3f3f3f\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){clr(ch,0);if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 500011\n#define base 1331\nint n;\null h[N],H[N],pw[N];\nchar s[N];\nll ans=0;\null g(int l,int r){\n    return h[l]-h[r+1]*pw[r-l+1];\n}\null G(int l,int r){\n    return H[r]-H[l-1]*pw[r-l+1];\n}\nvoid q(int x){\n    int l=0,r=MIN(x,n-x),t;\n    while(l<=r){\n        int m=(l+r)>>1;\n        if(g(x-m+1,x+m)==G(x-m+1,x+m))l=m+1,t=m;\n        else r=m-1;\n    }\n    ans+=t;\n}\nint main(){\n    fin(\"in\");\n    in>>n>>(s+1);\n    pw[0]=1;\n    Fur(i,1,n)H[i]=H[i-1]*base+(s[i]=='0'),pw[i]=pw[i-1]*base;\n    Fdr(i,n,1)h[i]=h[i+1]*base+(s[i]=='1');\n    Fur(i,1,n-1)if(s[i]!=s[i+1])q(i);\n    out<<ans<<ln;\n}\n```\n","link":null,"tags":["hash"],"title":"LG 3501 [POI2010]ANT-Antisymmetry"},{"categories":[["刷题记录"]],"content":"\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;rg char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\n#define N 111\nint n;\nint f[N][N][5][5];\nint main(){\n    in(n);\n    int a,b,c;\n    Fur(i,1,n)\n        Fur(j,1,n)\n            Fur(x,1,4)\n                Fur(y,1,4)\n                f[i][j][x][y]=-(1<<25);\n    Fur(i,1,n){\n        in(a,b,c);\n        f[i][i][a][c]=f[i][i][c][a]=b;\n    }\n    int ans=0;\n    Fdr(i,n,1)\n        Fur(j,i,n)\n            Fur(x,1,4)\n                Fur(y,1,4){\n                    Fur(k,i,j-1){\n                        f[i][j][x][y]=MAX(f[i][j][x][y],MAX(f[i][k][x][y],f[k+1][j][x][y]));\n                        Fur(p,1,4)\n                            f[i][j][x][y]=MAX(f[i][j][x][y],MAX(f[i][k][p][y]+f[k+1][j][x][p],f[i][k][x][p]+f[k+1][j][p][y]));\n                    }\n                    ans=MAX(ans,f[i][j][x][y]);\n                }\n    cout<<ans<<endl;\n}\n```\n","link":null,"tags":["动态规划","欧拉图"],"title":"LG CF1038E Maximum-Matching"},{"categories":[["刷题记录"]],"content":"\n同usaco工作调度\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;rg char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\n#define N 10011\nint n;\nstruct node{\n    int p,d;\n}a[N];\nil bool cmp(node x,node y){\n    return x.d<y.d;\n}\nint main(){\nwhile(1){\n    in(n);\n    if(__)break;\n    Fur(i,1,n)in(a[i].p,a[i].d);\n    sort(a+1,a+n+1,cmp);\n    priority_queue<int,vector<int>,greater<int>>q;\n    ll ans=0;\n    Fur(i,1,n)\n        if(q.size()<a[i].d){\n            ans+=a[i].p;\n            q.push(a[i].p);\n        }\n        else if(a[i].p>q.top()){\n                ans+=a[i].p-q.top();\n                q.pop();\n                q.push(a[i].p);\n            }\n    \n    printf(\"%lld\\n\",ans);\n}\n}\n```\n","link":null,"tags":["贪心","堆"],"title":"LG UVA1316 Supermarket"},{"categories":[["刷题记录"]],"content":"\n首先要知道选定一个区间首先要减去的是最大的连续$d$区间的和\n\n可以用单调队列维护当前区间最大连续长度为$d$的子区间和\n\n我们可以发现如果$[l,r]$合法,那么$[l+1...r,r]$都合法\n\n可以使用双指针来优化\n\n复杂度$\\Theta(n)$\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\n#define N 2000011\nint n,d,q[N];\nll a[N],p,s[N];\nint main(){\n    in(n,p,d);\n    Fur(i,1,n)in(a[i]),s[i]=s[i-1]+a[i];\n    Fdr(i,n,d)s[i]-=s[i-d];\n    int ans=d,l=0,h=1,t=0;\n    ll tt=0;\n    Fur(i,1,n){\n        tt+=a[i];\n        while(h<=t&&s[q[h]]<=s[i])--t;\n        q[++t]=i;\n        while(tt-s[q[h]]>p&&h<=t){\n            tt-=a[++l];\n            while(q[h]-d<=l&&h<=t)++h;\n        }\n        ans=MAX(ans,i-l);\n    }\n    cout<<ans<<endl;\n}\n```\n","link":null,"tags":["双指针","单调队列"],"title":"LG 3594 [POI2015]WIL-Wilcze-doły"},{"categories":[["刷题记录"]],"content":"\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n\t#pragma GCC optimize(3)\n\t#define il __inline__ __attribute__ ((always_inline))\n\t#define rg register\n\t#define ll long long\n\t#define ull unsigned long long\n\t#define db double\n\t#define sht short\n\t#define MB template <class T>il\n\t#define Fur(i,x,y) for(int i=x;i<=y;i++)\n\t#define Fdr(i,x,y) for(int i=x;i>=y;i--)\n\t#define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n\t#define clr(x,y) memset(x,y,sizeof(x))\n\t#define cpy(x,y) memcpy(x,y,sizeof(x))\n\t#define fin(s) freopen(s\".in\",\"r\",stdin)\n\t#define fout(s) freopen(s\".out\",\"w\",stdout)\n\t#define fcin ios::sync_with_stdio(false)\n\t#define l2(n) (int(log2(n)))\n\t#define inf 0x3f3f3f3f\n\tMB T ABS(T x){return x>0?x:-x;}\n\tMB T MAX(T x,T y){return x>y?x:y;}\n\tMB T MIN(T x,T y){return x<y?x:y;}\n\tMB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n\tMB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 1000011\nint n,k,a[N];\nint main(){\n\tin>>n>>k;\n\tFur(i,1,k)in>>a[i];\n\tsort(a+1,a+k+1);\n\tint ans=MAX(a[1],n-a[k]);\n\tFur(i,2,k)ans=MAX(ans,(a[i]-a[i-1])\/2);\n\tout<<ans<<ln;\n}\n```\n","link":null,"tags":[],"title":"LG 2988 [USACO10MAR]考试Test-Taking"},{"categories":[["刷题记录"]],"content":"\n```cpp\n#include <iostream>\n#include <cstdio>\n#define lson now << 1\n#define rson now << 1 | 1\n#define ll long long\nconst ll maxN = 100000 + 7;\n\ninline ll read() {\n    ll x = 0,f = 1;char c = getchar();\n    while(c < '0' || c > '9') {if(c == '-')f = -1;c = getchar();}\n    while(c >= '0' && c <= '9') {x = x * 10 + c - '0';c = getchar();}\n    return x * f;\n}\n\nll gcd(ll a,ll b) {\n    return !b ? a : gcd(b,a % b);\n}\n\nstruct Node {\n    ll sum[6];\n    ll lazy;\n    ll l,r;\n}tree[maxN << 2];\nll sum1,sum2,sum3;\n\nvoid updata(ll now) {\n    tree[now].sum[1] = tree[lson].sum[1] + tree[rson].sum[1];\n    tree[now].sum[2] = tree[lson].sum[2] + tree[rson].sum[2];\n    tree[now].sum[3] = tree[lson].sum[3] + tree[rson].sum[3];\n    return ;\n}\n\nvoid build(ll l,ll r,ll now) {\n    tree[now].l = l;tree[now].r = r;\n    if(l == r) {\n        tree[now].sum[4] = l * l;\n        tree[now].sum[5] = l;\n        return ;\n    }\n    ll mid = (l + r) >> 1;\n    build(l,mid,lson);\n    build(mid + 1,r,rson);\n    tree[now].sum[4] = tree[lson].sum[4] + tree[rson].sum[4];\n    tree[now].sum[5] = tree[lson].sum[5] + tree[rson].sum[5];\n    return ;\n}\n\nvoid work(ll now,ll k) {\n    tree[now].sum[1] += (tree[now].r - tree[now].l + 1) * k;\n    tree[now].sum[2] += k * tree[now].sum[5];\n    tree[now].sum[3] += k * tree[now].sum[4];\n    tree[now].lazy += k;\n}\n\nvoid pushdown(ll now) {\n    work(lson,tree[now].lazy);\n    work(rson,tree[now].lazy);\n    tree[now].lazy = 0;\n    return ;\n}\n\nvoid modify(ll l,ll r,ll now,ll val) {\n    if(tree[now].l >= l && tree[now].r <= r) {\n        work(now,val);\n        return ;\n    }\n    if(tree[now].lazy) pushdown(now);\n    ll mid = (tree[now].l + tree[now].r) >> 1;\n    if(mid >= l) modify(l,r,lson,val);\n    if(mid < r) modify(l,r,rson,val);\n    updata(now);\n    return ;\n}\n\nvoid query(ll l,ll r,ll now) {\n    if(tree[now].l >= l && tree[now].r <= r)  {\n        sum1 += tree[now].sum[1];\n        sum2 += tree[now].sum[2];\n        sum3 += tree[now].sum[3];\n        return ;\n    }\n    if(tree[now].lazy) pushdown(now);\n    ll mid = (tree[now].l + tree[now].r) >> 1;\n    if(mid >= l) query(l,r,lson);\n    if(mid < r) query(l,r,rson);\n    return ;\n}\n\nint main(){   \n    ll n,m,l,r,v;\n    char s[3];\n    n = read();m = read();\n    build(1,n,1);\n    while(m --) {\n        scanf(\"%s\",&s);\n        l = read();r = read() - 1;\n        if(s[0] == 'C') {\n            v = read();\n            modify(l,r,1,v);\n        }\n        else {\n            ll a;\n            sum1 = sum2 = sum3 = 0;\n            query(l,r,1);\n            a = (r - l + 1 - r * l) * sum1 + (r + l) * sum2 - sum3;\n            ll b = ( r - l + 2 ) * (r - l + 1) \/ 2;\n            ll g = gcd(a,b);\n            printf(\"%lld\/%lld\\n\", a \/ g,b \/ g);\n        }\n    }\n}\n```\n","link":null,"tags":[],"title":"LG 2221 [HAOI2012]高速公路"},{"categories":[["刷题记录"]],"content":"\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i=x;i<=y;i++)\n    #define Fdr(i,x,y) for(int i=x;i>=y;i--)\n    #define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) (int(log2(n)))\n    #define inf 0x3f3f3f3f\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 100011\nint n,m;\nint main(){\n\t\n}\n\n```\n","link":null,"tags":[],"title":"LG 4069 [SDOI2016]游戏"},{"categories":[["刷题记录"]],"content":"\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i=x;i<=y;++i)\n    #define Fdr(i,x,y) for(int i=x;i>=y;--i)\n    #define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){clr(ch,0);if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 11\nint n,a[N][N],zs[N*N];\nbool v[N*N];\nvoid zs()\nvoid dfs(int x,int y){\n    Fur(i,1,n*n)\n}\nint main(){\n    \n}\n```\n","link":null,"tags":["搜索"],"title":"LG 1549 棋盘问题（2）"},{"categories":[["刷题记录"]],"content":"\n排序 贪心\n\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n\t#define il __inline__ __attribute__ ((always_inline))\n\t#define ll long long\n\t#define MB template <class T>il\n\t#define Fur(i,x,y) for(int i=x;i<=y;i++)\n\t#define inf 0x3f3f3f3f\n\tMB T ABS(T x){return x>0?x:-x;}\n\tMB T MIN(T x,T y){return x<y?x:y;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 100011\nint a[N],b[N],n;\nll f[N];\nil int get(int x,int y){return (x==y)?inf:ABS(x-y);}\nint main(){\n\tin>>n;\n\tFur(i,1,n)in>>a[i]>>b[i];\n\tstd::sort(a+1,a+n+1);\n\tstd::sort(b+1,b+n+1);\n\tFur(i,1,n){\n\t\tf[i]=f[i-1]+get(a[i],b[i]);\n\t\tf[i]=MIN(f[i],f[i-2]+get(a[i],b[i-1])+get(a[i-1],b[i]));\n        f[i]=MIN(f[i],f[i-3]+get(a[i],b[i-2])+get(a[i-2],b[i])+get(a[i-1],b[i-1]));\n        f[i]=MIN(f[i],f[i-3]+get(a[i],b[i-1])+get(a[i-1],b[i-2])+get(a[i-2],b[i]));\n        f[i]=MIN(f[i],f[i-3]+get(a[i],b[i-2])+get(a[i-1],b[i])+get(a[i-2],b[i-1]));\n\t}\n\tout<<f[n]<<ln;\n}\n```\n","link":null,"tags":[],"title":"LG 2507 [SCOI2008]配对"},{"categories":[["刷题记录"]],"content":"\n一道中档题-Factorial\ntop: 0\n\n\n观察一下,\n\n一个数在$k$进制下有多少个后缀0,就是一个数能整除$k$多少次\n\n那么先把$k$分解质因数,并求出每个质因数的个数,存到数组里面\n\n要怎么算出$n!$里面有多少个质因数？\n\n> 每$p$($p$是质数)个数里面有一个$p$,这些数是$p^1,p^2,...p^x$,这些数中每$p$个数中又有一个$p$,那我们这样一直循环下去就可以求出质因数的个数,然后在除以他们在$k$中出现的次数,然后取$min$就是答案\n\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n\t#pragma GCC optimize(3)\n\t#define il __inline__ __attribute__ ((always_inline))\n\t#define rg register\n\t#define ll long long\n\t#define ull unsigned long long\n\t#define db double\n\t#define sht short\n\t#define MB template <class T>il\n\t#define Fur(i,x,y) for(int i=x;i<=y;i++)\n\t#define Fdr(i,x,y) for(int i=x;i>=y;i--)\n\t#define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n\t#define clr(x,y) memset(x,y,sizeof(x))\n\t#define cpy(x,y) memcpy(x,y,sizeof(x))\n\t#define fin(s) freopen(s\".in\",\"r\",stdin)\n\t#define fout(s) freopen(s\".out\",\"w\",stdout)\n\t#define fcin ios::sync_with_stdio(false)\n\t#define l2(n) (int(log2(n)))\n\t#define inf 0x3f3f3f3f\n\tMB T ABS(T x){return x>0?x:-x;}\n\tMB T MAX(T x,T y){return x>y?x:y;}\n\tMB T MIN(T x,T y){return x<y?x:y;}\n\tMB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n\tMB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 1000011\nll n,k,a[N],s[N],cnt=0;\nint main(){\n\tin>>n>>k;\n\tll ans=1ll<<62;\n\tfor(ll i=2;i*i<=k;i++)\n\tif(k%i==0){\n\t\ta[++cnt]=i;s[cnt]=0;\n\t\twhile(k%i==0)s[cnt]++,k\/=i;\n\t}\n\tif(k>1)a[++cnt]=k,s[cnt]=1;\n\tFur(i,1,cnt){\n\t\tll res=0,t=n;\n\t\twhile(t)res+=(t\/=a[i]);\n\t\tres\/=s[i];\n\t\tans=MIN(ans,res);\n\t}\n\tout<<ans<<ln;\n}\n```\n","link":null,"tags":["数论"],"title":"LG 3927 SAC-Et1"},{"categories":[["刷题记录"]],"content":"\n当我们选中一个$i$后\n\n$i,i^2,i^3...,i^k$都会被去掉\n\n我们设$d_t$为可以去掉$t$的数字的个数\n\n$ans = \\sum_{i=1}^n \\frac 1 {d_i}$\n\n那么如何统计呢？\n\n分解质因数\n\n$n = p_1^{k_1}p_2^{k_2}p_3^{k_3}p_4^{k_4}...$\n\n对于$k_i$贡献为$1+\\frac12+\\frac12+\\frac14+...$\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;rg char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\n#define N 100011\nint n,d[N];\ndb p[N];\ndb ans=0;\nint main(){\n    cin>>n;\n    int len;\n    Fur(t,1,30){\n        len=sqrt(t);\n        Fur(i,1,len)\n\n    }\n    len=sqrt(n);\n    Fur(i,2,len){\n        int t=0;\n        while(n%i==0)++t,n\/=i;\n        ans+=p[t];\n    }\n    \n}\n```\n","link":null,"tags":["期望"],"title":"LG 5589 小猪佩奇玩游戏"},{"categories":[["刷题记录"]],"content":"\n很裸的树形dp\n\n因为是二叉树,所以处理起来非常方便\n\n设$f[i][j]$为根为$i$的子树用了$j$条边,最多保留多少,\n\n$l,r$表示左右节点,$lw,rw$表示连接左右儿子的边的权值分别为多少\n\n$f[i][j]=\\max(lw+f[l][j-1],rw+f[r][j-1])$\n\n$f[i][j]=\\max(lw+f[l][k-1],rw+f[r][j-k-1])$\n\n\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i=x;i<=y;++i)\n    #define Fdr(i,x,y) for(int i=x;i>=y;--i)\n    #define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 0x3f3f3f3f\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){clr(ch,0);if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 111\nint n,m,cnt=0,head[N];\nstruct edge{\n    int to,nxt,w;\n}e[N*2];\nvoid add(int x,int y,int w){\n    e[++cnt].to=y;e[cnt].w=w;e[cnt].nxt=head[x];head[x]=cnt;\n}\nint s[N][N];\nvoid dfs(int x,int f){\n    int l=0,r=0,lw=0,rw=0;\n    fl(i,x)if(to!=f){\n        if(l)r=to,rw=e[i].w;\n        else l=to,lw=e[i].w;\n    }\n    if(l)dfs(l,x),dfs(r,x);\n    Fur(i,1,m)s[x][i]=MAX(lw+s[l][i-1],rw+s[r][i-1]);\n    Fur(i,2,m){\n        Fur(j,1,i-1)\n        s[x][i]=MAX(s[x][i],lw+s[l][j-1]+rw+s[r][i-j-1]);\n    }\n}\nint main(){\n    fin(\"in\");\n    in>>n>>m;\n    int x,y,w;\n    Fur(i,1,n-1)in>>x>>y>>w,add(x,y,w),add(y,x,w);\n    dfs(1,0);\n    out<<s[1][m]<<ln;\n}\n```\n","link":null,"tags":["树形dp"],"title":"LG 2015 二叉苹果树"},{"categories":[["刷题记录"]],"content":"\n题解很妙\n\n设$f[i][j][k]$为从$i$到$j$走$k$步的方案数\n\n$f[i][j]$这个矩阵的$k$次方就是答案\n\n$ans = \\sum f[1][i]$\n\n\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;rg char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\n#define N 101\nconst int mod=2017;\nint n,m;\nstruct mat{\n    mat(){clr(a,0);}\n    int a[N][N];\n}a;\nil mat operator * (mat a,mat b){\n    mat c;\n    Fur(i,0,100)\n        Fur(j,0,100)\n            Fur(k,0,100)\n            c.a[i][j]=(c.a[i][j]+a.a[i][k]*b.a[k][j]%mod)%mod;\n    return c;\n}\nmat pw(mat x,int p){\n    mat c;\n    Fur(i,0,100)c.a[i][i]=1;\n    while(p){\n        if(p&1)c=c*x;\n        p>>=1;x=x*x;\n    }\n    return c;\n}\nint main(){\n    in(n,m);\n    int x,y;\n    Fur(i,1,m){\n        in(x,y);\n        a.a[x][y]=a.a[y][x]=1;\n    }\n    Fur(i,0,n)a.a[i][i]=1;\n    Fur(i,1,n)a.a[i][0]=1;\n    int ans=0,t;\n    in(t);\n    mat ANS=pw(a,t);\n    Fur(i,0,n)ans=(ans+ANS.a[1][i])%mod;\n    out(ans,ln);\n    flush();\n}\n```\n","link":null,"tags":["floyed","邻接矩阵","矩阵乘法"],"title":"LG 3758 [TJOI2017]可乐"},{"categories":[["刷题记录"]],"content":"\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i=x;i<=y;i++)\n    #define Fdr(i,x,y) for(int i=x;i>=y;i--)\n    #define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) (int(log2(n)))\n    #define inf 0x3f3f3f3f\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){clr(ch,0);if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 1000011\nint n,cnt=0,head[N],top[N],id[N],sz=0,d[N],siz[N],f[N];\nstruct edge{\n\tint to,nxt,w;\n}e[N<<1];\nvoid add(int x,int y,int w){\n\te[++cnt].to=y;e[cnt].w=w;e[cnt].nxt=head[x];head[x]=cnt;\n}\nvoid dfs(int x){\n\tsiz[x]=1;\n\tfl(i,x)if(to!=f[x]){\n\t\tf[to]=x;d[to]=d[x]+e[i].w;\n\t\tdfs(to);siz[x]+=siz[to];\n\t}\n}\nvoid bt(int x,int tp){\n\ttop[x]=tp;id[x]=++sz;\n\tint k=0;\n\tfl(i,x)if(to!=f[x]&&siz[to]>siz[k])k=to;\n\tif(!k)return;bt(k,tp);\n\tfl(i,x)if(!top[to])bt(to,to);\n}\nint lca(int x,int y){\n\twhile(top[x]!=top[y]){\n\t\tif(d[top[x]]<d[top[y]])SWAP(x,y);\n\t\tx=f[top[x]];\n\t}\n\treturn d[x]<d[y]?x:y;\n}\nstruct node{\n\tint x,y;\n}s[N<<2];\n#define ls rt<<1\n#define rs rt<<1|1\nbool cmp(int x,int y){\n\treturn d[x]>d[y];\n}\nnode P(node u,node v){\n\tint x=u.x,y=u.y;\n\tint X=v.x,Y=v.y;\n\tint t[4];\n\tt[0]=lca(x,X);\n\tt[1]=lca(x,Y);\n\tt[2]=lca(y,X);\n\tt[3]=lca(y,Y);\n\tsort(t,t+4,cmp);\n\treturn node{t[0],t[1]};\n}\nvoid build(int l,int r,int rt){\n\tif(l==r){\n\t\tin>>s[rt].x>>s[rt].y;\n\t\treturn;\n\t}\n\tint m=(l+r)>>1;\n\tbuild(l,m,ls);build(m+1,r,rs);\n\ts[rt]=P(s[ls],s[rs]);\n}\nnode ask(int L,int R,int l,int r,int rt){\n\tif(L<=l&&r<=R)return s[rt];\n\tint m=(l+r)>>1;\n\tif(R<=m)return ask(L,R,l,m,ls);\n\telse if(L>m)return ask(L,R,m+1,r,rs);\n\telse return P(ask(L,R,l,m,ls),ask(L,R,m+1,r,rs));\n}\nint main(){\n\tfin(\"in\");\n\tin>>n;\n\tint x,y,w,m,q;\n\tFur(i,1,n-1)in>>x>>y>>w,add(x,y,w),add(y,x,w);\n\tdfs(1);bt(1,1);\n\tin>>m;\n\tbuild(1,m,1);\n\tin>>q;\n\twhile(q--){\n\t\tin>>x>>y;\n\t\tnode t=ask(x,y,1,m,1);\n\t\tout<<d[t.x]+d[t.y]-2*d[lca(t.x,t.y)]<<ln;\n\t}\n}\n\n```\n","link":null,"tags":[],"title":"51nod 1830 路径交"},{"categories":[["刷题记录"]],"content":"\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;rg char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\n#define N 100011\nint a[10][10],bl[10][10];\nbool h[10][10],l[10][10],block[10][10];\nint belong(int x,int y){\n    int p=(x-1)\/3+1,q=(y-1)\/3+1;\n    return (p-1)*3+q;\n}\nvoid add(int i,int j,int k){\n    l[i][k]^=1;\n    h[j][k]^=1;\n    block[bl[i][j]][k]^=1;\n}\nil bool chk(int x,int y,int k){\n    return !(l[x][k]||h[y][k]||block[bl[x][y]][k]);\n}\nint ans=-1;\nil int point(int i,int j){\n    if(i==1||j==1||i==9||j==9)return 6;\n    if(i==2||j==2||i==8||j==8)return 7;\n    if(i==3||j==3||i==7||j==7)return 8;\n    if(i==4||j==4||i==6||j==6)return 9;\n    return 10;\n}\nil void op(){\n    int res=0;\n    Fur(i,1,9)Fur(j,1,9)res+=a[i][j]*point(i,j);\n    ans=MAX(ans,res);\n}\nvoid fil();\nvoid dfs(int x,int y){\n    if(a[x][y]){\n        if(x==9&&y==9){op();return;}\n        if(y==9)dfs(x+1,1);\n        else dfs(x,y+1);\n    }\n    else\n    Fdr(i,9,1)\n    if(chk(x,y,i)){\n        a[x][y]=i;\n        add(x,y,i);\n        if(x==9&&y==9){op();return;}\n        if(y==9)dfs(x+1,1);\n        else dfs(x,y+1);\n        add(x,y,i);\n        a[x][y]=0;\n    }\n}\nint main(){\n    Fur(i,1,9)\n        Fur(j,1,9)\n        bl[i][j]=belong(i,j);\n\n    Fur(i,1,9)  \n        Fur(j,1,9){\n            cin>>a[i][j];\n            if(a[i][j])add(i,j,a[i][j]);\n        }\n\n    dfs(1,1);\n\n    cout<<ans<<endl;\n}\n```\n","link":null,"tags":["搜索"],"title":"LG 1074 靶形数独"},{"categories":[["刷题记录"]],"content":"\nhttps:\/\/www.luogu.org\/blog\/CSGO\/solution-p3413\n\n直接肝不行,我们反着来\n\n找不包含回文串的个数\n\n一个数任何一位都与前两位不相同时,它就不包含回文串\n\n\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n\t#pragma GCC optimize(3)\n\t#define il __inline__ __attribute__ ((always_inline))\n\t#define rg register\n\t#define ll long long\n\t#define ull unsigned long long\n\t#define db double\n\t#define sht short\n\t#define MB template <class T>il\n\t#define Fur(i,x,y) for(int i=x;i<=y;i++)\n\t#define Fdr(i,x,y) for(int i=x;i>=y;i--)\n\t#define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n\t#define clr(x,y) memset(x,y,sizeof(x))\n\t#define cpy(x,y) memcpy(x,y,sizeof(x))\n\t#define fin(s) freopen(s\".in\",\"r\",stdin)\n\t#define fout(s) freopen(s\".out\",\"w\",stdout)\n\t#define fcin ios::sync_with_stdio(false)\n\t#define l2(n) (int(log2(n)))\n\t#define inf 0x3f3f3f3f\n\tMB T ABS(T x){return x>0?x:-x;}\n\tMB T MAX(T x,T y){return x>y?x:y;}\n\tMB T MIN(T x,T y){return x<y?x:y;}\n\tMB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n\tMB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 1111\n#define mod 1000000007\n#define int ll\nint f[N][10][10],n1[N],n2[N];\nchar s1[N],s2[N];\nint solve(int *num){\n\tint n=num[0],ans=0,tot=0;\n\tFur(i,1,n)tot=(tot*10%mod+num[i])%mod;\n\tFur(i,1,n-1)\n\t\tFur(j,1,9)\n\t\t\tFur(k,0,9)\n\t\t\tif(j!=k)\n\t\t\t\tans=(ans+f[i][j][k])%mod;\n\tif(n>1)ans+=10;\n\tFdr(i,n,2){\n\t\tint v=num[n-i];\n\t\tFur(j,0,v-1)\n\t\t\tif(i!=n||j!=0){\n\t\t\t\t\n\t\t\t}\n\t}\n\treturn (tot+1-ans+mod)%mod;\n}\nsigned main(){\n\tin>>s1>>s2;\n\tFur(i,0,strlen(s1)-1)n1[++n1[0]]=s1[i]-48;\n\tFur(i,0,strlen(s2)-1)n2[++n2[0]]=s2[i]-48;\n\t\n\tFur(i,2,1000)\n\t\tFur(j,0,9)\n\t\t\tFur(k,0,9)\n\t\t\tif(k!=j){\n\t\t\t\tFur(a,0,9)\n\t\t\t\tif(a!=j&&a!=k)\n\t\t\t\t\tf[i][j][k]+=f[i-1][a][j];\n\t\t\t\tif(i-1==1)f[i][j][k]++;\n\t\t\t\tf[i][j][k]%=mod;\n\t\t\t}\n\t\n\t\n}\n```\n","link":null,"tags":[],"title":"LG 3413 SAC#1 - 萌数"},{"categories":[["刷题记录"]],"content":"\n我们可以用分治愉快的解决这道题\n\n答案统计的时候记得开$long\\ long$\n\n# 由于某种不可抗力,ai的值将会是1~10^9内随机的一个数。（除了样例）\n\n看到这句话了没？\n\n所以不用考虑分治是否会tle\n\n~~不过我加了个$rmq$,就算没有这句话也可以过~~\n\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i=x;i<=y;++i)\n    #define Fdr(i,x,y) for(int i=x;i>=y;--i)\n    #define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) (int(log2(n)))\n    #define inf 0x3f3f3f3f\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){clr(ch,0);if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 100001\nint n,a[N],f[17][N],g[17][N];\nll ans[N];\nil int get(int x,int y){\n\treturn a[x]<a[y]?x:y;\n}\nil int GET(int x,int y){\n\treturn a[x]>a[y]?x:y;\n}\nil void st(){\n\tFur(i,1,16)\n\t\tFur(j,1,n-(1<<i)+1)\n\t\tf[i][j]=get(f[i-1][j],f[i-1][j+(1<<(i-1))]),\n\t\tg[i][j]=GET(g[i-1][j],g[i-1][j+(1<<(i-1))]);\n}\nil int ask(int l,int r){\n\tint len=l2(r-l+1);\n\treturn get(f[len][l],f[len][r-(1<<len)+1]);\n}\nil int ASK(int l,int r){\n\tint len=l2(r-l+1);\n\treturn GET(g[len][l],g[len][r-(1<<len)+1]);\n}\nvoid work(int l,int r){\n\tif(l>=r)return;\n\tint p=ask(l,r),q=ASK(l,r);\n\tans[r-l+1]=MAX(ans[r-l+1],1ll*a[p]*a[q]);\n\twork(l,p-1);work(p+1,r);\n}\nint main(){\n\tfin(\"in\");\n\tin>>n;\n\tFur(i,1,n)in>>a[i],f[0][i]=g[0][i]=i,ans[1]=MAX(ans[1],1ll*a[i]*a[i]);\n\tst();\n\twork(1,n);\n\tFdr(i,n-1,1)ans[i]=MAX(ans[i],ans[i+1]);\n\tFur(i,1,n)out<<ans[i]<<ln;\n}\n\n```\n","link":null,"tags":["分治","rmq"],"title":"51nod 1564 区间的价值"},{"categories":[["刷题记录"]],"content":"\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\n#define N 100011\nint q,cnt=0,sz=0,ls[N*20],rs[N*20],rt[N*20],siz[N*20];\nchar s[N*20];\nvoid ins(int l,int r,int p,char ch,int &x,int pre){\n    x=++sz;\n    ls[x]=ls[pre];\n    rs[x]=rs[pre];\n    s[x]=s[pre];\n    if(l==r){s[x]=ch;return;}\n    int m=(l+r)>>1;\n    if(p<=m)ins(l,m,p,ch,ls[x],ls[pre]);\n    else ins(m+1,r,p,ch,rs[x],rs[pre]);\n}\nchar get(int l,int r,int p,int x){\n    if(l==r)return s[x];\n    int m=(l+r)>>1;\n    if(p<=m)return get(l,m,p,ls[x]);\n    else return get(m+1,r,p,rs[x]);\n}\nint main(){\n    in(q);\n    rt[0]=++sz;\n    siz[0]=0;\n    Fur(i,1,q){\n        char opt,c;\n        int x;\n        in(opt);\n        if(opt=='T'){\n            in(c);\n            ++cnt;\n            siz[cnt]=siz[cnt-1]+1;\n            ins(1,q,siz[cnt],c,rt[cnt],rt[cnt-1]);\n        }\n        else if(opt=='U'){\n            in(x);\n            ++cnt;\n            siz[cnt]=siz[cnt-x-1];\n            rt[cnt]=rt[cnt-x-1];\n        }\n        else{\n            in(x);\n            pt(get(1,q,x,rt[cnt])),pt('\\n');\n        }\n    }\n    flush();\n}\n```\n","link":null,"tags":["主席树"],"title":"LG 1383 高级打字机"},{"categories":[["刷题记录"]],"content":"\n类似[Moo](https:\/\/www.luogu.org\/problem\/P1885)\n\n我们可以发现字符串每次长度变成原来的两倍\n\n我们可以把之前不需要的状态删去\n\n一开始按套路用递归写\n\n然后爆栈了\n\n应该用循环写\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;rg char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\n#define N 50\nchar s[N];\nint main(){\n    ll n,t;\n    in(s+1);in(n);\n    t=strlen(s+1);\n\n    while(t<n){\n        ll i=t;\n        while(n>(i<<1))i<<=1;\n        n-=(i+1);\n        if(n==0)n=i;\n    }\n    putchar(s[n]);\n}\n```\n","link":null,"tags":["分治","模拟"],"title":"LG 3612 [USACO17JAN]Secret-Cow-Code秘密奶牛码"},{"categories":[["刷题记录"]],"content":"\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;rg char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\n#define N 1011\nint n,d[N],head[N],cnt=0;\nstruct edge{\n    int to,nxt,w;\n}e[N*2];\nil void add(int x,int y,int w){\n    e[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;\n    e[cnt].w=w;\n}\nint D[N],siz[N],top[N],f[N];\nvoid dfs(int x){\n    siz[x]=1;\n    fl(i,x)if(to!=f[x]){\n        f[to]=x;D[to]=D[x]+e[i].w;\n        d[to]=d[x]+1;\n        dfs(to);\n        siz[x]+=siz[to];\n    }\n}\nvoid bt(int x,int tp){\n    top[x]=tp;int k=0;\n    fl(i,x)if(to!=f[x]&&siz[to]>siz[k])k=to;\n    if(!k)return;bt(k,tp);\n    fl(i,x)if(!top[to])bt(to,to);\n}\nint lca(int x,int y){\n    while(top[x]!=top[y]){\n        if(d[top[x]]<d[top[y]])SWAP(x,y);\n        x=f[top[x]];\n    }\n    return (d[x]<d[y])?x:y;\n}\nint main(){\n    int q;\n    in(n,q);\n    int x,y,w;\n    Fur(i,1,n-1)in(x,y,w),add(x,y,w),add(y,x,w);\n    dfs(1);bt(1,1);\n    while(q--){\n        in(x,y);\n        out(D[x]+D[y]-2*D[lca(x,y)],ln);\n    }\n    flush();\n}\n```\n","link":null,"tags":["lca"],"title":"LG 2912 [USACO08OCT]牧场散步Pasture-Walking"},{"categories":[["刷题记录"]],"content":"\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i=x;i<=y;++i)\n    #define Fdr(i,x,y) for(int i=x;i>=y;--i)\n    #define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){clr(ch,0);if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 200011\nint n,h,s[N];\nstruct node{\n    int l,r;\n}a[N];\nint main(){\n    fin(\"in\");\n    in>>n>>h;\n    Fur(i,1,n)in>>a[i].l>>a[i].r;\n    Fur(i,2,n)s[i]=s[i-1]+a[i].l-a[i-1].r;\n    int r=1,ans=0;\n    Fur(i,1,n){\n        while(s[i]-s[r]>=h)++r;\n        ans=MAX(ans,a[i].r-a[r].l+h-(s[i]-s[r]));\n    }\n    out<<ans<<ln;\n}\n```\n","link":null,"tags":["双指针"],"title":"LG CF1041D Glider"},{"categories":[["刷题记录"]],"content":"\n[LG 1415 拆分数列](https:\/\/www.luogu.org\/problemnew\/show\/P1415)加强版\n\n复杂度要求减少\n\n我们先来考虑$dp$方式\n\n$f_i = max(j)|(num(f[j],j) < num(j+1,i))$\n\n我们把填表式换成刷表式\n\n现在不考虑$0$:\n\n如果$num(f[i],i)<num(i+1,i+1+i-f[i])$\n\n那么$f(x) = max(f(x),i+1) (x\\in[i+1+i-f[i],n])$\n\n否则$f(x) = max(f(x),i+1) (x\\in[i+1+i-f[i]+1,n])$\n\n(因为长度+1肯定满足)\n\n于是我们可以令开一个数组来记录或者用线段树优化$dp$\n\n\n\n现在考虑那个毒瘤的$0$:\n\n要从$i$推到$j$\n\n到达$i$时最小的数字应该是$num(f[i],i)$\n\n这时候$num(f[i],i)$可能有前导$0$\n\n$num(i+1,i+1+i-f[i])$也可能有前导$0$\n\n我们用$R0[i]$表示从$i$开始有连续几个$0$\n\n比较的时候就可以排除$0$的干扰\n\n\n\n枚举的时候可以用hash+二分求出最大公共前缀优化到$log n$\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i=x;i<=y;++i)\n    #define Fdr(i,x,y) for(int i=x;i>=y;--i)\n    #define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 0x3f3f3f3f\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){clr(ch,0);if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 1011\nint n,f[N],R0[N];\nchar a[N];\nint g[N],s[N];\null h[N],pw[N];\n#define base 1331\null get(int l,int r){\n    return h[r]-h[l-1]*pw[r-l+1];\n}\nil bool cmp(int l,int r,int L,int R){\n    if(r-l<R-L)return 1;\n    if(r-l>R-L)return 0;\n    int ar=r-l+1,al=1,ans=0;\n    while(al<=ar){\n        int m=(al+ar)>>1;\n        if(get(l,l+m-1)==get(L,L+m-1))ans=m,al=m+1;\n        else ar=m-1;\n    }\n    return (ans!=r-l+1&&a[l+ans]<a[L+ans]);\n}\nint main(){\n    fin(\"in\");\n    in>>(a+1);\n    n=strlen(a+1);\n    pw[0]=1;\n    Fur(i,1,n){\n        s[i]=1,f[i]=1;\n        h[i]=h[i-1]*base+a[i];\n        pw[i]=pw[i-1]*base;\n    }\n    Fdr(i,n,1)if(a[i]=='0')R0[i]=R0[i+1]+1;\n    int S=1;\n    Fur(i,1,n){\n        S=MAX(S,s[i]);\n        f[i]=MAX(f[i],S);\n        int p,q,l,r;\n        l=f[i]+R0[f[i]];r=i;l=MIN(l,r);\n        p=r+1;p+=R0[p];q=p+r-l;\n        if(cmp(l,r,p,q))s[q]=MAX(s[q],r+1);\n        else s[q+1]=MAX(s[q+1],r+1);\n    }\n\n    clr(s,0);\n    \n    g[f[n]]=n;\n    int zero=f[n];\n    while(a[zero-1]=='0')g[--zero]=n;\n    Fdr(i,f[n]-1,1){\n        Fdr(j,f[n]-1,i)\n            if(cmp(i,j,j+1,g[j+1])){\n                g[i]=j;\n                break;\n            }\n    }\n    int p=1,ff=0;\n    while(p<=n){\n        if(ff)out.pt(',');\n        ff=1;\n        Fur(i,p,g[p])out.pt(a[i]);\n        p=g[p]+1;\n    }\n}\n```\n","link":null,"tags":[],"title":"LG 2282 [HNOI2003]历史年份"},{"categories":[["刷题记录"]],"content":"\n考虑如何快速找出拥有（与它的前缀相同的）后缀的串。这个东西可以通过把字符串放到$Trie$里面。 分类两种情况,**短串+长串**和**长串+短串**。对于**短串+长串**的情况,先将字符串按$len$排序,然后顺序将字符串倒着插入$trie$里面,并在$trie$中的尾节点记录$hash$。利用当前串作为查询串来找答案,这样能保证当前串一定是长串,并且找到的所有短串都有和它的前缀相同的后缀,所以再利用$hash$判断一下就可以确定拼出来的是不是回文串了。另外一个情况同理。 复杂度是$O(26\\sum len)$。\n\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i=x;i<=y;i++)\n    #define Fdr(i,x,y) for(int i=x;i>=y;i--)\n    #define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) (int(log2(n)))\n    #define inf 0x3f3f3f3f\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){clr(ch,0);if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 200011\n#define M 1000011\n#define base 233\nint n;\nchar s[M];\nint bg[N],ed[N],pos[N],c[M][27],v[M],cnt[M],len,sz=0;\null  h[M],g[M],p[M];\nil bool cmp(int x,int y){return ed[x]-bg[x]<ed[y]-bg[y];}\nil int idx(char c){return c-'a';}\nil void ins(int i){\n    int rt=0;\n    Fdr(j,ed[i],bg[i]){\n        int k=idx(s[j]);\n        if(!c[rt][k])c[rt][k]=++sz;\n        rt=c[rt][k];\n    }\n    v[rt]=i;cnt[rt]++;\n}\nil void INS(int i){\n    int rt=0;\n    Fur(j,bg[i],ed[i]){\n        int k=idx(s[j]);\n        if(!c[rt][k])c[rt][k]=++sz;\n        rt=c[rt][k];\n    }\n    v[rt]=i;cnt[rt]++;\n}\nil ull gh(int l,int r){return h[r]-h[l-1]*p[r-l+1];}\nil ull gg(int l,int r){return g[l]-g[r+1]*p[r-l+1];}\nil bool chk(int x,int y){\n    ull a=gh(bg[x],ed[x])*p[ed[y]-bg[y]+1]+gh(bg[y],ed[y]);\n    ull b=gg(bg[y],ed[y])*p[ed[x]-bg[x]+1]+gg(bg[x],ed[x]);\n    return a==b;\n}\nint main(){\n    in>>n;\n    Fur(i,1,n){\n        bg[i]=ed[i]=ed[i-1]+1;\n        in>>(s+bg[i]);\n        ed[i]+=strlen(s+bg[i])-1;\n    }\n    len=ed[n];\n    p[0]=1;\n    Fur(i,1,len){\n        h[i]=h[i-1]*base+s[i];\n        p[i]=p[i-1]*base;\n    }\n    Fdr(i,len,1)g[i]=g[i+1]*base+s[i];\n    Fur(i,1,n)pos[i]=i;\n    sort(pos+1,pos+n+1,cmp);\n    ll ans=0;\n    Fur(t,1,n){\n        int i=pos[t],rt=0;\n        Fur(j,bg[i],ed[i]){\n            int k=idx(s[j]);\n            if(!c[rt][k])break;\n            if(v[rt]&&chk(i,v[rt]))ans+=cnt[rt];\n            rt=c[rt][k];\n        }\n        if(v[rt]&&chk(i,v[rt]))ans+=cnt[rt];\n        ins(i);\n    }\n    clr(c,0);clr(cnt,0);clr(v,0);sz=0;\n    Fur(t,1,n){\n        int i=pos[t],rt=0;\n        Fdr(j,ed[i],bg[i]){\n            int k=idx(s[j]);\n            if(!c[rt][k])break;\n            if(v[rt]&&chk(v[rt],i))ans+=cnt[rt];\n            rt=c[rt][k];\n        }\n        if(v[rt]&&chk(v[rt],i))ans+=cnt[rt];\n        INS(i);\n    }\n    out<<ans<<ln;\n}\n\n```\n","link":null,"tags":["trie","hash"],"title":"51nod 2372 回文串统计"},{"categories":[["刷题记录"]],"content":"\n```cpp\n#include<bits\/stdc++.h>\n#include<bits\/extc++.h>\nusing namespace __gnu_pbds;\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;rg char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\n#define N 100011\nint n,sz,Q,a[N];\ngp_hash_table<int,int>cnt;\nstruct que{\n    int l,r,id;\n}q[N];\nil int bl(int x){return (x-1)\/sz+1;}\nbool cmp(que x,que y){\n    if(bl(x.l)==bl(y.l))return x.r<y.r;\n    return x.l<y.l;\n}\nint ans=0,ANS[N];\nil void add(int x){\n    if(cnt[a[x]]==a[x])--ans;\n    ++cnt[a[x]];\n    if(cnt[a[x]]==a[x])++ans;\n}\nil void del(int x){\n    if(cnt[a[x]]==a[x])--ans;\n    --cnt[a[x]];\n    if(cnt[a[x]]==a[x])++ans;\n}\nint main(){\n    in(n,Q);sz=sqrt(n);\n    Fur(i,1,n)in(a[i]);\n    Fur(i,1,Q)in(q[i].l,q[i].r),q[i].id=i;\n    sort(q+1,q+Q+1,cmp);\n    int l=1,r=1;\n    if(++cnt[a[1]]==a[1])++ans;\n    Fur(i,1,Q){\n        Fur(j,l,q[i].l-1)del(j);\n        Fdr(j,l-1,q[i].l)add(j);\n        Fur(j,r+1,q[i].r)add(j);\n        Fdr(j,r,q[i].r+1)del(j);\n        ANS[q[i].id]=ans;\n        l=q[i].l;r=q[i].r;\n    }\n    Fur(i,1,Q)out(ANS[i],ln);\n    flush();\n}\n```\n","link":null,"tags":["莫队"],"title":"LG CF220B Little-Elephant-and-Array"},{"categories":[["刷题记录"]],"content":"\n$i$对答案会统计$\\left \\lfloor \\frac ni \\right \\rfloor$次,但只有出现奇数次才会产生贡献\n\n\n\n每次的贡献是$i \\bigoplus i+1 \\bigoplus ... \\bigoplus j$,那么可以用[数列之异或](https:\/\/www.luogu.org\/problem\/P3908)这道题的思路做\n\n\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i=x;i<=y;i++)\n    #define Fdr(i,x,y) for(int i=x;i>=y;i--)\n    #define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) (int(log2(n)))\n    #define inf 0x3f3f3f3f\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\n#define N 10001\nll n,ans=0;\nll get(ll x){\n\tint t=x%4;\n\tif(!t)return x;\n\tif(t==1)return 1;\n\tif(t==2)return x+1;\n\treturn 0;\n}\nint main(){\n\tcin>>n;\n\tfor(ll i=1,j;i<=n;i=j+1){\n\t\tj=n\/(n\/i);\n\t\tif((n\/i)&1)ans^=get(j)^get(i-1);\n\t}\n\tcout<<ans<<endl;\n}\n\n```\n","link":null,"tags":["数论分块","异或"],"title":"51nod 1984 异或约数和"},{"categories":[["刷题记录"]],"content":"\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;rg char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\n#define N 100011\n#define int ll\nint n;\nint p(int x,int p){\n    if(x>n)return -1;\n    int ans=1;\n    while(p){\n        if(p&1)ans*=x;\n        p>>=1;x*=x;\n        if(ans>n)return -1;\n    }\n    return ans;\n}\nint g[35][10011];\nint f(int a,int b){\n    if(b>30)return 1;\n    if(!g[b][a])g[b][a]=p(a,b);\n    if(!~g[b][a])return 2;\n    int x=f(a+1,b),y=f(a,b+1);\n    if(x==2&&y==2)return 0;\n    if(!x||!y)return 2;\n    return 1;\n}\nsigned main(){\n    in(n);\n    int T;in(T);\n    while(T--){\n        int a,b,c;\n        in(a,b);\n        if(a>sqrt(n))c=(b==1)?(n-a&1?2:0):0;\n        else c=!~p(a,b)?0:f(a,b);\n        if(c==0)out(\"Stas\\n\");\n        if(c==1)out(\"Missing\\n\");\n        if(c==2)out(\"Masha\\n\");\n    }\n    flush();\n}\n```\n","link":null,"tags":["博弈论"],"title":"LG 1839 Play-with-Power_NOI导刊2011提高（05"},{"categories":[["刷题记录"]],"content":"\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\n#define N 100011\nint n;\nint main(){\n    \n}\n```\n","link":null,"tags":["动态规划","斜率优化"],"title":"LG 4360 [CEOI2004]锯木厂选址"},{"categories":[["刷题记录"]],"content":"\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;rg char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\n#define N 100011\nint n;\nll s[N],dft[N],siz[N],len[N];\nint cnt=0,head[N];\nstruct edge{\n    int to,nxt,w;\n}e[N*2];\nil void add(int x,int y,int w){\n    e[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;\n    e[cnt].w=w;\n}\nbool cmp(int x,int y){return dft[x]*siz[y]<dft[y]*siz[x];}\nvoid dfs(int x,int f){\n    siz[x]=1;\n    vector<int>son;\n    fl(i,x)if(to!=f){\n        len[to]=e[i].w;\n        dfs(to,x);\n        dft[to]+=2*len[to];\n        son.push_back(to);\n    }\n    sort(son.begin(),son.end(),cmp);\n    for(auto to:son){\n        s[x]+=s[to]+siz[to]*(dft[x]+len[to]);\n        dft[x]+=dft[to];\n        siz[x]+=siz[to];\n    }\n}\nsigned main(){\n    in(n);\n    int x,y,w;\n    Fur(i,1,n-1)in(x,y,w),add(x,y,w),add(y,x,w);\n    dfs(1,0);\n    printf(\"%lf\\n\",(db)s[1]\/(db)(n-1));\n}\n```\n","link":null,"tags":["期望","dfs","贪心","排序"],"title":"LG CF101D Castle"},{"categories":[["刷题记录"]],"content":"\n设$[l,r]$之间最小值位置为$p$,原数组为$a$\n\n那么左端点在$[l,p]$,右端点在$[p,r]$的区间的最小值都是$a[p]$\n\n那么这部分的贡献为$a[p] \\times (p-l+1) \\times (r-p+1)$\n\n接下来还有$[l,p-1],[p+1,r]$没有处理\n\n\n\n设$pre_i$为$i$前第一个比$a[i]$小的数的位置(用单调栈筛出)\n\n存在$x$,满足$pre_x=p$\n\n设$f[l][r]$表示以$r$为右端点,左端点在$[l,r]$的区间的答案\n\n那么$f[l][r]=f[l][pre_r]+a_r\\times(r-pre_r)$\n\n因为$f$的变化只与$r$有关,所以可以删掉一维\n\n那么$f_r= a_r \\times (r-pre_r) +f_{pre_r}$\n\n所以$[p+1,r]$的答案就是$f_r-f_{p-1}$\n\n$[l,p-1]$求法类似\n\n\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n\t#pragma GCC optimize(3)\n\t#define il __inline__ __attribute__ ((always_inline))\n\t#define rg register\n\t#define ll long long\n\t#define ull unsigned long long\n\t#define db double\n\t#define sht short\n\t#define MB template <class T>il\n\t#define Fur(i,x,y) for(int i=x;i<=y;i++)\n\t#define Fdr(i,x,y) for(int i=x;i>=y;i--)\n\t\/\/#define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n\t#define clr(x,y) memset(x,y,sizeof(x))\n\t#define cpy(x,y) memcpy(x,y,sizeof(x))\n\t#define fin(s) freopen(s\".in\",\"r\",stdin)\n\t#define fout(s) freopen(s\".out\",\"w\",stdout)\n\t#define fcin ios::sync_with_stdio(false)\n\t#define l2(n) (int(log2(n)))\n\t#define inf 0x3f3f3f3f\n\tMB T ABS(T x){return x>0?x:-x;}\n\tMB T MAX(T x,T y){return x>y?x:y;}\n\tMB T MIN(T x,T y){return x<y?x:y;}\n\tMB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n\tMB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 100011\nint n,m,f[18][N],a[N],pre[N],sta[N],tp=0,suf[N];\nll fl[N],fr[N],gl[N],gr[N];\n#define cmp(x,y) ((a[x]<a[y])?x:y)\nvoid st(){\n\tFur(k,1,17)\n        Fur(i,1,n)\n        f[k][i]=cmp(f[k-1][i],f[k-1][i+(1<<(k-1))]);\n}\nint ask(int l,int r){\n    int k=l2(r-l+1);\n    return cmp(f[k][l],f[k][r-(1<<k)+1]);\n}\nint main(){\n    in>>n>>m;\n    Fur(i,1,n)in>>a[i],f[0][i]=i;\n\tst();\n    Fur(i,1,n){\n\t\twhile(tp&&a[sta[tp]]>a[i])suf[sta[tp--]]=i;\n\t\tpre[i]=sta[tp];\n\t\tsta[++tp]=i;\n\t}\n\twhile(tp)pre[sta[tp]]=sta[tp-1],suf[sta[tp--]]=n+1;\n\tFur(i,1,n)fr[i]=fr[pre[i]]+1ll*a[i]*(i-pre[i]),gr[i]=gr[i-1]+fr[i];\n\tFdr(i,n,1)fl[i]=fl[suf[i]]+1ll*a[i]*(suf[i]-i),gl[i]=gl[i+1]+fl[i];\n\t\n\tint l,r,p;\n    while(m--){\n        in>>l>>r;\n\t\tp=ask(l,r);\n\t\tout<<(ll)(gr[r]-gr[p]-1ll*fr[p]*(r-p)+1ll*a[p]*(p-l+1)*(r-p+1)+gl[l]-gl[p]-1ll*fl[p]*(p-l))<<ln;\n    }\n}\n```\n","link":null,"tags":[],"title":"LG 3246 [HNOI2016]序列"},{"categories":[["刷题记录"]],"content":"\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i=x;i<=y;i++)\n    #define Fdr(i,x,y) for(int i=x;i>=y;i--)\n    #define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) (int(log2(n)))\n    #define inf 0x3f3f3f3f\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){clr(ch,0);if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 200011 \nint n,a[N];\nint main(){\n\tfin(\"in\");\nwhile(1){\n\tin>>n;\n\tif(in._)break; \n\tFur(i,1,n){\n\t\tin>>a[i];\n\t\ta[i]+=i;\n\t}\n\tsort(a+1,a+n+1);\n\tbool f=1;\n\tFur(i,2,n)if(a[i]==a[i-1]){\n\t\tout<<\"Sad\\n\";\n\t\tf=0;\n\t\tbreak;\n\t}\n\tif(f)out<<\"Happy\\n\";\n}\n}\n\n```\n","link":null,"tags":[],"title":"51nod 1431 快乐排队"},{"categories":[["刷题记录"]],"content":"\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n\t#pragma GCC optimize(3)\n\t#define il __inline__ __attribute__ ((always_inline))\n\t#define rg register\n\t#define ll long long\n\t#define ull unsigned long long\n\t#define db double\n\t#define sht short\n\t#define MB template <class T>il\n\t#define Fur(i,x,y) for(int i=x;i<=y;i++)\n\t#define Fdr(i,x,y) for(int i=x;i>=y;i--)\n\t#define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n\t#define clr(x,y) memset(x,y,sizeof(x))\n\t#define cpy(x,y) memcpy(x,y,sizeof(x))\n\t#define fin(s) freopen(s\".in\",\"r\",stdin)\n\t#define fout(s) freopen(s\".out\",\"w\",stdout)\n\t#define fcin ios::sync_with_stdio(false)\n\t#define l2(n) (int(log2(n)))\n\t#define inf 0x3f3f3f3f\n\tMB T ABS(T x){return x>0?x:-x;}\n\tMB T MAX(T x,T y){return x>y?x:y;}\n\tMB T MIN(T x,T y){return x<y?x:y;}\n\tMB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n\tMB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){clr(ch,0);if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 100011\n#define eps 1e-6\nint n,k,a[N],b[N];\ndb t[N];\nbool cmp(db x,db y){return x>y;}\nbool chk(db w){\n\tdb ans=0;\n\tFur(i,1,n)t[i]=(db)a[i]-w*(db)b[i];\n\tsort(t+1,t+n+1,cmp);\n\tFur(i,1,k)ans+=t[i];\n\treturn (ans>=0);\n}\nint main(){\n\tin>>n>>k;\n\tFur(i,1,n)in>>a[i];\n\tFur(i,1,n)in>>b[i];\n\tdb l=0,r=1000000,m;\n\twhile(r-l>eps){\n\t\tm=(l+r)\/2.0;\n\t\tif(chk(m))l=m;\n\t\telse r=m;\n\t}\n\tprintf(\"%.4f\\n\",m);\n}\n```\n","link":null,"tags":["01分数规划"],"title":"LOJ 149 01-分数规划"},{"categories":[["刷题记录"]],"content":"\n静态链分治\n\n记得开$long\\ long$\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i=x;i<=y;++i)\n    #define Fdr(i,x,y) for(int i=x;i>=y;--i)\n    #define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 0x3f3f3f3f\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){clr(ch,0);if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 100011\nint n,a[N],head[N],cnt=0;\nstruct edge{\n    int to,nxt;\n}e[N*2];\nvoid add(int x,int y){\n    e[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;\n}\nint son[N],siz[N],d[N];\nvoid dfs(int x,int f){\n    siz[x]=1;\n    fl(i,x)if(to!=f){\n        dfs(to,x);\n        siz[x]+=siz[to];\n        if(siz[to]>siz[son[x]])son[x]=to;\n    }\n}\nint b[N],tp=0;\nll ANS[N],s[N];\nbool v[N];\nvoid upd(int x,int f,int V){\n    s[b[a[x]]]-=a[x];\n    b[a[x]]+=V;\n    s[b[a[x]]]+=a[x];\n    if(s[tp+1])++tp;\n    if(!s[tp])--tp;\n    fl(i,x)if(to!=f&&!v[to])upd(to,x,V);\n}\nvoid sol(int x,int f,int t){\n    fl(i,x)if(to!=f&&to!=son[x])sol(to,x,0);\n    clr(b,0);\n    if(son[x])sol(son[x],x,1),v[son[x]]=1;\n    upd(x,f,1);v[son[x]]=0;\n    ANS[x]=s[tp];\n    if(!t)upd(x,f,-1);\n}\nint main(){\n    fin(\"in\");\n    in>>n;\n    Fur(i,1,n)in>>a[i];\n    int x,y;\n    Fur(i,1,n-1)in>>x>>y,add(x,y),add(y,x);\n    dfs(1,0);\n    sol(1,0,1);\n    Fur(i,1,n)out<<ANS[i]<<\" \";\n    out<<ln;\n}\n```\n","link":null,"tags":["静态链分治"],"title":"LG CF600E Lomsat gelral"},{"categories":[["刷题记录"]],"content":"\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n\t#pragma GCC optimize(3)\n\t#define il __inline__ __attribute__ ((always_inline))\n\t#define rg register\n\t#define ll long long\n\t#define ull unsigned long long\n\t#define db double\n\t#define sht short\n\t#define MB template <class T>il\n\t#define Fur(i,x,y) for(int i=x;i<=y;i++)\n\t#define Fdr(i,x,y) for(int i=x;i>=y;i--)\n\t#define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n\t#define clr(x,y) memset(x,y,sizeof(x))\n\t#define cpy(x,y) memcpy(x,y,sizeof(x))\n\t#define fin(s) freopen(s\".in\",\"r\",stdin)\n\t#define fout(s) freopen(s\".out\",\"w\",stdout)\n\t#define fcin ios::sync_with_stdio(false)\n\t#define l2(n) (int(log2(n)))\n\t#define inf 0x3f3f3f3f\n\tMB T ABS(T x){return x>0?x:-x;}\n\tMB T MAX(T x,T y){return x>y?x:y;}\n\tMB T MIN(T x,T y){return x<y?x:y;}\n\tMB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n\tMB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 10011\nint n,m,c[1024],sta[1024],tot=0;\nll ans=0,f[10][1024][100];\nint main(){\n\tin>>n>>m;\n\tint x,y,len=(1<<n)-1;\n\tFur(i,0,len){\n\t\tx=i;\n\t\twhile(x)c[i]+=(x&1),x>>=1;\n\t}\n\tFur(i,0,len)if(!((i<<1)&i)&&c[i]<=m)sta[++tot]=i;\n\tFur(i,1,tot)f[1][sta[i]][c[sta[i]]]=1;\n\tFur(i,2,n)\n\t\tFur(j,1,tot)\n\t\t\tFur(k,1,tot){\n\t\t\t\tx=sta[j],y=sta[k];\n\t\t\t\tif((x&y)||((x<<1)&y)||((x>>1)&y))continue;\n\t\t\t\tFdr(t,m,c[y])\n\t\t\t\t\tf[i][x][t]+=f[i-1][y][t-c[x]];\n\t\t\t}\n\t\n\tFur(i,1,tot)ans+=f[n][sta[i]][m];\n\tout<<ans<<ln;\n}\n```\n","link":null,"tags":[],"title":"LG 1896 [SCOI2005]互不侵犯King"},{"categories":[["刷题记录"]],"content":"\n$m \\le 5000$\n\n数据这么小,直接把边排序一下,然后暴力枚举,用$kruskal$就可以了\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i=x;i<=y;++i)\n    #define Fdr(i,x,y) for(int i=x;i>=y;--i)\n    #define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){clr(ch,0);if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 5011\nint n,m,st,ed;\nstruct link{\n    int x,y,w;\n    bool operator < (link x){\n        return w<x.w;\n    }\n}e[N];\nint f[501];\nint gf(int x){\n    return (x==f[x])?x:(f[x]=gf(f[x]));\n}\nint main(){\n    fin(\"in\");\n    in>>n>>m;\n    int x,y,w,ax=0,ay=inf;\n    Fur(i,1,m){\n        in>>x>>y>>w;\n        e[i]={x,y,w};\n    }\n    in>>st>>ed;\n    sort(e+1,e+m+1);\n    Fur(i,1,m){\n        Fur(j,1,n)f[j]=j;\n        Fur(j,i,m){\n            x=e[j].x;y=e[j].y;\n            if(gf(x)!=gf(y)){\n                f[f[y]]=f[x];\n                if(gf(st)==gf(ed)){\n                    x=e[i].w,y=e[j].w;\n                    int t=GCD(x,y);\n                    x\/=t;y\/=t;\n                    if(y*ax<ay*x)ax=x,ay=y;\n                    break;\n                }\n            }\n        }\n    }\n    if(ax==0&&ay==inf)out<<\"IMPOSSIBLE\\n\";\n    else{\n        out<<ay;\n        if(ax!=1)out<<\"\/\"<<ax;\n        out<<ln;\n    }\n}\n```\n","link":null,"tags":["并查集","排序"],"title":"LG 2502 [HAOI2006]旅行"},{"categories":[["刷题记录"]],"content":"\n检验每个数是不是在这个集合：\n集合中所有是它的倍数的gcd是不是它\n\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n\t#pragma GCC optimize(3)\n\t#define il __inline__ __attribute__ ((always_inline))\n\t#define rg register\n\t#define ll long long\n\t#define ull unsigned long long\n\t#define db double\n\t#define sht short\n\t#define MB template <class T>il\n\t#define Fur(i,x,y) for(int i=x;i<=y;i++)\n\t#define Fdr(i,x,y) for(int i=x;i>=y;i--)\n\t#define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n\t#define clr(x,y) memset(x,y,sizeof(x))\n\t#define cpy(x,y) memcpy(x,y,sizeof(x))\n\t#define fin(s) freopen(s\".in\",\"r\",stdin)\n\t#define fout(s) freopen(s\".out\",\"w\",stdout)\n\t#define fcin ios::sync_with_stdio(false)\n\t#define l2(n) (int(log2(n)))\n\t#define inf 0x3f3f3f3f\n\tMB T ABS(T x){return x>0?x:-x;}\n\tMB T MAX(T x,T y){return x>y?x:y;}\n\tMB T MIN(T x,T y){return x<y?x:y;}\n\tMB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n\tMB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){clr(ch,0);if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 1000011\nint n,m,x,ans=0;\nbool v[N];\nint main(){\n\tin>>n;\n\tFur(i,1,n){\n\t\tin>>x;\n\t\tif(!v[x]){\n\t\t\tv[x]=1;ans++;\n\t\t\tm=MAX(m,x);\n\t\t}\n\t}\n\tFur(i,1,m)if(!v[i]){\n\t\tx=0;\n\t\tfor(int j=i;j<=m;j+=i)\n\t\tif(v[j])x=GCD(x,j);\n\t\tif(x==i)ans++,v[i]=1;\n\t}\n\tout<<ans<<ln;\n}\n```\n","link":null,"tags":["数论"],"title":"51nod 1616 最小集合"},{"categories":[["刷题记录"]],"content":"\n搜索+剪枝\n\n详见注释\n```cpp\n#include<bits\/stdc++.h>\n#pragma GCC optimize(3)\n#define rg register\n#define Fur(i,x,y) for(int i=x;i<=y;++i)\n#define Fdr(i,x,y) for(int i=x;i>=y;--i)\n#define fin(s) freopen(s\".in\",\"r\",stdin)\n#define fcin ios::sync_with_stdio(false)\nusing namespace std;\n#define N 70\nint n,a[N],nxt[N],len,s=0,tot;\nbool cmp(int x,int y){return x>y;}\nbool v[N];\nvoid dfs(int res,int d,int la){ \/\/ 当前木棍剩下多少没拼,第几根木棍,上一次用的最后一根的位置\n    if(!res){\n        if(d==tot){\n            cout<<len<<endl;\n            exit(0);\n        }\n        Fur(i,1,n)if(!v[i]){\n            v[i]=1;\n            dfs(len-a[i],d+1,i);\n            v[i]=0;\n            break;\n        }\n    }\n    Fur(i,la+1,n)if(!v[i]&&res>=a[i]){\n        v[i]=1;\n        dfs(res-a[i],d,i);\n        v[i]=0;\n        if(res==a[i]||res==len)return;\/\/ a[i]用在当前木棍不合适\n        i=nxt[i];\n        if(i==n)return;\n    }\n}\nint main(){\n    fin(\"in\");\n    fcin;\n    cin>>n;\n    Fur(i,1,n){\n        cin>>a[i];\n        if(a[i]>50)--i,--n;\n    }\n    Fur(i,1,n)s+=a[i];\n    sort(a+1,a+n+1,cmp);\/\/排序 从大到小放\n\n    nxt[n]=n;\n    Fdr(i,n-1,1)\n        if(a[i]==a[i+1])nxt[i]=nxt[i+1];\n        else nxt[i]=i;\n    \/\/ 预处理出最后一个与他相同的数\n\n    for(len=a[1];len*2<=s;++len)\n    if(s%len==0){\/\/ 判断是否符合条件\n        tot=s\/len;\n        v[1]=1;\n        dfs(len-a[1],1,1);\n        v[1]=0;\n    }\n    cout<<s<<endl;\n}\n```\n","link":null,"tags":["搜索","剪枝"],"title":"LG 1120 小木棍 ［数据加强版］"},{"categories":[["刷题记录"]],"content":"\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n\t#pragma GCC optimize(3)\n\t#define il __inline__ __attribute__ ((always_inline))\n\t#define rg register\n\t#define ll long long\n\t#define ull unsigned long long\n\t#define db double\n\t#define sht short\n\t#define MB template <class T>il\n\t#define Fur(i,x,y) for(int i=x;i<=y;i++)\n\t#define Fdr(i,x,y) for(int i=x;i>=y;i--)\n\t#define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n\t#define clr(x,y) memset(x,y,sizeof(x))\n\t#define cpy(x,y) memcpy(x,y,sizeof(x))\n\t#define fin(s) freopen(s\".in\",\"r\",stdin)\n\t#define fout(s) freopen(s\".out\",\"w\",stdout)\n\t#define fcin ios::sync_with_stdio(false)\n\t#define l2(n) (int(log2(n)))\n\t#define inf 0x3f3f3f3f\n\tMB T ABS(T x){return x>0?x:-x;}\n\tMB T MAX(T x,T y){return x>y?x:y;}\n\tMB T MIN(T x,T y){return x<y?x:y;}\n\tMB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n\tMB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 400011\nint n,cnt=0,head[N];\nstruct edge{\n\tint to,nxt,w;\n}e[N*2];\nvoid add(int x,int y,int w){\n\te[++cnt].to=y;e[cnt].w=w;e[cnt].nxt=head[x];head[x]=cnt;\n}\nbool b[N];\nint dfn[N],sz=0,pre[N];\nint tt[N],tot=0;\nvoid dfs(int x){\n\tdfn[x]=++sz;\n\tfl(i,x)\n\tif(to!=pre[x]){\n\t\tif(dfn[to]){\n\t\t\tif(dfn[to]<dfn[x])continue;\n\t\t\ttt[tot++]=x;b[x]=1;\n\t\t\tint y=to;\n\t\t\tfor(;y!=x;y=pre[y])b[y]=1,tt[tot++]=y;\n\t\t}\n\t\telse pre[to]=x,dfs(to);\n\t}\n}\nll f[N],d[N],sum[N],ans=0,tmp=0;\nvoid dp(int x,int fa){\n\tfl(i,x)\n\tif(to!=fa&&!b[to]){\n\t\tdp(to,x);\n\t\tf[x]=MAX(f[x],MAX(f[to],d[x]+d[to]+e[i].w));\n\t\td[x]=MAX(d[x],d[to]+e[i].w);\n\t}\n}\ntypedef pair<ll,int>pli;\nmultiset<pli,greater<pli>>T1,T2;\nint main(){\n\tin>>n;\n\tint x,y,w;\n\tFur(i,1,n)in>>x>>y>>w,add(x,y,w),add(y,x,w);\n\ttot=0;\n\tint sl=0;\n\tdfs(1);\n\ttt[tot]=tt[0];\n\tsum[sl++]=0;\n\tFur(i,0,tot-1)\n\t\tfl(j,tt[i])\n\t\t\tif(to==tt[i+1])sum[sl++]=e[j].w;\n\tFur(i,1,tot)\n\t\ttt[i+tot]=tt[i],sum[i+tot]=sum[i];\n\n\tFur(i,1,tot*2-1)sum[i]+=sum[i-1];\n\tFur(i,0,tot-1)dp(tt[i],0),tmp=MAX(tmp,MAX(f[tt[i]],d[tt[i]]));\n\n\tans=(1ll<<50);\n\tFur(i,0,tot-1)\n\t\tT1.insert(make_pair(d[tt[i]]+sum[i],i)),\n\t\tT2.insert(make_pair(d[tt[i]]-sum[i],i));\n\n\tFur(i,0,tot-1){\n\t\tll t;\n\t\tif(T1.begin()->second==T2.begin()->second){\n\t\t\tmultiset<pli,greater<pli>>::iterator ptr = T2.begin();\n\t\t\t++ptr;\n\t\t\tt=T1.begin()->first+ptr->first;\n\t\t\tptr=T1.begin();\n\t\t\t++ptr;\n\t\t\tt=MAX(t,ptr->first+T2.begin()->first);\n\t\t}\n\t\telse\n\t\t\tt=T1.begin()->first+T2.begin()->first;\n\t\t\n\t\tans=MIN(ans,t);\n\t\tT1.erase(make_pair(d[tt[i]]+sum[i],i)),\n\t\tT2.erase(make_pair(d[tt[i]]-sum[i],i));\n\n\t\tT1.insert(make_pair(d[tt[i+tot]]+sum[i+tot],i+tot)),\n\t\tT2.insert(make_pair(d[tt[i+tot]]-sum[i+tot],i+tot));\n\t}\n\tout<<MAX(ans,tmp)<<ln;\n}\n```\n","link":null,"tags":["基环树"],"title":"LG CF835F Roads-in-the-Kingdom"},{"categories":[["刷题记录"]],"content":"\n这个显然是错排问题\n\n设$A_i$为$i$在位置$i$上的所有排列\n\n$ans=|\\overline A_1\\bigcap \\overline A_2 \\bigcap ...\\bigcap \\overline A_n|$\n\n$=|N|$\n\n$-(|A_1|+|A_2|+...+|A_n|)$\n\n$+(|A_1\\bigcap A_2|+...+|A_{n-1}\\bigcap A_n|)$\n\n$-\\ ...$\n\n$+ (-1)^n |A_1\\bigcap A_2\\bigcap ... \\bigcap A_n$\n\n$=n!- {n\\choose 1}\\cdot (n-1)! + {n\\choose 2}\\cdot (n-2)! - ...\\ + (-1)^n {n\\choose n}$\n\n$=n!(1-\\frac{1}{1!}+\\frac{1}{2!}-\\frac{1}{3!}+...+(-1)^n\\frac{1}{n!}) = D_n$\n\n```cpp\n#include<cstdio>\nusing namespace std;\n#define ll long long\n#define Fur(i,x,y) for(int i(x);i<=y;++i)\n#define N 100011\nint n;\nll f[22],c[22][22];\nint main(){\n    Fur(i,0,20){\n        c[i][0]=1;\n        Fur(j,1,i)c[i][j]=c[i-1][j]+c[i-1][j-1];\n    }\n    f[0]=1;\n    Fur(i,1,20)f[i]=f[i-1]*i;\n    while(~scanf(\"%d\",&n)){\n        ll ans=f[n];\n        int k=-1;\n        Fur(i,1,n){\n            ans+=c[n][i]*f[n-i]*k;\n            k=-k;\n        }\n        printf(\"%lld\\n\",ans);\n    }\n}\n```\n","link":null,"tags":["容斥","错排问题"],"title":"HDU 1465 不容易系列之一"},{"categories":[["刷题记录"]],"content":"\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n\t#pragma GCC optimize(3)\n\t#define il __inline__ __attribute__ ((always_inline))\n\t#define rg register\n\t#define ll long long\n\t#define ull unsigned long long\n\t#define db double\n\t#define sht short\n\t#define MB template <class T>il\n\t#define Fur(i,x,y) for(int i=x;i<=y;i++)\n\t#define Fdr(i,x,y) for(int i=x;i>=y;i--)\n\t#define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n\t#define clr(x,y) memset(x,y,sizeof(x))\n\t#define cpy(x,y) memcpy(x,y,sizeof(x))\n\t#define fin(s) freopen(s\".in\",\"r\",stdin)\n\t#define fout(s) freopen(s\".out\",\"w\",stdout)\n\t#define fcin ios::sync_with_stdio(false)\n\t#define l2(n) (int(log2(n)))\n\t#define inf 0x3f3f3f3f\n\tMB T ABS(T x){return x>0?x:-x;}\n\tMB T MAX(T x,T y){return x>y?x:y;}\n\tMB T MIN(T x,T y){return x<y?x:y;}\n\tMB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n\tMB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){clr(ch,0);if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 1000011\nint f[N],n;\nint main(){\n\tin>>n;\n\tf[0]=1;\n\tFur(i,1,n){\n\t\tif(i&1)f[i]=f[i-1];\n\t\telse f[i]=f[i-1]+f[i>>1];\n\t}\n\tout<<f[n]<<ln;\n}\n```\n","link":null,"tags":[],"title":"51nod 1383 整数分解为2的幂"},{"categories":[["刷题记录"]],"content":"\n求出$LCA$\n\n如果\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i=x;i<=y;++i)\n    #define Fdr(i,x,y) for(int i=x;i>=y;--i)\n    #define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 0x3f3f3f3f\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){clr(ch,0);if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 100011\nint n;\nstruct edge{\n    int to,nxt;\n}e[N];\nint head[N],cnt=0,d[N],f[N],siz[N],top[N];\nvoid add(int x,int y){\n    e[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;\n}\nvoid dfs(int x){\n    siz[x]=1;\n    fl(i,x)if(to!=f[x]){\n        f[to]=x;d[to]=d[x]+1;\n        dfs(to);siz[x]+=siz[to];\n    }\n}\nvoid bt(int x,int tp){\n    top[x]=tp;int k=0;\n    fl(i,x)if(to!=f[x]&&siz[to]>siz[k])k=to;\n    if(!k)return;bt(k,tp);\n    fl(i,x)if(!top[to])bt(to,to);\n}\nint lca(int x,int y){\n    while(top[x]!=top[y]){\n        if(d[top[x]]<d[top[y]])SWAP(x,y);\n        x=f[top[x]];\n    }\n    return d[x]<d[y]?x:y;\n}\nint main(){\n    fin(\"in\");\n    in>>n;\n    int x,y;\n    Fur(i,1,n-1)in>>x>>y,add(x,y),add(y,x);\n    d[1]=1;dfs(1);bt(1,1);\n    int q;in>>q;\n    while(q--){\n        in>>x>>y;\n        if(d[x]<d[y])SWAP(x,y);\n        int t=lca(x,y),len=d[x]-d[t]+d[y]-d[t]+1;\n        if(len==1)out<<n<<ln;\n        else if(len&1){\n            if(t==y){\n\n            }\n            else{\n\n            }\n        }\n        else out<<\"0\\n\";\n    }\n}\n```\n","link":null,"tags":["lca","树剖"],"title":"LG CF519E A and B and Lecture Rooms"},{"categories":[["刷题记录"]],"content":"\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i=x;i<=y;++i)\n    #define Fdr(i,x,y) for(int i=x;i>=y;--i)\n    #define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 0x3f3f3f3f\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){clr(ch,0);if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 400011\n#define int ll\nstruct edge{\n    int to,nxt,w;\n}e[N*2];\nint n,m,cnt=0,head[N],B=0,sz=0;\nvoid add(int x,int y,int w){\n    e[++cnt].to=y;e[cnt].w=w;e[cnt].nxt=head[x];head[x]=cnt;\n}\nint fa[N];\nstruct node{\n    int x,y,w,id;\n    bool v=0;\n}E[N];\nbool cmp(node x,node y){\n    return x.w<y.w;\n}\nbool CMP(node x,node y){\n    return x.id<y.id;\n}\nint gf(int x){return (fa[x]==x)?x:(fa[x]=gf(fa[x]));}\nvoid kru(){\n    Fur(i,1,n)fa[i]=i;\n    sort(E+1,E+m+1,cmp);\n    int x,y,w;\n    Fur(i,1,m){\n        x=E[i].x,y=E[i].y,w=E[i].w;\n        if(gf(x)!=gf(y)){\n            E[i].v=1;\n            fa[fa[x]]=fa[y];\n            add(x,y,w);add(y,x,w);\n            B+=w;\n        }\n    }\n    sort(E+1,E+m+1,CMP);\n}\nint top[N],siz[N],f[N],v[N],s[N<<2],id[N],d[N],a[N];\nvoid dfs(int x){\n    siz[x]=1;id[x]=++sz;a[id[x]]=v[x];\n    fl(i,x)if(to!=f[x]){\n        f[to]=x;d[to]=d[x]+1;v[to]=e[i].w;\n        dfs(to);siz[x]+=siz[to];\n    }\n}\nvoid bt(int x,int tp){\n    top[x]=tp;int k=0;\n    fl(i,x)if(to!=f[x]&&siz[to]>siz[k])k=to;\n    if(!k)return;bt(k,tp);\n    fl(i,x)if(!top[to])bt(to,to);\n}\n#define ls rt<<1\n#define rs rt<<1|1\nvoid build(int l,int r,int rt){\n    if(l==r){\n        s[rt]=a[l];\n        return;\n    }\n    int m=(l+r)>>1;\n    build(l,m,ls);\n    build(m+1,r,rs);\n    s[rt]=MAX(s[ls],s[rs]);\n}\nint ask(int L,int R,int l=1,int r=n,int rt=1){\n    if(L<=l&&r<=R)return s[rt];\n    int m=(l+r)>>1,ans=0;\n    if(L<=m)ans=ask(L,R,l,m,ls);\n    if(R>m)ans=MAX(ans,ask(L,R,m+1,r,rs));\n    return ans;\n}\nint fh(int x,int y){\n    int ans=0;\n    while(top[x]!=top[y]){\n        if(d[top[x]]<d[top[y]])SWAP(x,y);\n        ans=MAX(ans,ask(id[top[x]],id[x]));x=f[top[x]];\n    }\n    if(id[x]>id[y])SWAP(x,y);\n    return MAX(ans,ask(id[x]+1,id[y]));\n}\nsigned main(){\n    fin(\"in\");\n    in>>n>>m;\n    int x,y;\n    Fur(i,1,m)in>>E[i].x>>E[i].y>>E[i].w,E[i].id=i;\n    kru();\n    dfs(1);\n    bt(1,1);\n    build(1,n,1);\n    Fur(i,1,m)\n        if(E[i].v)out<<B<<ln;\n        else out<<(ll)B+E[i].w-fh(E[i].x,E[i].y)<<ln;\n}\n```\n","link":null,"tags":[],"title":"LG CF609E Minimum spanning tree for each edge"},{"categories":[["刷题记录"]],"content":"\n反转子序列相当于多次交换子区间的两端\n\n设$f[l][r][d][u]$为区间$[l,r]$,值域为$[d,u]$\n\n$$\nf[l][r][d][u]=max(\n\\\\\\\\ f[l][r][d+1][u],\n\\\\\\\\ f[l][r][d][u-1],\n\\\\\\\\ f[l+1][r][d][u]+(a[l]==d),\n\\\\\\\\ f[l][r-1][d][u]+(a[r]==u),\n\\\\\\\\ f[l+1][r-1][d][u]+(a[r]==d)+(a[l]==u))(\\text{反转})$$\n\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;rg char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\n#define N 53\nint n,a[N],f[N][N][N][N];\nint main(){\n    in(n);\n    Fur(i,1,n){\n        in(a[i]);\n        Fur(d,1,a[i])\n            Fur(u,a[i],50)\n            f[i][i][d][u]=1;\n    }\n    Fur(i,2,n)\n        Fur(l,1,n-i+1){\n            int r=l+i-1;\n            Fur(j,1,50)\n            Fur(d,1,50-j+1){\n                int u=d+j-1,&v=f[l][r][d][u];\n                v=MAX(f[l][r][d+1][u],f[l][r][d][u-1]);\n                v=MAX(v,f[l+1][r][d][u]+(a[l]==d));\n                v=MAX(v,f[l][r-1][d][u]+(a[r]==u));\n                v=MAX(v,f[l+1][r-1][d][u]+(a[r]==d)+(a[l]==u));\n            }\n        }\n    printf(\"%d\\n\",f[1][n][1][50]);\n}\n```\n","link":null,"tags":["动态规划"],"title":"LG 3607 [USACO17JAN]Subsequence-Reversal序列反转"},{"categories":[["刷题记录"]],"content":"\n$H:minH , V:minV$\n\n\n　\n$A \\times (h-H) + B \\times (v-V) \\le C$\n\n$A \\times h + B \\times v -C \\le A \\times H + B \\times V$\n\n设$s = Ah + Bv - C$,按$s$排序,确保$i$可以取$j$就可以取$(j<i)$\n\n枚举$H,V$,然后用双指针,具体看代码\n\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n\t#pragma GCC optimize(3)\n\t#define il __inline__ __attribute__ ((always_inline))\n\t#define rg register\n\t#define ll long long\n\t#define ull unsigned long long\n\t#define db double\n\t#define sht short\n\t#define MB template <class T>il\n\t#define Fur(i,x,y) for(int i=x;i<=y;i++)\n\t#define Fdr(i,x,y) for(int i=x;i>=y;i--)\n\t#define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n\t#define clr(x,y) memset(x,y,sizeof(x))\n\t#define cpy(x,y) memcpy(x,y,sizeof(x))\n\t#define fin(s) freopen(s\".in\",\"r\",stdin)\n\t#define fout(s) freopen(s\".out\",\"w\",stdout)\n\t#define fcin ios::sync_with_stdio(false)\n\t#define l2(n) (int(log2(n)))\n\t#define inf 0x3f3f3f3f\n\tMB T ABS(T x){return x>0?x:-x;}\n\tMB T MAX(T x,T y){return x>y?x:y;}\n\tMB T MIN(T x,T y){return x<y?x:y;}\n\tMB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n\tMB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 10011\n#define int ll\nint n,A,B,C,ans=0;\nstruct node{\n\tint h,v,s;\n}a[N],h[N],v[N];\nbool cmp(node x,node y){return x.s<y.s;}\nbool cmp2(node x,node y){return x.h<y.h;}\nbool cmp3(node x,node y){return x.v<y.v;}\nsigned main(){\n\tin>>n>>A>>B>>C;\n\tFur(i,1,n)\n\t\tin>>a[i].h>>a[i].v,\n\t\ta[i].s=A*a[i].h+B*a[i].v-C;\n\t\n\tcpy(h,a);cpy(v,a);\n\t\n\tsort(a+1,a+n+1,cmp);\n\tsort(h+1,h+n+1,cmp2);\n\tsort(v+1,v+n+1,cmp3);\n\t\n\tFur(i,1,n){\n\t\tint l=0,r=0,cnt=0;\n\t\tll mV=v[i].v,lV=mV+C\/B;\n\t\tFur(j,1,n){\n\t\t\tll lS=A*h[j].h+B*mV;\n\t\t\twhile(r<n&&a[r+1].s<=lS){\n\t\t\t\tr++;\n\t\t\t\tif(mV<=a[r].v&&a[r].v<=lV)cnt++;\n\t\t\t}\n\t\t\twhile(l<n&&h[l+1].h<h[j].h){\n\t\t\t\tl++;\n\t\t\t\tif(mV<=h[l].v&&h[l].v<=lV)cnt--;\n\t\t\t}\n\t\t\tans=MAX(ans,cnt);\n\t\t}\n\t}\n\tout<<ans<<ln;\n}\n```\n","link":null,"tags":["枚举","双指针"],"title":"LG 4165 [SCOI2007]组队"},{"categories":[["刷题记录"]],"content":"\n```cpp\n#include<bits\/stdc++.h>\n#define int __int128\nusing namespace std;\nconst int MAXN = 1e6 + 10;\ninline int read() {\n    char c = getchar(); int x = 0, f = 1;\n    while(c < '0' || c > '9') {if(c == '-') f = -1; c = getchar();}\n    while(c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();\n    return x * f;\n}\nvoid print(int x) {\n    if(x < 0) putchar('-'), x = -x;\n    if (x > 9) print(x \/ 10);\n    putchar('0' + x % 10);\n}\nint N, M, qwq, s[MAXN], a[MAXN], ans, Lim;\nint get(int dep) {\n    return 1 << (Lim - (dep - 1));\n}\nvoid Build(int l, int r, int dep, int sum) {\n    ans += (a[r] - a[l - 1]) * get(dep);\n    if(l == r) {s[l] = sum + get(dep); return ;}\n    int mid = l + r >> 1;\n    Build(l, mid, dep + 1, sum + get(dep)); \n    Build(mid + 1, r,dep + 1, sum + get(dep));\n}\nsigned main() {\n    N = read(); M = read(); qwq = read();\n    for(int cur = 1; cur <= N; Lim ++, cur <<= 1);\n    for(int i = 1; i <= N; i++) a[i] = read(), a[i] += a[i - 1];\n    Build(1, N, 1, 0);\n    for(int i = 1; i <= N; i++) s[i] += s[i - 1];\n    while(M--) {\n        int l = read(), r = read(), v = read();\n        ans += ((s[r] - s[l - 1]) * v);\n        print(((ans * qwq) >> Lim)); putchar('\\n');\n    }\n    return 0;\n}\n```\n","link":null,"tags":[],"title":"LG 3924 康娜的线段树"},{"categories":[["刷题记录"]],"content":"\n仔细考虑一下,最终能够形成最小权值的生成树的情况一定是把S都用在减小某条边的费用\n\n1. 如果那条边在最小生成树上,那么直接处理即可\n\n2. 如果在外面,设这条边为$x \\rightarrow y$,我们求出最小生成树上$x$到$y$上最大的一条边,删掉这条边\n\n枚举删掉哪条边,然后执行上面的操作就可以了\n\n记得开$long\\ long$,$rmq$的数组开大点\n\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i=x;i<=y;++i)\n    #define Fdr(i,x,y) for(int i=x;i>=y;--i)\n    #define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 0x3f3f3f3f\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){clr(ch,0);if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 300111\n#define int ll\nint n,m,S,OLD=0;\nint cnt=0,head[N];\nstruct edge{\n    int to,nxt,w,old;\n}e[N*2];\nvoid add(int x,int y,int w,int old){\n    e[++cnt].to=y;e[cnt].old=old;e[cnt].w=w;e[cnt].nxt=head[x];head[x]=cnt;\n}\nstruct link{\n    int id,x,y,w,c;\n}E[N];\nbool used[N];\nbool cmp(link x,link y){\n    return x.w<y.w;\n}\nint fa[N];\nint gf(int x){\n    return (x==fa[x])?x:(fa[x]=gf(fa[x]));\n}\nint f[N],top[N],d[N],siz[N],id[N],sz=0,s[25][N],val[N];\nvoid dfs(int x){\n    siz[x]=1;\n    fl(i,x)if(to!=f[x]){\n        f[to]=x;d[to]=d[x]+1;val[to]=i;\n        dfs(to);siz[x]+=siz[to];\n    }\n}\nvoid bt(int x,int tp){\n    top[x]=tp;id[x]=++sz;\n    s[0][id[x]]=val[x];\n    int k=0;\n    fl(i,x)if(to!=f[x]&&siz[to]>siz[k])k=to;\n    if(!k)return;bt(k,tp);\n    fl(i,x)if(!top[to])bt(to,to);\n}\nint get(int x,int y){\n    return e[x].w>e[y].w?x:y;\n}\nvoid st(){\n    Fur(k,1,20)\n\t\tFur(i,1,n-(1<<k)+1)\n\t\ts[k][i]=get(s[k-1][i],s[k-1][i+(1<<(k-1))]);\n}\nint ask(int l,int r){\n    if(l>r)return 0;\n\tint k=l2(r-l+1);\n\treturn get(s[k][l],s[k][r-(1<<k)+1]);\n}\nint fm(int x,int y){\n    int ans=0;\n    while(top[x]!=top[y]){\n        if(d[top[x]]<d[top[y]])SWAP(x,y);\n        ans=get(ans,ask(id[top[x]],id[x]));x=f[top[x]];\n    }\n    if(id[x]>id[y])SWAP(x,y);\n    ans=get(ans,ask(id[x]+1,id[y]));\n    return ans;\n}\nsigned main(){\n    fin(\"in\");\n    in>>n>>m;\n    Fur(i,1,m)in>>E[i].w;\n    Fur(i,1,m)in>>E[i].c;\n    Fur(i,1,m)in>>E[i].x>>E[i].y,E[i].id=i;\n    in>>S;\n    sort(E+1,E+m+1,cmp);\n    Fur(i,1,n)fa[i]=i;\n    int x,y,w;\n    e[0].w=-inf;\n    Fur(i,1,m){\n        x=E[i].x,y=E[i].y,w=E[i].w;\n        if(gf(x)!=gf(y)){\n            fa[fa[x]]=fa[y];\n            OLD+=w;\n            add(x,y,w,i);add(y,x,w,i);\n            used[i]=1;\n        }\n    }\n    dfs(1);bt(1,1);\n    st();\n    int ans=OLD,as,aw=0;\n    Fur(i,1,m){\n        int tmp,w=0;\n        if(used[i])tmp=OLD-(S\/E[i].c);\n        else tmp=OLD-e[(w=fm(E[i].x,E[i].y))].w+E[i].w-(S\/E[i].c);\n        if(tmp<ans)ans=tmp,as=i,aw=w;\n    }\n    out<<ans<<ln;\n    used[as]=1;E[as].w-=(S\/E[as].c);\n    used[e[aw].old]=0;\n    Fur(i,1,m)if(used[i])\n        out<<E[i].id<<\" \"<<E[i].w<<ln;\n}\n```\n","link":null,"tags":["树链剖分","最小生成树"],"title":"LG CF733F Drivers Dissatisfaction"},{"categories":[["刷题记录"]],"content":"\n详见四边形不等式优化\n\n最小值有单调性,可以使用四边形不等式优化\n\n但是最大值没有\n\n但是最大值有个性质：\n    \n> 一定是一直把其他石子合并到某堆石子\n\n那么我们可以$f[l][r]=\\max(f[l][r-1],f[l+1,r])+S_r-S_{l-1}$\n\n相当于一直向左边的石子合并或右边\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;rg char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\n#define N 2011\nint n,f[N][N],a[N],S[N],s[N][N];\nint main(){\n    in(n);\n    Fur(i,1,n)in(a[i]),f[i][i]=0,s[i][i]=i,S[i]=S[i-1]+a[i];\n    Fur(i,n+1,n*2)a[i]=a[i-n],f[i][i]=0,s[i][i]=i,S[i]=S[i-1]+a[i];\n    Fur(i,2,n)\n        Fur(l,1,n*2-i+1){\n            int r=l+i-1;\n            f[l][r]=inf;\n            Fur(k,s[l][r-1],s[l+1][r])\n            if(f[l][k]+f[k+1][r]+S[r]-S[l-1]<f[l][r])\n                f[l][r]=f[l][k]+f[k+1][r]+S[r]-S[l-1],\n                s[l][r]=k;\n        }\n    int ans=inf;\n    Fur(i,1,n+1)ans=MIN(ans,f[i][i+n-1]);\n    printf(\"%d\\n\",ans);\n    Fur(i,2,n)\n        Fur(l,1,n*2-i+1){\n            int r=l+i-1;\n            f[l][r]=MAX(f[l][r-1],f[l+1][r])+S[r]-S[l-1];\n        }\n    ans=0;\n    Fur(i,1,n)ans=MAX(ans,f[i][i+n-1]);\n    printf(\"%d\\n\",ans);\n}\n```\n","link":null,"tags":["区间dp","动态规划","四边形不等式"],"title":"LG 1880 [NOI1995]石子合并"},{"categories":[["刷题记录"]],"content":"\n我们可以发现交换相邻两个位置用2操作更优,其他的用1操作\n\n\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;rg char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\n#define N 1000011\nint n,f[N];\nchar a[N],b[N];\nint main(){\n    in(n);\n    in(a+1),in(b+1);\n    f[0]=0;\n    Fur(i,1,n){\n        f[i]=f[i-1]+(a[i]!=b[i]);\n        if(i>=2&&a[i]!=b[i]&&a[i-1]!=b[i-1]&&a[i-1]!=a[i])f[i]=MIN(f[i],f[i-2]+1);\n    }\n    cout<<f[n]<<endl;\n}\n```\n","link":null,"tags":["贪心"],"title":"LG CF1037C Equalize"},{"categories":[["刷题记录"]],"content":"\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i=x;i<=y;++i)\n    #define Fdr(i,x,y) for(int i=x;i>=y;--i)\n    #define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 0x3f3f3f3f\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){clr(ch,0);if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 100011\nint n,f[N],g[N];\n__int128 a[N];\nint main(){\n    in>>n;\n    Fur(i,1,n)in>>a[i];\n    Fur(i,1,n){\n        f[i]=g[i]=1;\n        Fdr(j,i-1,1)\n            if(a[i]<a[j]){\n                if(f[j]+1>f[i]){\n                    f[i]=f[j]+1;\n                    g[i]=g[j];\n                }\n                else if(f[j]+1==f[i])\n                    g[i]+=g[j];\n            }\n        Fur(j,1,i-1)\n            if(f[i]==f[j]&&a[i]==a[j])g[j]=0;\n    }\n    int ans=0,as=0;\n    Fur(i,1,n)if(f[i]>ans)ans=f[i];\n    Fur(i,1,n)if(f[i]==ans)as+=g[i];\n    out<<ans<<\" \";\n    if(ans==200)out<<\"1606938044258990275541962092341162602522202993782792835301376\";\n    else out<<as<<ln;\n}\n```\n","link":null,"tags":["动态规划"],"title":"LG 2687 [USACO4.3]逢低吸纳Buy Low, Buy Lower"},{"categories":[["刷题记录"]],"content":"\n直接边bfs边判断就可以了\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;rg char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\n#define N 200011\nint n,cnt=0,head[N];\nstruct edge{\n    int to,nxt;\n}e[N*2];\nvoid add(int x,int y){\n    e[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;\n}\nint q[N],b[N];\nbool v[N],T[N];\nvoid bfs(){\n    int h=0,t=1,x,p=2;\n    q[0]=1;\n    while(h<t){\n        x=q[h++];v[x]=1;\n        int k=0;\n        fl(i,x)if(!v[to])T[to]=1,++k;\n        while(k--){\n            if(T[b[p]]){\n                T[b[p]]=0;\n                q[t++]=b[p];\n                ++p;\n            }\n            else puts(\"No\"),exit(0);\n        }\n    }\n}\nint main(){\n    in(n);\n    int x,y;\n    Fur(i,1,n-1)in(x,y),add(x,y),add(y,x);\n    Fur(i,1,n)in(b[i]);\n    if(b[1]!=1)return puts(\"No\"),0;\n    bfs();\n    puts(\"Yes\");\n}\n```\n","link":null,"tags":["bfs","模拟"],"title":"LG CF1037D Valid-BFS"},{"categories":[["刷题记录"]],"content":"\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i=x;i<=y;i++)\n    #define Fdr(i,x,y) for(int i=x;i>=y;i--)\n    #define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) (int(log2(n)))\n    #define inf 0x3f3f3f3f\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 10000011\nint pri[N],tot=0;\nll phi[N];\nbool f[N];\nvoid ol(int n){\n    phi[1]=1;\n    Fur(i,2,n){\n        if(!f[i])phi[i]=i-1,pri[++tot]=i;\n        Fur(j,1,tot){\n            if(pri[j]*i>n)break;\n            f[i*pri[j]]=1;\n            if(i%pri[j])phi[i*pri[j]]=phi[i]*phi[pri[j]];\n            else{\n                phi[i*pri[j]]=phi[i]*pri[j];\n                break;\n            }\n        }\n    }\n    Fur(i,2,n)phi[i]+=phi[i-1];\n}\nint main(){\n    int n;\n    in>>n;\n    ol(n);\n    ll ans=0;\n    Fur(i,1,n)ans+=(phi[n\/i]*2-1)*i;\n    out<<ans<<ln;\n    \n}\n\n```\n","link":null,"tags":["数论","欧拉函数"],"title":"LG 2398 GCD SUM"},{"categories":[["刷题记录"]],"content":"\n我们先把所有边的方向掉转为从上到下\n\n那么所有下端必须是$n$\n\n有一种简单粗暴无脑但是好用的构造方案,就是构造一条链,并且$n$在长链的一端\n\n问题变成了给你一个数组的前缀$\\max$数组,反着构造原数组\n\n\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;rg char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\n#define N 100011\nint n,b[N],a[N];\nil void no(){puts(\"NO\");exit(0);}\nbool v[N];\nint main(){\n    in(n);\n    int x,y;\n    Fur(i,1,n-1){\n        in(x,y);\n        if(x>y)SWAP(x,y);\n        if(y!=n)no();\n        b[i]=x;\n    }\n    sort(b+1,b+n);\n    Fur(i,1,n){\n        if(b[i]!=b[i-1])a[i]=b[i],v[a[i]]=1;\n        else{\n            Fur(j,1,b[i])\n                if(!v[j]){a[i]=j;b[j]=1;goto ed;}\n            no();\n            ed:;\n        }\n    }\n    out(\"YES\\n\");\n    a[n]=n;\n    Fur(i,1,n-1)out(a[i],\" \",a[i+1],ln);\n    flush();\n}\n```\n","link":null,"tags":["构造"],"title":"LG CF1041E Tree-Reconstruction"},{"categories":[["刷题记录"]],"content":"\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n\t#pragma GCC optimize(3)\n\t#define il __inline__ __attribute__ ((always_inline))\n\t#define rg register\n\t#define ll long long\n\t#define ull unsigned long long\n\t#define db double\n\t#define sht short\n\t#define MB template <class T>il\n\t#define Fur(i,x,y) for(int i=x;i<=y;i++)\n\t#define Fdr(i,x,y) for(int i=x;i>=y;i--)\n\t#define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n\t#define clr(x,y) memset(x,y,sizeof(x))\n\t#define cpy(x,y) memcpy(x,y,sizeof(x))\n\t#define fin(s) freopen(s\".in\",\"r\",stdin)\n\t#define fout(s) freopen(s\".out\",\"w\",stdout)\n\t#define fcin ios::sync_with_stdio(false)\n\t#define l2(n) (int(log2(n)))\n\t#define inf 0x3f3f3f3f\n\tMB T ABS(T x){return x>0?x:-x;}\n\tMB T MAX(T x,T y){return x>y?x:y;}\n\tMB T MIN(T x,T y){return x<y?x:y;}\n\tMB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n\tMB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){clr(ch,0);if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 100011\n#define int ll\nint sz[N],ans=inf,as,head[N],n,cnt=0,d[N];\nstruct edge{\n\tint to,nxt,w;\n}e[N*2];\nvoid add(int x,int y,int w){\n\te[++cnt].to=y;e[cnt].nxt=head[x];e[cnt].w=w;head[x]=cnt;\n}\nvoid dfs(int x,int f){\n\tsz[x]=1;\n\tint res=0;\n\tfl(i,x)\n\tif(to!=f){\n\t\tdfs(to,x);sz[x]+=sz[to];\n\t\tres=MAX(res,sz[to]);\n\t}\n\tres=MAX(res,n-sz[x]);\n\tif(res<ans)ans=res,as=x;\n}\nvoid DFS(int x,int f){\n\tans+=d[x];\n\tfl(i,x)if(to!=f)\n\t\td[to]=d[x]+e[i].w,DFS(to,x);\n}\nsigned main(){\n\tin>>n;\n\tint x,y,w;\n\tFur(i,1,n-1)\n\t\tin>>x>>y>>w,\n\t\tadd(x,y,w),\n\t\tadd(y,x,w);\n\t\t\n\tdfs(1,0);\n\tans=0;\n\tDFS(as,0);\n\tout<<ans<<ln;\n}\n```\n","link":null,"tags":["树的重心"],"title":"51nod 1737 配对"},{"categories":[["刷题记录"]],"content":"\n一定是我做题太少了\n\n看不出这是个最小割\n\n我们将每个人看成一个点,然后如下建边：\n\n1. 源点向每个人连流量为其总收益的边（$\\sum_{j=1}^n E_{i,j}$) \n\n2. 每个人向汇点连流量为其花费的边\n\n3. $i$向$j$连流量为$E_{i,j} \\times 2$的边\n\n然后用所有能赚到的利润减去最小花费就可以了\n\n第三条,如果两个人都选,可以获得$E_{i,j}$的利润\n\n如果有一个不选,会亏损$E_{i,j}$的利润\n\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n\t#pragma GCC optimize(3)\n\t#define il __inline__ __attribute__ ((always_inline))\n\t#define rg register\n\t#define ll long long\n\t#define ull unsigned long long\n\t#define db double\n\t#define sht short\n\t#define MB template <class T>il\n\t#define Fur(i,x,y) for(int i=x;i<=y;i++)\n\t#define Fdr(i,x,y) for(int i=x;i>=y;i--)\n\t#define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n\t#define clr(x,y) memset(x,y,sizeof(x))\n\t#define cpy(x,y) memcpy(x,y,sizeof(x))\n\t#define fin(s) freopen(s\".in\",\"r\",stdin)\n\t#define fout(s) freopen(s\".out\",\"w\",stdout)\n\t#define fcin ios::sync_with_stdio(false)\n\t#define l2(n) (int(log2(n)))\n\t#define inf 0x3f3f3f3f\n\tMB T ABS(T x){return x>0?x:-x;}\n\tMB T MAX(T x,T y){return x>y?x:y;}\n\tMB T MIN(T x,T y){return x<y?x:y;}\n\tMB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n\tMB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){clr(ch,0);if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 1011\n#define int ll\nint n,m,st,ed,cnt=1;\nint head[N],d[N],q[N];\nstruct edge{int to,nxt,w;}e[N*N];\nvoid add(int x,int y,int w){\n    e[++cnt].to=y;e[cnt].w=w;e[cnt].nxt=head[x];head[x]=cnt;\n    e[++cnt].to=x;e[cnt].w=0;e[cnt].nxt=head[y];head[y]=cnt;\n}\nbool bfs(){\n    int h=0,t=1,x;\n    clr(d,0);d[q[h]=st]=1;\n    while(h<t){\n        x=q[h++];if(x==ed)return 1;\n        fl(i,x)if(e[i].w&&!d[to]){\n            d[to]=d[x]+1;\n            q[t++]=to;\n        }\n    }\n    return 0;\n}\nint dfs(int x,int mf){\n    if(x==ed)return mf;\n    int us=0,w;\n    fl(i,x)\n    if(e[i].w&&d[to]==d[x]+1){\n        w=dfs(to,MIN(mf-us,e[i].w));\n        e[i].w-=w;e[i^1].w+=w;\n        us+=w;\n        if(us==mf)return mf;\n    }\n    if(!us)d[x]=-1;\n    return us;\n}\nsigned main(){\n\tin>>n;\n\tint x,y,w,sum=0,ans=0;\n\tst=N-1,ed=N-2;\n\tFur(i,1,n){\n\t\tin>>w;\n\t\tadd(i,ed,w);\n\t}\n\tFur(i,1,n){\n\t\tint c=0;\n\t\tFur(j,1,n){\n\t\t\tin>>w;\n\t\t\tif(w){\n\t\t\t\tc+=w;\n\t\t\t\tadd(i,j,w<<1);\n\t\t\t}\n\t\t}\n\t\tadd(st,i,c);\n\t\tsum+=c;\n\t}\n\twhile(bfs())ans+=dfs(st,inf);\n\tout<<sum-ans<<ln;\n}\n```\n","link":null,"tags":["网络流"],"title":"LG 1791 [国家集训队]人员雇佣"},{"categories":[["刷题记录"]],"content":"\n题目意思就是有$n$个干草包,将一条路分成了$n-1$段区间,把起点设在这$n-1$段的每一段中,判断从那里开始是否能够逃脱,输出所有不能逃脱的区间长度之和。\n\n记录每个区间能不能冲出去\n\n一个区间只要中间有一个点可以冲出去就每个点都可以冲出去\n\n那么我们只要一直向左边和右边冲,一直到没法继续冲位置,只要冲到一个可以冲出去的区间,就可以冲出去\n\n~~冲冲冲~~\n\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i=x;i<=y;++i)\n    #define Fdr(i,x,y) for(int i=x;i>=y;--i)\n    #define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 0x3f3f3f3f\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){clr(ch,0);if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 100011\nint n;\nbool b[N];\nstruct node{\n    int v,p;\n}a[N];\nbool cmp(node x,node y){return x.p<y.p;}\nbool chk(int p){\n    int s=a[p+1].p-a[p].p,l=p,r=p+1;\n    while(1<=l&&r<=n){\n        bool ff=0;\n        if(s>a[l].v){\n            ff=1;--l;\n            if(b[l])return b[p]=1,1;\n            s+=a[l+1].p-a[l].p;\n        }\n        if(s>a[r].v){\n            ff=1;++r;\n            if(b[r])return b[p]=1,1;\n            s+=a[r].p-a[r-1].p;\n        }\n        if(!ff)return 0;\n    }\n    return 1;\n}\nint main(){\n    fin(\"in\");\n    in>>n;\n    Fur(i,1,n)in>>a[i].v>>a[i].p;\n    sort(a+1,a+n+1,cmp);\n    b[0]=b[n]=1;\n    int ans=0;\n    Fur(i,1,n)\n        if(!chk(i))ans+=a[i+1].p-a[i].p;\n    out<<ans<<ln;\n}\n```\n","link":null,"tags":["模拟"],"title":"LG 3127 [USACO15OPEN]被困在haybales（金）Trappe…"},{"categories":[["刷题记录"]],"content":"\n```cpp\n#include<bits\/stdc++.h>\nusing namespace std;\n#define Fur(i,s,t) for(int i=s;i<=t;i++)\n#define dwn(i,s,t) for(int i=s;i>=t;i--)\n#define clr(x,c) memset(x,c,sizeof(x))\nint read(){\n    int x=0;char c=getchar();\n    while(!isdigit(c)) c=getchar();\n    while(isdigit(c)) x=x*10+c-'0',c=getchar();\n    return x;\n}\nconst int nmax=5e4+5;\nconst int inf=0x7f7f7f7f;\nstruct node{\n    int u,v,d;\n    node(int u,int v,int d):u(u),v(v),d(d){};\n    node(){};\n    bool operator<(const node&rhs)const{\n      return d<rhs.d;}\n};\nnode ns[nmax];\nvoid maxs(int &a,int b){\n    if(a<b) a=b;\n}\nint g[nmax],dp[nmax];\nint main(){\n    int n=read(),m=read(),u,v,d;\n    Fur(i,1,m) ns[i].u=read(),ns[i].v=read(),ns[i].d=read();\n    sort(ns+1,ns+m+1);\n    int last=0;\n    Fur(i,1,m){\n        if(i==m||ns[i].d<ns[i+1].d){\n            Fur(j,last+1,i) g[ns[j].u]=dp[ns[j].u],g[ns[j].v]=dp[ns[j].v];\n            Fur(j,last+1,i){\n                maxs(dp[ns[j].u],g[ns[j].v]+1);\n                maxs(dp[ns[j].v],g[ns[j].u]+1);\n            }\n            last=i;\n        }\n    }\n    int ans=0;\n    Fur(i,0,n-1) maxs(ans,dp[i]);\n    printf(\"%d\\n\",ans);\n}\n```\n","link":null,"tags":[],"title":"51nod 1274 最长递增路径"},{"categories":[["刷题记录"]],"content":"\n维护两个单调递减栈,当$i$加进栈,位置$x$的数弹出的时候,在另一个栈中找到和这个数一样大的数,计算贡献$(x-$靠右左端点$)\\times (i-x)$\n```cpp\n#include<bits\/stdc++.h>\n#define ll long long \nusing namespace std;\nconst int maxn=500010,inf=1e9;\nint n,m,x,y,z,tot,topa,topb;\nint a[maxn],b[maxn],sta[maxn],stb[maxn];\nll ans;\nvoid read(int &k){\n    int f=1;k=0;char c=getchar();\n    while(c<'0'||c>'9')c=='-'&&(f=-1),c=getchar();\n    while(c<='9'&&c>='0')k=k*10+c-'0',c=getchar();\n    k*=f;\n}\nint main(){\n    read(n);\n    for(int i=1;i<=n;i++)read(a[i]);\n    for(int i=1;i<=n;i++)read(b[i]);\n    a[++n]=inf;b[n]=inf-1;\n    for(int i=1;i<=n;i++){\n        for(;topa&&a[sta[topa]]<=a[i];topa--)\n        if(topb){\n            int l=1,r=topb;\n            while(l<r){\n                int mid=(l+r)>>1;\n                if(b[stb[mid]]<=a[sta[topa]])r=mid;\n                else l=mid+1;\n            }\n            int x=l;if(b[stb[x]]!=a[sta[topa]])continue;\n            ans+=1ll*max(0,min(stb[x],sta[topa])-max(stb[x-1],sta[topa-1]))*(i-max(stb[x],sta[topa]));\n        }\n        for(;topb&&b[stb[topb]]<=b[i];topb--)\n        if(topa){\n            int l=1,r=topa;\n            while(l<r){\n                int mid=(l+r)>>1;\n                if(a[sta[mid]]<=b[stb[topb]])r=mid;\n                else l=mid+1;\n            }\n            int x=l;if(a[sta[x]]!=b[stb[topb]])continue;\n            ans+=1ll*max(0,min(sta[x],stb[topb])-max(sta[x-1],stb[topb-1]))*(i-max(sta[x],stb[topb]));\n        }\n        sta[++topa]=stb[++topb]=i;\n    }\n    printf(\"%lld\\n\",ans);\n}\n```\n","link":null,"tags":["单调栈","数论"],"title":"51nod 1962 区间计数"},{"categories":[["刷题记录"]],"content":"\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;rg char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\n#define N 100011\nint p[N],ans[N],tt=0;\nint main(){\n    int a,b,c;\n    cin>>a>>b;\n    c=GCD(a,b);\n    a\/=c;b\/=c;\n    cout<<(a\/b)<<\".\";a%=b;\n    if(!a)return cout<<0,0;\n    int d=0,n=1000;\n    a*=10;\n    Fur(i,1,n){\n        p[i]=a\/b;\n        a%=b;\n        if(!a){\n            Fur(j,1,i)cout<<p[j];\n            return 0;\n        }\n        a*=10;\n    }\n    Fur(len,1,n\/2){\n        Fur(l,1,n-len*2+1){\n            int r=l+len-1,f=1;\n            Fur(i,1,r-l+1)\n            if(p[l+i-1]!=p[r+i]){f=0;break;}\n            if(f){\n                Fur(i,1,l-1)cout<<p[i];\n                cout<<\"(\";\n                Fur(i,l,r)cout<<p[i];\n                cout<<\")\";\n                return 0;\n            }\n        }\n    }\n}\n```\n","link":null,"tags":["模拟"],"title":"LG 1530 分数化小数-Fractions-to-Decimals"},{"categories":[["刷题记录"]],"content":"\n一个点在某个高度有水满足左边和右边在同一高度要么是水要么是石头\n\n预处理出$L_i$和$R_i$表示一个点左边和右边的限制\n\n$L_i = \\max (\\min(L_{i-1},s_i),p_i)$\n\n$R_i$同理\n\n$ans = \\sum_{i=1}^n \\min(L_i,R_i) - p_i$\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i=x;i<=y;++i)\n    #define Fdr(i,x,y) for(int i=x;i>=y;--i)\n    #define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){clr(ch,0);if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 1100011\nint n,a[N],b[N],L[N],R[N],q[N],tp;\nvoid work(){\n    in>>n;\n    Fur(i,1,n)in>>a[i];\n    Fur(i,1,n)in>>b[i];\n    int now;\n    L[1]=now=b[1];\n    Fur(i,2,n){\n        now=MIN(now,b[i]);\n        now=MAX(now,a[i]);\n        L[i]=now;\n    }\n    R[n]=now=b[n];\n    Fdr(i,n-1,1){\n        now=MIN(now,b[i]);\n        now=MAX(now,a[i]);\n        R[i]=now;\n    }\n    int ans=0;\n    Fur(i,1,n)ans+=MIN(L[i],R[i])-a[i];\n    out<<ans<<ln;\n}\nint main(){\n    fin(\"in\");\n    int tt;in>>tt;\n    while(tt--)work();\n}\n```\n","link":null,"tags":["思维"],"title":"LG UVA1442 洞穴 Cav"},{"categories":[["刷题记录"]],"content":"\n1. $x_i$改成$val_i$,可以转换成加法\n2. $x_i$加上$val_i$,可以看成乘法\n\n然后排序贪心\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i=x;i<=y;i++)\n    #define Fdr(i,x,y) for(int i=x;i>=y;i--)\n    #define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 0x3f3f3f3f\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){clr(ch,0);if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 10001\n\nint main(){\n\n}\n\n```\n","link":null,"tags":["打标记"],"title":"LG CF521D Shop"},{"categories":[["刷题记录"]],"content":"\n设$f_i$表示前$i$块土地\n\n$$\nf_i=\\min_{j=1}^{i-1}(f_j+maxw[j-1][i]\\times maxh[j-1][i])\n$$\n\n这样的话怎么想都没有办法优化\n\n我们发现,如果一块土地被另一块土地所包含(即长和宽都比另一块土地小),\n\n那么只需购买那另一块土地即可,于是我们可以据此筛掉其他的土地,\n\n只剩下一些长度递减,宽度递增的土地\n\n那么：\n\n$$\nf_i=\\min_{j=1}^{i-1}(f_j+l[j+1]\\times w[i])\n$$\n\n设任意$0\\le j<k<i$,若从$j$转移比从$k$转移优,那么\n\n$$\nf_j+l[j+1]\\times w[i]\\le f_k+l[k+1]\\times w[i]\n\\\\\nw[i](l[j+1]-l[k+1])\\le f_k-f_j\n\\\\\nw[i]\\le \\frac{f_k-f_j}{l[j+1]-l[k+1]}\n$$\n\n维护一个下凸壳就完事了\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\n#define N 50011\n#define int ll\nint n,f[N],q[N],l[N],w[N];\nstruct node{\n    int l,w;\n}a[N];\nbool cmp(node x,node y){\n    if(x.l!=y.l)return x.l>y.l;\n    return x.w<y.w;    \n}\ndb S(int i,int j){\n    return ((db)(f[j]-f[i]))\/((db)(l[i+1]-l[j+1]));\n}\nsigned main(){\n    in(n);\n    Fur(i,1,n)in(a[i].w,a[i].l);\n    sort(a+1,a+n+1,cmp);\n    int h=1,t=1,d=0,mx=0;\n    Fur(i,1,n)\n    if(a[i].w>mx){\n        mx=a[i].w;\n        w[++d]=a[i].w;\n        l[d]=a[i].l;\n    }\n    n=d;\n    Fur(i,1,n){\n        while(h<t&&S(q[h],q[h+1])<=(db)w[i])++h;\n        f[i]=f[q[h]]+l[q[h]+1]*w[i];\n        while(h<t&&S(q[t-1],q[t])>=S(q[t-1],i))--t;\n        q[++t]=i;\n    }\n    cout<<f[n]<<endl;\n}\n```\n","link":null,"tags":["动态规划","斜率优化"],"title":"LG 2900 [USACO08MAR]土地征用Land-Acquisition"},{"categories":[["刷题记录"]],"content":"\n$\\sum\\limits_{i=l}^{r} a_i - k \\lceil \\frac{r - l + 1}{m} \\rceil$\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\n#define N 100011\nint n;\nint main(){\n    \n}\n```\n","link":null,"tags":[],"title":"LG CF1197D Yet-Another-Subarray-Problem"},{"categories":[["刷题记录"]],"content":"\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i=x;i<=y;++i)\n    #define Fdr(i,x,y) for(int i=x;i>=y;--i)\n    #define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){clr(ch,0);if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 100011\nint n;\nint main(){\n    \n}\n```\n","link":null,"tags":["折半搜索"],"title":"LG 4799 [CEOI2015 Day2]世界冰球锦标赛"},{"categories":[["刷题记录"]],"content":"\n显而易见：\n\n$f_i = f_j + [ a_i \\le a_j ] (i < j \\le n)$\n\n题目要求是复杂度$O(nq)$\n\n一看有个步伐限制\n\n那么显然加个单调队列就完事了\n\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n\t#pragma GCC optimize(3)\n\t#define il __inline__ __attribute__ ((always_inline))\n\t#define rg register\n\t#define ll long long\n\t#define ull unsigned long long\n\t#define db double\n\t#define sht short\n\t#define MB template <class T>il\n\t#define Fur(i,x,y) for(int i=x;i<=y;i++)\n\t#define Fdr(i,x,y) for(int i=x;i>=y;i--)\n\t#define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n\t#define clr(x,y) memset(x,y,sizeof(x))\n\t#define cpy(x,y) memcpy(x,y,sizeof(x))\n\t#define fin(s) freopen(s\".in\",\"r\",stdin)\n\t#define fout(s) freopen(s\".out\",\"w\",stdout)\n\t#define fcin ios::sync_with_stdio(false)\n\t#define l2(n) (int(log2(n)))\n\t#define inf 0x3f3f3f3f\n\tMB T ABS(T x){return x>0?x:-x;}\n\tMB T MAX(T x,T y){return x>y?x:y;}\n\tMB T MIN(T x,T y){return x<y?x:y;}\n\tMB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n\tMB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 1000011\nint f[N],a[N],n,m,q[N];\nint main(){\n\tin>>n;\n\tFur(i,1,n)in>>a[i];\n\tin>>m;\n\tint len;\n\twhile(m--){\n\t\tin>>len;\n\t\tf[1]=0;q[1]=1;\n\t\tint h=1,t=1;\n\t\tFur(i,2,n){\n\t\t\twhile(h<=t&&i-q[h]>len)h++;\n\t\t\tf[i]=f[q[h]]+(a[q[h]]<=a[i]);\n\t\t\twhile(h<=t&&(f[i]<f[q[t]]||(f[i]==f[q[t]]&&a[i]>=a[q[t]])))t--;\n\t\t\tq[++t]=i;\n\t\t}\n\t\tout<<f[n]<<ln;\n\t}\n}\n```\n","link":null,"tags":["动态规划","单调队列"],"title":"LG 3572 [POI2014]PTA-Little-Bird"},{"categories":[["刷题记录"]],"content":"\n其实一点stl什么的都不用用到\n\n区间交也就是$[\\max(l_i),\\min(r_i)]$\n\n我们要求的就是每次删掉某个区间后其他区间的区间交\n\n我们只需要记录最大$l_i$和次大$l_i$还有最小$r_i$和次小$r_i$\n\n若当前要删掉的区间$[l_i,r_i],l_i$为最大L,那我们就取次大L\n\nR同理\n\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;rg char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\n#define N 300011\nint n,ml1=0,ml2=0,mr1=inf,mr2=inf;\nstruct node{\n    int l,r;\n}a[N];\nint main(){\n    in(n);\n    int l,r;\n    Fur(i,1,n){\n        in(l,r);\n        a[i]={l,r};\n        if(l>=ml1)ml2=ml1,ml1=l;\n        else if(l>ml2)ml2=l;\n\n        if(r<=mr1)mr2=mr1,mr1=r;\n        else if(r<mr2)mr2=r;\n    }\n    int ans=0,L,R;\n    Fur(i,1,n){\n        l=a[i].l,r=a[i].r;\n        if(l==ml1)L=ml2;\n        else L=ml1;\n\n        if(r==mr1)R=mr2;\n        else R=mr1;\n        ans=MAX(ans,R-L);\n    }\n    printf(\"%d\\n\",ans);\n}\n```\n","link":null,"tags":["模拟","枚举"],"title":"LG CF1029C Maximal-Intersection"},{"categories":[["刷题记录"]],"content":"\n这题真的很妙\n\n可以想到二分最大值\n\n问题就转化为如何判断是否合法\n\n从左到右扫描区间的左端点,扫描到的就把右端点放入堆\n\n每个点的权值可以用~~线段树~~树状数组维护\n\n扫描时遇到点值不够时,就从优先队列中找到最大的右端点,区间加一遍\n\n当优先队列为空或次数不足时就不符合要求\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i=x;i<=y;++i)\n    #define Fdr(i,x,y) for(int i=x;i>=y;--i)\n    #define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){clr(ch,0);if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 200011\nint n,q,k,V,a[N],s[N];\nstruct node{\n    int l,r;\n    il bool operator<(node x){\n        return l<x.l;\n    }\n}b[N];\nil void add(int x,int v){\n    while(x<=n)s[x]+=v,x+=(x&-x);\n}\nil int ask(int x){\n    int ans=0;\n    while(x)ans+=s[x],x-=(x&-x);\n    return ans;\n}\nint que[N];\npriority_queue<int>T;\nbool chk(int w){\n    clr(s,0);\n    int tot=0;\n    Fur(i,1,n)if(a[i]<w)que[++tot]=i;\n    while(!T.empty())T.pop();\n    int j=1,cnt=0;\n    Fur(i,1,tot){\n        while(j<=q&&b[j].l<=que[i])\n            T.push(upper_bound(que+1,que+tot+1,b[j].r)-que-1),++j;\n        while(a[que[i]]+ask(i)<w){\n            ++cnt;\n            if(cnt>k||T.empty())return 0;\n            add(i,V);add(T.top()+1,-V);\n            T.pop();\n        }\n    }\n    return 1;\n}\nvoid work(){\n    in>>n>>q>>k>>V;\n    int mi=inf;\n    Fur(i,1,n)in>>a[i],mi=MIN(mi,a[i]);\n    Fur(i,1,q)in>>b[i].l>>b[i].r;\n    sort(b+1,b+q+1);\n    int l=mi,r=mi+k*V,ans;\n    while(l<=r){\n        int mid=(l+r)>>1;\n        if(chk(mid))ans=mid,l=mid+1;\n        else r=mid-1;\n    }\n    out<<ans<<ln;\n}\nint main(){\n    fin(\"in\");\n    int tt;in>>tt;\n    while(tt--)work();\n}\n```\n","link":null,"tags":["二分","堆","树状数组"],"title":"LG 4064 [JXOI2017]加法"},{"categories":[["刷题记录"]],"content":"\n预处理出二维前缀和\n\n预处理出每个以$(i,j)$为右下角的A*B矩阵的和\n\n预处理出每个以$(i,j)$为右下角的C*D矩阵的和\n\n先用单调队列出列的C*D的最小值\n\n再用另一个单调队列处理出行的\n\n然后枚举比较即可\n\n照着代码意会\n\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n\t#pragma GCC optimize(3)\n\t#define il __inline__ __attribute__ ((always_inline))\n\t#define rg register\n\t#define ll long long\n\t#define ull unsigned long long\n\t#define db double\n\t#define sht short\n\t#define MB template <class T>il\n\t#define Fur(i,x,y) for(int i=x;i<=y;i++)\n\t#define Fdr(i,x,y) for(int i=x;i>=y;i--)\n\t#define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n\t#define clr(x,y) memset(x,y,sizeof(x))\n\t#define cpy(x,y) memcpy(x,y,sizeof(x))\n\t#define fin(s) freopen(s\".in\",\"r\",stdin)\n\t#define fout(s) freopen(s\".out\",\"w\",stdout)\n\t#define fcin ios::sync_with_stdio(false)\n\t#define l2(n) (int(log2(n)))\n\t#define inf 0x3f3f3f3f\n\tMB T ABS(T x){return x>0?x:-x;}\n\tMB T MAX(T x,T y){return x>y?x:y;}\n\tMB T MIN(T x,T y){return x<y?x:y;}\n\tMB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n\tMB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 1011\nint n,m,A,B,C,D,Q[N];\nint s[N][N],a[N][N],b[N][N],p[N][N],q[N][N];\nint main(){\n\tin>>n>>m>>A>>B>>C>>D;\n\tFur(i,1,n)\n\t\tFur(j,1,m)\n\t\tin>>s[i][j],s[i][j]+=s[i-1][j]+s[i][j-1]-s[i-1][j-1];\n\t\n\tFur(i,C+1,n-1)\n\t\tFur(j,D+1,m-1)\n\t\ta[i][j]=s[i][j]-s[i][j-D]-s[i-C][j]+s[i-C][j-D];\n\t\n\tFur(i,A,n)\n\t\tFur(j,B,m)\n\t\tb[i][j]=s[i][j]-s[i][j-B]-s[i-A][j]+s[i-A][j-B];\n\n\tFur(i,C+1,n-1){\n\t\tint h=1,t=0;\n\t\tFur(j,D+1,m-1){\n\t\t\twhile(h<=t&&Q[h]<j-B+D+2)h++;\n\t\t\twhile(h<=t&&a[i][Q[t]]>=a[i][j])t--;\n\t\t\tQ[++t]=j;\n\t\t\tif(j>=B-1)p[i][j+1]=a[i][Q[h]];\n\t\t}\n\t}\n\n\tFur(j,B,m){\n\t\tint h=1,t=0;\n\t\tFur(i,C+1,n-1){\n\t\t\twhile(h<=t&&Q[h]<i-A+2+C)h++;\n\t\t\twhile(h<=t&&p[Q[t]][j]>=p[i][j])t--;\n\t\t\tQ[++t]=i;\n\t\t\tif(i>=A-1)q[i+1][j]=p[Q[h]][j];\n\t\t}\n\t}\n\tint ans=0;\n\tFur(i,A,n)\n\t\tFur(j,B,m)\n\t\tans=MAX(ans,b[i][j]-q[i][j]);\n\t\n\tout<<ans<<ln;\n}\n```\n","link":null,"tags":["单调队列","前缀和"],"title":"LG 2219 [HAOI2007]修筑绿化带"},{"categories":[["刷题记录"]],"content":"\n先缩点,然后跑最长路\n\n然后更新的时候顺便记录最大亮度就可以了\n\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n\t#pragma GCC optimize(3)\n\t#define il __inline__ __attribute__ ((always_inline))\n\t#define rg register\n\t#define ll long long\n\t#define ull unsigned long long\n\t#define db double\n\t#define sht short\n\t#define MB template <class T>il\n\t#define Fur(i,x,y) for(int i=x;i<=y;i++)\n\t#define Fdr(i,x,y) for(int i=x;i>=y;i--)\n\t#define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n\t#define clr(x,y) memset(x,y,sizeof(x))\n\t#define cpy(x,y) memcpy(x,y,sizeof(x))\n\t#define fin(s) freopen(s\".in\",\"r\",stdin)\n\t#define fout(s) freopen(s\".out\",\"w\",stdout)\n\t#define fcin ios::sync_with_stdio(false)\n\t#define l2(n) (int(log2(n)))\n\t#define inf 0x3f3f3f3f\n\tMB T ABS(T x){return x>0?x:-x;}\n\tMB T MAX(T x,T y){return x>y?x:y;}\n\tMB T MIN(T x,T y){return x<y?x:y;}\n\tMB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n\tMB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 2000011\nint head[N],n,m,cnt=0,z[N],bl[N],dfn[N],low[N],c[N],tp=0,sz=0,mx[N];\nint Head[N],Cnt=0,r[N],q[N],top=0,f[N],F[N];\nbool v[N];\nstruct edge{\n\tint x,to,nxt;\n}e[N*10],E[N*10];\nvoid add(int x,int y){\n\te[++cnt].to=y;e[cnt].x=x;e[cnt].nxt=head[x];head[x]=cnt;\n}\nvoid Add(int x,int y){\n\tE[++Cnt].to=y;E[Cnt].x=x;E[Cnt].nxt=Head[x];Head[x]=Cnt;\n}\nvoid tarjan(ll x){\n\tdfn[x]=low[x]=++sz;v[x]=1;z[++tp]=x;\n\tfl(i,x)\n\tif(!dfn[to]){\n\t\ttarjan(to);\n\t\tlow[x]=min(low[x],low[to]);\n\t}\n\telse if(v[to])low[x]=min(low[x],dfn[to]);\n\tif(low[x]==dfn[x])\n\twhile(ll k=z[tp--]){\n\t\tv[k]=0,bl[k]=x;\n\t\tif(k==x)break;\n\t\tc[x]+=c[k];\n\t}\n}\nint main(){\n\tin>>n>>m;\n\tFur(i,1,n)in>>c[i],mx[i]=c[i];\n\tint x,y;\n\tFur(i,1,m)in>>x>>y,add(x,y);\n\tFur(i,1,n)if(!dfn[i])tarjan(i);\n\tFur(i,1,m){\n\t\tx=bl[e[i].x];y=bl[e[i].to];\n\t\tif(x!=y)Add(x,y),r[y]++;\n\t}\n\tFur(i,1,n)if(bl[i]==i&&!r[i])q[++top]=i,f[i]=c[i],F[i]=mx[i];\n\twhile(top){\n\t\tx=q[top--];\n\t\tfor(int i=Head[x],to;to=E[i].to,i;i=E[i].nxt){\n\t\t\tif(f[x]+c[to]==f[to])\n\t\t\t\tF[to]=MAX(F[to],MAX(F[x],mx[to]));\n\t\t\t\n\t\t\tif(f[x]+c[to]>f[to]){\n\t\t\t\tf[to]=f[x]+c[to];\n\t\t\t\tF[to]=MAX(F[x],mx[to]);\n\t\t\t}\n\t\t\t\n\n\t\t\tif(--r[to]==0)q[++top]=to;\n\t\t}\n\t}\n\tint ans=0,as=0;\n\tFur(i,1,n){\n\t\tif(f[i]>ans)ans=f[i],as=F[i];\n\t\telse if(f[i]==ans)as=MAX(as,F[i]);\n\t}\n\tout<<ans<<\" \"<<as<<ln;\n}\n```\n","link":null,"tags":["tarjan"],"title":"LG 4742 [Wind-Festival]Running-In-The-Sky"},{"categories":[["刷题记录"]],"content":"\n先考虑每种硬币可以用无数次\n\n设$f_i$表示金额为$i$有多少种方案\n\n$f_i = \\sum_{j=1}^4 f_{i-c[j](i \\ge c_j)}$\n\n我们再来考虑硬币使用次数有限制怎么办\n\n> 不合法的情况有:\n>\n> 1超额\n>\n> 1,2超额\n>\n> 1,3超额\n>\n> 1,4超额\n>\n> 1,2,3超额\n>\n> 1,2,4超额\n>\n> 1,3,4超额\n>\n> 1,2,3,4超额\n>\n> ...\n>\n> 要注意的是在多种硬币限制的情况下可能会减去多次,或加上多次\n>\n> 比如1超额,2超额,（1,2同时超额被减去两次,这是就要加回来\n>\n> 而$(1,2,3)$ 、$(1,2,4)$又是多算的...\n\n是不是更直观的了解了容斥？\n\n为了方便,我们可以枚举二进制下状态来更加优美实现。\n\n(当有奇数种不合法的时候减去,偶数种不合法时加上)\n\n\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;rg char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\n#define N 100011\nint n,c[5],d[5],s;\nll f[N];\nint main(){\n    Fur(i,1,4)in(c[i]);\n    f[0]=1;\n    Fur(i,1,4)\n        Fur(j,c[i],100000)\n            f[j]+=f[j-c[i]];\n    \n    in(n);\n    while(n--){\n        Fur(i,1,4)in(d[i]);\n        in(s);\n        ll ans=f[s];\n        Fur(i,1,15){\n            int t=s,sta=i,k=1;\n            Fur(j,1,4)\n            if(sta&(1<<(j-1))){\n                k=-k;\n                t-=(d[j]+1)*c[j];\n            }\n            if(t>=0)ans+=1ll*f[t]*k;\n        }\n        out(ans,ln);\n    }\n    flush();\n}\n```\n","link":null,"tags":["背包","动态规划","容斥"],"title":"LG 1450 [HAOI2008]硬币购物"},{"categories":[["刷题记录"]],"content":"\n因为边权为1,所以直接跑奇偶最短路即可\n\n但是当$x=y$时,我们需要判断$x$是否有向外连边\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;rg char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\n#define N 5011\nshort n,m,cnt=0,head[N];\nstruct edge{\n    int to,nxt;\n}e[10011];\nil void add(int x,int y){\n    e[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;\n}\nshort d[2][N][N];\nshort q[N*3],p[N*3];\nvoid bfs(int st){\n    int h=0,t=1,x,y;\n    x=st;\n    q[0]=x;d[0][st][x]=1;p[0]=0;\n    while(h<t){\n        x=q[h];y=p[h++];\n        fl(i,x)\n        if(!d[y^1][st][to]||d[y][st][x]+1<d[y^1][st][to]){\n            d[y^1][st][to]=d[y][st][x]+1;\n            q[t]=to,p[t++]=y^1;\n        }\n    }\n}\nint main(){\n    int q;\n    in(n,m,q);\n    int x,y,w;\n    Fur(i,1,m)in(x,y),add(x,y),add(y,x);\n    Fur(i,1,n)bfs(i);\n    while(q--){\n        in(x,y,w);\n        if(d[w&1][x][y]&&(x!=y||head[x])&&d[w&1][x][y]-1<=w)out(\"TAK\\n\");\n        else out(\"NIE\\n\");\n    }\n    flush();\n}\n```\n","link":null,"tags":["最短路","bfs"],"title":"LG 3556 [POI2013]MOR-Tales-of-seafaring"},{"categories":[["刷题记录"]],"content":"\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n\t#pragma GCC optimize(3)\n\t#define il __inline__ __attribute__ ((always_inline))\n\t#define rg register\n\t#define ll long long\n\t#define ull unsigned long long\n\t#define db double\n\t#define sht short\n\t#define MB template <class T>il\n\t#define Fur(i,x,y) for(int i=x;i<=y;i++)\n\t#define Fdr(i,x,y) for(int i=x;i>=y;i--)\n\t#define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n\t#define clr(x,y) memset(x,y,sizeof(x))\n\t#define cpy(x,y) memcpy(x,y,sizeof(x))\n\t#define fin(s) freopen(s\".in\",\"r\",stdin)\n\t#define fout(s) freopen(s\".out\",\"w\",stdout)\n\t#define fcin ios::sync_with_stdio(false)\n\t#define l2(n) (int(log2(n)))\n\t#define inf 0x3f3f3f3f\n\tMB T ABS(T x){return x>0?x:-x;}\n\tMB T MAX(T x,T y){return x>y?x:y;}\n\tMB T MIN(T x,T y){return x<y?x:y;}\n\tMB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n\tMB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){clr(ch,0);if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 111\n#define mod 1000000007\nchar s[N];\nll f[N][3010];\nint main(){\nFur(i,0,25)f[1][i]=1;\nFur(j,2,100)\n\tFur(k,0,3000)\n\t\tFur(i,0,25)\n\t\tif(k>=i)\n\t\t\tf[j][k]+=f[j-1][k-i],\n\t\t\tf[j][k]%=mod;\n\nint T;in>>T;\nwhile(T--){\n\tin>>s;\n\tint tot=0,len=strlen(s);\n\tFur(i,0,len-1)tot+=s[i]-'a';\n\tout<<f[len][tot]-1<<ln;\n}\n}\n```\n","link":null,"tags":[],"title":"LG 1385 密令"},{"categories":[["刷题记录"]],"content":"\n考虑排序后的序列\n\n第$i$个人说有$a_i$个人分数比他高,有$b_i$个分数比他低\n\n从大到小排序后分数和$i$相同的人的区间为$[a_i+1,n-b_i]$\n\n我们设$L_i = a_i + 1, R_i = n - b_i$\n\n那么如果$L_i > R_i$显然是假话\n\n如果$R_i-L_i+1$小于这个区间的人数($L_{i'}=L_i$且$R_{i'}=R_i$),那么这也是假话\n\n去掉所有一定是假的话后,问题变成：给若干个区间$[l_i,r_i]$,价值为$v_i$,从中选出若干个没有交集的区间,价值和最大为多少？\n\n\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i=x;i<=y;++i)\n    #define Fdr(i,x,y) for(int i=x;i>=y;--i)\n    #define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){clr(ch,0);if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 100011\nint n;\nstruct node{\n    int l,r;\n}a[N];\nint main(){\n    in>>n;\n    int x,y;\n    Fur(i,1,n){\n        in>>x>>y;\n        a[i]=node{x+1,n-y};\n    }\n    \n}\n```\n","link":null,"tags":["动态规划","二分"],"title":"LG 2519 [HAOI2011]problem a"},{"categories":[["刷题记录"]],"content":"\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i=x;i<=y;++i)\n    #define Fdr(i,x,y) for(int i=x;i>=y;--i)\n    #define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) (int(log2(n)))\n    #define inf 0x3f3f3f3f\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){clr(ch,0);if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 1011\nint n,a[N][N],b[N][N],f[N][N],F[N][N],p[N][N],q[N][N];\nchar ans[N*2];\nint main(){\n    fin(\"in\");\n    in>>n;\n    int x,y,X=0,Y=0;\n    Fur(i,1,n)Fur(j,1,n){\n        int x;in>>x;\n        if(x==0){\n            X=i,Y=j;\n            a[i][j]=b[i][j]=1;\n        }\n        else{\n            while(x%2==0)a[i][j]++,x>>=1;\n            while(x%5==0)b[i][j]++,x\/=5;\n        }\n    }\n    f[1][1]=a[1][1];\n    F[1][1]=b[1][1];\n    Fur(i,2,n){\n        f[1][i]=f[1][i-1]+a[1][i];\n        F[1][i]=F[1][i-1]+b[1][i];\n        f[i][1]=f[i-1][1]+a[i][1];p[i][1]=1;\n        F[i][1]=F[i-1][1]+b[i][1];q[i][1]=1;\n    }\n    Fur(i,2,n)\n        Fur(j,2,n){\n            if(f[i-1][j]<f[i][j-1])p[i][j]=1,f[i][j]=f[i-1][j]+a[i][j];\n            else f[i][j]=f[i][j-1]+a[i][j];\n            if(F[i-1][j]<F[i][j-1])q[i][j]=1,F[i][j]=F[i-1][j]+b[i][j];\n            else F[i][j]=F[i][j-1]+b[i][j];\n        }\n    int d=0;\n    if(f[n][n]>1&&F[n][n]>1&&X){\n        out<<\"1\\n\";\n        Fur(i,1,X-1)out<<\"D\";\n        Fur(i,1,Y-1)out<<\"R\";\n        Fur(i,X+1,n)out<<\"D\";\n        Fur(i,Y+1,n)out<<\"R\";\n        return 0;\n    }\n    if(f[n][n]<F[n][n]){\n        out<<f[n][n]<<ln;\n        x=n,y=n;\n        while(x!=1||y!=1){\n            if(p[x][y])ans[d++]='D',x--;\n            else ans[d++]='R',y--;\n        }\n    }\n    else{\n        out<<F[n][n]<<ln;\n        x=n,y=n;\n        while(x!=1||y!=1){\n            if(q[x][y])ans[d++]='D',x--;\n            else ans[d++]='R',y--;\n        }\n    }\n    reverse(ans,ans+d);\n    out<<ans<<ln;\n}\n```\n","link":null,"tags":[],"title":"LG CF2B The least round way"},{"categories":[["刷题记录"]],"content":"\n静态链分治 参见模板\n\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i=x;i<=y;++i)\n    #define Fdr(i,x,y) for(int i=x;i>=y;--i)\n    #define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 0x3f3f3f3f\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){clr(ch,0);if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 200011\nint n,q,f[N],son[N],siz[N],a[N];\nint cnt=0,head[N];\nstruct edge{\n    int to,nxt;\n}e[N*2];\nil void add(int x,int y){\n    e[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;\n}\nvoid dfs(int x){\n    siz[x]=1;\n    fl(i,x)if(to!=f[x]){\n        f[to]=x;dfs(to);\n        siz[x]+=siz[to];\n        if(siz[to]>siz[son[x]])son[x]=to;\n    }\n}\nint c[N],ans[N],ANS[N];\nil void Add(int x,int v){\n    if(~v)++ans[++c[a[x]]];\n    else --ans[c[a[x]]--];\n}\nvoid upd(int x,int v){\n    Add(x,v);\n    fl(i,x)if(to!=f[x])upd(to,v);\n}\nstruct node{\n    int x,k,id;\n};\nvector<node>que[N];\nvoid sol(int x){\n    fl(i,x)if(to!=f[x]&&to!=son[x]){\n        sol(to);\n        upd(to,-1);\n    }\n    if(son[x])sol(son[x]);\n    Add(x,1);\n    fl(i,x)if(to!=f[x]&&to!=son[x])upd(to,1);\n    for(int i=0;i<que[x].size();++i)\n        ANS[que[x][i].id]=ans[que[x][i].k];\n}\nint main(){\n    fin(\"in\");\n    in>>n>>q;\n    Fur(i,1,n)in>>a[i];\n    int x,y;\n    Fur(i,1,n-1)in>>x>>y,add(x,y),add(y,x);\n    dfs(1);\n    Fur(i,1,q){\n        in>>x>>y;\n        que[x].push_back(node{x,y,i});\n    }\n    sol(1);\n    Fur(i,1,q)out<<ANS[i]<<ln;\n}\n```\n","link":null,"tags":["静态链分治"],"title":"LG CF375D Tree and Queries"},{"categories":[["刷题记录"]],"content":"\n设$f_i$表示前$i$个拆分后最大战斗力和\n\n$$\nf_i=\\max_{j=1}^{i-1}(f_j+a(s_i-s_j)^2+b(s_i-s_j)+c)\n$$\n\n~~这个很明显是斜率优化式子~~\n\n设任意$0\\le j<k < i$,若从$j$转移到$i$优于从$k$转移,那么：\n\n$$\nf_j+a(s_i-s_j)^2+b(s_i-s_j)+c\\ge f_k+a(s_i-s_k)^2+b(s_i-s_k)+c\n\\\\\n2as_i\\le\\frac{(f_k+a{s_k}^2-bs_k)-(f_j+a{s_j}^2-bs_j)}{s_k-s_j}\n$$\n\n维护个下凸壳就完事了\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\n#define N 1000011\nint n,q[N];\ndb f[N],s[N],a,b,c;\ndb S(int i,int j){\n    return (db)((f[j]+a*s[j]*s[j]-b*s[j])-(f[i]+a*s[i]*s[i]-b*s[i]))\/(db)(s[j]-s[i]);\n}\nint main(){\n    in(n,a,b,c);\n    int x;\n    Fur(i,1,n)in(x),s[i]=s[i-1]+x;\n    int h=1,t=1;q[1]=0;\n    Fur(i,1,n){\n        while(h<t&&S(q[h],q[h+1])>=2*a*s[i])++h;\n        f[i]=f[q[h]]+a*(s[i]-s[q[h]])*(s[i]-s[q[h]])+b*(s[i]-s[q[h]])+c;\n        while(h<t&&S(q[t-1],q[t])<=S(q[t-1],i))--t;\n        q[++t]=i;\n    }\n    printf(\"%.0lf\\n\",f[n]);\n}\n```\n","link":null,"tags":["动态规划","单调队列","斜率优化","前缀和"],"title":"LG 3628 [APIO2010]特别行动队"},{"categories":[["刷题记录"]],"content":"\n如果没有时间限制那就是一个裸的完全背包\n\n我们可以先按时间从大到小排序,保证如果选了后面作业能选的话不会影响当前作业\n\n接着背包求出每天的最小花费\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;rg char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\n#define N 5011\n#define int ll\nint x,w,n,f[N*2];\nstruct node{\n    int x,w,t,c;\n}a[N];\nbool cmp(node p,node q){\n    return p.t>q.t;\n}\nsigned main(){\n    in(x,w,n);\n    Fur(i,1,n)in(a[i].x,a[i].w,a[i].t);\n    sort(a+1,a+n+1,cmp);\n    clr(f,0x3f);\n    f[0]=0;\n    Fur(i,1,n){\n        if(a[i].w>=w)f[w]=MIN(f[w],a[i].x);\/\/特判\n        else \n            Fur(j,a[i].w,w+a[i].w)\n                f[j]=MIN(f[j],f[j-a[i].w]+a[i].x);\n        a[i].c=inf;\n        Fur(j,w,w*2)\/\/不会超过w*2\n            a[i].c=MIN(a[i].c,f[j]);\n    }\n    Fdr(i,n,1){\n        int c=a[i].c*(a[i].t-a[i+1].t);\n        if(c<=x)x-=c;\n        else printf(\"%d %d\\n\",a[i+1].t+x\/a[i].c,x%a[i].c),exit(0);\n    }\n    printf(\"%d %d\\n\",a[1].t,x);\n}\n```\n","link":null,"tags":["动态规划","背包"],"title":"LG 5585 【SWTR-01】Doing-Homework"},{"categories":[["刷题记录"]],"content":"\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i=x;i<=y;++i)\n    #define Fdr(i,x,y) for(int i=x;i>=y;--i)\n    #define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) (int(log2(n)))\n    #define inf 0x3f3f3f3f\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){clr(ch,0);if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 200011\nint n,m,head[N],f[N],X[N],Y[N],XX[N],YY[N];\nstruct node{\n    int x,y;\n}a[N];\nint gf(int x){\n    return (f[x]==x)?x:(f[x])=gf(f[x]);\n}\nint main(){\n    in>>n>>m;\n    Fur(i,1,n)in>>a[i].x>>a[i].y,f[i]=i,X[i]=inf,Y[i]=inf;\n    int x,y;\n    Fur(i,1,m){\n        in>>x>>y;\n        if(gf(x)!=gf(y))f[f[x]]=f[y];\n    }\n    Fur(i,1,n){\n        int t=gf(i);\n        X[t]=MIN(X[t],a[i].x);\n        XX[t]=MAX(XX[t],a[i].x);\n        Y[t]=MIN(Y[t],a[i].y);\n        YY[t]=MAX(YY[t],a[i].y);\n    }\n    int ans=inf;\n    Fur(i,1,n)if(i==gf(i))\n        ans=MIN(ans,XX[i]-X[i]+YY[i]-Y[i]);\n\n    out<<(ans<<1)<<ln;\n}\n```\n","link":null,"tags":["并查集"],"title":"LG 5429 [USACO19OPEN]Fence Planning"},{"categories":[["刷题记录"]],"content":"\n直接做可能想不出\n\n我们可以逆着想\n\n我们倒着删边,然后连锁反应\n\n\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;rg char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\n#define N 200011\nint n,m,k,d[N],ans=0,cnt=0,head[N];\nstruct edge{\n    int to,nxt;\n}e[N*2];\nil void add(int x,int y){e[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;}\nbool v[N];\nint q[N],h=0,t=1;\nil void del(int x){\n    if(d[x]>=k||v[x])return;\n    v[x]=1;\n    q[0]=x;h=0,t=1;\n    --ans;\n    while(h<t){\n        x=q[h++];\n        fl(i,x)if(--d[to]<k&&!v[to]){\n            q[t++]=to;\n            v[to]=1;\n            --ans;\n        }\n    }\n}\nint ANS[N];\nstruct link{\n    int x,y;\n}E[N];\nint main(){\n    int x,y;\n    in(n,m,k);\n    Fur(i,1,m){\n        in(x,y);\n        ++d[x];++d[y];\n        add(x,y);add(y,x);\n        E[i]={x,y};\n    }\n    ans=n;\n    Fur(i,1,n)del(i);\n    ANS[m]=ans;\n    Fdr(i,m-1,1){\n        x=E[i+1].x,y=E[i+1].y;\n        if(!v[y])--d[x];\n        head[x]=e[head[x]].nxt;\n        if(!v[x])--d[y];\n        head[y]=e[head[y]].nxt;\n        del(x);del(y);\n        ANS[i]=ans;\n    }\n    Fur(i,1,m)out(ANS[i],ln);\n    flush();\n}\n```\n","link":null,"tags":["搜索","队列","逆向思维"],"title":"LG CF1037E Trips"},{"categories":[["刷题记录"]],"content":"\n$f_{i,j,k,(1\/0)}$：$a_i$(选或不选)$,b_j,$第$k$位\n\n$f_{i,j,k,0} = f_{i-1,j,k,0} + f_{i-1,j,k,1}$\n\n$a_i = b_j$:\n\n$$f_{i,j,k,1}=f_{i-1,j-1,k,1}+f_{i-1,j-1,k-1,0}+f_{i-1,j-1,k-1,1}$$\n\n$a_i = b_j$:\n\n$f_{i,j,k,1} = 0$\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n\t#pragma GCC optimize(3)\n\t#define il __inline__ __attribute__ ((always_inline))\n\t#define rg register\n\t#define ll long long\n\t#define ull unsigned long long\n\t#define db double\n\t#define sht short\n\t#define MB template <class T>il\n\t#define Fur(i,x,y) for(int i=x;i<=y;i++)\n\t#define Fdr(i,x,y) for(int i=x;i>=y;i--)\n\t#define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n\t#define clr(x,y) memset(x,y,sizeof(x))\n\t#define cpy(x,y) memcpy(x,y,sizeof(x))\n\t#define fin(s) freopen(s\".in\",\"r\",stdin)\n\t#define fout(s) freopen(s\".out\",\"w\",stdout)\n\t#define fcin ios::sync_with_stdio(false)\n\t#define l2(n) (int(log2(n)))\n\t#define inf 0x3f3f3f3f\n\tMB T ABS(T x){return x>0?x:-x;}\n\tMB T MAX(T x,T y){return x>y?x:y;}\n\tMB T MIN(T x,T y){return x<y?x:y;}\n\tMB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n\tMB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 1011\n#define mod 1000000007\nint n,m,K,f[2][2][211][211];\nchar a[N],b[N];\nint main(){\n\tin>>n>>m>>K;\n\tin>>(a+1)>>(b+1);\n\tf[0][0][0][0]=f[1][0][0][0]=1;\n\tint t=1;\n\tFur(i,1,n){\n\t\tFur(j,1,m)\n\t\t\tFur(k,1,K){\n\t\t\t\tf[t][0][k][j]=(f[!t][0][k][j]+f[!t][1][k][j])%mod;\n\t\t\t\tif(a[i]==b[j])\n\t\t\t\t\tf[t][1][k][j]=((f[!t][1][k][j-1]+f[!t][0][k-1][j-1])%mod+f[!t][1][k-1][j-1])%mod;\n\t\t\t\telse f[t][1][k][j]=0;\n\t\t\t}\n\t\tt^=1;\n\t}\n\tout<<(f[n&1][0][K][m]+f[n&1][1][K][m])%mod<<ln;\n}\n```\n","link":null,"tags":["动态规划"],"title":"LG 2679 子串"},{"categories":[["刷题记录"]],"content":"\n记忆化搜索\n```cpp\n#include<bits\/stdc++.h>\n#define N 15\nint n,f[N][N],g[N][N],cnt;\nstruct node{\n    int al,ar,yk,zk;\n}a[N];\nvoid init(){\n    memset(a,0,sizeof(a));\n    memset(g,0,sizeof(g));\n    memset(f,0x3f,sizeof(f));\n    for(int i=1;i<=n;++i)scanf(\"%d %d\",&a[i].al,&a[i].ar);\n}\nint solve(int l,int r){\n    if(f[l][r]!=0x3f3f3f3f)return f[l][r];\n    if(l>=r)return f[l][r]=0;\n    int pos=0;\n    for(int k=l;k<r;++k){\n        int temp=solve(l,k)+solve(k+1,r)+a[l].al*a[k].ar*a[r].ar;\n        if(temp<f[l][r])pos=k,f[l][r]=temp;\n    }\n    g[l][r]=pos;\n    return f[l][r];\n}\nvoid dfs(int l,int r){\n    if(l==r)return ;\n    a[l].zk++,a[r].yk++;\n    dfs(l,g[l][r]),dfs(g[l][r]+1,r);\n}\nvoid out(){\n    printf(\"Case %d: \",++cnt);\n    for(int i=1;i<=n;++i){\n        if(i!=1)printf(\" x \");\n        while(a[i].zk)putchar('('),a[i].zk--;\n        printf(\"A%d\",i);\n        while(a[i].yk)putchar(')'),a[i].yk--;\n    }\n    putchar('\\n');\n}\nint main(){\n    while(scanf(\"%d\",&n)&&n){\n        init();\n        solve(1,n);\n        dfs(1,n);\n        out();\n    }\n}\n```\n","link":null,"tags":["dfs"],"title":"LG UVA348 Optimal Array-Multiplication-Sequence"},{"categories":[["刷题记录"]],"content":"\n找度最大的点 \n\n\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i=x;i<=y;i++)\n    #define Fdr(i,x,y) for(int i=x;i>=y;i--)\n    #define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) (int(log2(n)))\n    #define inf 0x3f3f3f3f\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 100011\nint n,cnt[N];\nint main(){\nfin(\"in\");\n\tin>>n;\t\n\tint x,y,ans=0;\n\tFur(i,1,n-1)in>>x>>y,ans=MAX(ans,MAX(++cnt[x],++cnt[y]));\n\tout<<ans+1<<ln;\n}\n\n```\n","link":null,"tags":["找度最大的点"],"title":"LG 5197 [USACO19JAN]Grass Planting"},{"categories":[["刷题记录"]],"content":"\n并查集技巧：记录每个点后面和它不属于同一个集合的第一个点\n\n\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i=x;i<=y;++i)\n    #define Fdr(i,x,y) for(int i=x;i>=y;--i)\n    #define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 0x3f3f3f3f\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){clr(ch,0);if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 200011\nint f[N],n,q,nxt[N];\nint gf(int x){\n    return (x==f[x])?x:(f[x]=gf(f[x]));\n}\nil void mg(int x,int y){\n    if(gf(x)!=gf(y))f[f[y]]=f[x];\n}\nint main(){\n    fin(\"in\");\n    in>>n>>q;\n    Fur(i,1,n)f[i]=i,nxt[i]=i+1;\n    int opt,x,y;\n    while(q--){\n        in>>opt>>x>>y;\n        if(opt==3)out<<(gf(x)==gf(y)?\"YES\":\"NO\")<<ln;\n        if(opt==2)\n            for(int i=x+1;i<=y;)mg(i-1,i),x=nxt[i],nxt[i]=nxt[y],i=x;\n        if(opt==1)mg(x,y);\n    }\n}\n```\n","link":null,"tags":["并查集","线段树"],"title":"LG CF566D Restructuring Company"},{"categories":[["刷题记录"]],"content":"\n因为$a$是单调递增的\n\n所以每个段的值就是$a_n-a_1$\n\n我们可以分成$k$个段,相当于选$k-1$的切点\n\n比如我们将$[1,n]$分成$[1,x],[x+1,n]$\n\n原来的值是$a_n-a_1$\n\n现在变成了$a_n-a_{x+1}+a_x-a_1$\n\n相当于减去了$a_{x+1}-a_x$\n\n对所有$a_{x+1}-a_x$排个序然后贪心就可以了\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\n#define N 300011\nint n,k,a[N],b[N];\npriority_queue<int>q;\nint main(){\n    in(n,k);\n    Fur(i,1,n)in(a[i]);\n    Fur(i,2,n)q.push(a[i]-a[i-1]);\n    int ans=a[n]-a[1];\n    while(--k)ans-=q.top(),q.pop();\n    cout<<ans<<endl;\n}\n```\n","link":null,"tags":["贪心"],"title":"LG CF1197C Array-Splitting"},{"categories":[["刷题记录"]],"content":"\n```cpp\n#include<iostream>\n#include<cstring>\n#define int long long\nusing namespace std;\nconst int maxs=(1<<18)+10,maxm=110;\nint w[20],cnt=-1,m,n,f[maxs][maxm];\nbool vis[10];\nsigned main()\n{\n    for(cin>>n>>m;n;n\/=10)\n        w[++cnt]=n%10;\n    f[0][0]=1;\n    for(int s=1;s<1<<cnt+1;s++)\n    {\n        memset(vis,0,sizeof(vis));\n        for(int i=0;i<=cnt;i++)\n        {\n            if(s==(1<<i)&&!w[i])\n                break;\n            if(!(s&(1<<i))||vis[w[i]])\n                continue;\n            vis[w[i]]=1;\n            for(int j=0;j<m;j++)\n                f[s][(j*10+w[i])%m]=f[s][(j*10+w[i])%m]+f[s^(1<<i)][j];\n        }\n    }\n    cout<<f[(1<<cnt+1)-1][0]<<endl;\n    return 0;\n}\n```\n","link":null,"tags":["状压dp"],"title":"LG CF401D Roman and Numbers"},{"categories":[["刷题记录"]],"content":"\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i=x;i<=y;i++)\n    #define Fdr(i,x,y) for(int i=x;i>=y;i--)\n    #define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) (int(log2(n)))\n    #define inf 0x3f3f3f3f\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 1000011\nint pri[N],tot=0,g[N],cnt[N];\nbool f[N];\nvoid ol(int n){\n\tFur(i,2,n){\n\t\tif(!f[i])pri[++tot]=i,g[i]=tot;\n\t\tFur(j,1,tot){\n\t\t\tif(pri[j]*i>n)break;\n\t\t\tf[i*pri[j]]=1;g[i*pri[j]]=j;\n\t\t\tif(i%pri[j]==0)break;\n\t\t}\n\t}\n}\nint main(){\n\tfin(\"in\");\n\tint n;\n\tll ans=1;\n\tin>>n;\n\tol(n);\n\tFur(i,2,n)\n\t\tfor(int x=i;x!=1;x\/=pri[g[x]])cnt[g[x]]++;\n\tFur(i,1,tot)ans=ans*(cnt[i]*2+1)%1000000007;\n\tout<<ans<<ln;\n}\n\n```\n","link":null,"tags":[],"title":"LG 1445 [Violet]樱花"},{"categories":[["刷题记录"]],"content":"\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i=x;i<=y;++i)\n    #define Fdr(i,x,y) for(int i=x;i>=y;--i)\n    #define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 0x3f3f3f3f\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){clr(ch,0);if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 100011\nint n,m;\nvoid dfs(){\n    \n}\nint main(){\n    cin>>n>>m;\n\n}\n```\n","link":null,"tags":["dfs","剪枝"],"title":"LG 1731 [NOI1999]生日蛋糕"},{"categories":[["刷题记录"]],"content":"\n设$S_i$表示$[1,i]$的异或和,区间$[l,r]$的异或和就是$S_r \\bigoplus S_{l-1}$\n\n那么题目可以转化为$[l-1,r]$中有多少对$S_i \\bigoplus S_j = k$,直接用莫队统计就可以了\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;rg char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\n#define N 100011\nint n,k,sz,Q,s[N],cnt[1200010];\nstruct que{\n    int l,r,id;\n}q[N];\nil int bl(int x){return (x-1)\/sz+1;}\nbool cmp(que x,que y){\n    if(bl(x.l)==bl(y.l))return x.r<y.r;\n    return x.l<y.l;\n}\nll ans=0,ANS[N];\nil void add(int x){\n    ans+=cnt[s[x]^k];\n    ++cnt[s[x]];\n}\nil void del(int x){\n    --cnt[s[x]];\n    ans-=cnt[s[x]^k];\n}\nint main(){\n    in(n,Q,k);sz=sqrt(n);\n    s[0]=0;\n    Fur(i,1,n){\n        int x;\n        in(x);\n        s[i]=x^s[i-1];\n    }\n    Fur(i,1,Q)in(q[i].l,q[i].r),--q[i].l,q[i].id=i;\n    sort(q+1,q+Q+1,cmp);\n    cnt[0]=1;\n    int l=0,r=0;\n    Fur(i,1,Q){\n        Fur(j,l,q[i].l-1)del(j);\n        Fdr(j,l-1,q[i].l)add(j);\n        Fur(j,r+1,q[i].r)add(j);\n        Fdr(j,r,q[i].r+1)del(j);\n        ANS[q[i].id]=ans;\n        l=q[i].l;r=q[i].r;\n    }\n    Fur(i,1,Q)out(ANS[i],ln);\n    flush();\n}\n```\n","link":null,"tags":["莫队","前缀和"],"title":"LG CF617E XOR-and-Favorite-Number"},{"categories":[["刷题记录"]],"content":"\n记录区间内最先出现的左括号和右括号\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i=x;i<=y;i++)\n    #define Fdr(i,x,y) for(int i=x;i>=y;i--)\n    #define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) (int(log2(n)))\n    #define inf 0x3f3f3f3f\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){clr(ch,0);if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 200011\n#define ls rt<<1\n#define rs rt<<1|1\nint n,q,s[N<<2],sl[N<<2],sr[N<<2];\nvoid pu(int rt){\n\ts[rt]=s[ls]+s[rs];\n\tif(sl[ls]&&sr[rs])s[rt]++;\n\tif(sl[rs])sl[rt]=sl[rs];\n\telse if(!s[rs]&&!sr[rs]&&!sl[rs]&&sl[ls])sl[rt]=sl[ls];\n\telse sl[rt]=0;\n\tif(sr[ls])sr[rt]=s[ls];\n\telse if(!s[ls]&&!sl[ls]&&!sr[ls]&&sr[rs])sr[rt]=sr[rs];\n\telse sr[rt]=0;\n}\nvoid build(int l,int r,int rt){\n\tif(l==r){\n\t\tif(l==1)sl[rt]=1;\n\t\tif(l==n)sr[rt]=n;\n\t\treturn;\n\t}\n\tint m=(l+r)>>1;\n\tbuild(l,m,ls);\n\tbuild(m+1,r,rs);\n\tpu(rt);\n}\nvoid upd(int x,int c,int l,int r,int rt){\n\tif(l==r){\n\t\tif(c==0)sl[rt]=sr[rt]=0;\n\t\tif(c==1)sl[rt]=l,sr[rt]=0;\n\t\tif(c==2)sr[rt]=l,sl[rt]=0;\n\t\treturn;\n\t}\n\tint m=(l+r)>>1;\n\tif(x<=m)upd(x,c,l,m,ls);\n\telse upd(x,c,m+1,r,rs);\n\tpu(rt);\n}\nint ask(int L,int R,int l,int r,int rt){\n\tif(L<=l&&r<=R)return s[rt];\n\tint m=(l+r)>>1,ans=0;\n\tif(L<=m)ans=ask(L,R,l,m,ls);\n\tif(R>m)ans+=ask(L,R,m+1,r,rs);\n\tif(L<=sl[ls]&&sr[rs]<=R&&sr[rs])ans++;\n\treturn ans;\n}\nint main(){\n\tfin(\"in\");\n\tin>>n>>q;\n\tint u,x,y;\n\tchar ch;\n\tbuild(1,n,1);\n\twhile(q--){\n\t\tin>>u>>x;\n\t\tif(u==1){\n\t\t\tin>>ch;\n\t\t\tif(ch=='X')y=0;\n\t\t\tif(ch=='(')y=1;\n\t\t\tif(ch==')')y=2;\n\t\t\tupd(x,y,1,n,1);\n\t\t}\n\t\telse{\n\t\t\tin>>y;\n\t\t\tout<<ask(x,y,1,n,1)<<ln;\n\t\t}\n\t}\n}\n\n```\n","link":null,"tags":["线段树"],"title":"LG 3797 妖梦斩木棒"},{"categories":[["刷题记录"]],"content":"\n原本打算写dp的,但是~~仔细观察一下~~,只要第一个点确定了,后面的点也确定了\n\n答案只有可能是$0,1,2$中的一种\n\n~~(可能是我扫雷玩太少了)~~\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i=x;i<=y;++i)\n    #define Fdr(i,x,y) for(int i=x;i>=y;--i)\n    #define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){clr(ch,0);if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 10011\nint n,a[N],ans=0;\nint b[N];\nbool chk(){\n    Fur(i,2,n+1){\n        b[i]=a[i-1]-b[i-1]-b[i-2];\n        if(b[i]!=1&&b[i]!=0)return 0;\n        if(i==n+1&&b[i]!=0)return 0;\n    }\n    return 1;\n}\nint main(){\n    fin(\"in\");\n    in>>n;\n    b[0]=0;\n    Fur(i,1,n)in>>a[i];\n    b[1]=1;\n    ans+=chk();\n    b[1]=0;\n    ans+=chk();\n    out<<ans<<ln;\n}\n```\n","link":null,"tags":["思维","递推"],"title":"LG 2327 [SCOI2005]扫雷"},{"categories":[["刷题记录"]],"content":"\n一个数有三种情况：\n\n1. 放左边\n2. 放右边\n3. 不选\n\n折半搜索\n\n还是一样的套路\n\n分前部分和后部分搜索\n\n但是有可能出现前后选的数出现重叠状况\n\n我们可以用状压并开一个桶来记录是否重复出现过\n\n最后答案记得-1,因为空集不算\n\n```cpp\n#include<bits\/stdc++.h>\nusing namespace std;\n#define N 1000011\nint n,v[40],ans=0;\nstruct node{\n    int s,sta;    \n}a[1<<22],b[1<<22];\nbool cmp(node x,node y){\n    return x.s<y.s;\n}\nbool CMP(node x,node y){\n    return x.s>y.s;\n}\nint dep=0,ta=0,tb=0;\ninline void dfs(int d,int s,int now,bool f){\n    if(d==dep+1){\n        if(f)a[++ta]=node{s,now};\n        else b[++tb]=node{s,now};\n        return;\n    }\n    dfs(d+1,s,now,f);\n    dfs(d+1,s+v[d],(now+(1<<(d-1))),f);\n    dfs(d+1,s-v[d],(now+(1<<(d-1))),f);\n}\nbool vis[1<<22];\nint main(){\n    cin>>n;\n    for(int i=1;i<=n;++i)cin>>v[i];\n    dep=n\/2;\n    dfs(1,0,0,1);\n    dep=n;\n    dfs(n\/2+1,0,0,0);\n    sort(a+1,a+ta+1,cmp);\n    sort(b+1,b+tb+1,CMP);\n    int p=1,q=1;\n    while(p<=ta&&q<=tb){\n        while(-a[p].s<b[q].s&&q<=tb)++q;\n        int pos=q;\n        while(q<=tb&&-a[p].s==b[q].s){\n            if(!vis[a[p].sta|b[q].sta])\n                vis[a[p].sta|b[q].sta]=1,++ans;\n            ++q;\n        }\n        if(p<ta&&a[p].s==a[p+1].s)q=pos;\n        ++p;\n    }\n    cout<<ans-1<<endl; \n}\n```\n","link":null,"tags":["折半搜索"],"title":"LG 3067 [USACO12OPEN]平衡的奶牛群Balanced-Cow"},{"categories":[["刷题记录"]],"content":"\n设$f_i$为前$i$个最小代价\n\n设$s_i$为前$i$个字符串总字符数\n\n$$\nf_i=\\min(f_j+|(s_i-s_j)+(i-j-1)-L|^p)\n$$\n\n可以发现这个方程有决策单调性\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\n#define N 100011\nint n,L,P,s[N],k[N],pre[N];\n#define ld long double\nld f[N];\nld calc(int i,int j){\n    return f[j]+pow(ABS(s[i]-s[j]-L-1),P);\n}\nchar ch[N][33];\nil int bound(int x,int y){\n    int l=x,r=n+1,ret=n+1,m;\n    while(l<=r){\n        m=(l+r)>>1;\n        if(calc(m,x)>=calc(m,y))\n            ret=m,r=m-1;\n        else l=m+1;\n    }\n    return ret;\n}\nint q[N];\nvoid work(){\n    in(n,L,P);\n    Fur(i,1,n){\n        in(ch[i]);\n        s[i]=s[i-1]+strlen(ch[i])+1;\n    }\n\n    int h=1,t=1;\n    q[1]=0;\n    Fur(i,1,n){\n        while(h<t&&k[h]<=i)++h;\n        f[i]=calc(i,q[h]);pre[i]=q[h];\n        while(h<t&&k[t-1]>=bound(q[t],i))--t;\n        k[t]=bound(q[t],i);\n        q[++t]=i;\n    }\n\n    if(f[n]>1e18)out(\"Too hard to arrange\\n\");\n    else{\n        out((ll)f[n],ln);\n        int i;\n        for(q[t=0]=i=n;i;q[++t]=i=pre[i]);\n        for(;t;--t){\n            for(i=q[t]+1;i<q[t-1];++i)\n                out(ch[i],\" \");\n            out(ch[i],ln);\n        }\n    }\n    out(\"--\\n\");\n}\nint main(){\n    int T;in(T);\n    while(T--)work();\n    flush();\n}\n```\n","link":null,"tags":["决策单调性","动态规划"],"title":"LG 1912 [NOI2009]诗人小G"},{"categories":[["刷题记录"]],"content":"\n好题\n\n思路很妙\n\n$L[i][j]$表示区间$[i,j-1]$作为$j$的左儿子是否合法\n\n$R[i][j]$表示区间$[i+1,j]$作为$i$的右儿子是否合法\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;rg char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\n#define N 711\nint n,a[N];\nbool g[N][N],L[N][N],R[N][N];\nint main(){\n    in(n);\n    Fur(i,1,n)in(a[i]);\n    Fur(i,1,n)\n        Fur(j,i,n)if(GCD(a[i],a[j])>1)g[i][j]=g[j][i]=1;\n\n    Fur(i,1,n)L[i][i]=R[i][i]=1;\n    Fur(i,1,n-1)\n        Fur(l,1,n-i+1){\n            int r=l+i-1;\n            Fur(p,l,r)\n            if(L[l][p]&&R[p][r]){\n                if(g[l-1][p])R[l-1][r]=1;\n                if(g[p][r+1])L[l][r+1]=1;\n            }\n        }\n\n    Fur(i,1,n)\n        if(L[1][i]&&R[i][n])return puts(\"Yes\"),0;\n    \n    puts(\"No\");\n}\n```\n","link":null,"tags":["动态规划","区间dp"],"title":"LG CF1025D Recovering-BST"},{"categories":[["刷题记录"]],"content":"\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i=x;i<=y;i++)\n    #define Fdr(i,x,y) for(int i=x;i>=y;i--)\n    #define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) (int(log2(n)))\n    #define inf 0x3f3f3f3f\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 100011\nstruct node{\n\tint l,r;\n}a[N];\nbool cmp(node p,node q){\n\treturn (p.l==p.l)?(p.l<q.l):(p.r>q.r);\n}\nint n,ans=0;\nint main(){\n\tfin(\"in\");\n\tin>>n;\n\tint x,y;\n\tFur(i,1,n)in>>x>>y,a[i].l=x-y,a[i].r=x+y;\n\tsort(a+1,a+n+1,cmp);\n\tint t=0;\n\tFur(i,1,n)if(a[i].r>t)t=a[i].r,ans++;\n\tout<<ans<<ln;\n}\n\n```\n","link":null,"tags":["技巧"],"title":"LG 5199 [USACO19JAN]Mountain View"},{"categories":[["刷题记录"]],"content":"\n$f[i][j]$表示第$i$天有$j$只股票最多赚多少钱\n$$\\\\$$\n\n1. 直接买\n   $f[i][j] = -ap[i] \\times j$\n2. 不买不卖\n\n    $f[i][j] =f[i-1][j]$\n\n3. 买股\n\n   $f[i][j] = f[i-w-1][k] - ap[i] \\times (j-k) (j-as[i] \\le k \\le j)$\n\n4. 卖股\n\n    $f[i][j] = f[i-w-1][k] + bp[i] \\times (k-j) (j \\le k \\le j + bs[i])$\n\n但是这样还是$O(n^3)$的复杂度,得想办法降到$O(n^2)$\n\n看一下$f[i][j] = f[i-w-1][k] - ap[i] \\times (j-k) (j-as[i] \\le k \\le j)$\n\n可以化为$f[i][j] = (f[i-w-1][k] + ap[i] \\times k) - ap[i] \\times j (j-as[i] \\le k \\le j)$\n\n于是就可以单调队列了 OωO\n\n```cpp\n\t#include<bits\/stdc++.h>\n\tnamespace ZDY{\n\t\t#pragma GCC optimize(3)\n\t\t#define il __inline__ __attribute__ ((always_inline))\n\t\t#define rg register\n\t\t#define ll long long\n\t\t#define ull unsigned long long\n\t\t#define db double\n\t\t#define sht short\n\t\t#define MB template <class T>il\n\t\t#define Fur(i,x,y) for(int i=x;i<=y;i++)\n\t\t#define Fdr(i,x,y) for(int i=x;i>=y;i--)\n\t\t#define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n\t\t#define clr(x,y) memset(x,y,sizeof(x))\n\t\t#define cpy(x,y) memcpy(x,y,sizeof(x))\n\t\t#define fin(s) freopen(s\".in\",\"r\",stdin)\n\t\t#define fout(s) freopen(s\".out\",\"w\",stdout)\n\t\t#define fcin ios::sync_with_stdio(false)\n\t\t#define l2(n) (int(log2(n)))\n\t\t#define inf 0x3f3f3f3f\n\t\tMB T ABS(T x){return x>0?x:-x;}\n\t\tMB T MAX(T x,T y){return x>y?x:y;}\n\t\tMB T MIN(T x,T y){return x<y?x:y;}\n\t\tMB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n\t\tMB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n\t}using namespace ZDY;using namespace std;\n\tnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n\t#define N 2001\n\tint n,p,w,ap,bp,as,bs,f[N][N],q[N],ans=0;\n\tint main(){\n\t\tin>>n>>p>>w;\n\t\tclr(f,128);\n\t\tFur(i,1,n){\n\t\t\tin>>ap>>bp>>as>>bs;\n\t\t\tFur(j,0,as)f[i][j]=-ap*j;\n\t\t\tFur(j,0,p)f[i][j]=MAX(f[i][j],f[i-1][j]);\n\t\t\tif(i<=w)continue;\n\t\t\tint l=1,r=0;\n\t\t\tFur(j,0,p){\n\t\t\t\twhile(l<=r&&q[l]<j-as)l++;\n\t\t\t\twhile(l<=r&&f[i-w-1][q[r]]+q[r]*ap<=f[i-w-1][j]+j*ap)r--;\n\t\t\t\tq[++r]=j;\n\t\t\t\tif(l<=r)f[i][j]=MAX(f[i][j],f[i-w-1][q[l]]+q[l]*ap-j*ap);\n\t\t\t}\n\t\t\tl=1,r=0;\n\t\t\tFdr(j,p,0){\n\t\t\t\twhile(l<=r&&q[l]>j+bs)l++;\n\t\t\t\twhile(l<=r&&f[i-w-1][q[r]]+q[r]*bp<=f[i-w-1][j]+j*bp)r--;\n\t\t\t\tq[++r]=j;\n\t\t\t\tif(l<=r)f[i][j]=MAX(f[i][j],f[i-w-1][q[l]]+q[l]*bp-j*bp);\n\t\t\t}\n\t\t}\n\t\tFur(i,0,p)ans=MAX(ans,f[n][i]);\n\t\tout<<ans<<ln;\n\t}\n```\n","link":null,"tags":["动态规划","单调队列"],"title":"LG 2569 [SCOI2010]股票交易"},{"categories":[["刷题记录"]],"content":"\n```cpp\n\n```\n","link":null,"tags":[],"title":"LG 5482 [JLOI2011]不等式组"},{"categories":[["刷题记录"]],"content":"\n# 玄学的最短路优化\n\n一看数据范围这么大,一定不能直接做\n\n当你删掉某条边(u,u+1)时,最短路路线为：1->x(<=u)->y(>u)->n,并且x->y一定不会属于原最短路\n\n就是最短路->其他边->最短路\n\nban:(禁用)\n\n先把所有堵车的边ban掉,然后跑最短路\n\n接着依次加边,跑最短路,就不用清空dis了\n\n$d(x,y)$指$x$到$y$的最短距离\n\n每个点的答案就是$d(1,x)+d(x,n)$\n\n所以开一个堆,\n\n枚举被ban的边\n\n把答案和没被ban的边的编号扔进去就可以了\n\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n\t#pragma GCC optimize(3)\n\t#define il __inline__ __attribute__ ((always_inline))\n\t#define rg register\n\t#define ll long long\n\t#define ull unsigned long long\n\t#define db double\n\t#define sht short\n\t#define MB template <class T>il\n\t#define Fur(i,x,y) for(int i=x;i<=y;i++)\n\t#define Fdr(i,x,y) for(int i=x;i>=y;i--)\n\t#define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n\t#define clr(x,y) memset(x,y,sizeof(x))\n\t#define cpy(x,y) memcpy(x,y,sizeof(x))\n\t#define fin(s) freopen(s\".in\",\"r\",stdin)\n\t#define fout(s) freopen(s\".out\",\"w\",stdout)\n\t#define fcin ios::sync_with_stdio(false)\n\t#define l2(n) (int(log2(n)))\n\t#define inf 0x3f3f3f3f\n\tMB T ABS(T x){return x>0?x:-x;}\n\tMB T MAX(T x,T y){return x>y?x:y;}\n\tMB T MIN(T x,T y){return x<y?x:y;}\n\tMB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n\tMB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 200011\nint n,m,k,cnt=0,head[N],d[N],path[N],fr[N],s[N],g[N];\nbool b[N],v[N];\nstruct edge{\n\tint to,nxt,w;\n}e[N*10];\nvoid add(int x,int y,int w){\n\te[++cnt].to=y;e[cnt].w=w;e[cnt].nxt=head[x];head[x]=cnt;\n}\nstruct cmp{\n\tbool operator()(int x,int y){return d[x]>d[y];}\n};\nstruct node{\n\tint to,val;\n\tbool operator < (const node &fff) const {\n        return val > fff.val;\n    }\n};\npriority_queue<int,vector<int>,cmp>q;\npriority_queue<node>T;\nvoid spfa(int st){\n\tint x;\n\tq.push(st);v[st]=1;\n\twhile(!q.empty()){\n\t\tx=q.top();q.pop();\n\t\tv[x]=0;\n\t\tfl(i,x)if(!b[i]&&d[x]+e[i].w<d[to]){\n\t\t\td[to]=d[x]+e[i].w;\n\t\t\tif(fr[to])T.push(node{fr[to],d[to]+g[fr[to]]});\n\t\t\telse if(!v[to])q.push(to),v[to]=1;\n\t\t}\n\t}\n}\n\nint main(){\n\tin>>n>>m>>k;\n\tint x,y,w;\n\tFur(i,1,m)in>>x>>y>>w,add(x,y,w);\n\tFur(i,1,k){\n\t\tin>>path[i];\n\t\tb[path[i]]=1;\n\t\ts[i+1]=e[path[i]].to;\n\t\tfr[s[i+1]]=i+1;\n\t}\n\tFdr(i,k,1)g[i]=g[i+1]+e[path[i]].w;\n\tclr(d,126);\n\td[1]=0;\n\tfr[1]=s[1]=1;\n\tspfa(1);\n\tFur(i,1,k){\n\t\twhile(!T.empty()&&T.top().to<=i)T.pop();\n\t\tif(T.empty())out<<\"-1\\n\";\n\t\telse out<<T.top().val<<ln;\n\t\td[e[path[i]].to]=d[s[i]]+e[path[i]].w;\n\t\tspfa(s[i+1]);\n\t}\n}\n```\n","link":null,"tags":["spfa","技巧"],"title":"LG 3238 [HNOI2014]道路堵塞"},{"categories":[["刷题记录"]],"content":"\n$f[0] = 0$　\n\n（$i$指状态压缩后的二进制数）$f[i]=\\sum f[i'])$　\n\nlowbit可以很快地获取一个数在二进制下第一个1在哪　\n\n一直lowbit和异或就可以把所有1找到　\n\n因为这道题卡常,所以只能用lowbit\n\n\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n\t#pragma GCC optimize(3)\n\t#define il __inline__ __attribute__ ((always_inline))\n\t#define rg register\n\t#define ll long long\n\t#define ull unsigned long long\n\t#define db double\n\t#define sht short\n\t#define MB template <class T>il\n\t#define Fur(i,x,y) for(rg int i=x;i<=y;i++)\n\t#define Fdr(i,x,y) for(rg int i=x;i>=y;i--)\n\t#define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n\t#define clr(x,y) memset(x,y,sizeof(x))\n\t#define cpy(x,y) memcpy(x,y,sizeof(x))\n\t#define fin(s) freopen(s\".in\",\"r\",stdin)\n\t#define fout(s) freopen(s\".out\",\"w\",stdout)\n\t#define fcin ios::sync_with_stdio(false)\n\t#define l2(n) (int(log2(n)))\n\t#define inf 0x3f3f3f3f\n\tMB T ABS(T x){return x>0?x:-x;}\n\tMB T MAX(T x,T y){return x>y?x:y;}\n\tMB T MIN(T x,T y){return x<y?x:y;}\n\tMB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n\tMB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 24\nint f[1<<N|1],d[1<<N|1],n,m;\nint b1,b2;\nint main(){\n\tin>>n;\n\tFur(i,0,n-1)in>>d[1<<i];\n\tin>>m;\n\tif(m>0)in>>b1;\n\tif(m>1)in>>b2;\n\tf[0]=1;\n\tint len=(1<<n)-1;\n\tFur(i,1,len){\n\t\tint j=i&(-i);\n\t\td[i]=d[i^j]+d[j];\n\t\tif(d[i]==b1||d[i]==b2)continue;\n\t\tfor(rg int x=i,k;x;x^=k)k=x&(-x),f[i]=(f[i]+f[i^k])%1000000007;\n\t}\n\tout<<f[len]<<ln;\n}\n```\n","link":null,"tags":["状态压缩","动态规划","位运算"],"title":"LG 2396 yyy-loves-Maths-VII"},{"categories":[["刷题记录"]],"content":"\n$f[i][j]$表示状态为$i$,上一个吃的是第$j$道菜\n\n$f[i'][k]=\\max(f[i'][k],f[i][j]+a[j]+d[j][k])$ ($d[j][k]$表示连续吃$j,k$能额外获得多少满意度)\n\n\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i=x;i<=y;i++)\n    #define Fdr(i,x,y) for(int i=x;i>=y;i--)\n    #define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 0x3f3f3f3f\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){clr(ch,0);if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 600\nint n,m,K,a[N],d[N][N];\nll f[1<<18][20],ans=0;\nint main(){\n    in>>n>>m>>K;\n    Fur(i,1,n)in>>a[i];\n    int x,y,w;\n    Fur(i,1,K){\n        in>>x>>y>>w;\n        d[x][y]=MAX(d[x][y],w);\n    }\n    Fur(i,1,n)f[1<<(i-1)][i]=a[i];\n    Fur(i,0,(1<<n)-1){\n        int t=i,s=0;\n        while(t)s+=(t&1),t>>=1;\n        Fur(j,1,n)\n        if(i&(1<<(j-1))){\n            if(s==m)ans=MAX(ans,f[i][j]);\n            else{\n                Fur(k,1,n)\n                if(k!=j&&!(i&(1<<(k-1))))f[i|(1<<(k-1))][k]=MAX(f[i|(1<<(k-1))][k],f[i][j]+a[k]+d[j][k]);\n            }   \n        }\n    }\n    out<<ans<<ln;\n}\n\n```\n","link":null,"tags":["状压dp"],"title":"LG CF580D Kefa-and-Dishes"},{"categories":[["刷题记录"]],"content":"\n还是用并查集统计连通块大小\n\n离线处理,按相关性从大到小加边\n\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i=x;i<=y;++i)\n    #define Fdr(i,x,y) for(int i=x;i>=y;--i)\n    #define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 0x3f3f3f3f\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){clr(ch,0);if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 100011\nint n,q,ans[N];\nstruct que{\n    int k,x,id;\n}b[N];\nstruct link{\n    int x,y,w;\n}e[N];\nbool cmp(link x,link y){return x.w>y.w;}\nbool cmp2(que x,que y){return x.k>y.k;}\nint f[N],sz[N];\nint gf(int x){\n    return (x==f[x])?x:(f[x]=gf(f[x]));\n}\nint main(){\n    fin(\"in\");\n    in>>n>>q;\n    Fur(i,1,n-1)in>>e[i].x>>e[i].y>>e[i].w;\n    sort(e+1,e+n,cmp);\n    Fur(i,1,q)in>>b[i].k>>b[i].x,b[i].id=i;\n    sort(b+1,b+q+1,cmp2);\n    int t=1,x,y;\n    Fur(i,1,n)f[i]=i,sz[i]=1;\n    Fur(i,1,q){\n        while(e[t].w>=b[i].k&&t<n){\n            x=e[t].x,y=e[t].y;\n            int fx=gf(x),fy=gf(y);\n            if(fx!=fy){\n                f[fx]=fy;\n                sz[fy]+=sz[fx];\n                sz[fx]=sz[fy];\n            }\n            ++t;\n        }\n        ans[b[i].id]=sz[gf(b[i].x)]-1;\n    }\n    Fur(i,1,q)out<<ans[i]<<ln;\n}\n```\n","link":null,"tags":["并查集"],"title":"LG 4185 [USACO18JAN]MooTube"},{"categories":[["刷题记录"]],"content":"\n有趣的题\n\n先倍增处理出$len_x$一个点最长往上跳多少个\n\n然后动态规划\n\n设$dp_x$为在放置最少的情况下$x$还能再向上跳多少个\n\n那么$dp_x = \\max(f[to])-1$\n\n如果$dp_x = -1$,那么在选中$++ans_x,dp_x = len_x-1$\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;rg char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\n#define N 100111\n#define int ll\nint n,L,S,cnt=0,head[N],w[N],f[N],d[N],D[N],up[N][22],len[N];\nstruct edge{\n    int to,nxt;\n}e[N];\nvoid add(int x,int y){e[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;}\nvoid dfs(int x){\n    D[x]=D[f[x]]+w[x];\n    d[x]=d[f[x]]+1;\n    up[x][0]=f[x];\n    int k=l2(d[x]);\n    Fur(i,1,k)\n        up[x][i]=up[up[x][i-1]][i-1];\n    \n    fl(i,x)dfs(to);\n}\nint ans[N],dp[N];\nvoid sol(int x){\n    dp[x]=-1;ans[x]=0;\n    fl(i,x){\n        sol(to);\n        ans[x]+=ans[to];\n        dp[x]=MAX(dp[x],dp[to]-1);\n    }\n    if(dp[x]==-1)dp[x]=len[x]-1,++ans[x];\n}\nsigned main(){\n    in(n,L,S);\n    if(!L)return puts(\"-1\"),0;\n    Fur(i,1,n){\n        in(w[i]);\n        if(w[i]>S)return puts(\"-1\"),0;\n    }\n    Fur(i,2,n)in(f[i]),add(f[i],i);\n    dfs(1);\n    Fur(i,1,n){\n        int x=i;\n        Fdr(j,20,0)\n        if(up[x][j]&&D[i]-D[f[up[x][j]]]<=S&&d[i]-d[f[up[x][j]]]<=L)\n            x=up[x][j];\n        len[i]=d[i]-d[x]+1;\n    }\n    sol(1);\n    cout<<ans[1]<<endl;\n}\n```\n","link":null,"tags":["动态规划","倍增"],"title":"LG CF1059E Split-the-Tree"},{"categories":[["刷题记录"]],"content":"\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n\t#pragma GCC optimize(3)\n\t#define il __inline__ __attribute__ ((always_inline))\n\t#define rg register\n\t#define ll long long\n\t#define ull unsigned long long\n\t#define db double\n\t#define sht short\n\t#define MB template <class T>il\n\t#define Fur(i,x,y) for(int i=x;i<=y;i++)\n\t#define Fdr(i,x,y) for(int i=x;i>=y;i--)\n\t#define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n\t#define clr(x,y) memset(x,y,sizeof(x))\n\t#define cpy(x,y) memcpy(x,y,sizeof(x))\n\t#define fin(s) freopen(s\".in\",\"r\",stdin)\n\t#define fout(s) freopen(s\".out\",\"w\",stdout)\n\t#define fcin ios::sync_with_stdio(false)\n\t#define l2(n) (int(log2(n)))\n\t#define inf 0x3f3f3f3f\n\tMB T ABS(T x){return x>0?x:-x;}\n\tMB T MAX(T x,T y){return x>y?x:y;}\n\tMB T MIN(T x,T y){return x<y?x:y;}\n\tMB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n\tMB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){clr(ch,0);if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 10011\nint main(){\n\tll n,ans,mod=1000000007;in>>n;\n\tans=n%mod*n%mod;\n\tfor(ll l=1,r=0;l<=n;l=r+1){\n\t\tr=n\/(ll)(n\/l);\n\t\tans-=((n\/l)%mod*(r-l+1)%mod*(l+r)%mod*500000004%mod)%mod;\n\t\twhile(ans<=mod)ans+=mod;\n\t\tans%=mod;\n\t}\n\tout<<ans<<ln;\n}\n```\n","link":null,"tags":[],"title":"51nod 1225 余数之和"},{"categories":[["刷题记录"]],"content":"\n我们假设现在要合并的两个数是$x,y$,那么合并后是$x\\cdot10^{{\\ln y}+1} +y$\n\n我们可以预处理出 $a_i \\cdot 10^t \\mod k(t\\le 10)$\n\n每个$a_i$统计有多少个数接到它前面符合要求\n\n\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;rg char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\n#define N 200011\nint n,k,a[N],pw[13];\n#include<bits\/extc++.h>\nusing namespace __gnu_pbds;\ncc_hash_table<int,int>T[13];\nint main(){\n    in(n,k);\n    pw[0]=1;\n    Fur(i,1,10)pw[i]=1ll*pw[i-1]*10%k;\n    Fur(i,1,n){\n        in(a[i]);\n        Fur(j,1,10)\n            ++T[j][1ll*a[i]%k*pw[j]%k];\n    }\n    ll ans=0;\n    Fur(i,1,n){\n        int len=int(log10(a[i]))+1;\n        ans+=T[len][((k-a[i])%k+k)%k];\n        if((1ll*a[i]%k*pw[len]%k+a[i]%k)%k==0)--ans;\n    }\n    printf(\"%lld\\n\",ans);\n}\n```\n","link":null,"tags":["桶","数论"],"title":"LG CF1029D Concatenated-Multiples"},{"categories":[["刷题记录"]],"content":"\n对$p$条直线分情况讨论平行线的条数,已知在有$r$条平行线时有$p-r$条线与他们相交于$p\\times(p-r)$个交点,再加上对于这$p-r$个交点的相交组合即可！\n```cpp\n#include<iostream>\nusing namespace std;\nint n,ans=0;\nbool f[10010];\nvoid suv(int p,int m){\n\tif(p==0){\n\t\tif(!f[m])ans++;\n\t\tf[m]=1;\n\t}\n\telse \n\t\tfor(int r=p;r>=1;r--)\n\t\t\tsuv(p-r,r*(p-r)+m);\n}\nint main(){\n\tcin>>n;\n\tsuv(n,0);\n\tcout<<ans<<endl;\n}\n```\n","link":null,"tags":[],"title":"LG 2789 直线交点数"},{"categories":[["刷题记录"]],"content":"\n我们回想一下 'TJOI2017可乐'\n\n如果边权都是1,我们可以用矩阵乘法来求邻接矩阵的$k$次幂\n\n因为边权只有$0-9$,所以我们可以直接把一个点拆成9个\n\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;rg char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\n#define N 100011\nconst int mod=2009;\nint n,t,nn;\nstruct mat{\n    mat(){clr(a,0);}\n    int a[111][111];\n}a;\nmat operator*(mat x,mat y){\n    mat c;\n    Fur(i,1,nn)\n        Fur(j,1,nn)\n            Fur(k,1,nn)\n            c.a[i][j]=(c.a[i][j]+x.a[i][k]*y.a[k][j]%mod)%mod;\n    return c;\n}\nmat operator^(mat x,int p){\n    mat ans;\n    Fur(i,1,nn)ans.a[i][i]=1;\n    while(p){\n        if(p&1)ans=ans*x;\n        p>>=1;x=x*x;\n    }\n    return ans;\n}\nint main(){\n    in(n,t);\n    nn=n*9;\n    Fur(i,1,n)\n        Fur(j,1,8)\n        a.a[9*(i-1)+j][9*(i-1)+j+1]=1;\n    \n    char s[20];\n    Fur(i,1,n){\n        in(s+1);\n        Fur(j,1,n)\n        if(s[j]>'0')\n            a.a[9*(i-1)+s[j]-'0'][9*(j-1)+1]=1;\n    }\n    a=a^t;\n    printf(\"%d\\n\",a.a[1][n*9-8]);\n}\n```\n","link":null,"tags":["矩阵乘法"],"title":"LG 4159 [SCOI2009]迷路"},{"categories":[["刷题记录"]],"content":"\n关于同一张图上的最小生成树,有一些性质：\n\n对于任意权值的边,所有最小生成树中这个权值的边的数量是一定的\n\n对于任意正确加边方案,加完小于某权值的所有边后图的连通性是一样的\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;rg char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\n#define N 500011\nint n,m,q;\nstruct link{\n    int x,y,w,id,bx,by;\n}E[N],tmp[N];\nbool cmp(link x,link y){return x.w<y.w;}\nbool CMP(link x,link y){return x.id<y.id;}\nint f[N];\nint gf(int x){return (x==f[x])?x:(f[x]=gf(f[x]));}\nil void mg(int x,int y){f[gf(y)]=gf(x);}\nint cnt[N];\nint main(){\n    in(n,m);\n    int x,y,w;\n    Fur(i,1,m){\n        in(x,y,w);\n        E[i]=link{x,y,w,i,0,0};\n    }\n    sort(E+1,E+m+1,cmp);\n    Fur(i,1,n)f[i]=i;\n    E[0].w=-1;\n    for(int i=1;i<=m;){\n        int j=i;\n        do{\n            E[j].bx=gf(E[j].x);\n            E[j].by=gf(E[j].y);\n            ++j;\n        }while(j<=m&&E[j].w==E[j-1].w);\n        while(i<j){\n            while(gf(E[i].x)==gf(E[i].y)&&i<j)++i;\n            if(i<j)mg(E[i].x,E[i].y);\n        }\n    }\n    sort(E+1,E+m+1,CMP);\n    in(q);\n    Fur(i,1,n)f[i]=i;\n    while(q--){\n        bool ff=1;\n        int t;in(t);\n        Fur(i,1,t){\n            in(x);\n            tmp[i]=E[x];\n        }\n        sort(tmp+1,tmp+t+1,cmp);\n        int tot=0;\n        Fur(i,1,t){\n            x=tmp[i].bx,y=tmp[i].by;\n            if(x==y){ff=0;break;}\n            mg(x,y);\n            int j=i+1;\n            while(j<=t&&tmp[j].w==tmp[i].w){\n                if(gf(tmp[j].bx)==gf(tmp[j].by)){ff=0;break;}\n                mg(tmp[j].bx,tmp[j].by);++j;\n            }\n            while(i<j)f[tmp[i].bx]=tmp[i].bx,f[tmp[i].by]=tmp[i].by,++i;\n        }\n        if(ff)out(\"YES\\n\");\n        else out(\"NO\\n\");\n    }\n    flush();\n}\n```\n","link":null,"tags":["kruskal"],"title":"LG CF891C Envy"},{"categories":[["刷题记录"]],"content":"\ndp\n\n(其实记忆化搜索也可以啦)\n\n只要假设组成$n$的数是递增或递减,就不会重复了\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n\t#pragma GCC optimize(3)\n\t#define il __inline__ __attribute__ ((always_inline))\n\t#define rg register\n\t#define ll long long\n\t#define ull unsigned long long\n\t#define db double\n\t#define sht short\n\t#define MB template <class T>il\n\t#define Fur(i,x,y) for(int i=x;i<=y;i++)\n\t#define Fdr(i,x,y) for(int i=x;i>=y;i--)\n\t#define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n\t#define clr(x,y) memset(x,y,sizeof(x))\n\t#define cpy(x,y) memcpy(x,y,sizeof(x))\n\t#define fin(s) freopen(s\".in\",\"r\",stdin)\n\t#define fout(s) freopen(s\".out\",\"w\",stdout)\n\t#define fcin ios::sync_with_stdio(false)\n\t#define l2(n) (int(log2(n)))\n\t#define inf 0x3f3f3f3f\n\tMB T ABS(T x){return x>0?x:-x;}\n\tMB T MAX(T x,T y){return x>y?x:y;}\n\tMB T MIN(T x,T y){return x<y?x:y;}\n\tMB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n\tMB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){clr(ch,0);if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 50011\n#define mod 1000000007\nint n;\nll f[321][N],ans=0;\nint main(){\n\tin>>n;\n\tf[0][0]=1;\n\tFur(i,1,320)\n\t\tFur(j,i,n)\n\t\tf[i][j]=(f[i-1][j-i]+f[i][j-i])%mod;\n\t\n\tFur(i,1,320)ans=(ans+f[i][n])%mod;\n\tout<<ans<<ln;\n}\n```\n","link":null,"tags":["动态规划","记忆化搜索"],"title":"51nod 1201 整数划分"},{"categories":[["刷题记录"]],"content":"\n把节点按行排序\n\n因为$k$很小,所以直接$k^2$dp就可以了\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i=x;i<=y;i++)\n    #define Fdr(i,x,y) for(int i=x;i>=y;i--)\n    #define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) (int(log2(n)))\n    #define inf 0x3f3f3f3f\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){clr(ch,0);if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 10001\nint n,m,t,k,f[N],ans=0;\nstruct node{\n\tint x,y,v;\n}a[N];\nbool cmp(node x,node y){\n\treturn (x.x==y.x)?(x.y<y.y):(x.x<y.x);\n}\nbool chk(node x,node y){\n\treturn ABS(x.y-y.y)<=t*ABS(x.x-y.x);\n}\nint main(){\n\tfin(\"in\");\n\tin>>n>>m>>k>>t;\n\tFur(i,1,k)in>>a[i].x>>a[i].y>>a[i].v;\n\tsort(a+1,a+k+1,cmp);\n\tFur(i,1,k){\n\t\tFur(j,1,i-1)\n\t\tif(chk(a[i],a[j]))\n\t\t\tf[i]=MAX(f[i],f[j]);\n\t\tf[i]+=a[i].v;\n\t\tans=MAX(ans,f[i]);\n\t}\n\tout<<ans<<ln;\n}\n\n```\n","link":null,"tags":["动态规划"],"title":"LG 3800 Power收集"},{"categories":[["刷题记录"]],"content":"\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;rg char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\n#define N 100011\nchar type[2];\nint n,m,p[N];\nint cnt=0,head[N];\nstruct edge{\n    int to,nxt;\n}e[N];\nil void add(int x,int y){\n    e[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;\n}\nint main(){\n    in(n,m,type);\n    Fur(i,1,n)in(p[i]);\n    int x,y;\n    Fur(i,1,n-1)in(x,y),add(x,y),add(y,x);\n    \n}\n```\n","link":null,"tags":[],"title":"LG 5024 保卫王国"},{"categories":[["刷题记录"]],"content":"\n求树的直径\n\n读入毒瘤\n\n自己探索吧(不怀好意\n\n(tips:getline,ssstream)\n\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n\t#pragma GCC optimize(3)\n\t#define il __inline__ __attribute__ ((always_inline))\n\t#define rg register\n\t#define ll long long\n\t#define ull unsigned long long\n\t#define db double\n\t#define sht short\n\t#define MB template <class T>il\n\t#define Fur(i,x,y) for(int i=x;i<=y;i++)\n\t#define Fdr(i,x,y) for(int i=x;i>=y;i--)\n\t#define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n\t#define clr(x,y) memset(x,y,sizeof(x))\n\t#define cpy(x,y) memcpy(x,y,sizeof(x))\n\t#define fin(s) freopen(s\".in\",\"r\",stdin)\n\t#define fout(s) freopen(s\".out\",\"w\",stdout)\n\t#define fcin ios::sync_with_stdio(false)\n\t#define l2(n) (int(log2(n)))\n\t#define inf 0x3f3f3f3f\n\tMB T ABS(T x){return x>0?x:-x;}\n\tMB T MAX(T x,T y){return x>y?x:y;}\n\tMB T MIN(T x,T y){return x<y?x:y;}\n\tMB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n\tMB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\n#define N 20000011\nstruct edge{\n\tint nxt,to,w;\n}e[N*2];\nint d[N],head[N],q[N],f[N],n,k=0,cnt=0;\nvoid add(int x,int y,int w){\n\te[++cnt].to=y;e[cnt].w=w;e[cnt].nxt=head[x];head[x]=cnt;\n}\nvoid bfs(int x){\n\tint h=0,t=1;\n\tq[h]=x;\n\tclr(d,0);clr(f,0);\n\twhile(h<t){\n\t\tint x=q[h++];\n\t\tif(d[k]<d[x])k=x;\n\t\tfl(i,x)if(to!=f[x]){\n\t\t\tf[to]=x;d[to]=d[x]+e[i].w;\n\t\t\tq[t++]=to;\n\t\t}\n\t}\n}\nint main(){\n\tint x,y,w;\n\tfcin;\n\tstring s;\n\tstringstream ss;\n\twhile(getline(cin,s)){\n\t\tcnt=0;clr(head,0);\n\t\tss.clear();\n\t\tss.str(s);\n\t\twhile(ss>>x>>y>>w){\n\t\t\tadd(x,y,w);add(y,x,w);\n\t\t\tgetline(cin,s);\n\t\t\tss.clear();\n\t\t\tss.str(s);\n\t\t}\n\t\tbfs(1);\n\t\tbfs(k);\n\t\tcout<<d[k]<<endl;\n\t}\n}\n```\n","link":null,"tags":["树的直径"],"title":"LG UVA10308 Roads-in-the-North"},{"categories":[["刷题记录"]],"content":"\n单调队列优化dp\n\n$f[i]$表示从$1-i$最多能选出的效率\n\n枚举断点$j$,\n\n$f[i] = \\max(f[j-1]+ \\sum_{t=j+1}^i a[t])$\n\n但是直接这样的复杂度不可行\n\n我们可以考虑用单调队列优化\n\n$f[i] = \\max(f[j-1] - S_j) + S_i$\n\n\n```cpp\n#include<iostream>\n#include<cstdio>\nusing namespace std;\n#define ll long long\nll n,m,a[100010],sum[100010],f[100010];\nll d[100010];\nint q[100010],head=0,tail=1;\nll que(int i){\n    d[i]=f[i-1]-sum[i];\n    while(head<=tail&&d[q[tail]]<d[i])tail--;\n    q[++tail]=i;\n    while(head<=tail&&q[head]<i-m)head++;\n    return d[q[head]];\n}\nint main(){\n    scanf(\"%lld%lld\",&n,&m);\n    for(int i=1;i<=n;++i)scanf(\"%d\",a+i),sum[i]=sum[i-1]+a[i];\n    for(int i=1;i<=n;++i)f[i]=que(i)+sum[i];\n    cout<<f[n];\n}\n```\n","link":null,"tags":["动态规划","单调队列"],"title":"LG 2627 修剪草坪"},{"categories":[["刷题记录"]],"content":"\n用所有总数减掉不符合的\n\nhash或马拉车\n\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i=x;i<=y;i++)\n    #define Fdr(i,x,y) for(int i=x;i>=y;i--)\n    #define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 0x3f3f3f3f\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){clr(ch,0);if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 10001\n#define base 233\n#define mod 51123987\null h[N],g[N],pw[N];\null gh(int l,int r){\n    return h[r]-h[l-1]*pw[r-l+1];\n}\null gg(int l,int r){\n    return g[l]-g[r+1]*pw[r-l+1];\n}\nint L[N],R[N],n,sum=0;\nchar s[N];\nvoid add(int l,int r){\n    L[l]++;L[r+1]--;\n    R[r]++;R[l-1]--;\n}\nvoid a1(int x){\n    int l=0,r=MIN(x,n-x),as;\n    while(l<=r){\n        int m=(l+r)>>1;\n        if(gh(x-m,x+m)==gg(x-m,x+m))as=m,l=m+1;\n        else r=m-1;\n    }\n    sum+=as;\n    add(x-as,x+as);\n}\nvoid a2(int x){\n    int l=0,r=MIN(x,n-x),as;\n    while(l<=r){\n        int m=(l+r)>>1;\n        if(gh(x-m+1,x+m)==gg(x-m+1,x+m))as=m,l=m+1;\n        else r=m-1;\n    }\n    sum+=as;\n    add(x-as+1,x+as);\n}\nint main(){\n    in>>n>>(s+1);\n    pw[0]=1;\n    Fur(i,1,n){\n        pw[i]=pw[i-1]*base;\n        h[i]=h[i-1]*base+s[i];\n    }\n    Fdr(i,n,1)\n        g[i]=g[i+1]*base+s[i];\n    \n    Fur(i,1,n)a1(i),a2(i);\n    Fur(i,1,n)L[i]+=L[i-1];\n    Fdr(i,n,1)R[i]+=R[i+1];\n    int ans=sum*(sum-1)%mod;\n    Fur(i,1,n)ans-=L[i]*R[i+1]%mod;\n    out<<ans<<ln;\n}\n\n```\n","link":null,"tags":["逆向思维","回文串","hash","马拉车"],"title":"LG CF17E Palisection"},{"categories":[["刷题记录"]],"content":"\n[同树网的核](..\/LG%201099%20树网的核\/index.html)\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n\t#pragma GCC optimize(3)\n\t#define il __inline__ __attribute__ ((always_inline))\n\t#define rg register\n\t#define ll long long\n\t#define ull unsigned long long\n\t#define db double\n\t#define sht short\n\t#define MB template <class T>il\n\t#define Fur(i,x,y) for(int i=x;i<=y;i++)\n\t#define Fdr(i,x,y) for(int i=x;i>=y;i--)\n\t#define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n\t#define clr(x,y) memset(x,y,sizeof(x))\n\t#define cpy(x,y) memcpy(x,y,sizeof(x))\n\t#define fin(s) freopen(s\".in\",\"r\",stdin)\n\t#define fout(s) freopen(s\".out\",\"w\",stdout)\n\t#define fcin ios::sync_with_stdio(false)\n\t#define l2(n) (int(log2(n)))\n\t#define inf 0x3f3f3f3f\n\tMB T ABS(T x){return x>0?x:-x;}\n\tMB T MAX(T x,T y){return x>y?x:y;}\n\tMB T MIN(T x,T y){return x<y?x:y;}\n\tMB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n\tMB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 300011\nint n,s,cnt=0,head[N],d[N],f[N],tmp=0,top,ans=inf;\nbool b[N];\nstruct edge{\n\tint to,nxt,w;\n}e[N*2];\nvoid add(int x,int y,int w){\n\te[++cnt].to=y;e[cnt].w=w;e[cnt].nxt=head[x];head[x]=cnt;\n}\nvoid dfs(int x){\n\tif(d[x]>d[tmp])tmp=x;\n\tfl(i,x)\n\tif(to!=f[x]&&!b[to])d[to]=d[x]+e[i].w,f[to]=x,dfs(to);\n}\nint main(){\n\tin>>n>>s;\n\tint x,y,w;\n\tFur(i,1,n-1)\n\t\tin>>x>>y>>w,\n\t\tadd(x,y,w),add(y,x,w);\n\t\n\td[1]=1;dfs(1);\n\td[tmp]=0;f[tmp]=0;\n\tdfs(tmp);\n\ttop=tmp;\n\tint h=0,t=1;\n\tfor(int i=top,j=top;i;i=f[i]){\n\t\twhile(d[j]-d[i]>s)j=f[j];\n\t\tans=MIN(ans,MAX(d[top]-d[j],d[i]));\n\t}\n\tfor(int i=top;i;i=f[i])b[i]=1;\n\tfor(int i=top;i;i=f[i]){\n\t\tx=i;d[i]=0;\n\t\tdfs(i);\n\t}\n\tFur(i,1,n)ans=MAX(ans,d[i]);\n\tout<<ans<<ln;\n}\n```\n","link":null,"tags":["dfs"],"title":"LG 2491 [SDOI2011]消防"},{"categories":[["刷题记录"]],"content":"\n第二类斯特林数\n\n将$n$个不同的球放进$m$个相同的盒子,保证盒子非空,求方案数。\n\n### 容斥法：\n\n$S(n,m)=\\frac 1{m!}\\sum_{i=0}^m {m\\choose i}(m-i)^n(-1)^i$\n\n枚举空盒个数,剩下随便放,到这里开始也有了二项式反演的形式\n\n由于盒子相同,所以除以$m!$\n\n### 递推法：\n\n$S(n,m)=S(n-1,m-1)+mS(n-1,m)$\n\n相当于考虑现在要放的求是否单独在一个盒子里：\n\n1. 不占一盒：\n   \n   其余$n-1$个球放到$m-1$个盒子里\n\n2. 放到某个有球的盒子里：\n   \n   有$m$个盒子可放($m$种可能),其余$n-1$个球放到$m$个盒子里\n\n此题要求的是$S(n,m) \\mod 2$\n\n当$m$为偶数,$S(n,m) \\equiv S(n-1,m-1)$\n\n当$m$为奇数,$S(n,m) \\equiv S(n-1,m-1)+s(n-1,m)$\n\n这样的话,相当于：\n\n当$(x,y)$中$y$为奇数时,可以走到$(x+1,y+1)(a$变换\n\n否则可以走到$(x+1,y+1)(a$变换,或$(x+1,y)(b$变换\n\n求从$(0,0)$走到$(n,m)$的方案数$\\mod 2$\n\n这个过程必然走了$m$次$a$变换,走了$n-m$次$b$变换\n\n而$b$变换只能在偶数位置出现,那么变换的序列必然是如下形式：\n\n$a,b\\times ?,a,a,b\\times ?,a,a,...,a$\n\n也就是在$\\frac {m+1}2$个间隔中插入$n-m$个$b$,即隔板法\n\n方案数:$C(n-m+\\frac{m+1}2-1,\\frac{m+1}2 -1) \\mod 2$\n\n还有一个结论：仅当$n\\&m==m$时,$C(n,m) \\equiv 1 \\bmod 2$\n```cpp\n#include<cstdio>\nbool C(int n,int m){\n    return (n&m)==m;\n}\nint main(){\n    int T;scanf(\"%d\",&T);\n    while(T--){\n        int n,m;\n        scanf(\"%d%d\",&n,&m);\n        if(!n&&!m)puts(\"1\");\n        else if(!n||!m||n<0)puts(\"0\");\n        else{\n            int b=n-m,a=(m+1)>>1;\n            puts(C(b+a-1,a-1)?\"1\":\"0\");\n        }\n    }\n}\n```\n","link":null,"tags":["容斥","递推","第二类斯特林数"],"title":"POJ 1430 Binary-Stirling-Numbers"},{"categories":[["刷题记录"]],"content":"\n设$f_i$表示$[1,i]$最多变成多少个\n\n$$f_i=\\max_{s_i=s_j}(f[j-1]+s_j\\times (\\sum_{i=j}^i[s_i=s_j])^2)$$\n\n我们可以发现如果$s_j=s_{j'}(j'< j)$,从$j'$转移一定比从$j$优\n\n这一条件满足决策单调性！\n\n我们可以用单调队列维护单调性\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\n#define N 100011\nint n,a[N],s[N],la[10011];\nvector<int>q[10011];\nll f[N];\nil ll calc(int p,int t){\n    return f[p-1]+1ll*a[p]*t*t;\n}\n#define sz(x) q[x].size()\nil int bound(int x,int y){\n    int ret=n+1;\n    int l=1,r=n,m;\n    while(l<=r){\n        m=(l+r)>>1;\n        if(calc(x,m-s[x]+1)>=calc(y,m-s[y]+1))\n            ret=m,r=m-1;\n        else l=m+1;\n    }\n    return ret;\n}\nint main(){\n    in(n);\n    Fur(i,1,n){\n        in(a[i]);\n        s[i]=s[la[a[i]]]+1;\n        la[a[i]]=i;\n    }\n    int h=1,t=0,x;\n    Fur(i,1,n){\n        x=a[i];\n        while(sz(x)>1&&bound(q[x][sz(x)-2],q[x][sz(x)-1])<=bound(q[x][sz(x)-1],i))\n            q[x].pop_back();\n        q[x].push_back(i);\n        while(sz(x)>1&&bound(q[x][sz(x)-2],q[x][sz(x)-1])\/*相当于决策点,懒得开k数组了*\/<=s[i])\n            q[x].pop_back();\n        f[i]=calc(q[x][sz(x)-1],s[i]-s[q[x][sz(x)-1]]+1);\n    }\n    cout<<f[n]<<endl;\n}\n```\n","link":null,"tags":["动态规划","决策单调性","单调队列"],"title":"LG 5504 [JSOI2011]柠檬"},{"categories":[["刷题记录"]],"content":"\n设$f[i][j]$表示前$i$个数选了$j$个最多多少\n\n$f[i][j]=\\max(f[i-1][j-1]+[a[i]=j],f[i-1][j]);$\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;rg char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\n#define N 1011\nint n,a[N],f[N][N];\nint main(){\n    fin(\"in\");\n    in(n);\n    Fur(i,1,n)in(a[i]);\n    Fur(i,1,n)\n        Fur(j,1,i)\n        f[i][j]=MAX(f[i-1][j-1]+(a[i]==j),f[i-1][j]);\n    \n    int ans=0;\n    Fur(i,1,n)ans=MAX(ans,f[n][i]);\n    out(ans,ln);\n    flush();\n}\n```\n","link":null,"tags":["动态规划"],"title":"LG 1799 数列_NOI导刊2010提高（06）"},{"categories":[["刷题记录"]],"content":"\n把工作按截止时间排序,如果当前时间没到截止时间,那么答案加上它的价值,然后往小根堆中插入它的价值\n\n否则,如果他的价值比堆顶大,那么答案加上它的价值减去堆顶,删除堆顶,插入它的价值\n\n\n\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;rg char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\n#define N 1000011\nint n;\nstruct node{\n    int v,d;\n}a[N];\nil bool cmp(node x,node y){return x.d<y.d;}\npriority_queue<int,vector<int>,greater<int>>q;\nint main(){\n    in(n);\n    Fur(i,1,n)in(a[i].d,a[i].v);\n    sort(a+1,a+n+1,cmp);\n    ll ans=0;\n    Fur(i,1,n){\n        if(a[i].d<=q.size()){\n            if(a[i].v>q.top())ans+=(a[i].v-q.top()),q.pop(),q.push(a[i].v);\n        }\n        else ans+=a[i].v,q.push(a[i].v);\n    }\n    cout<<ans<<endl;\n}\n```\n","link":null,"tags":["贪心"],"title":"LG 2949 [USACO09OPEN]工作调度Work-Scheduling"},{"categories":[["刷题记录"]],"content":"\n$f_{i,j} =f_{i,k}+1(|a_i-a_k| = |a_k-a_j|)$\n\n先对$a$排序,然后$dp$,双指针,记得数组开成$short$\n\n\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i=x;i<=y;i++)\n    #define Fdr(i,x,y) for(int i=x;i>=y;i--)\n    #define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) (int(log2(n)))\n    #define inf 0x3f3f3f3f\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){clr(ch,0);if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 10001\nint n,a[N];\nshort f[N][N];\nint main(){\n\tfin(\"in\");\n\tin>>n;\n\tFur(i,1,n)in>>a[i];\n\tsort(a+1,a+n+1);\n\tint ans=0,j,k;\n\tFur(i,2,n-1){\n\t\tj=i-1;k=i+1;\n\t\twhile(j&&k<=n){\n\t\t\tif(a[j]+a[k]>2*a[i])--j;\n\t\t\telse if(a[j]+a[k]<2*a[i])++k;\n\t\t\telse{\n\t\t\t\tif(!f[j][i])f[j][i]=f[i][k]=3;\n\t\t\t\telse f[j][i]=f[i][k]=f[j][i]+1;\n\t\t\t\tans=MAX(ans,int(f[i][k]));--j,++k;\n\t\t\t}\n\t\t}\n\t}\n\tout<<ans<<ln;\n}\n\n```\n","link":null,"tags":["双指针"],"title":"51nod 1055 最长等差数列"},{"categories":[["刷题记录"]],"content":"\n先用set预处理出离每个点最近的点和第二近的点\n\n从$n$~$1$ 每次往$set$里插入{$a[i],i$} 然后把前驱后继找出来比较一下 ~~具体看代码~~\n\n（听说有排序后双向链表的神仙做法）\n\n接着用倍增处理出开$2^i$循环次的数据\n\n然后就直接暴力\n\n~~具体看代码,码风有点新奇~~\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n\t#pragma GCC optimize(3)\n\t#define il __inline__ __attribute__ ((always_inline))\n\t#define rg register\n\t#define ll long long\n\t#define ull unsigned long long\n\t#define db double\n\t#define sht short\n\t#define MB template <class T>il\n\t#define Fur(i,x,y) for(int i=x;i<=y;i++)\n\t#define Fdr(i,x,y) for(int i=x;i>=y;i--)\n\t#define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n\t#define clr(x,y) memset(x,y,sizeof(x))\n\t#define cpy(x,y) memcpy(x,y,sizeof(x))\n\t#define fin(s) freopen(s\".in\",\"r\",stdin)\n\t#define fout(s) freopen(s\".out\",\"w\",stdout)\n\t#define fcin ios::sync_with_stdio(false)\n\t#define l2(n) (int(log2(n)))\n\t#define inf 0x3f3f3f3f\n\tMB T ABS(T x){return x>0?x:-x;}\n\tMB T MAX(T x,T y){return x>y?x:y;}\n\tMB T MIN(T x,T y){return x<y?x:y;}\n\tMB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n\tMB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 100011\nint a[N],n,m,A[N],B[N],f[N][20],fa[N][20],fb[N][20],P,Q;\nstruct node{\n\tint v,id;\n\tbool operator < (const node&x) const{\n\t\treturn v<x.v;\n\t}\n};\nset<node>T;\nvoid work(int p,int l){\n    int i,j;\n    P=Q=0;\n    Fdr(i,19,0){\n        if(f[p][i]&&P+Q+fa[p][i]+fb[p][i]<=l){\n            P+=fa[p][i];\n            Q+=fb[p][i];\n            p=f[p][i];\n        }\n    }\n    if(A[p]&&P+Q+fa[p][0]<=l)P+=fa[p][0];\n}\nint main(){\n\tin>>n;\n\tFur(i,1,n)in>>a[i];\n\tT.insert(node{a[n],n});\n\tFdr(i,n-1,1){\n\t\tset<node>::iterator it=T.lower_bound(node{a[i],i});\n\t\tnode t1,t2;\n\t\tt1.v=t2.v=inf;\n\t\tt1.id=t2.id=0;\n\t\tif((*it).v>a[i]){\n\t\t\tt1=(*it);\n\t\t\tif(++it!=T.end())t2=*it;\n\t\t\tit--;\n\t\t}\n\t\tif(it!=T.begin()){\n\t\t\tnode t=*--it;\n\t\t\t\n\t\t\tif(ABS(t.v-a[i])<ABS(t1.v-a[i]))t2=t1,t1=t;\n\t\t\telse if(ABS(t.v-a[i])==ABS(t1.v-a[i])&&t.v<t1.v)t2=t1,t1=t;\n\t\t\telse if(ABS(t.v-a[i])<ABS(t2.v-a[i]))t2=t;\n\t\t\telse if(ABS(t.v-a[i])==ABS(t2.v-a[i])&&t.v<t2.v)t2=t;\n\t\t\t\n\t\t\tif(it!=T.begin()){\n\t\t\t\tt=*--it;\n\t\t\t\t\n\t\t\t\tif(ABS(t.v-a[i])<ABS(t1.v-a[i]))t2=t1,t1=t;\n\t\t\t\telse if(ABS(t.v-a[i])==ABS(t1.v-a[i])&&t.v<t1.v)t2=t1,t1=t;\n\t\t\t\telse if(ABS(t.v-a[i])<ABS(t2.v-a[i]))t2=t;\n\t\t\t\telse if(ABS(t.v-a[i])==ABS(t2.v-a[i])&&t.v<t2.v)t2=t;\n\t\t\t}\n\t\t}\n\t\tB[i]=t1.id;A[i]=t2.id;\n\t\tT.insert(node{a[i],i});\n\t}\n\tFur(i,1,n){\n\t\tf[i][0]=B[A[i]];\n\t\tfa[i][0]=ABS(a[i]-a[A[i]]);\n\t\tfb[i][0]=ABS(a[A[i]]-a[B[A[i]]]);\n\t}\n\tFur(k,1,19)\n\t\tFur(i,1,n){\n\t\t\tf[i][k]=f[f[i][k-1]][k-1];\n\t\t\tfa[i][k]=fa[i][k-1]+fa[f[i][k-1]][k-1];\n\t\t\tfb[i][k]=fb[i][k-1]+fb[f[i][k-1]][k-1];\n\t\t}\n\tint x,len,ans=0;\n\tdb as=inf;\n\tin>>len;\n\tFur(i,1,n){\n\t\twork(i,len);\n\t\tif(Q){\n\t\t\tif(1.0*P\/Q<as)as=1.0*P\/Q,ans=i;\n\t\t}\n\t\telse if(a[i]>a[ans]&&as==inf)ans=i;\n\t}\n\tout<<ans<<ln;\n\tin>>m;\n\twhile(m--){\n\t\tin>>x>>len;\n\t\twork(x,len);\n\t\tout<<P<<\" \"<<Q<<ln;\n\t}\n}\n```\n","link":null,"tags":["倍增","set"],"title":"LG 1081 开车旅行"},{"categories":[["刷题记录"]],"content":"\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;rg char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\n#define N 10011\nint st,ed;\nint n,m,k,cnt=0,head[N],val[N];\nstruct edge{\n    int to,nxt,w;\n}e[200011];\nil void add(int x,int y,int w){\n    e[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;\n    e[cnt].w=w;\n}\nint d[N][30];\nbool v[N][30];\nstruct node{\n    int x,k;\n    il bool operator<(node y)const{\n        return d[x][k]>d[y.x][y.k];\n    }\n};\nint main(){\nint T;in(T);\nwhile(T--){\n    cnt=0;clr(head,0);\n    in(n,m,k);\n    int x,y,w;\n    Fur(i,1,n)in(x),val[i]=((x==1)?-1:1);\n    Fur(i,1,m)in(x,y,w),add(x,y,w),add(y,x,w);\n    in(st,ed);\n    clr(d,126);\n    d[st][k+val[st]]=0;\n    priority_queue<node>q;\n    q.push(node{st,k+val[st]});\n    while(!q.empty()){\n        node tmp=q.top();q.pop();\n        x=tmp.x,y=tmp.k;v[x][y]=0;\n        fl(i,x){\n            int nk=y+val[to];\n            if(nk<0||nk>2*k)continue;\n            if(d[x][y]+e[i].w<d[to][nk]){\n                d[to][nk]=d[x][y]+e[i].w;\n                if(!v[to][nk])q.push(node{to,nk}),v[to][nk]=1;\n            }\n        }\n    }\n    int ans=inf;\n    Fur(i,0,2*k)ans=MIN(ans,d[ed][i]);\n    if(ans==inf)ans=-1;\n    out(ans,ln);\n}\n    flush();\n}\n```\n","link":null,"tags":["分层图","最短路"],"title":"LG 5340 [TJOI2019]大中锋的游乐场"},{"categories":[["刷题记录"]],"content":"\n先用并查集求出所有连通块(相邻且相同颜色的节点)\n\n接着是相邻节点的颜色都不一样的一棵树\n\n最少次数就是树的直径\/2了\n\n```cpp\n#include<bits\/stdc++.h>\nusing namespace std;\n#define Fur(i,x,y) for(int i=x;i<=y;i++)\n#define N 200011\nint n,a[N],b[N];\nstruct edge{\n\tint to,nxt;\n}e[N*2];\nint head[N],cnt=1;\nvoid add(int x,int y){\n\te[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;\n}\nint mx=0,d[N];\nvoid dfs(int x,int f){\n\tif(d[x]>d[mx])mx=x;\n\tfor(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n\t\tif(to!=f)d[to]=d[x]+1,dfs(to,x);\n}\nint f[N];\nint gf(int x){\n\treturn (x==f[x])?x:(f[x]=gf(f[x]));\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tFur(i,1,n)scanf(\"%d\",&a[i]),f[i]=i;\n\tint x,y,t;\n\tFur(i,1,n-1)\n\t\tscanf(\"%d%d\",&x,&y),\n\t\tadd(x,y),add(y,x);\n\t\t\n\tFur(i,2,cnt){\n\t\tx=e[i].to,y=e[i^1].to;\n\t\tif(a[x]==a[y]&&gf(x)!=gf(y))f[f[y]]=f[x];\n\t\t++i;\n\t}\n\tt=cnt;cnt=0;\n\tmemset(head,0,sizeof(head));\n\tFur(i,2,t){\n\t\tx=gf(e[i].to),y=gf(e[i^1].to);\n\t\tif(x!=y)add(x,y),add(y,x);\n\t\t++i;\n\t}\n\tdfs(f[1],0);\n\tmemset(d,0,sizeof(d));\n\tdfs(mx,0);\n\tprintf(\"%d\\n\",(d[mx]+1)\/2);\n}\n```\n","link":null,"tags":["并查集","树的直径"],"title":"LG CF734E Anton and Tree"},{"categories":[["刷题记录"]],"content":"\n$f[i][0\/1]$表示以$i$为根的子树在$i$节点放置或不放置最少需要多少个\n\n$f[i][1]=1 + \\sum \\min(f[to][0],f[to][1])$\n\n$f[i][0]=\\sum f[1][to]$\n\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i=x;i<=y;++i)\n    #define Fdr(i,x,y) for(int i=x;i>=y;--i)\n    #define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 0x3f3f3f3f\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){clr(ch,0);if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 2011\nint n,cnt=0,head[N];\nstruct edge{\n    int to,nxt;\n}e[N*2];\nvoid add(int x,int y){\n    e[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;\n}\nint s[2][N];\nvoid dfs(int x,int f){\n    s[1][x]=1;\n    fl(i,x)if(to!=f){\n        dfs(to,x);\n        s[1][x]+=MIN(s[0][to],s[1][to]);\n        s[0][x]+=s[1][to];\n    }\n}\nint main(){\n    in>>n;\n    int x,y,tot;\n    Fur(i,1,n){\n        in>>x>>tot;\n        ++x;\n        while(tot--)in>>y,++y,add(x,y),add(y,x);\n    }\n    dfs(1,0);\n    out<<MIN(s[1][1],s[0][1]);\n}\n```\n","link":null,"tags":["树型dp"],"title":"LG 2016 战略游戏"},{"categories":[["刷题记录"]],"content":"\n```cpp\n#include<bits\/stdc++.h>\nusing namespace std;\nint n,k,a[257],rest,t=1,minp,cnt=0;\nbool flag=0;\nstring num;\nint main(){\n    cin>>num>>k;\n    n=num.length();\n    for(int i=1;i<=n;++i)a[i]=num[i-1]-'0';\n    rest=n-k;\n    while(cnt<rest){\n        minp=t;\n        for(int i=t;i<=k+t;++i)if(a[minp]>a[i])minp=i;\n        if(a[minp])flag=1;\n        if(flag)cout<<a[minp];\n        k-=minp-t;\n        t=minp+1;\n        cnt++;\n    }\n    if(!flag)cout<<0;\n}\n```\n","link":null,"tags":["贪心"],"title":"LG 1106 删数问题"},{"categories":[["刷题记录"]],"content":"\n```cpp\n#include<bits\/stdc++.h>\n#define il __inline__ __attribute__ ((always_inline))\n#define rg register\n#define Fur(i,x,y) for(rg int i=x;i<=y;i++)\n#define Fdr(i,x,y) for(rg int i=x;i>=y;i--)\nusing namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 100001\nint n,a[N],t[N],ans[N],tot=0;\nil void add(int x){while(x<=n)t[x]++,x+=x&-x;}\nil int ask(int x){int ans=0;while(x)ans+=t[x],x-=x&-x;return ans;}\nint main(){\n\tint x,k=n+1;\n\tFur(i,1,n)in>>a[i];\n\tFdr(i,n,1)\n\t\tif(a[i]>k){\n\t\t\tout<<i<<ln;\n\t\t\tFur(j,1,i)out<<i-j+ask(a[j])<<\" \",add(a[j]);\n\t\t\tout<<ln;\n\t\t\tbreak;\n\t\t}\n\t\telse add(a[i]),k=a[i];\n}\n\n```\n","link":null,"tags":[],"title":"LG 5200 [USACO19JAN]Sleepy Cow Sorting"},{"categories":[["刷题记录"]],"content":"\n```cpp\n#include<bits\/stdc++.h>\nint ans[300000],bns[300000],ap[1000005];\nusing namespace std;\nint main() {\n    int n;\n    scanf(\"%d\",&n);\n    int i,j;\n    int maxx = 0;\n    for(i = 0; i < n; i++)\n        scanf(\"%d\",&ans[i]),\n        maxx = max(ans[i],maxx);\n    \n    sort(ans,ans+n);\n    int cn = 0;\n    bns[cn++] = ans[0];\n    int t =bns[0];\n    for(i = 1; i < n; i++)\n        if(ans[i]!=t) {\n            t = ans[i];\n            bns[cn++] = t;\n        }\n    \n    if(n == 1)\n        printf(\"0\\n\");\n    else {\n        int ask = 0;\n        for(i = cn-1; i >= 0; i--) {\n            if(bns[i]!=1) {\n                for(j = 2; bns[i]*j <= maxx+bns[i]; j++) {\n                    int l = i+1,r = cn-1;\n                    int id = -1;\n                    while(l <= r) {\n                        int mid = (l+r)\/2;\n                        if(bns[mid] < bns[i]*j) {\n                            id = mid;\n                            l = mid + 1;\n                        } else r = mid-1;\n                    }\n                    if(id!=-1) \n                        ask = max(bns[id]%bns[i],ask);\n                }\n            }\n            if(ask >= bns[i])break;\n        }\n        printf(\"%d\\n\",ask);\n    }\n}\n```\n","link":null,"tags":[],"title":"51nod 1421 最大MOD值"},{"categories":[["刷题记录"]],"content":"\nFavorite-Dice\ntop: 0\n\n\n我是没看题解和标签写出来的,完全不知道这是期望\n\n假设你已经取了$i$个面,你取到没取过的一个面,概率是$\\frac {n-i}n$\n\n把所有概率加起来就是答案啦,也就是$\\sum_{i=0}^{n-1} \\frac  {n-i}n$\n\n\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n\t#pragma GCC optimize(3)\n\t#define il __inline__ __attribute__ ((always_inline))\n\t#define rg register\n\t#define ll long long\n\t#define ull unsigned long long\n\t#define db double\n\t#define sht short\n\t#define MB template <class T>il\n\t#define Fur(i,x,y) for(int i=x;i<=y;i++)\n\t#define Fdr(i,x,y) for(int i=x;i>=y;i--)\n\t#define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n\t#define clr(x,y) memset(x,y,sizeof(x))\n\t#define cpy(x,y) memcpy(x,y,sizeof(x))\n\t#define fin(s) freopen(s\".in\",\"r\",stdin)\n\t#define fout(s) freopen(s\".out\",\"w\",stdout)\n\t#define fcin ios::sync_with_stdio(false)\n\t#define l2(n) (int(log2(n)))\n\t#define inf 0x3f3f3f3f\n\tMB T ABS(T x){return x>0?x:-x;}\n\tMB T MAX(T x,T y){return x>y?x:y;}\n\tMB T MIN(T x,T y){return x<y?x:y;}\n\tMB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n\tMB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 10011\ndb work(int n){\n\tdb ans=0;\n\tFur(i,1,n)ans+=1.0*n\/(n-i+1);\n\treturn ans;\n}\nint main(){\n\tint q,x;in>>q;\n\twhile(q--)in>>x,printf(\"%.2f\\n\",work(x));\n}\n```\n","link":null,"tags":["期望"],"title":"LG SP1026 FAVDICE"},{"categories":[["刷题记录"]],"content":"\n思路很妙\n\n注意$m-n \\le 20$！\n\n也就是说最多只有$21$条非树边\n\n我们可以先跑一遍kruskal,然后按套路建树,两点之间的距离就是$d_x+d_y-2\\times lca(x,y)$\n\n接着剩下最多$21$条边($42$个节点),再跑最多$42$次最短路就可以处理出加上非树边的结果了\n```cpp\n#include<bits\/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define ull unsigned long long\n    #define db double\n    #define sht short\n    #define MB template <class T>il\n    #define Fur(i,x,y) for(int i(x);i<=y;++i)\n    #define Fdr(i,x,y) for(int i(x);i>=y;--i)\n    #define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) ((int)(log2(n)))\n    #define inf 2122219134\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;rg char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;rg char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\n#define N 100111\nint n,m,q,cnt=0,head[N];\nstruct edge{\n    int to,nxt,w;\n}e[N*2],ee[60];\nil void add(int x,int y,int w){\n    e[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;\n    e[cnt].w=w;\n    e[++cnt].to=x;e[cnt].nxt=head[y];head[y]=cnt;\n    e[cnt].w=w;\n}\nll D[N];\nint siz[N],top[N],f[N],d[N];\nvoid dfs(int x){\n    siz[x]=1;\n    fl(i,x)if(to!=f[x]){\n        D[to]=D[x]+e[i].w;f[to]=x;\n        d[to]=d[x]+1;\n        dfs(to);siz[x]+=siz[to];\n    }\n}\nvoid bt(int x,int tp){\n    top[x]=tp;int k=0;\n    fl(i,x)if(to!=f[x]&&siz[to]>siz[k])k=to;\n    if(!k)return;bt(k,tp);\n    fl(i,x)if(!top[to])bt(to,to);\n}\nll get(int x,int y){\n    int ox=x,oy=y;\n    while(top[x]!=top[y]){\n        if(d[top[x]]<d[top[y]])SWAP(x,y);\n        x=f[top[x]];\n    }\n    if(d[x]>d[y])SWAP(x,y);\n    return D[ox]+D[oy]-2*D[x];\n}\nstruct link{\n    int x,y,w,u;\n}E[N];\nint tt=0;\nbool cmp(link x,link y){return x.w<y.w;}\nint fa[N];\nint gf(int x){\n    return (x==fa[x])?x:(fa[x]=gf(fa[x]));\n}\nll dis[60][N];\nbool v[N];\nstruct node{\n    int x;\n    ll d;\n    bool operator<(node x)const{\n        return d>x.d;\n    }\n};\npriority_queue<node>T;\nvoid dij(int id,int st){\n    dis[id][st]=0;\n    T.push(node{st,0});\n    clr(v,0);\n    while(!T.empty()){\n        int x=T.top().x;T.pop();\n        if(v[x])continue;\n        v[x]=1;\n        fl(i,x)if(dis[id][x]+e[i].w<dis[id][to]){\n            dis[id][to]=dis[id][x]+e[i].w;\n            T.push(node{to,dis[id][to]});\n        }\n    }\n}\nvoid init(){\n    clr(dis,126);\n    sort(E+1,E+m+1,cmp);\n    Fur(i,1,n)fa[i]=i;\n    int x,y,w;\n    Fur(i,1,m){\n        x=E[i].x,y=E[i].y,w=E[i].w;\n        if(gf(x)!=gf(y)){\n            fa[fa[y]]=fa[x];\n            add(x,y,w);\n        }\n        else E[i].u=1;\n    }\n    dfs(1);bt(1,1);\n    Fur(i,1,m)if(E[i].u)\n        add(E[i].x,E[i].y,E[i].w);\n    Fur(i,1,m)if(E[i].u)\n        dij(++tt,E[i].x),dij(++tt,E[i].y);\n}\nsigned main(){\n    in(n,m);\n    int x,y,w;\n    Fur(i,1,m)in(x,y,w),E[i]=link{x,y,w};\n    init();\n    in(q);\n    while(q--){\n        in(x,y);\n        ll ans=get(x,y);\n        Fur(i,1,tt)\n            ans=MIN(ans,dis[i][x]+dis[i][y]);\n        out(ans,ln);\n    }\n    flush();\n}\n```\n","link":null,"tags":["lca","最短路","最小生成树"],"title":"LG CF1051F The-Shortest-Statement"},{"categories":[["算法","动态规划"],["算法","树论"],["note"]],"content":"\n# 划分dp\n\n## 题意\n\n每组输入是两个整数$n$和$k$($1\\le n \\le 50, 1 \\le k \\le n)$\n\n输出\n\n对于输入的$n,k$;\n\n第一行： 将$n$划分成若干正整数之和的方案数。\n\n第二行： 将$n$划分成$k$个正整数之和的方案数。\n\n第三行： 将$n$划分成最大数不超过$k$的方案数。\n\n第四行： 将$n$划分成若干个奇正整数之和的方案数。\n\n第五行： 将$n$划分成若干不同整数之和的方案数。\n\n第六行： 打印一个空行\n\n## Sol.：\n\n### 划分的多个正整数可以相同\n\n设$f[i][j]$表示将$i$划分成不大于$j$的整数的方案数\n\n1. 当$i<j$时,$i$不能划分为大于$i$的数,所以$f[i][j]=f[i][i]$\n2. 当$i>j$时,分为两种情况\n   - 划分中后的数含有$j$\n\n     方案数：$f[i-j][j](i<j)$\n\n   - 划分中不含$j$\n\n     相当于把$i$划分成不大于$j-1$的数\n     方案数：$f[i][j-1]$\n\n   所以$f[i][j]=f[i-j][j]+f[i-1][j-1](i>j)$\n\n3. 当$i=j$时,两种情况：\n\n   - 划分后的数只含有$j$,那么只有一种情况\n   - 相当于把$i$划分成不大于$j-1$的数\n   方案数：$f[i][j-1]$\n\n   所以$f[i][j]=1+f[i][j-1]$\n\n$f[n][n]$:将$n$划分为若干正整数之和的划分数\n\n$f[n][k]$:将$n$划分成最大数不超过$k$的划分数。\n\n### 划分的正整数必须不同\n\n设$f[i][j]$表示将$i$划分成不大于$j$的不同整数的方案数\n\n1. 当$i<j$时,$i$不能划分为大于$i$的数,所以$f[i][j]=f[i][i]$\n2. 当$i>j$时,分为两种情况\n   - 划分后的数中含有$j$\n\n     其余的不能含有$j$\n\n     方案数：$f[i-j][j-1](i<j)$\n\n   - 划分中不含$j$\n\n     相当于把$i$划分成不大于$j-1$的数\n\n     方案数：$f[i][j-1]$\n\n   所以$f[i][j]=f[i-j][j-1]+f[i-1][j-1](i>j)$\n\n3. 当$i=j$时,两种情况：\n\n   - 划分后的数只含有$j$,那么只有一种情况\n   - 相当于把$i$划分成不大于$j-1$的数\n   方案数：$f[i][j-1]$\n\n   $f[i][j]=1+f[i][j-1]$\n\n$f[n][n]$:将$n$划分为不同正整数之和的划分数\n\n### 将n划分为k个正整数的划分数\n\n设$f[i][j]$为将$i$划分为$j$个正整数的方案数\n\n1. $i<j$,不可能出现,$f[i][j]=0(i<j)$\n2. $i=j$, 只有一种情况：划分成$i$个$1$\n3. $i>j$,两种情况：\n   - 划分后的数中含有$1$\n\n     可以使用“截边法”将划分出的$j$个数分别减去$1$,把问题转化为将$i-j$划分成$j-1$个数,方案数：$f[i-j][j-1]$\n\n   - 划分后的数中不含$1$\n\n     使用“截边法”将划分出的$j$个数分别减去$1$,将为题转化为求$i-j$的$j$个划分数,为$f[i-j][j]$\n\n    所以$f[i][j]=f[i-j][j-1]+f[i-j][j]$\n\n$f[n][k]$表示将$n$划分为$k$个正整数的方案数\n\n### 将n划分为若干正奇数之和的划分数\n\n设$f[i][j]$为将$i$划分为$j$个奇数之和的划分数,\n\n$g[i][j]$为将$i$划分为$j$个偶数之和的划分数\n\n使用截边法,将$g[i][j]$的$j$个划分都减去$1$,可以得到$f[i-j][j]$,所以\n\n$g[i][j] = f[i-j][j]$\n\n对于$f[i][j]$\n\n1. 划分后的数中包含$1$\n   \n   可以将划分出的$1$除去,转化为“将$i-1$划分为$j-1$个奇数之和的划分数\n\n   即$f[i-1][j-1]$\n\n2. 划分后的数中不含$1$\n   \n   使用截边法将划分出的$j$个数每一个都减去$1$\n   \n   转化为“将$i-j$划分为$j$个偶数之和的划分数”,\n   \n   即$g[i-j][j]$\n\n所以$f[i][j]=f[i-1][j-1]+g[i-j][j]$。\n\n$\\sum_{i=0}^nf[n][i]$表示将$n$划分为若干奇数的方案数","link":null,"tags":["动态规划","计数"],"title":"划分dp"},{"categories":[["算法","数论"],["note"]],"content":"\n\n# 容斥\n\n## 容斥原理\n\n- 求具有n个属性之一（并集）的元素的个数\n\n- 求不具有n个属性中任何一个（交集）的元素的个数\n\n\n\n### 两个集合的并集\n\n$|A \\bigcup B| = |A|+|B|-|A \\bigcap B|$\n\n\n\n### 三个集合的并集\n\n$\n\\begin{aligned}\n|A \\bigcup B \\bigcup C|\n&=\\quad|A|+|B|+|C|\\\\\n&\\quad-|A \\bigcap B|-|A \\bigcap C|-|B \\bigcap C|\\\\\n&\\quad+|A\\bigcap B \\bigcap C|\n\\end{aligned}\n$\n\n\n\n### 多个集合的并集\n\n又称多步容斥\n\n$$\n\\begin{aligned}\n&\\quad|A_1 \\bigcup A_2 \\bigcup ... \\bigcup A_n|\\\\\n&=\\sum_{i=1}^n|A_i|\\\\\n&- \\sum_{i=1}^{n-1} \\sum_{j=i+1}^n|A_i \\bigcap A_j|\\\\\n&+ \\sum_{i=1}^{n-2} \\sum_{j=i+1}^{n-1}\\sum_{k=j+1}^{n}|A_i \\bigcap A_j \\bigcap A_k|\\\\\n&- ...\\\\\n&+(-1)^{n-1}|A_1 \\bigcap A_2 \\bigcap ... \\bigcap A_n|\n\\end{aligned}\n$$\n\n\n\n### De Morgan定理\n\n若$A,B$是$U$的子集,则\n\n($\\overline A$表示$A$的补集)\n\n$\\overline{A\\bigcup B} = \\overline A\\bigcap \\overline B$\n\n$\\overline{A\\bigcap B}=\\overline A \\bigcup \\overline B$\n\n若$A_1,A_2,…A_n$是$U$的子集,则\n\n$\\overline{A_1\\bigcup A_2 \\bigcup ... \\bigcup A_n} = \\overline{A_1} \\bigcap \\overline{A_2} \\bigcap ... \\bigcap \\overline A_n$\n\n$\\overline{A_1\\bigcap A_2 \\bigcap ... \\bigcap A_n} = \\overline{A_1} \\bigcup \\overline{A_2} \\bigcup ... \\bigcup \\overline A_n$\n\n\n\n### Example 1:\n\n给定集合$N$和具有性质$i$的集合$A_1,A_2,...,A_n$\n\n多步容斥变形:\n\n$$\n\\begin{aligned}\n&\\quad|\\overline{A_1}\\bigcap \\overline{A_2}\\bigcap...\\bigcap \\overline{A_n}|\\\\\n&=N\\\\\n&-\\sum|A_i|\\\\\n&+\\sum|A_i\\bigcap A_j|\\\\\n&-\\sum|A_i\\bigcap A_j \\bigcap A_k|\\\\\n&+...\\\\\n&+(-1)^n |A_1\\bigcap A_2 \\bigcap ... \\bigcap A_n|\n\\end{aligned}\n$$\n\n补集的补集就是原集:\n\n$$\n\\begin{aligned}\n&\\quad|A_1\\bigcap A_2\\bigcap...\\bigcap A_n|\\\\\n&=N\\\\\n&-\\sum|\\overline{A_i}|\\\\\n&+\\sum|\\overline{A_i} \\bigcap \\overline{A_j}|\\\\\n&-\\sum|\\overline{A_i} \\bigcap \\overline{A_j} \\bigcap \\overline{A_k}|\\\\\n&+...\\\\\n&+(-1)^n |\\overline{A_1}\\bigcap \\overline{A_2} \\bigcap ... \\bigcap \\overline{A_n}|\n\\end{aligned}\n$$\n\n\n\n### Example 2:\n\n> 求$a,b,c,d,e,f$六个字母的全排列中不允许出现$ace$和$df$图象的排列数\n\n设$N$为总排列数,$A$为$ace$出现的排列数,$B$为$df$出现的排列数\n\n$$\n\\begin{aligned}\nans\n&=|\\overline A \\bigcap \\overline B|\\\\\n&=|N|-|A|-|B|+|A\\bigcap B|\\\\\n&=6!-4!-5!+3!=582\n\\end{aligned}\n$$\n\n\n\n### Example 3:\n\n> $4$个$x,3$个$y,2$个$z$的全排列中,求不出现$xxxx,yyy,zz$图象的排列数.\n\n设$N$为总排列集合,出现$xxxx$的排列集合为$A$,出现$yyy$为$B$,出现$zz$为$C$\n\n$$\n\\begin{aligned}\nans\n&=\\quad|N|\\\\\n&\\quad-(|A|+|B|+|C|)\\\\\n&\\quad+(|A\\bigcap B|+|A\\bigcap C|+|B\\bigcap C|)\\\\\n&\\quad-|A\\bigcap B\\bigcap C|\\\\\n&=1260-(60+105+280)+(12+20+30)-6=871\n\\end{aligned}\n$$\n\n\n\n### 错排问题\n\n> 求整数$1,2,…,n$的全排列中所有$i$都不在第$i$个位置上的排列的个数,$i=1,2,…,n$\n\n设$A_i$为$i$在位置$i$上的所有排列\n\n$$\n\\begin{aligned}\nans\n&=|\\overline A_1\\bigcap \\overline A_2 \\bigcap ...\\bigcap \\overline A_n|\\\\\n&=\\quad|N|\\\\\n&\\quad-(|A_1|+|A_2|+...+|A_n|)\\\\\n&\\quad+(|A_1\\bigcap A_2|+...+|A_{n-1}\\bigcap A_n|)\\\\\n&\\quad-\\ ...\\\\\n&\\quad+ (-1)^n |A_1\\bigcap A_2\\bigcap ... \\bigcap A_n|\\\\\n&=n!- {n\\choose 1}\\cdot (n-1)! + {n\\choose 2}\\cdot (n-2)! - ...\\ + (-1)^n {n\\choose n}\\\\\n&=n!(1-\\frac{1}{1!}+\\frac{1}{2!}-\\frac{1}{3!}+...+(-1)^n\\frac{1}{n!}) = D_n\\\\\n\\end{aligned}\n$$\n\n$$D_n=n!\\sum_{i=0}^n \\frac{(-1)^i}{i!}$$\n\n递推法:\n\n设$f_x$表示错了$x$个\n\n1. 把第$n$个数放在$[1,n-1]$中的某个位置,有$n-1$种可能\n\n2. 放第$k(k\\not=n)$个元素\n\n   - 放在位置$n$,剩余的$n-2$个元素有$f_{n-2}$种方法\n\n   - 不放位置$n$,那么相当于剩下$n-1$个元素有$f_{n-1}$种方法\n\n初始:$f_1=0,f_2=1$\n\n[HDU 1465 不容易系列之一](http:\/\/acm.hdu.edu.cn\/showproblem.php?pid=1465)\n\n## 第二类斯特林数\n\n> 将$n$个不同的球放进$m$个相同的盒子,保证盒子非空,求方案数.\n\n### 容斥法:\n\n$$S(n,m)=\\frac 1{m!}\\sum_{i=0}^m {m\\choose i}(m-i)^n(-1)^i$$\n\n> 枚举空盒个数,剩下随便放,到这里开始也有了二项式反演的形式\n>\n> 由于盒子相同,所以除以$m!$\n\n### 递推法\n\n$$S(n,m)=S(n-1,m-1)+mS(n-1,m)$$\n\n> 相当于考虑现在要放的求是否单独在一个盒子里:\n>\n> 1. 不占一盒:\n>\n>    其余$n-1$个球放到$m-1$个盒子里\n>\n> 2. 放到某个有球的盒子里:\n>\n>    有$m$个盒子可放($m$种可能),其余$n-1$个球放到$m$个盒子里\n\n## 广义容斥原理\n\n- 求恰好具有m个属性的元素的个数\n\n### $\\alpha(m)$\n\n给定集合$N$和性质$A_1,A_2,...,A_n$,令$\\alpha(0)=|N|$\n\n$\\displaystyle\n\\alpha(1) = \\sum|A_i|\\\\\n\\alpha(2) = \\sum|A_i\\bigcap A_j|\\\\\n\\alpha(3) = \\sum|A_i\\bigcap A_j\\bigcap A_k|\\\\\n...\\\\\n\\alpha(n) = |A_1\\bigcap A_2\\bigcap ...\\bigcap A_n|\\\\\n$\n\n则$\\alpha(m)$计数了具有$m+k$个性质的元素${m+k}\\choose m$次\n\n\n\n### $\\beta(m)$\n\n给定集合$N$和性质$A_1,A_2,...,A_n$,令$\\beta(m)$表示$N$中恰好有$m$个性质的元素个数,则\n\n$\\Beta(m)=\\alpha(m)-{m+1 \\choose m}a(m+1)+{m+2\\choose m}\\alpha(m+2)-...+(-1)^{n-m}{n\\choose m}\\alpha(n)$\n\n证明:请看下面的二项式反演\n\n推论:$\\beta(0)=\\alpha(0)-\\alpha(1)+\\alpha(2)-...+(-1)^n\\alpha(n)$\n\n我们可以发现这个和接下来的二项式反演非常像,如果无法理解可以强行记一下,因为这个非常对称,很好记\n\n## 二项式反演\n\n1. 回顾Example 1\n\n   考虑一种特殊情况：多个集合的交集大小只和集合的数目有关\n\n   设$f_n$表示$n$个补集的交集大小,$g_n$表示$n$个原集的大小\n\n   $$\n   f_n = \\sum_{i=0}^n (-1)^i {n\\choose i} g_i \n   \\\\\\Updownarrow\\\\ \n   g_n = \\sum_{i=0}^n (-1)^i {n\\choose i}f_i\n   $$\n\n2. 设$f_i$为至多具有$i$个属性的方案数,$g_i$表示恰好具有$i$个属性的方案数:\n\n   $$\n   f_n=\\sum_{i=0}^n{n\\choose i} g_i\n   \\\\ \\Updownarrow \\\\\n   g_n=\\sum_{i=0}^n (-1)^{n-i} {n\\choose i}f_i\n   $$\n\n   $f_n$表示先钦定$n$个属性,再统计至多具有这$n$个属性的方案数(也就是不能有这$n$个之外的,这$n$个任意),\n   \n   其中会包含重复的方案,因为一个方案可以有多种钦定情况.具体地,对于恰好选择$i$个,钦定情况数位${n\\choose i}$ ,故$g_i$在$f_n$中被计算了${n\\choose i}$次\n\n3. 设$f_i$为至少具有$i$个属性,$g_i$表示恰好具有$i$个属性的方案数的方案数:\n\n   $$\n   f_n = \\sum_{i=n}^m g_i {i\\choose n}\n   \\\\ \\Updownarrow \\\\\n   g_n=\\sum_{i=n}^m(-1)^{i-n}{i\\choose n}f_i\n   $$\n\n   注意:\n\n   $f_n$表示先钦定$n$个属性,再统计至少具有这$n$个属性的方案数(也就是包含这$n$个属性,其余属性任意),\n\n   其中会包含重复的方案,因为一个方案可以有多种钦定情况.具体地,对于恰好选择$i$个,钦定情况数位${i\\choose n}$ ,故$g_i$在$f_i$中被计算了${i\\choose n}$次\n\n4. **tips:**\n\n   **二项式反演**(或**广义容斥原理**)可以用来解决一些**恰好**,**至多**,**至少**的计数问题\n\n   可以通过容斥来完成**恰好**,**至多**,**至少**之间的互相转换\n\n   是一个很好用的工具\n\n5. 证明\n\n   至多:\n\n   $$\n   \\begin{aligned}\n   g_n\n   &=\\sum_{i=0}^n (-1)^{n-i}{n\\choose i}f_i\\\\\n   &=\\sum_{i=0}^n (-1)^{n-i} {n\\choose i}\\sum_{j=0}^i{i\\choose j}g_j\\\\\n   &=\\sum_{j=0}^n g_j\\sum_{i=j}^n {n\\choose i}{i \\choose j}(-1)^{n-i}\\\\\n   &=\\sum_{j=0}^n g_j\\sum_{i=j}^n {n\\choose j}{n-j \\choose i-j}(-1)^{n-i}\\\\\n   &=\\sum_{j=0}^n g_j\\left[{n\\choose j}\\sum_{i=j}^n{n-j \\choose i-j}(-1)^{n-i}\\right]\\\\\n   &=\\sum_{j=0}^n g_j\\left[{n\\choose j}\\sum_{i=0}^{n-j}{n-j \\choose i}(-1)^{n-j-i}\\right]\\\\\n   &=\\sum_{j=0}^n g_j\\left[{n \\choose j}(1-1)^{n-j}\\right]\\\\\n   &=g_n\n   \\end{aligned}\n   $$\n\n# 例题\n\n## BZOJ 2839 集合计数\n\n[地址](https:\/\/ruanx.pw\/bzojch\/p\/2839.html)\n\n### 题意:\n\n一个有$N$个元素的集合有$2^N$个不同子集（包含空集）,现在要在这$2^N$个集合中取出若干集合（至少一个）,使得\n它们的交集的元素个数为$K$,求取法的方案数,答案模$1000000007$\n\n### 解法:\n\n设$g_i$表示交集个数至少为$i$的方案数\n\n那么$\\displaystyle g_i = {n\\choose i}(2^{2^{n-i}}-1)$\n\n> 先从$n$中选$i$个,然后其他可以随便取\n>\n> 那就是有$2^{n-i}$个集合可以取\n>\n> 然后又可以取至少1个集合\n>\n> 那么答案就是${n\\choose i}(2^{2^{n-i}}-1)$\n\n设$f_i$表示恰好为$i$的\n\n那么$\\displaystyle g_k=\\sum_{i=k}^n f_i\\cdot {i\\choose k}$\n\n反演$\\displaystyle f_k=\\sum_{i=k}^n g_i\\cdot{i\\choose k} (-1)^{i-k}$\n\n不能直接快速幂,因为指数不能$\\mod p$,要用$2^{2^i}=(2^{2^{i-1}})^2$倒着枚举算\n\n```cpp\n#define N 1000011\nconst int mod=1000000007;\nint n,k,g[N],fac[N],inv[N];\nint C(int a,int b){\n    return 1ll*fac[a]*inv[b]%mod*inv[a-b]%mod;\n}\nint pw(int x,int p){\n    int ans=1;\n    while(p){\n        if(p&1)ans=1ll*ans*x%mod;\n        p>>=1;x=1ll*x*x%mod;\n    }\n    return ans;\n}\nint main(){\n    in(n,k);\n    fac[0]=inv[0]=1;\n    for(int i=1;i<=n;++i)\n        fac[i]=1ll*fac[i-1]*i%mod;\n    inv[n]=pw(fac[n],mod-2);\n    for(int i=n-1;i>=1;--i)\n        inv[i]=1ll*inv[i+1]*(i+1)%mod;\n\n    for(int i=0;i<=n;++i)\n        g[i]=1ll*C(n,i)*(pw(2,(pw(2,n-i))-1+mod)%mod)%mod;\n\n    int ans=0,b=2;\n    for(int i=n;i>=k;--i){\n        int t=1ll*C(n,i)%mod*C(i,k)%mod*(b-1)%mod;\n        if((i-k)&1)ans=(ans-t+mod)%mod;\n        else ans=(ans+t)%mod;\n        b=1ll*b*b%mod;\n    }\n    printf(\"%d\\n\",ans);\n}\n```\n\n## [JSOI2011]分特产\n\n[地址](https:\/\/www.luogu.com.cn\/problem\/P5505)\n\n### 题意\n\n有$n$个人和$m$种物品,第$i$种物品有$a_i$个,同种物品之间没有区别。现在要将这些物品分给这些人,使得每个人至少分到一个物品\n\n### 题解\n\n每个同学都必须**至少**分得一个\n\n可以通过 **恰好**没有同学没有分得 来反演\n\n设$f_i$为钦定$i$个人没有分到,\n\n钦定的方案数为${n\\choose i}$,这时第$j$种物品分给$n-i$个人,使用隔板法,方案数为${n-i+a_j-1\\choose n-i-1}$\n\n$$\nf_i={n\\choose i}\\prod_{j=1}^m{n-i+a_j-1\\choose n-i-1}\n$$\n\n设$g_i$为恰好$i$个人没有分到,反演:\n\n$$\ng_k=\\sum_{i=k}^n(-1)^{i-k}{i \\choose k}f_i\n$$\n\n那么:\n\n$$\n\\begin{aligned}\nans\n&=g_0\\\\\n&=\\sum_{i=0}^n(-1)^if_i\\\\\n&=\\sum_{i=0}^n(-1)^i{n\\choose i}\\prod_{j=1}^m{n-i+a_j-1\\choose n-i-1}\n\\end{aligned}\n$$\n\n```cpp\n#include<bits\/stdc++.h>\nconst int N=1001,P=1000000007;\nint n,m,a[N],ans,c[N*2][N*2];\nvoid mod(int&x){if(x>=P)x-=P;}\nint main(){\n    scanf(\"%d%d\",&n,&m);\n    for(int i=0;i<=2000;++i){\n        c[i][0]=c[i][i]=1;\n        for(int j=1;j<i;++j)\n            mod(c[i][j]=c[i-1][j-1]+c[i-1][j]);\n    }\n    for(int i=1;i<=m;++i)scanf(\"%d\",a+i);\n    for(int i=0;i<=n;++i){\n        long long res=c[n][i];\n        for(int j=1;j<=m;++j)\n            (res*=c[n-i+a[j]-1][n-i-1])%=P;\n        if(i&1)mod(ans+=P-res);\n        else mod(ans+=res);\n    }\n    printf(\"%d\\n\",ans);\n}\n```\n\n## 已经没有什么好害怕的了\n\n[地址](https:\/\/www.luogu.com.cn\/problem\/P4859)\n\n### 题意:\n\n给出$n$个数$a_i$及$n$个数$b_i$ ,要求两两配对使得 $a>b$的对数减去$a<b$的对数等于$k$.\n\n$0\\leq k\\leq n\\leq 2000$,保证$a,b$ 无相同元素.\n\n### 题解:\n\n先将$b$数组从小到大排序\n\n设选中了$x$对$a > b$,由总对数为$n$,由$x-(n-x)=k$,可以知道$x=\\frac{n+k}2$\n\n我们设$f(i,j)$为前$i$个$a$中选中了$j$组$a > b$的方案数\n\n那么$f(i,j)=f(i-1,j)+f(i-1,j-1)\\times(l_i-j+1)$\n\n($l_i$表示$b$中小于$a_i$的最后一个位置)\n\n但是还有剩下的$n-x$对\n\n我们可以设$g_i$表示$a>b$对数$\\ge i$的方案数\n\n那么$g_i = f(n,i) \\times (n-i)!$(相当于剩下的随便排列组合)\n\n我们设$f_i$表示$a>b$对数恰好为$i$对的方案数\n\n那么$\\displaystyle g_k = \\sum_{i=k}^n f_i \\times {i\\choose k}$\n (相当于从恰好$i$个方案中选$k$对出来)\n\n经过二项式反演可以知道:\n\n$\\displaystyle f(k)=\\sum_{i=k}^n(-1)^{i-k}{i\\choose k}g(i)$\n\n代码:\n\n```cpp\nconst int N=4011,mod=1000000009;\nint n,k,f[N][N],a[N],b[N],l[N],fac[N],inv[N],g[N];\nil int pw(int x,int p){\n    int ans=1;\n    while(p){\n        if(p&1)ans=1ll*ans*x%mod;\n        p>>=1;x=1ll*x*x%mod;\n    }\n    return ans;\n}\nint C(int a,int b){\n    return 1ll*fac[a]*inv[b]%mod*inv[a-b]%mod;\n}\nsigned main(){\n    in(n,k);\n    if((n+k)&1){puts(\"0\");return 0;};\n    k=(n+k)>>1;\n    for(int i=1;i<=n;++i)in(a[i]);\n    for(int i=1;i<=n;++i)in(b[i]);\n    fac[0]=inv[0]=1;\n    for(int i=1;i<=n;++i)\n        fac[i]=1ll*fac[i-1]*i%mod;\n    inv[n]=pw(fac[n],mod-2);\n    for(int i=n-1;i>=0;--i)\n        inv[i]=1ll*inv[i+1]*(i+1)%mod;\n    sort(a+1,a+n+1);\n    sort(b+1,b+n+1);\n    int p=0;\n    for(int i=1;i<=n;++i){\n        while(p<n&&b[p+1]<a[i])++p;\n        l[i]=p;\n    }\n    f[0][0]=1;\n    for(int i=1;i<=n;++i){\n        f[i][0]=1;\n        for(int j=1;j<=i;++j)\n            f[i][j]=(f[i-1][j]+1ll*f[i-1][j-1]*MAX(0,l[i]-j+1)%mod)%mod;\n    }\n    for(int i=0;i<=n;++i)\n        g[i]=1ll*f[n][i]*fac[n-i]%mod;\n    int ans=0;\n    for(int i=k;i<=n;++i)\n        if((i-k)&1)ans=(ans-1ll*C(i,k)*g[i]%mod+mod)%mod;\n        else ans=(ans+1ll*C(i,k)*g[i]%mod)%mod;\n\n    printf(\"%d\\n\",ans);\n}\n```\n\n\n\n## [HAOI2008]硬币购物\n\n[地址](https:\/\/www.luogu.com.cn\/problem\/P1450)\n\n### 题意:\n\n硬币购物一共有4种硬币.面值分别为$c1,c2,c3,c4$.\n\n某人去商店买东西,去了$tot$次.\n\n每次带$d_i$枚$c_i$硬币,买$s_i$的价值的东西.\n\n请问每次有多少种付款方法.\n\n### 题解:\n\n先考虑每种硬币可以用无数次\n\n设$f_i$表示金额为$i$有多少种方案\n\n那么$\\displaystyle f_i = \\sum_{j=1}^4 f_{i-c[j](i \\ge c_j)}$\n\n我们再来考虑硬币使用次数有限制怎么办\n\n> 不合法的情况有:\n>\n> 1超额\n>\n> 1,2超额\n>\n> 1,3超额\n>\n> 1,4超额\n>\n> 1,2,3超额\n>\n> 1,2,4超额\n>\n> 1,3,4超额\n>\n> 1,2,3,4超额\n>\n> ...\n>\n> 要注意的是在多种硬币限制的情况下可能会减去多次,或加上多次\n>\n> 比如1超额,2超额,（1,2同时超额被减去两次,这是就要加回来\n>\n> 而$(1,2,3)$ 、$(1,2,4)$又是多算的...\n\n是不是更直观的了解了容斥？\n\n为了方便,我们可以枚举二进制下状态来更加优美实现.\n\n(当有奇数种不合法的时候减去,偶数种不合法时加上)\n\n代码:\n\n```cpp\n#define N 100011\nint n,c[5],d[5],s;\nll f[N];\nint main(){\n    for(int i=1;i<=4;++i)in(c[i]);\n    f[0]=1;\n    for(int i=1;i<=4;++i)\n        for(int j=c[i];j<=100000;++j)\n            f[j]+=f[j-c[i]];\n\n    in(n);\n    while(n--){\n        for(int i=1;i<=4;++i)in(d[i]);\n        in(s);\n        ll ans=f[s];\n        for(int i=1;i<=15;++i){\n            int t=s,sta=i,k=1;\n            for(int j=1;j<=4;++j)\n            if(sta&(1<<(j-1))){\n                k=-k;\n                t-=(d[j]+1)*c[j];\n            }\n            if(t>=0)ans+=1ll*f[t]*k;\n        }\n        out(ans,ln);\n    }\n}\n```\n\n\n\n## [SDOI2009]Bill的挑战\n\n[地址](https:\/\/www.luogu.com.cn\/problem\/P2167)\n\n### 题意:\n给$n$个长度相同的字符串(由小写字母和`?`组成):$S_1,S_2,...,S_n$,\n\n求这$n$个串中的刚好$k$个串匹配的字符串$T$的个数$\\pmod{1000003}$\n\n若$S_x$与$T$匹配,满足:\n\n1. $|S_x|=|T|$\n2. $\\forall S_x[i]=?||S_x[i]=T[i]$\n\n### 状压解法:\n\n设$f[i][j]$表示到了第$i$位,匹配的状态为$j$\n\n代码:\n```cpp\n#define N 111\n#define mod 1000003\n#define M(x) ((x>=mod)?(x)%=mod:x)\nint mt[N][30];\nll f[N][1<<15];\nchar ch[N][N];\nil void work(){\n    clr(mt,0);\n    clr(f,0);\n    int n,k,len;\n    in(n,k);\n    for(int i=1;i<=n;++i)in(ch[i]);\n    len=strlen(ch[1]);\n    for(int i=0;i<=len-1;++i)\n        for(char t='a';t<='z';++t)\n            for(int j=1;j<=n;++j)\n            if(ch[j][i]=='?'||ch[j][i]==t)\n                mt[i][t-'a']|=(1<<(j-1));\/\/更新比较当前位的影响\n    f[0][(1<<n)-1]=1;\n    for(int i=0;i<=len-1;++i)\n        for(int j=0;j<(1<<n);++j)\n        if(f[i][j])\n            for(int t=0;t<=26;++t)\n                M(f[i+1][j&mt[i][t]]+=f[i][j]);\n    ll ans=0;\n    for(int i=0;i<(1<<n);++i){\n        int t=i,tt=0;\n        while(t)tt+=(t&1),t>>=1;\n        if(tt==k)M(ans+=f[len][i]);\n    }\n    out(ans,ln);\n}\nint main(){\n    int T;in(T);\n    while(T--)work();\n    flush();\n}\n```\n\n### 容斥解法:\n\n看到恰好$k$个,我们就可以想到容斥套路\n\n找出至少匹配$k$个的方案数$g(k)$,设$f(k)$为恰好$k$个的方案数\n\n然后还是按套路就可以了\n\n$$\ng(n) = \\sum_{i=k}^n {n\\choose i}f(i)\n\\\\\n\\Updownarrow\n\\\\\nf(n) = \\sum_{i=k}^n {n\\choose i}g(i) (-1)^{i-k}\n$$\n\n问题转换为如何求至少匹配$k$个的方案数\n\n我们可以使用dfs来统计,这样比起状压思维难度可能降低了许多,只需要枚举排列组合(当然枚举二进制状态也可以)\n\n状压需要处理全部状态\n\ndfs只需要统计$k$～$n$的部分\n\n最后统计的时间可忽略不计\n\n状压:$492ms$\n\n容斥: $100ms$\n\n容斥代码:\n\n```cpp\n#define N 111\n#define mod 1000003\nchar ch[N][N];\nint len,n,k,cnt,c[N][N],up,tot=0,las,a[N];\nvoid dfs(int x,int now){\n    if(x==n+1){\n        if(now!=up)return;\n        ll lp=1;\n        for(int j=1;j<=len;++j){\n            las=-1;\n            for(int i=1;i<=up;++i)\n            if(ch[a[i]][j]!='?'){\n                if(las==-1)\n                    las=ch[a[i]][j]-'a';\n                else if(las!=ch[a[i]][j]-'a')return;\n            }\n            if(las==-1)lp=(lp*26)%mod;\n        }\n        (tot+=lp)%=mod;\n        return;\n    }\n    if(now<up){\n        a[++cnt]=x;\n        dfs(x+1,now+1);\n        a[cnt--]=0;\n    }\n    if(n-x>=up-now)dfs(x+1,now);\n}\nll g[N];\nil void work(){\n    clr(g,0);\n    in(n,k);\n    for(int i=1;i<=n;++i)in(ch[i]+1);\n    len=strlen(ch[1]+1);\n    for(int i=k;i<=n;++i)\n        up=i;\n        tot=0;\n        dfs(1,0);\n        g[i]=tot;\n    }\n\n    \/\/ 容斥部分:\n    ll ans=0;\n    for(int i=k;i<=n;++i)\n        if((i-k)&1)ans=(ans-1ll*c[i][k]*g[i]%mod+mod)%mod;\n        else ans=(ans+1ll*c[i][k]*g[i]%mod)%mod;\n    out(ans,ln);\n}\nint main(){\n    for(int i=0;i<=20;++i){\n        c[i][0]=1;\n        for(int j=1;j<=i;++j)\n            c[i][j]=c[i-1][j]+c[i-1][j-1];\n    }\n    int T;in(T);\n    while(T--)work();\n    flush();\n}\n```\n\n\n\n其他有关容斥题目:\n\n## Emiya 家今天的饭\n\n[地址](https:\/\/www.luogu.com.cn\/problem\/P5664)\n\n### 题意:\n\n给出一个矩阵,要求每行只能选一个节点,每列选的节点不能超过所有选的节点的一半,不能不选,\n给出每个节点的选择方案数,求总方案数\n\n### 解法:\n\n考虑到限制是每列选择的不能超过一半,我们可以想到不合法的最多只有一列\n\n我们可以用总方案数减去不符合的\n\n$\\displaystyle s_i=\\sum_{j=1}^m a_{ij}$\n\n总方案数:$\\displaystyle \\prod_{i=1}^n (s_i+1) - 1$\n\n$\\because k=\\frac {tot}2$\n\n所以我们有一个很妙的方法:\n\n设选中目标行之外的权值+1,不选+0,选中目标行权值位+2\n\n最后只要权值$> n$,那么目标行一定被选了超过$\\frac n2$次\n\n设$f(i,k)$表示总共选了$i$次(也就是选到第$i$行)权值为$k$的方案数\n\n\n$f(i,k) += f(i-1,k)\\cdot(s_i-a_{ij})$(当前行不选目标列\n\n$f(i,k+1) += f(i-1,k)$(当前行完全不选\n\n$f(i,k+2) += f(i-1,k)\\times a_{ij}$(当前行选中目标列\n\n$\\displaystyle ans = \\prod_{i=1}^n (s_i+1) - 1 - \\sum_{i=n+1}^{2n} f(n,i)$\n\n```cpp\n#include<bits\/stdc++.h>\nusing namespace std;\n#define N 111\ntypedef long long ll;\nconst int mod=998244353;\nint a[N][2011],n,m;\nll f[N][2011],s[N];\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;++i)\n\t\tfor(int j=1;j<=m;++j)\n\t\t\tscanf(\"%d\",&a[i][j]),\n            s[i]=(s[i]+a[i][j])%mod;\n\n\tll ans=1;\n\tfor(int i=1;i<=n;++i)\n\t\tans=(ans*(s[i]+1))%mod;\n\n    --ans;\n\tfor(int j=1;j<=m;++j){\n        memset(f,0,sizeof f);\n        f[0][0]=1;\n        for(int i=1;i<=n;++i)\n            for(int k=0;k<=n*2;++k){\n                f[i][k]=(f[i][k]+f[i-1][k]*(s[i]-a[i][j]))%mod;\n                f[i][k+1]=(f[i][k+1]+f[i-1][k])%mod;\n                f[i][k+2]=(f[i][k+2]+f[i-1][k]*a[i][j])%mod;\n            }\n        for(int i=n+1;i<=n*2;++i)\n            ans=(ans-f[n][i])%mod;\n    }\n    printf(\"%lld\\n\",(ans+mod)%mod);\n}\n```\n\n## LG 2567 [SCOI2010]幸运数字\n\n[地址](https:\/\/www.luogu.com.cn\/problem\/P2567)\n\n### 题意:\n\n定义幸运号码为:由$6$或$8$组成的数字\n\n定义近似幸运号码为:幸运号码的倍数\n\n求$[l,r]$之间幸运数字的个数($1\\le l,r \\le 10^9$).\n\n### 题解:\n\n先预处理出所有幸运数字\n\n当前要求的是$[l,r]$中的幸运数字\n\n我们可以使用容斥,用$[1,r]-[1,l-1]$\n\n假设当前幸运数字为$x$,$[l,r]$中是$x$的倍数的有$\\left \\lfloor \\frac rx \\right \\rfloor - \\left \\lfloor \\frac lx \\right \\rfloor +1$\n\n$[1,r],[1,l-1]$中的幸运数字的倍数可能有交集\n\n继续容斥:\n\n选$1$个$-$选$2$个的$lcm+$选$3$个的$lcm-...$\n\n剪枝:\n\n1. 可以发现,一个数是另一个合法倍数的倍数,那么这个数字相当于没用(因为被前面的统计过了),可以删掉\n\n2. 如果将幸运数字从大到小排序,搜索时可以更快突破边界\n\n3. 现在因为所有数都不满足是另外一个数的倍数,所以合并任意两个数的时候,$lcm$的最小情况就是乘上一个$3$,\n\n   所以对于所有$>r\/3$的合法数字,显然不能够和任何一个数合并了,所以这一部分可以拿出来直接提前算好\n\n剩下的直接暴搜\n\n```cpp\n#include<bits\/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define N 100011\nint tot=0,t=0;\nll ans=0,l,r,a[N];\nbool v[N];\ninline void init(){\n    int h=0;\n    while(h<=tot){\n        ll x=a[h++]*10;\n        if(x+6<=r)a[++tot]=x+6;\n        if(x+8<=r)a[++tot]=x+8;\n    }\n}\nconst int mod=1000000007;\ninline bool chk(ll a,ll b){\n    int A=a\/mod,B=b\/mod;\n    if(A*B)return 1;\n    return a*b>r;\n}\nvoid calc(int x,ll s,int k){\n    if(x>tot){\n        if(s!=1){\n            if(k&1)ans+=r\/s-l\/s;\n            else ans-=r\/s-l\/s;\n        }\n        return;\n    }\n    calc(x+1,s,k);\n    ll d=a[x]\/__gcd(s,a[x]);\n    if(!chk(s,d))calc(x+1,s*d,k+1);\n}\ninline void work(){\n    sort(a+1,a+tot+1);\n    for(int i=1;i<=tot;++i)\n        for(int j=1;j<i;++j)\n        if(a[i]%a[j]==0){\n            v[i]=1;\n            break;\n        }\n\n    for(int i=1;i<=tot;++i)\n    if(!v[i]){\n        if(a[i]<=r\/3)a[++t]=a[i];\n        else ans+=r\/a[i]-l\/a[i];\n    }\n    tot=t;\n    reverse(a+1,a+tot+1);\n    calc(1,1,0);\n    printf(\"%lld\\n\",ans);\n}\nint main(){\n    cin>>l>>r;\n    --l;\n    init();\/\/找出所有\"幸运号码\"\n    work();\n}\n```","link":null,"tags":["数论","容斥","反演","组合数","二项式反演"],"title":"容斥与二项式反演"},{"categories":[["游记"]],"content":"\n\n## 赛后总结\n\n其实感觉这次打的失误挺多的。\n\n### day1:\n\n1. t1其实就是个二分或者递归模拟一下就好了($2^{64}$要特判一下)\n2. t2看到是括号序列这样的套路也还可以接受,就是每个点的答案就是父节点的答案加上它自己的贡献(以它结尾的合法子串有多少个),(早知道还是循规蹈矩写$O(n \\log n)$的,非要写$O(n)$,可能哈希或者其他地方写炸了,可能50分保底)\n3. 因为调t2,t3也没时间打暴力了,大失败,唉\n\n\n\n### day2:\n\n1. t1应该是动态规划+容斥,可惜调炸了,暴力也没来得及调好\n2. t2已经想出了$n^2$的dp,过了大样例,尝试过用单调队列,线段树,二分等优化,可都炸了(有点心态崩了)\n3. t3的话把$n^2$暴力和链的暴力快速打完就心满意足地走了。(c拿的比a还多)。仔细想了想应该是树型dp,但是也没这个资本去调出来\n\nwc应该是莫得了,但是一等应该还是有的\n\n可以说是问心无愧了,谁叫它今年考的都没特意去复习到,还出了noi难度(~~花了$\\frac15$的钱参加了noi,大赚~~)\n\n当做**教训**吧,之后也不能对数据结构那么专一了\n\n争取能~~拍平~~我的算法技能树吧\n\n> 有心翻盘,无力回天,死得其所,快哉！快哉！\n\n## 游记\n\nemmm\n\n这次去广州其实挺高兴的\n\n第一天去了酒店停电,我们正好出去看了**《海上钢琴师》**的复刻,果然经典的电影还是好看呀\n\n在宾馆周围逛的时候又能欣赏广州塔的夜景,值了(~~没钱上去~~)\n\n第二天下午在宾馆和朋友们打了一下午的牌,真的一年难得几次,大家都非常高兴,可高兴之余却被伤感填充,许多高二的师兄们就这么退役了,唉。(希望到时候打acm的时候还能再次相遇吧)\n\n(像zn,lg,csl,...他们都是很善良的学长,但可能都因此退役了qwq)\n\n\n\n第二天晚上,意想不到的事发生了\n\n>  我们找了其他oier面基\n>\n> 然后他带了两套女装\n>\n> 然后他自己先穿了\n>\n> 然后我没拍脸发到群上\n>\n> 然后被教练看见了\n>\n> 教练直接发了句“女装大佬\/se)”\n>\n> 然后又发了句\"先别脱掉,等我过去\"\n>\n> 接着那个oier果断脱掉,说刚刚是谁说要女装来着(可真正要女装的lyl跑出去恰饭了)\n>\n> 我只能硬着头皮穿上,要不然怎么也解释不清楚\n>\n> 等我换完衣服从厕所出来,发现我们学校的oier全部跑来我房间了(教练都来看了\n>\n> 非常羞耻\n>\n> 然后他们蜂拥而上\n>\n> 全部拿着手机在拍\n>\n> 我赶快跑到窗帘后面躲起来\n>\n> 可还是被揪出来了\n>\n> to be continued ...\n>\n> --意识中断\n>\n> 过了一会儿,教练开口了:\"女孩纸这水平要争取进省队\"\n\n~~这下可出名了~~\n\n关于女装后的感受：\n\n>  不过其实女装的感觉挺好的\n>\n> 第一感觉就是 档 下 生 风（可能夏天会更爽？\n>\n> 一开始在厕所一看镜子,像当自己npy,qwq\n>\n> 可能女装很容易就刺激到了少女心吧\n>\n> 裙子就把大(粗)腿遮住了,小腿又瘦,还有黑长筒袜..\n>\n> 突然也觉得自己腿有点细（~~居然还被csl姐姐夸了~~\n>\n> ~~(如果自己是女生是不是也挺不错的呢？~~\n>\n> ~~如果来个鸭子坐……~~\n>\n> 我都在想些什么啊.........................\n>\n> (要爆照的话私信qq 3088482189,或luogu id: mimi)\n\n太羞耻了\n\n回去要怎么跟班主和同学解释啊....(幸亏爸妈还不知道)\n\n\n\n第三天回来路上也是刷着知乎,看着车外的风景,莫名有点伤感\n\nqwq\n\n$qwq$\n\n$QwQ$\n\n希望之后一切都会好起来的\n\n\n\n~~预告：下次可以看我npy女装了~~","link":null,"tags":["游记"],"title":"csp-s-2019-游记"},{"categories":[["算法","树论"],["note"]],"content":"\n静态链分治用于解决静态树上众数问题,比如[$Codeforces\\ 600E$](https:\/\/www.luogu.org\/problem\/CF570D)\n\n静态链分治是离线算法,有点像莫队,复杂度$\\Theta (n \\log n \\log n)$\n\n比如说遍历一遍子树可以得出答案,但是每棵子树都遍历的话太慢了,\n\n我们用树剖的方式把每个节点的重儿子划分出来,\n\n遍历这个子树的时候先遍历轻儿子,再遍历重儿子,遍历重儿子后答案不清空,我们就可以省下遍历重儿子的时间\n\n几道练手的题：\n\n[CF 375D Tree and Queries](https:\/\/www.luogu.org\/problem\/CF375D)\n\n[CF570D Tree Requests](https:\/\/www.luogu.org\/problem\/CF570D)\n\n[CF208E Blood Cousins](https:\/\/www.luogu.org\/problem\/CF208E)\n\n","link":null,"tags":["算法","技巧","树"],"title":"静态链分治"},{"categories":[["算法","树论"],["note"]],"content":"\n# 点分治\n\n点分治用于大规模处理树上路径\n\n## 树的重心\n\n树的最大子树最小的点\n\n性质:每一个子树的大小都不超过$\\frac n2$\n\n```cpp\nint rt,mxs=inf,siz[N];\/\/ 当前 根,最大子树大小\nvoid frt(int x,int f){\n    siz[x]=1;\n    int res=0;\n    fl(i,x)if(!v[to]&&to!=f){\n        frt(to,x);\n        siz[x]+=siz[to];\n        res=max(res,siz[to]);\n    }\n    res=max(res,SZ-siz[x]);\n    \/*\n     SZ是当前树大小\n     \n     因为是无根树,所以除了自己的子树外的部分也要当做一棵子树\n     *\/\n    if(res<mxs)rt=x,mxs=res;\n}\n```\n\n## 实现\n\n```cpp\nvoid sol(int x){\n    v[x]=1;\/\/标记为已统计\n    ans+=calc(x,0);\/\/找出当前节点的答案\n    fl(i,x)if(!v[to]){\n        ans-=calc(to,e[i].w);\/\/减去重复的\n        rt=0,mxs=inf;SZ=siz[to];\n        frt(to,0);\/\/找出子树的重心\n        sol(rt);\/\/进入子树,继续分治\n    }\n}\n```\n\n<html>\n<svg width=\"300px\" height=\"300px\" _=\"SVGRoot\"><g _=\"EditableGraph\"><g _=\"SVGGroup\"><g _=\"GraphEdge\"><path d=\"M 136.77083333333331 39 L 71.77083333333334 128.30729166666666\" fill=\"none\" stroke-width=\"2\" stroke=\"black\" _=\"SVGPath\"><\/path><path d=\"M 136.77083333333331 39 L 71.77083333333334 128.30729166666666\" opacity=\"0\" fill=\"none\" stroke-width=\"30\" stroke=\"black\" _=\"SVGPath\"><\/path><\/g><g _=\"GraphEdge\"><path d=\"M 136.77083333333331 39 L 201.7708333333334 128.30729166666666\" fill=\"none\" stroke-width=\"2\" stroke=\"black\" _=\"SVGPath\"><\/path><path d=\"M 136.77083333333331 39 L 201.7708333333334 128.30729166666666\" opacity=\"0\" fill=\"none\" stroke-width=\"30\" stroke=\"black\" _=\"SVGPath\"><\/path><\/g><g _=\"GraphEdge\"><path d=\"M 71.77083333333334 128.30729166666666 L 39.27083333333333 239.6875\" fill=\"none\" stroke-width=\"2\" stroke=\"black\" _=\"SVGPath\"><\/path><path d=\"M 71.77083333333334 128.30729166666666 L 39.27083333333333 239.6875\" opacity=\"0\" fill=\"none\" stroke-width=\"30\" stroke=\"black\" _=\"SVGPath\"><\/path><\/g><g _=\"GraphEdge\"><path d=\"M 71.77083333333334 128.30729166666666 L 104.27083333333333 239.6875\" fill=\"none\" stroke-width=\"2\" stroke=\"black\" _=\"SVGPath\"><\/path><path d=\"M 71.77083333333334 128.30729166666666 L 104.27083333333333 239.6875\" opacity=\"0\" fill=\"none\" stroke-width=\"30\" stroke=\"black\" _=\"SVGPath\"><\/path><\/g><g _=\"GraphEdge\"><path d=\"M 201.7708333333334 128.30729166666666 L 169.27083333333331 239.6875\" fill=\"none\" stroke-width=\"2\" stroke=\"black\" _=\"SVGPath\"><\/path><path d=\"M 201.7708333333334 128.30729166666666 L 169.27083333333331 239.6875\" opacity=\"0\" fill=\"none\" stroke-width=\"30\" stroke=\"black\" _=\"SVGPath\"><\/path><\/g><g _=\"GraphEdge\"><path d=\"M 201.7708333333334 128.30729166666666 L 234.27083333333334 239.6875\" fill=\"none\" stroke-width=\"2\" stroke=\"black\" _=\"SVGPath\"><\/path><path d=\"M 201.7708333333334 128.30729166666666 L 234.27083333333334 239.6875\" opacity=\"0\" fill=\"none\" stroke-width=\"30\" stroke=\"black\" _=\"SVGPath\"><\/path><\/g><\/g><g _=\"SVGGroup\"><g fixed=\"false\" style=\"cursor: pointer;\" _=\"GraphNode\"><circle stroke-width=\"5\" fill=\"white\" stroke=\"black\" r=\"19\" cx=\"136.77083333333331\" cy=\"39\" _=\"SVGCircle\"><\/circle><text font-size=\"14\" dy=\".35em\" text-anchor=\"middle\" stroke-width=\"1\" fill=\"black\" stroke=\"black\" x=\"136.77083333333331\" y=\"39\" style=\"user-select: none;\" _=\"SVGText\">1<\/text><\/g><g fixed=\"false\" style=\"cursor: pointer;\" _=\"GraphNode\"><circle stroke-width=\"5\" fill=\"white\" stroke=\"black\" r=\"19\" cx=\"71.77083333333334\" cy=\"128.30729166666666\" _=\"SVGCircle\"><\/circle><text font-size=\"14\" dy=\".35em\" text-anchor=\"middle\" stroke-width=\"1\" fill=\"black\" stroke=\"black\" x=\"71.77083333333334\" y=\"128.30729166666666\" style=\"user-select: none;\" _=\"SVGText\">2<\/text><\/g><g fixed=\"false\" _=\"GraphNode\" style=\"cursor: pointer;\"><circle stroke-width=\"5\" fill=\"white\" stroke=\"black\" r=\"19\" cx=\"201.7708333333334\" cy=\"128.30729166666666\" _=\"SVGCircle\"><\/circle><text font-size=\"14\" dy=\".35em\" text-anchor=\"middle\" stroke-width=\"1\" fill=\"black\" stroke=\"black\" x=\"201.7708333333334\" y=\"128.30729166666666\" _=\"SVGText\" style=\"user-select: none;\">3<\/text><\/g><g fixed=\"false\" _=\"GraphNode\" style=\"cursor: pointer;\"><circle stroke-width=\"5\" fill=\"white\" stroke=\"black\" r=\"19\" cx=\"39.27083333333333\" cy=\"239.6875\" _=\"SVGCircle\"><\/circle><text font-size=\"14\" dy=\".35em\" text-anchor=\"middle\" stroke-width=\"1\" fill=\"black\" stroke=\"black\" x=\"39.27083333333333\" y=\"239.6875\" style=\"user-select: none;\" _=\"SVGText\">4<\/text><\/g><g fixed=\"false\" _=\"GraphNode\" style=\"cursor: pointer;\"><circle stroke-width=\"5\" fill=\"white\" stroke=\"black\" r=\"19\" cx=\"104.27083333333333\" cy=\"239.6875\" _=\"SVGCircle\"><\/circle><text font-size=\"14\" dy=\".35em\" text-anchor=\"middle\" stroke-width=\"1\" fill=\"black\" stroke=\"black\" x=\"104.27083333333333\" y=\"239.6875\" style=\"user-select: none;\" _=\"SVGText\">5<\/text><\/g><g fixed=\"false\" _=\"GraphNode\" style=\"cursor: pointer;\"><circle stroke-width=\"5\" fill=\"white\" stroke=\"black\" r=\"19\" cx=\"169.27083333333331\" cy=\"239.6875\" _=\"SVGCircle\"><\/circle><text font-size=\"14\" dy=\".35em\" text-anchor=\"middle\" stroke-width=\"1\" fill=\"black\" stroke=\"black\" x=\"169.27083333333331\" y=\"239.6875\" style=\"user-select: none;\" _=\"SVGText\">6<\/text><\/g><g fixed=\"false\" _=\"GraphNode\" style=\"cursor: pointer;\"><circle stroke-width=\"5\" fill=\"white\" stroke=\"black\" r=\"19\" cx=\"234.27083333333334\" cy=\"239.6875\" _=\"SVGCircle\"><\/circle><text font-size=\"14\" dy=\".35em\" text-anchor=\"middle\" stroke-width=\"1\" fill=\"black\" stroke=\"black\" x=\"234.27083333333334\" y=\"239.6875\" _=\"SVGText\" style=\"user-select: none;\">7<\/text><\/g><\/g><\/g><\/svg>\n<\/html>\n\n从点$1$开始的路径有：\n\n$1\\rightarrow 2$\n\n$1\\rightarrow 2\\rightarrow 4$\n\n$1\\rightarrow 2\\rightarrow 5$\n\n$1\\rightarrow 3$\n\n$1\\rightarrow 3\\rightarrow 6$\n\n$1\\rightarrow 3\\rightarrow 7$\n\n有些路径合并起来后,并不会经过点$1$,要减去这部分的答案\n\n比如$1\\rightarrow 2\\rightarrow 4$和$1\\rightarrow 2\\rightarrow 5$合并起来其实是：\n\n$4\\rightarrow 2\\rightarrow 5$,并没有经过$1$\n\n## 合并统计路径\n\n举个例子： 求长度为$k$的路径数\n\n我们将从$x$开始的所有路径的长度求出来存到数组中\n\n排序可以用类似双指针的方法扫描\n\n如果$k$的值较小的话可以用桶的方式来统计\n\n```cpp\n\/\/ get dis,获取从x开始的所有路径的长度\nvoid gd(int x,int d,int f){\n    if(d>k)return;\n    b[++tt]=d;\n    fl(i,x)if(!v[to]&&to!=f)gd(to,d+1,x);\n}\nll calc(int x,int d){\/\/ d是x的深度(用来减去子树中多余部分时用到)\n    tt=0;gd(x,d,0);\n    sort(b+1,b+tt+1);\n    int l=0,r=tt;\n    ll res=0;\n    while(l<r){\n        ++l;\n        while(b[l]+b[r]>k&&l<r)--r;\n        if(b[l]+b[r]==k){\n            int t1=1,t2=1;\/\/ 统计两边的个数\n            while(l<r&&b[l]==b[l+1])++l,++t1;\n            while(l<r&&b[r]==b[r-1])--r,++t2;\n            if(b[l]!=b[r])res+=1ll*t1*t2;\n            else res+=1ll*(t1+t2)*(t1+t2-1)\/2ll;\n            \/\/将所有长度为k\/2的路径组合\n        }\n    }\n    return res;\n}\n```\n\n## 例题\n\n### CF161D Distance in Tree\n\n[CodeForces 161D Distance in Tree](https:\/\/www.luogu.com.cn\/problem\/CF161D)\n\n> 输入点数为$N$一棵树\n> \n> 求树上长度恰好为$K$的路径个数\n\n模板题\n\n```cpp\n#include<bits\/stdc++.h>\nusing namespace std;\n#define N 500011\n#define inf 1000000000\n#define ll long long\nint n,k,cnt=0,SZ,rt,mxs,head[N],siz[N];\nbool v[N];\nstruct edge{\n    int to,nxt;\n}e[N<<1];\nvoid add(int x,int y){\n    e[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;\n}\n#define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\nvoid frt(int x,int f){\n    siz[x]=1;\n    int res=0;\n    fl(i,x)if(!v[to]&&to!=f){\n        frt(to,x);\n        siz[x]+=siz[to];\n        res=max(res,siz[to]);\n    }\n    res=max(res,SZ-siz[x]);\n    if(res<mxs)rt=x,mxs=res;\n}\nint b[N],tt;\nll ans=0;\nvoid gd(int x,int d,int f){\n    if(d>k)return;\n    b[++tt]=d;\n    fl(i,x)if(!v[to]&&to!=f)gd(to,d+1,x);\n}\nll calc(int x,int d){\n    tt=0;gd(x,d,0);\n    sort(b+1,b+tt+1);\n    int l=0,r=tt;\n    ll res=0;\n    while(l<r){\n        ++l;\n        while(b[l]+b[r]>k&&l<r)--r;\n        if(b[l]+b[r]==k){\n            int t1=1,t2=1;\n            while(l<r&&b[l]==b[l+1])++l,++t1;\n            while(l<r&&b[r]==b[r-1])--r,++t2;\n            if(b[l]!=b[r])res+=1ll*t1*t2;\n            else res+=1ll*(t1+t2)*(t1+t2-1)\/2ll;\n        }\n    }\n    return res;\n}\nvoid sol(int x){\n    v[x]=1;ans+=calc(x,0);\n    fl(i,x)if(!v[to]){\n        ans-=calc(to,1);\n        rt=0,mxs=inf;SZ=siz[to];\n        frt(to,0);\n        sol(rt);\n    }\n}\nint main(){\n    scanf(\"%d%d\",&n,&k);\n    int x,y;\n    for(int i=1;i<=n-1;++i)\n        scanf(\"%d%d\",&x,&y),\n        add(x,y),add(y,x);\n    \n    rt=0,mxs=inf,SZ=n;\n    frt(1,0);\n    sol(rt);\n    printf(\"%lld\\n\",ans);\n}\n```\n\n### [国家集训队]聪聪可可\n\n[LG P2634 [国家集训队]聪聪可可](https:\/\/www.luogu.com.cn\/problem\/P2634)\n\n[BZ 2152 聪聪可可](https:\/\/www.lydsy.com\/JudgeOnline\/problem.php?id=2152)\n\n也可以算是模板吧\n\n这个就是用桶来统计了\n\n```cpp\n#include<bits\/stdc++.h>\nusing namespace std;\n#define N 20011\nint n,cnt=0,head[N];\nstruct edge{\n    int to,nxt,w;\n}e[N<<1];\nvoid add(int x,int y,int w){\n    e[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;e[cnt].w=w;\n}\n#define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\nint siz[N],SZ,rt,mxs,ans=0,b[3];\nbool v[N];\nvoid frt(int x,int f){\n    siz[x]=1;\n    int res=0;\n    fl(i,x)if(!v[to]&&to!=f){\n        frt(to,x);\n        siz[x]+=siz[to];\n        res=max(res,siz[to]);\n    }\n    res=max(res,SZ-siz[x]);\n    if(res<mxs)rt=x,mxs=res;\n}\nvoid gd(int x,int d,int f){\n    ++b[d%3];\n    fl(i,x)if(!v[to]&&to!=f)gd(to,d+e[i].w,x);\n}\nint calc(int x,int d){\n    b[0]=b[1]=b[2]=0;\n    gd(x,d,0);\n    return b[0]*b[0]+b[1]*b[2]*2;\n}\nvoid sol(int x){\n    v[x]=1;\n    ans+=calc(x,0);\n    fl(i,x)if(!v[to]){\n        ans-=calc(to,e[i].w);\n        rt=0,mxs=(1<<30),SZ=siz[to];\n        frt(to,x);\n        sol(rt);\n    }\n}\nint main(){\n    scanf(\"%d\",&n);\n    int x,y,w;\n    for(int i=1;i<=n-1;++i)\n        scanf(\"%d%d%d\",&x,&y,&w),\n        add(x,y,w),\n        add(y,x,w);\n    \n    rt=0,mxs=(1<<30);SZ=n;\n    frt(1,0);\n    sol(rt);\n    int fm=n*n,gcd=__gcd(fm,ans);\n    fm\/=gcd;ans\/=gcd;\n    printf(\"%d\/%d\\n\",ans,fm);\n}\n```","link":null,"tags":["算法","树","分治","技巧"],"title":"点分治"},{"categories":[["算法","数论"],["note"]],"content":"\n## Lucas定理\n\n$$C_n^m\\pmod p\\equiv C_{n\\mod p}^{m\\mod p}*C_{\\lfloor n\/p\\rfloor}^{\\lfloor m\/p\\rfloor}\\pmod p$$\n\n就是一个组合数可以拆成$P$进制下的乘积\n\n这个算法可以处理当$m,n$非常大的时候的取模\n\n扩展：仅当$(n\\&m)=m$时,$C(n,m) \\equiv 1 \\bmod 2$\n\n## 裴蜀定理\n\n$ax+by=c(x\\in Z^*,y\\in Z^*)\\Leftrightarrow\\gcd(a,b)|c$\n\n## 欧拉定理\n\n若$\\gcd(a,p)=1$(互质),那么$a^{\\varphi(p)} \\equiv 1 \\pmod p$\n\n## 费马小定理(欧拉定理特例)\n\n对于质数$p$,任意整数$a$,均满足：\n$a^p \\equiv a \\pmod p$\n\n## 欧拉定理的推论\n\n若$\\gcd(a,p)=1$,那么对于任意正整数$b$,有：\n\n$a^b \\equiv a^{b \\mod \\varphi(p)} \\bmod n$\n\n## 扩展欧拉定理\n\n当$b\\ge \\varphi(m)$时,$a^b \\equiv a^{(b \\mod \\varphi(m))+\\varphi(m)} \\pmod m$\n\n## 卡特兰数\n\n$1,1,2,5,14,42,132,429,1430,4862,...$(从第$0$项开始)\n\n$$\nf_1=1\n\\\\\nf_n=\\sum_{i=1}^{n-1}f_if_{n-i-1}\n\\\\\nf_n=\\frac{1}{n+1}{2n\\choose n}\n\\\\\nf_{n+1}=\\frac{4n+2}{n+2}f_n\n$$\n","link":null,"tags":["数论"],"title":"数论定理"},{"categories":[["算法","树论"],["算法","数据结构"],["算法","离线"],["note"]],"content":"\n前置知识: 莫队算法(Mo's Algorithm)\n\n## 树上莫队:\n\n也就是把莫队搬到树上\n\n入手模板: [SP10707 COT2 - Count on a tree II](https:\/\/www.luogu.com.cn\/problem\/SP10707)\n\n> 给定一个n个节点的树,每个节点表示一个整数,问u到v的路径上有多少个不同的整数。\n\n要把莫队搬到树上,那我们如何把树上问题转化到序列上呢? 欧拉序\n\n### 欧拉序\n\n欧拉序就是前序遍历时,在遍历到$x$时将$x$加入序列,离开$x$子树时再将$x$加入序列\n\n```cpp\nvoid dfs(int x){\n    T[st[x]=++dfn]=x;\/\/加入序列\n    siz[x]=1;\n    fl(i,x)if(to!=f[x]){\/\/遍历x的儿子\n        f[to]=x;\n        d[to]=d[x]+1;\n        dfs(to);\n        siz[x]+=siz[to];\n    }\n    T[ed[x]=++dfn]=x;\/\/加入序列\n}\n```\n\n### 实现\n\n这里我们设$st_i$表示访问到$i$时加入欧拉序的时间,$ed_i$表示回溯经过$i$时加入欧拉序的时间\n\n不妨设$st_x<st_y$\n\n若$lca(x,y)==x$,$x,y$在一条链上,那么统计序列中$[st_x,st_y]$的答案\n\n否则$x,y$在不同的子树内,那么统计序列中$[ed_x,st_y]$的答案\n\n不理解的可以手动画图模拟一遍,并配合代码理解qwq\n\n于是我们就把树上问题转化为序列上的了\n\n接下来就和普通莫队一样了\n\n## 代码\n\n```cpp\n#include<bits\/stdc++.h>\n#define Fur(i,x,y) for(int i=x;i<=y;++i)\n#define fl(i,x) for(int i=head[x],to;to=e[i].to,i;to=e[i].nxt)\nusing namespace std;\nconst int N=40011,M=100011;\nint n,cnt=0,head[N],val[N],old[N];\nstruct edge{\n    int to,nxt;\n}e[N<<1];\nvoid add(int x,int y){\n    e[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;\n}\nint T[N],dfn=0,st[N],ed[N],top[N],siz[N],f[N],d[N];\nvoid dfs(int x){\n    T[st[x]=++dfn]=x;\n    siz[x]=1;\n    fl(i,x)if(to!=f[x]){\n        f[to]=x;\n        d[to]=d[x]+1;\n        dfs(to);\n        siz[x]+=siz[to];\n    }\n    T[ed[x]=++dfn]=x;\n}\nvoid bt(int x,int tp){\n    top[x]=tp;\n    int k=0;\n    fl(i,x)if(to!=f[x]&&siz[to]>siz[k])k=to;\n    if(!k)return;bt(k,tp);\n    fl(i,x)if(!top[to])bt(to,to);\n}\nint lca(int x,int y){\n    while(top[x]!=top[y]){\n        if(d[top[x]]<d[top[y]])swap(x,y);\n        x=f[top[x]];\n    }\n    return d[x]<d[y]?x:y;\n}\nint blk,bl[N<<1];\nstruct que{\n    int l,r,lca,bl,br,id;\n    bool operator<(que t)const{\n        (bl==t.bl)?((bl&1)?r<t.r:r>t.r):(l<t.l);\n    }\n}Q[N];\nint ans=0,c[N],ANS[M];\nbool v[N];\nvoid inc(int x){ans+=(++c[val[x]]==1);}\nvoid dec(int x){ans-=(--c[val[x]]==0);}\nvoid op(int x){\n    v[x]?dec(x):inc(x);\n    v[x]^=1;\n}\nstruct node{\n    int v,p;\n    bool operator<(node t)const{\n        return v<t.v;\n    }\n}a[M];\nint main(){\n    int q,x,y,l=1,r=0;\n    scanf(\"%d%d\",&n,&q);\n    blk=sqrt(n);\n    Fur(i,1,n*2)bl[i]=(i-1)\/blk+1;\n    Fur(i,1,n)scanf(\"%d\",&a[i].v),a[i].p=i;\n    sort(a+1,a+n+1);\n    int tt=0;\n    Fur(i,1,n)old[val[a[i].p]=(tt+=a[i].v!=a[i-1].v)]=a[i].v;\n    Fur(i,1,n-1)scanf(\"%d%d\",&x,&y),add(x,y),add(y,x);\n    dfs(1);bt(1,1);\n    Fur(i,1,q){\n        scanf(\"%d%d\",&x,&y);\n        if(st[x]>st[y])swap(x,y);\n        int t=lca(x,y);\n        if(t==x)Q[i]=que{st[x],st[y],0,bl[st[x]],bl[st[y]],i};\n        else Q[i]=que{ed[x],st[y],t,bl[ed[x]],bl[st[y]],i};\n    }\n    sort(Q+1,Q+q+1);\n    Fur(i,1,q){\n        while(l>Q[i].l)op(T[--l]);\n        while(r<Q[i].r)op(T[++r]);\n        while(l<Q[i].l)op(T[l++]);\n        while(r>Q[i].r)op(T[r--]);\n        if(Q[i].lca)op(Q[i].lca);\n        ANS[Q[i].id]=ans;\n        if(Q[i].lca)op(Q[i].lca);\n    }\n    Fur(i,1,q)printf(\"%d\\n\",ANS[i]);\n}\n```","link":null,"tags":["算法","技巧"],"title":"树上莫队"},{"categories":[["刷题记录"]],"content":"\n\n[题目地址：](https:\/\/www.luogu.org\/problemnew\/lists?name=&orderitem=difficulty&tag=332&content=0&type=)\n\n网络流24题真的好有质量~\\\\ ($\\ge $▽$\\le $ ) \/~！\n\n# 进度： $\\frac{7}{24}$ \n\n## 1. [飞行员配对方案问题](https:\/\/www.luogu.org\/problemnew\/show\/P2756)\n\n二分图模板\n\n### 匈牙利（待填坑）:\n\n### [网络流：](\/2019\/03\/04\/各类模板\/#dinic：飞行员配对方案问题)\n\n## 2.[负载平衡问题](https:\/\/www.luogu.org\/problemnew\/show\/P4016)\n\n等同于[[HAOI2008]糖果传递](https:\/\/www.luogu.org\/problemnew\/show\/P2512) ,懒,直接搬[题解](https:\/\/www.luogu.org\/blog\/five20\/solution-p4016)\n\n也有费用流做法(待填坑)\n\n```cpp\n#include<bits\/stdc++.h>\n#define il __inline__ __attribute__ ((always_inline))\n#define rg register\n#define ll long long\n#define Fur(i,x,y) for(rg int i=x;i<=y;i++)\nusing namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 111\nint n,a[N],t;\nint main(){\n    in>>n;ll s=0;\n    Fur(i,1,n)in>>a[i],s+=a[i];\n    s\/=n;\n    Fur(i,1,n)a[i]=a[i-1]-a[i]+s;\n    sort(a+1,a+n+1);\n    t=a[(n>>1)+1];s=0;\n    Fur(i,1,n)s+=abs(a[i]-t);\n    out<<s<<ln;\n}\n```\n\n\n\n## 3.[孤岛营救问题](https:\/\/www.luogu.org\/problemnew\/show\/P4011) \n\n背包+状态压缩\n\nN很小\n\n开三维保存状态$d[x][y][s]$,走到$x,y$,拥有钥匙状态为$s$的最小花费是多少。\n\n$map[x_1][y_1][x_2][y_2]$存墙\n\n**坑点：**\n\n1. 一个点可以放多个钥匙\n2. 初始点可以放钥匙\n\n```cpp\n#include<cstdio>\n#include<ctype.h>\n#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops,fast-math\")\n#pragma GCC target(\"sse,sse2,avx,avx2,popcnt,tune=native\")\n#define il __inline__ __attribute__ ((always_inline))\n#define rg register\n#define Fur(i,x,y) for(rg int i=x;i<=y;i++)\nusing namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 12\nint n,m,k,P,S;\nint d[N][N][1<<N],wa[N][N][N][N],a[N][N][N];\nint dx[4]={0,1,0,-1},dy[4]={1,0,-1,0},p[1000001],q[1000001],o[1000001];\nint bfs(){\n    int h=0,t=1,x,y,s,nx,ny,ns;\n    p[0]=1;q[0]=1;o[0]=1;d[1][1][1]=1;\n    Fur(i,1,a[1][1][0])d[1][1][1]|=(1<<a[1][1][i]);\n    while(h<t){\n        x=p[h];y=q[h];s=o[h++];\n        Fur(i,0,3){\n            nx=x+dx[i];ny=y+dy[i];\n            if(nx<1||ny<1||nx>n||ny>m||!(s&(1<<wa[x][y][nx][ny])))continue;\n            ns=s;Fur(j,1,a[nx][ny][0])ns|=(1<<a[nx][ny][j]);\n            if(!d[nx][ny][ns]){\n                d[nx][ny][ns]=d[x][y][s]+1;\n                if(nx==n&&ny==m)return d[x][y][s];\n                p[t]=nx,q[t]=ny,o[t++]=ns;\n            }\n        }\n    }\n    return -1;\n}\nint main(){\n    in>>n>>m>>P>>k;\n    int x,y,xx,yy,t;\n    Fur(i,1,k){\n        in>>x>>y>>xx>>yy>>t;\n        if(!t)t=P+1;\n        wa[xx][yy][x][y]=wa[x][y][xx][yy]=t;\n    }\n    in>>S;\n    Fur(i,1,S)in>>x>>y>>a[x][y][++a[x][y][0]];\n    out<<bfs()<<ln;\n}\n```\n\n## 4. [魔术球问题](https:\/\/www.luogu.org\/problemnew\/show\/P2765)\n\n转换的思路很巧妙。\n\n考虑一个点：\n\n1. 放在一根新的柱子上\n2. 放在与它加起来是完全平方数的点上\n\n这样一看,如果一个柱子可以以某个点开始,也可以以某个点结束,那么一个点$x$就要拆成两个点$(x,x')$\n\n对于1,我们把源点与$x$连一条边权为1的边,把$x'$与汇点连一条边权为1的边\n\n对于2,我们把能与$x$组成平方数的点与$x’​$连一条边。\n\n当连完边后最大流无法增广时说明得新建一根柱子,如果柱子数$>n$那就说明无法继续添加数了。\n\n关于输出,就自己看着代码意会意会吧$Q\\omega Q$\n\n```cpp\n#include<bits\/stdc++.h>\n#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops,fast-math\")\n#pragma GCC target(\"sse,sse2,avx,avx2,popcnt,tune=native\")\n#define il __inline__ __attribute__ ((always_inline))\n#define rg register\n#define MB template <class T>\n#define Fur(i,x,y) for(rg int i=x;i<=y;i++)\n#define clr(x,y) memset(x,y,sizeof(x))\n#define inf 2000000000\n#define fl(i,x) for(rg int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\nMB T MIN(T x,T y){return x<=y?x:y;}\nusing namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 10010\nint n,m,st,ed,cnt;\nint head[N],d[N],q[N],top[N],nex[N];\nstruct edge{int to,nxt,w;}e[100011];\nvoid add(int x,int y,int w){\n    e[++cnt].to=y;e[cnt].w=w;e[cnt].nxt=head[x];head[x]=cnt;\n    e[++cnt].to=x;e[cnt].w=0;e[cnt].nxt=head[y];head[y]=cnt;\n}\nbool bfs(){\n    int h=0,t=1,x;\n    clr(d,0);d[q[h]=st]=1;\n    while(h<t){\n        x=q[h++];if(x==ed)return 1;\n        fl(i,x)if(e[i].w&&!d[to]){\n            d[to]=d[x]+1;\n            q[t++]=to;\n        }\n    }\n    return 0;\n}\nint dfs(int x,int mf){\n    if(x==ed)return mf;\n    int us=0,w;\n    fl(i,x)\n    if(e[i].w&&d[to]==d[x]+1){\n        w=dfs(to,MIN(mf-us,e[i].w));\n        e[i].w-=w;e[i^1].w+=w;\n        us+=w;if(to!=ed)nex[x>>1]=to>>1;\n        if(us==mf)return mf;\n    }\n    if(!us)d[x]=-1;\n    return us;\n}\nint work(){int ans=0;while(bfs())ans+=dfs(st,inf);return ans;}\nbool v[N];\nint main(){\n    in>>n;\n    st=N-2;ed=N-1;\n    int d=0,tot=0,t;\n    while(tot<=n){\n        ++d;\n        add(st,d<<1,1);add(d<<1|1,ed,1);\n        for(rg int i=sqrt(d)+1;i*i<(d<<1);i++)add((i*i-d)<<1,d<<1|1,1);\n        if(!work())top[++tot]=d;\n    }\n    out<<(--d)<<ln;\n    Fur(i,1,n)\n    if(!v[top[i]]){\n        v[t=top[i]]=1;\n        while(t)out<<t<<\" \",v[t=nex[t]]=1;\n        out<<ln;\n    }\n}\n```\n\n## 5. [软件补丁问题](https:\/\/www.luogu.org\/problemnew\/show\/P2761)\n\n最短路+状态压缩\n\n将每个补丁状态压缩,然后跑最短路。\n\n因为边太多,所以枚举就可以了\n\n```cpp\n#include<bits\/stdc++.h>\n#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops,fast-math\")\n#pragma GCC target(\"sse,sse2,avx,avx2,popcnt,tune=native\")\n#define il __inline__ __attribute__ ((always_inline))\n#define rg register\n#define MB template <class T>\n#define Fur(i,x,y) for(rg int i=x;i<=y;i++)\n#define clr(x,y) memset(x,y,sizeof(x))\n#define inf 2000000000\n#define fl(i,x) for(rg int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\nMB T MIN(T x,T y){return x<=y?x:y;}\nusing namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 22\nint n,m;\nint d[1<<N],b1[101],b2[101],f1[101],f2[101],c[101];\nstruct cmp{bool operator()(int x,int y){return d[x]>d[y];}};\npriority_queue<int,vector<int>,cmp>q;\nbool v[1<<N];\nvoid spfa(){\n    clr(d,126);\n    d[(1<<n)-1]=0;q.push((1<<n)-1);\n    while(!q.empty()){\n        rg int x=q.top(),to;q.pop();v[x]=0;\n        Fur(i,1,m)\n        if((b1[i]&x)==b1[i]&&!(b2[i]&x)){\n            to=(x&(~f1[i]))|f2[i];\n            if(d[x]+c[i]<d[to]){\n                d[to]=d[x]+c[i];\n                if(!v[to])q.push(to),v[to]=1;\n            }\n        }\n    }\n    if(d[0]==2122219134)d[0]=0;\n}\nint main(){\n    in>>n>>m;\n    char s1[N],s2[N];\n    Fur(i,1,m){\n        in>>c[i]>>s1>>s2;\n        Fur(j,0,n-1){\n            if(s1[j]=='+')b1[i]|=(1<<j);\n            if(s1[j]=='-')b2[i]|=(1<<j);\n            if(s2[j]=='-')f1[i]|=(1<<j);\n            if(s2[j]=='+')f2[i]|=(1<<j);\n        }\n    }\n    spfa();\n    out<<d[0]<<ln;\n}\n```\n\n## 6. [圆桌问题](https:\/\/www.luogu.org\/problemnew\/show\/P3254)\n\n和飞行员配对方案问题差不多嘛。\n\n也是网络流二分图,再加个输出。\n\n大概的套路就是匹配的直接都连边1,然后源点汇点什么的按题意写就可以了\n\n输出的就是有连边的,而且这条边已经用过了（e[i^1])）。\n\n```cpp\n#include<bits\/stdc++.h>\n#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops,fast-math\")\n#pragma GCC target(\"sse,sse2,avx,avx2,popcnt,tune=native\")\n#define il __inline__ __attribute__ ((always_inline))\n#define rg register\n#define MB template <class T>\n#define Fur(i,x,y) for(rg int i=x;i<=y;i++)\n#define clr(x,y) memset(x,y,sizeof(x))\n#define inf 2000000000\n#define fl(i,x) for(rg int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\nMB T MIN(T x,T y){return x<=y?x:y;}\nusing namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 1001\nint n,m,st,ed,cnt=1;\nint head[N],d[N],q[N];\nstruct edge{int to,nxt,w;}e[1000011];\nvoid add(int x,int y,int w){\n    e[++cnt].to=y;e[cnt].w=w;e[cnt].nxt=head[x];head[x]=cnt;\n    e[++cnt].to=x;e[cnt].w=0;e[cnt].nxt=head[y];head[y]=cnt;\n}\nbool bfs(){\n    int h=0,t=1,x;\n    clr(d,0);d[q[h]=st]=1;\n    while(h<t){\n        x=q[h++];if(x==ed)return 1;\n        fl(i,x)if(e[i].w&&!d[to]){\n            d[to]=d[x]+1;\n            q[t++]=to;\n        }\n    }\n    return 0;\n}\nint dfs(int x,int mf){\n    if(x==ed)return mf;\n    int us=0,w;\n    fl(i,x)\n    if(e[i].w&&d[to]==d[x]+1){\n        w=dfs(to,MIN(mf-us,e[i].w));\n        e[i].w-=w;e[i^1].w+=w;\n        us+=w;\n        if(us==mf)return mf;\n    }\n    if(!us)d[x]=-1;\n    return us;\n}\nint main(){\n    in>>m>>n;\n    st=N-2;ed=N-1;\n    int x,sum=0;\n    Fur(i,1,m){\n        in>>x,add(st,i,x),sum+=x;\n        Fur(j,m+1,m+n)add(i,j,1);\n    }\n    Fur(i,m+1,m+n)in>>x,add(i,ed,x);\n    while(bfs())sum-=dfs(st,inf);\n    if(sum)out<<\"0\\n\";\n    else{\n        out<<\"1\\n\";\n        Fur(i,1,m){\n            fl(j,i)if(to!=st&&to!=ed&&e[j^1].w)out<<to-m<<\" \";\n            out<<ln;\n        }\n    }\n}\n```\n\n## 7.[试题库问题](https:\/\/www.luogu.org\/problemnew\/show\/P2763)\n\n也是水题吧。\n\n用网络流可能比二分图容易写点。\n\n套路和上一道一样,稍微改一下就可以了。\n\n```cpp\n#include<bits\/stdc++.h>\n#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops,fast-math\")\n#pragma GCC target(\"sse,sse2,avx,avx2,popcnt,tune=native\")\n#define il __inline__ __attribute__ ((always_inline))\n#define rg register\n#define MB template <class T>\n#define Fur(i,x,y) for(rg int i=x;i<=y;i++)\n#define clr(x,y) memset(x,y,sizeof(x))\n#define inf 2000000000\n#define fl(i,x) for(rg int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\nMB T MIN(T x,T y){return x<=y?x:y;}\nusing namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 2001\nint n,k,st,ed,cnt=1;\nint head[N],d[N],q[N];\nstruct edge{int to,nxt,w;}e[1000011];\nvoid add(int x,int y,int w){\n    e[++cnt].to=y;e[cnt].w=w;e[cnt].nxt=head[x];head[x]=cnt;\n    e[++cnt].to=x;e[cnt].w=0;e[cnt].nxt=head[y];head[y]=cnt;\n}\nbool bfs(){\n    int h=0,t=1,x;\n    clr(d,0);d[q[h]=st]=1;\n    while(h<t){\n        x=q[h++];if(x==ed)return 1;\n        fl(i,x)if(e[i].w&&!d[to]){\n            d[to]=d[x]+1;\n            q[t++]=to;\n        }\n    }\n    return 0;\n}\nint dfs(int x,int mf){\n    if(x==ed)return mf;\n    int us=0,w;\n    fl(i,x)\n    if(e[i].w&&d[to]==d[x]+1){\n        w=dfs(to,MIN(mf-us,e[i].w));\n        e[i].w-=w;e[i^1].w+=w;\n        us+=w;\n        if(us==mf)return mf;\n    }\n    if(!us)d[x]=-1;\n    return us;\n}\nint main(){\n    in>>k>>n;\n    st=N-2;ed=N-1;\n    int x,t,sum=0;\n    Fur(i,1,k)in>>x,add(st,i,x),sum+=x;\n    Fur(i,k+1,k+n){\n        add(i,ed,1);\n        in>>t;while(t--)in>>x,add(x,i,1);\n    }\n    while(bfs())sum-=dfs(st,inf);\n    if(sum)out<<\"No Solution!\\n\";\n    else Fur(i,1,k){\n            out<<i<<\": \";\n            fl(j,i)if(to!=st&&to!=ed&&e[j^1].w)out<<to-k<<\" \";\n            out<<ln;\n        }\n}\n```\n\n","link":null,"tags":["网络流","建图"],"title":"网络流24题"},{"categories":[["比赛"]],"content":"\n\n| [A](http:\/\/codeforces.com\/contest\/1110\/problem\/A) | [Parity](http:\/\/codeforces.com\/contest\/1110\/problem\/A) standard input\/output1 s, 256 MB | [![Submit](http:\/\/st.codeforces.com\/s\/27606\/images\/icons\/submit-22x22.png)](http:\/\/codeforces.com\/contest\/1110\/submit\/A) ![Add to favourites](http:\/\/st.codeforces.com\/s\/27606\/images\/icons\/star_gray_16.png) | [![img](http:\/\/st.codeforces.com\/s\/27606\/images\/icons\/user.png) x6385](http:\/\/codeforces.com\/contest\/1110\/status\/A) |\n| : | :-- | :-: | :-- |\n| [B](http:\/\/codeforces.com\/contest\/1110\/problem\/B) | [Tape](http:\/\/codeforces.com\/contest\/1110\/problem\/B)standard input\/output1 s, 256 MB | [![Submit](http:\/\/st.codeforces.com\/s\/27606\/images\/icons\/submit-22x22.png)](http:\/\/codeforces.com\/contest\/1110\/submit\/B) ![Add to favourites](http:\/\/st.codeforces.com\/s\/27606\/images\/icons\/star_gray_16.png) | [![img](http:\/\/st.codeforces.com\/s\/27606\/images\/icons\/user.png) x4448](http:\/\/codeforces.com\/contest\/1110\/status\/B) |\n| [C](http:\/\/codeforces.com\/contest\/1110\/problem\/C) | [Meaningless Operations](http:\/\/codeforces.com\/contest\/1110\/problem\/C)standard input\/output1 s, 256 MB | [![Submit](http:\/\/st.codeforces.com\/s\/27606\/images\/icons\/submit-22x22.png)](http:\/\/codeforces.com\/contest\/1110\/submit\/C) ![Add to favourites](http:\/\/st.codeforces.com\/s\/27606\/images\/icons\/star_gray_16.png) | [![img](http:\/\/st.codeforces.com\/s\/27606\/images\/icons\/user.png) x3704](http:\/\/codeforces.com\/contest\/1110\/status\/C) |\n| [D](http:\/\/codeforces.com\/contest\/1110\/problem\/D) | [Jongmah](http:\/\/codeforces.com\/contest\/1110\/problem\/D)standard input\/output3 s, 256 MB | [![Submit](http:\/\/st.codeforces.com\/s\/27606\/images\/icons\/submit-22x22.png)](http:\/\/codeforces.com\/contest\/1110\/submit\/D) ![Add to favourites](http:\/\/st.codeforces.com\/s\/27606\/images\/icons\/star_gray_16.png) | [![img](http:\/\/st.codeforces.com\/s\/27606\/images\/icons\/user.png) x940](http:\/\/codeforces.com\/contest\/1110\/status\/D) |\n| [E](http:\/\/codeforces.com\/contest\/1110\/problem\/E) | [Magic Stones](http:\/\/codeforces.com\/contest\/1110\/problem\/E)standard input\/output1 s, 256 MB | [![Submit](http:\/\/st.codeforces.com\/s\/27606\/images\/icons\/submit-22x22.png)](http:\/\/codeforces.com\/contest\/1110\/submit\/E) ![Add to favourites](http:\/\/st.codeforces.com\/s\/27606\/images\/icons\/star_gray_16.png) | [![img](http:\/\/st.codeforces.com\/s\/27606\/images\/icons\/user.png) x1096](http:\/\/codeforces.com\/contest\/1110\/status\/E) |\n\n## A. Parity\n\n### 题意：\n\n设$n = a_1 \\cdot  b_{k−1} + a_2 \\cdot b_{k−2} + … a_{k−1} \\cdot b + a_k$\n\n给出$b,k​$、数组$a​$,判断$n​$是偶数(even)还是奇数(odd).\n\n### 题解：\n\n用一个bool$f$记录到目前是奇数还是偶数\n\n如果$a_i$或$b_{k-i}$之间有一个是偶数,$a_i \\cdot b_{k-i}$就是偶数\n\n如果$i=k$就只看$a_k$就可以了\n\n```cpp\n#include<cstdio>\n#define Fur(i,x,y) for(int i=x;i<=y;i++)\nusing namespace std;\nint b,k,x;\nint main(){\n    scanf(\"%d%d\",&b,&k);\n    bool f=0;\n    Fur(i,1,k){\n        scanf(\"%d\",&x);\n        if((k-i!=0&&!(b&1))||!(x&1))continue;\n        f^=1;\n    }\n    printf(f?\"odd\\n\":\"even\\n\");\n}\n```\n\n## B. Parity\n\n### [原题](https:\/\/www.luogu.org\/problemnew\/show\/P1209)\n\n就是输入顺序不一样罢了\n\n\n\n贪心取空隙最大的不要就可以了。\n\n```cpp\n#include<cstdio> \n#include<algorithm> \n#define N 100010\nusing namespace std; \nint m,s,c,ans;\nint a[N],C[N];\nbool cmp(int x,int y){return x>y;}\nint main() { \n    scanf(\"%d %d %d\",&c,&s,&m);\n    for(int i=1;i<=c;i++)scanf(\"%d\",&a[i]);\n    if(m>c){printf(\"%d\\n\",c);return 0;}\n    sort(a+1,a+c+1);\n    ans=a[c]-a[1]+1;\n    for(int i=2;i<=c;i++)C[i-1]=a[i]-a[i-1];\n    sort(C+1,C+c,cmp);\n    for(int i=1;i<=m-1;i++)ans=ans-C[i]+1;\n    printf(\"%d\\n\",ans);\n} \n```\n\n\n\n## C. Meaningless Operations\n\n### 题意：\n\n输入$q$,然后输入$q$个$a$,对于每个$a$,找到一个$b(0<b<a)$,使$ gcd(a\\ xor\\ b, a\\ and\\ b) $最大,输出这个最大的$gcd$\n\n### 题解：\n\n如果$a$不是 $(1 << k) - 1$这种形式,那么总能找到一个$b$使$a\\ xor\\ b == (1 << k) - 1$,而$a\\ and\\ b == 0$,这个时候$gcd$一定最大\n\n如果$a$是 $(1 << k) - 1$,那么因为$b$不能为$0$,所以凑不出 $(1 << k) - 1$,没办法只能暴力了,因为 $(1 << k) - 1$这样的形式的a也只有24个,所以我们要事先打表,否则应该会超时\n\n```cpp\n#include<cstdio>\n#include<map>\nusing namespace std;\n#define N 100011\nint n;\nmap<int,int>mp;\nint main(){\nmp[3]=1;mp[7]=1;mp[15]=5;mp[31]=1;mp[63]=21;mp[127]=1;mp[255]=85;mp[511]=73;mp[1023]=341;mp[2047]=89;mp[4095]=1365;mp[8191]=1;mp[16383]=5461;mp[32767]=4681;mp[65535]=21845;mp[131071]=1;mp[262143]=87381;mp[524287]=1;mp[1048575]=349525;mp[2097151]=299593;mp[4194303]=1398101;mp[8388607]=178481;mp[16777215]=5592405;mp[33554431]=1082401;\nint T,n;scanf(\"%d\",&T);\nwhile(T--){\n    scanf(\"%d\",&n);\n    if(mp.count(n))printf(\"%d\\n\",mp[n]);\n    else printf(\"%d\\n\",(1<<(int(log2(n))+1))-1);\n}\n}\n```\n\n## D. Jongmah\n\n### 题意：\n\n你有$n(10^6)$个数字,范围$[1, m(10^6)]$,你可以选择其中的三个数字构成一个三元组,但是这三个数字必须是连续的或者相同的,每个数字只能用一次,问这$n$个数字最多构成多少个三元组?\n\n### 题解：\n\n看到$n$那么大,以为是贪心,其实是dp\n\n#### 分析：如果有3个三元组$(i,i+1,i+2)$那么肯定可以拆成3个三元组$(i,i,i),(i+1,i+1,i+1),(i+2,i+2,i+2)$,所以对于每个$i$最多有2对$(i,i+1,i+2)$\n\n先用桶$b$记录每种数字出现的次数\n\n设$f[i][j][k]$表示$1-i$中的数字有$j$个$(i-1,i,i+1)$的三元组,有$k$个$(i,i+1,i+2)$的三元组。\n\n根据分析可以得出$j,k \\leq 2$,所以复杂度不会翻车。\n\n#### 转移：\n\n我们考虑$i \\rightarrow i+1$的方式。\n\n设$now$为目前第$i$种数字剩下的个数\n\n$f[i+1][j][t]=MAX(f[i+1][j][t],f[i][j][k]+\\frac {(now-t)} 3+t)$\n\n意思就是在$f[i][j][k]$的基础上,把第$i$种数字剩下中的$t$个用来组成$3$个**连续数字$(i,i+1,i+2)$类型的三元组**。\n\n```cpp\n#include<cstdio>\n#include<cstring>\n#define Fur(i,x,y) for(int i=x;i<=y;i++)\nint MAX(int x,int y){return x>y?x:y;}\nint MIN(int x,int y){return x<y?x:y;}\nusing namespace std;\n#define N 1000011\nint n,m,b[N],f[N][3][3];\nint main(){\n    scanf(\"%d%d\",&n,&m);\n    int x;\n    Fur(i,1,n)scanf(\"%d\",&x),b[x]++;\n    memset(f,-1,sizeof(f));\n    f[0][0][0]=0;\n    Fur(i,0,m+1)\n        Fur(j,0,2)\n            Fur(k,0,2)if(f[i][j][k]>=0){\n                int now=b[i+1]-j-k;\n                Fur(t,0,MIN(2,now))f[i+1][k][t]=MAX(f[i+1][k][t],f[i][j][k]+(now-t)\/3+t);\n            }\n\tprintf(\"%d\\n\",f[m+1][0][0]);\n}\n```\n\n## E. Magic Stones\n\n~~感觉比D容易多了~~\n\n### 题意：\n\n有一个序列$a$,你可以把$a_i(1<i<n)$变成$a_{i-1}+a_{i+1}-a_i$,问序列$a$能否变成序列$b$\n\n### 题解：\n\n如果把序列$a,b​$变为差分数组（原来的$a_i​$变为$a_i-a_{i-1}​$）的话可以巧妙地发现每次操作就是交换差分数组中相邻的的两个数。\n\n所以把$a,b​$分别排序后比较是否相同就可以了。\n\n```cpp\n#include<cstdio>\n#include<algorithm>\nnamespace FastIO{const char* ln=\"\\n\";struct Reader{char buf[1<<20],*s,*t;bool EOF_FLG;Reader():s(buf),t(buf),EOF_FLG(false) {};char gt() {return s==t&&((t=(s=buf)+fread(buf,1,1<<20,stdin))==s)?EOF:(*s++);}Reader& operator>>(char* str) {if(EOF_FLG)return *str=0,*this;while((*str=gt())!=' '&&*str!='\\n'&&*str!=EOF)++str;if(*str==EOF)EOF_FLG=true;*str=0;return *this;}template<typename T>Reader&operator>>(T&x) {if(EOF_FLG)return *this;char c=0,d;while(c!=EOF&&(c<'0'||c>'9'))d=c,c=gt();if(c==EOF){EOF_FLG=true;return *this;}else x=0;while(c>='0'&&c<='9')x=(x<<3)+(x<<1)+c-'0',c=gt();if(d=='-')x=-x;return *this;}}in;struct Writer{char buf[1<<20],*s,*t;Writer():s(buf),t(buf+(1<<20)){}~Writer(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,1<<20,stdout),*s++=c):(*s++=c);}template<typename T>Writer&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[40],t=0;while(x)a[t++]=x%10,x\/=10;while(t--)pt(a[t]+'0');return *this;}Writer&operator<<(const char*s) {while(*s)pt(*s++);return *this;}}out;}using namespace FastIO;\n#define Fur(i,x,y) for(int i=x;i<=y;i++)\nusing namespace std;\n#define N 100011\nint a[N],b[N],n;\nint main(){\n    in>>n;\n    int x=0,y=0;\n    Fur(i,1,n)in>>x,a[i]=x-y,y=x;\n    x=y=0;\n    Fur(i,1,n)in>>x,b[i]=x-y,y=x;\n    if(a[1]!=b[1])return out<<\"No\\n\",0;\/\/因为第一个数没法操作\n    sort(a+2,a+n+1);\n    sort(b+2,b+n+1);\n    Fur(i,2,n)if(a[i]!=b[i])return out<<\"No\\n\",0;\n    out<<\"Yes\\n\";\n}\n```\n\n","link":null,"tags":[],"title":"CF1110"},{"categories":[["算法","图论"],["算法","树论"],["note"]],"content":"\n\n## 建树\n\ntarjan求出双连通分量后把其中的点连向新建的节点\n\n建成的新图(树)即为圆方树\n\n![](https:\/\/images.cnblogs.com\/cnblogs_com\/sdzwyq\/1268719\/o_%e5%9c%86%e6%96%b9%e6%a0%91.png)\n\n**性质：可以发现原图中两点间必经的点就是圆方树中的圆点**\n\n[道路相遇](https:\/\/www.luogu.com.cn\/problem\/P4320)\n\n可以用找出lca后直接求\n\n```cpp\n#include<bits\/stdc++.h>\n#define il __inline__ __attribute__ ((always_inline))\n#define MB template <class T>il\n#define Fur(i,x,y) for(int i(x);i<=y;++i)\n#define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n#define FL(i,x) for(int i(HEAD[x]),to;to=e[i].to,i;i=e[i].nxt)\nMB T MAX(T x,T y){return x>y?x:y;}\nMB T MIN(T x,T y){return x<y?x:y;}\nusing namespace std;\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?__=1,EOF:*in_s++;}il void in(string &ch){ch.clear();if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)__=1;}il void in(char &ch){if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)__=1;else ch=c;}il void in(char *ch){*ch='\\0';if(__)return;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF){__=1;return;}*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)__=1;*ch='\\0';}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}il void out(string s){for(int i=0;s[i];i++)pt(s[i]);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\nconst int N=1000011;\nint n,m,cnt=0,head[N],HEAD[N];\nstruct edge{int to,nxt;}e[N<<3];\nil void add(int x,int y){\n    e[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;\n    e[++cnt].to=x;e[cnt].nxt=head[y];head[y]=cnt;\n}\nil void ADD(int x,int y){\n    e[++cnt].to=y;e[cnt].nxt=HEAD[x];HEAD[x]=cnt;\n    e[++cnt].to=x;e[cnt].nxt=HEAD[y];HEAD[y]=cnt;\n}\nint dfn[N],low[N],sz=0,tot,st[N],tp=0;\nvoid tarjan(int x,int fa){\n    dfn[x]=low[x]=++sz;st[++tp]=x;\n    fl(i,x)\n    if(!dfn[to]){\n        tarjan(to,x);\n        low[x]=MIN(low[x],low[to]);\n        if(low[to]>=dfn[x]){\n            ADD(++tot,x);\n            while(int k=st[tp--]){\n                ADD(tot,k);\n                if(k==to)break;\n            }\n        }\n    }\n    else if(to!=fa)low[x]=MIN(low[x],dfn[to]);\n}\nint f[N],siz[N],d[N],top[N],son[N];\nvoid dfs(int x){\n    siz[x]=1;\n    FL(i,x)if(to!=f[x]){\n        f[to]=x;\n        d[to]=d[x]+1;\n        dfs(to);\n        siz[x]+=siz[to];\n        if(siz[to]>siz[son[x]])son[x]=to;\n    }\n}\nvoid bt(int x,int tp){\n    top[x]=tp;\n    if(son[x])bt(son[x],tp);\n    FL(i,x)if(!top[to])bt(to,to);\n}\nint lca(int x,int y){\n    while(top[x]!=top[y])\n        (d[top[x]]>d[top[y]])?x=f[top[x]]:y=f[top[y]];\n    return d[x]<d[y]?x:y;\n}\nint main(){\n    in(n,m);tot=n;\n    int x,y,q;\n    Fur(i,1,m)in(x,y),add(x,y);\n    tarjan(1,0);\n    d[1]=1;dfs(1);bt(1,1);\n    in(q);\n    while(q--){\n        in(x,y);\n        out((d[x]+d[y]-2*d[lca(x,y)])\/2+1,ln);\n    }\n    flush();\n}\n```\n\n## 圆方树与仙人掌\n\n[BZOJ 2125 最短路](https:\/\/www.lydsy.com\/JudgeOnline\/problem.php?id=2125)\n\n[LG 5236 静态仙人掌](https:\/\/www.luogu.com.cn\/problem\/P5236)\n\n还是先建成圆方树\n\n若两个点的lca是原图的点,那么直接$d_x+d_y-2\\times d_{lca(x,y)}$\n\n否则就是两个点到环(方点)的距离加上两个点在环上的最短距离(可以用前缀和解决)\n\n```cpp\n#include<cstdio>\n#pragma GCC optimize(3)\n#define il __inline__ __attribute__ ((always_inline))\n#define Fur(i,x,y) for(int i(x);i<=y;++i)\n#define Fdr(i,x,y) for(int i(x);i>=y;--i)\nil void swap(int &x,int &y){int t=x;x=y;y=t;}\nil int min(int x,int y){return x<y?x:y;}\nil int abs(int x){return x>0?x:-x;}\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?__=1,EOF:*in_s++;}template<typename T>il void in(T &x){if(__)return;char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}template<typename T,typename ... arr>il void in(T &x,arr & ... y){in(x),in(y...);}const char ln='\\n';static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}il void out(const char* s){while(*s)pt(*s++);}il void out(char* s){while(*s)pt(*s++);}il void out(char c){pt(c);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x\/= 10;while(t--)pt(a[t]+'0');}template<typename T,typename ... arr>il void out(T x,arr & ... y){out(x),out(y...);}}using namespace IO;\nconst int N=20011;\nint n,m,q,cnt=0,head[N],HEAD[N];\nstruct edge{\n    int to,nxt,w;\n}e[N<<2];\n#define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\n#define FL(i,x) for(int i(HEAD[x]),to;to=e[i].to,i;i=e[i].nxt)\nil void add(int x,int y,int w){\n    e[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;e[cnt].w=w;\n    e[++cnt].to=x;e[cnt].nxt=head[y];head[y]=cnt;e[cnt].w=w;\n}\nil void ADD(int x,int y,int w){\n    e[++cnt].to=y;e[cnt].nxt=HEAD[x];HEAD[x]=cnt;e[cnt].w=w;\n    e[++cnt].to=x;e[cnt].nxt=HEAD[y];HEAD[y]=cnt;e[cnt].w=w;\n}\nint dfn[N],low[N],sz=0,fa[N],tot,b[N],id[N];\nint s[N],dep[N];\nvoid solve(int x,int y,int w){\n    ++tot;\n    int t=w,tt=0;\n    for(int i=y;i!=fa[x];i=fa[i]){\n        s[i]=t;\n        t+=b[i];\n        id[i]=tt++;\n    }\n    s[tot]=s[x];s[x]=0;\n    for(int i=y;i!=fa[x];i=fa[i])\n        ADD(tot,i,min(s[i],s[tot]-s[i]));\n}\nvoid tarjan(int x){\n    dfn[x]=low[x]=++sz;\n    fl(i,x)if(to!=fa[x]){\n        if(!dfn[to]){\n            fa[to]=x;b[to]=e[i].w;\n            tarjan(to);\n            low[x]=min(low[x],low[to]);\n        }\n        else low[x]=min(low[x],dfn[to]);\n        if(low[to]>dfn[x])ADD(x,to,e[i].w);\n    }\n    fl(i,x)if(fa[to]!=x&&dfn[to]>dfn[x])\n        solve(x,to,e[i].w);\n}\nint f[16][N],d[N],A,B;\nvoid dfs(int x){\n    for(int j=1;(1<<j)<=d[x];++j)\n        f[j][x]=f[j-1][f[j-1][x]];\n    FL(i,x)if(to!=f[0][x]){\n        f[0][to]=x;\n        d[to]=d[x]+1;\n        dep[to]=dep[x]+e[i].w;\n        dfs(to);\n    }\n}\nint lca(int x,int y){\n    if(d[x]<d[y])swap(x,y);\n    int D=d[x]-d[y];\n    for(int i=0;(1<<i)<=D;++i)if(D&(1<<i))x=f[i][x];\n    if(x==y)return x;\n    Fdr(i,15,0)if((1<<i)<=d[x]&&f[i][x]!=f[i][y])\n        x=f[i][x],y=f[i][y];\n    A=x,B=y;\n    return f[0][x];\n}\nint main(){\n    in(n,m,q);tot=n;\n    int x,y,w;\n    Fur(i,1,m)in(x,y,w),add(x,y,w);\n    tarjan(1);\n    dfs(1);\n    while(q--){\n        in(x,y);\n        w=lca(x,y);\n        if(w<=n)out(dep[x]+dep[y]-2*dep[w],ln);\n        else out(dep[x]+dep[y]-dep[A]-dep[B]+min(s[w]-abs(s[B]-s[A]),abs(s[A]-s[B])),ln);\n    }\n    flush();\n}\n```\n\n## 仙人掌直径\n\n","link":null,"tags":["树","数据结构","tarjan","技巧","图论"],"title":"圆方树"},{"categories":[["刷题记录"]],"content":"\n[LG 3953 逛公园](https:\/\/www.luogu.org\/problemnew\/show\/P3953)\n\n题意: 求$dis(1,n)<=MinDis(1,n)+K$的路径数\n\n用拓扑啊什么的一想就很麻烦。\n\n有一种玄学的做法：记忆化搜索\n\n$f[x][k]$表示$dis(x,n)<=MinDis(x,n)+k$的路径数。\n\n先跑一般反向的最短路,然后dfs\n\n考虑边$(x,y,w)$,\n\n$\\because Mindis[x]-Mindis[y]+w<k$\n\n$\\therefore f[x][k]+=f[y][k-(Mindis[x]-Mindis[y]+w)]$\n\n$\\therefore f[x][k] = \\sum f[y][k-(Mindis[x]-Mindis[y]+w)]$\n\n```cpp\n#include<cstdio>\n#include<cstring>\n#include<queue>\n#define Fur(i,x,y) for(int i=x;i<=y;i++)\n#define clr(x,y) memset(x,y,sizeof(x))\n#define gc getchar\nint gi(){int x=0,f=0;char c=gc();while(c<'0'||'9'<c){if(c=='-')f=!f;c=gc();}while('0'<=c&&c<='9'){x=x*10+c-48;c=gc();}return f?(-x):x;}\nusing namespace std;\n#define N 100010\n#define fl(head,i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\nint n,m,cnt,k,mod,f[N][51],h1[N],h2[N],d[N];\nbool is[N][51],v[N];\nstruct eg{int to,w,nxt;}e[N*4];\nvoid add(int x,int y,int w,int *head){e[++cnt]=(eg){y,w,head[x]};head[x]=cnt;}\nstruct cmp{bool operator()(int a,int b){return d[a]>d[b];}};\npriority_queue<int,vector<int>,cmp>q;\nvoid spfa(){\n    clr(d,126);\n    int x;d[n]=0;q.push(n);\n    while(!q.empty()){\n        x=q.top();q.pop();v[x]=0;\n        fl(h2,i,x)\n        if(d[x]+e[i].w<d[to]){\n            d[to]=d[x]+e[i].w;\n            if(!v[to])q.push(to),v[to]=1;\n        }\n    }\n}\nint dfs(int x,int k){\n    if(is[x][k])return -1;\n    if(f[x][k])return f[x][k];\n    is[x][k]=1;f[x][k]=(x==n);\n    int tmp,w;\n    fl(h1,i,x)\n    if((tmp=d[to]-d[x]+e[i].w)<=k)\n        if((w=dfs(to,k-tmp))){\n            if(w==-1)return w;\n            f[x][k]+=w;if(f[x][k]>mod)f[x][k]-=mod;\n        }\n    is[x][k]=0;\n    return f[x][k];\n}\nint main(){\nint T=gi(),x,y,w;\nwhile(T--){\n    n=gi();m=gi();k=gi();mod=gi();cnt=0;\n    clr(f,0);clr(h1,0);clr(h2,0);clr(is,0);\n    Fur(i,1,m)x=gi(),y=gi(),w=gi(),add(x,y,w,h1),add(y,x,w,h2);\n    spfa();printf(\"%d\\n\",dfs(1,k));\n}\n}\n```\n\n","link":null,"tags":["spfa","记忆化搜索","图论"],"title":"LG 3953 逛公园"},{"categories":[["算法","数论"],["note"]],"content":"\n\n\n\n转自https:\/\/www.cnblogs.com\/hadilo\/p\/5914302.html\n\n## 欧几里得\n\n### 定义:\n\n$gcd(a,b)$为整数$a$与$b$的最大公约数\n\n### 引理：\n\n$gcd(a,b)=gcd(b,a \\bmod b)$\n\n### 证明：\n\n设$r=a \\bmod b , c=gcd(a,b)$\n\n则$a=xc,b=yc$, 其中$x,y$互质\n\n$r=a \\bmod b=a-pb=xc-pyc=(x-py)c$\n\n而$b=yc$\n\n可知：$y$与 $x-py$互质\n\n#### 证明：\n\n假设$y$与$x-py$不互质\n\n设$y=nk,x-py=mk$, 且$k>1$（因为互质）\n\n将$y$带入可得\n\n$x-pnk=mk$\n\n$x=(pn+m)k$\n\n则$a=xc=(pn+m)kc,b=yc=nkc$\n\n那么此时$a$与$b$的最大公约数为$kc$不为$k$\n\n与原命题矛盾,则$y$与$x-py$互质\n\n因为$y$与$x-py$互质,所以$r$与$b$的最大公约数为$c$\n\n即$gcd(b,r)=c=gcd(a,b)$\n\n得证\n\n当$a\\mod b=0$时,$gcd(a,b)=b$\n\n这样我们可以写成递归形式\n\n### 实现：\n\n```cpp\nint gcd(int a,int b){\n    return b?gcd(b,a%b):a;\n}\n```\n\n## 扩展欧几里得\n\n### 引理：\n\n存在$x,y$ 使得$gcd(a,b)=ax+by$\n\n### 证明：\n\n当 $b=0$ 时,$gcd(a,b)=a,此时 x=1 , y=0$\n当 $b \\neq  0$ 时,设\n\n$ax+by=gcd(a,b)=gcd(b,a \\bmod b)=b{x}'+(a \\bmod b){y}'$\n\n$\\because a \\bmod b = a-a\/b*b$\n\n$\\therefore ax+by=b{x}'+(a-a\/b*b){y}'$\n\n$\\therefore ax+by=b{x}'+a{y}'-b*a\/b*{y}'$\n\n$\\therefore ax+by=a{y}'+b{x}'-b*a\/b*{y}'$\n\n$\\therefore ax+by=a{y}'+b({x}'-a\/b*{y}')$\n\n$解得 x={y}' , y={x}'-a\/b*{y}'$\n\n当$b=0$时存在$x,y$为最后一组解\n\n### 实现：\n\n递归进入下一层,当$b=0$时就返回$x=1,y=0$\n\n再根据$x=y' , y={x}'-a\/b*y'$得出当前所在层的解\n\n回到第一层的时候得到答案。\n\n```cpp\nint x,y;\nvoid exgcd(int a,int b){\n    if(!b){x=1,y=0;return;}\n    exgcd(b,a%b);\n    int t=x;x=y;y=t-a\/b*y;\n}\n```\n## LG 1082 同余方程\n\n> 求关于$x$的同余方程$ax \\equiv 1 \\pmod b$的最小正整数解。\n\n$ax \\equiv 1 \\pmod b$可以转化为$ax+by=1$\n\n方程$ax + by = m$有解的必要条件是$m \\mod \\gcd(a,b) = 0$。\n\n$\\therefore \\gcd(a,b) = 1$,即$a,b$互质\n\n用扩展欧几里得求$ax+by=\\gcd(a,b)$的解即可\n\n我们求出来的$x$必然满足方程,但是不一定是最小正整数解\n\n> $ax+by=1$\n> \n> $ax+by+k\\times ba-k\\times ba=1$\n> \n> $a(x+kb)+(y-ka)b=1$\n\n所以$x+=b$或$x-=b$不会使$x$错过任何解\n\n```cpp\n#include<bits\/stdc++.h>\nusing namespace std;\n#define ll long long\nll x,y;\nvoid exgcd(ll a,ll b){\n    if(!b){\n        x=1,y=0;\n        return;\n    }\n    exgcd(b,a%b);\n    int t=x;\n    x=y;\n    y=t-a\/b*y;\n}\nint main(){\n    ll a,b;\n    cin>>a>>b;\n    exgcd(a,b);\n    while(x<0)x+=b;\n    x%=b;\n    cout<<x<<endl;\n}\n```\n","link":null,"tags":["exgcd","数论","算法","逆元"],"title":"exgcd"},{"categories":[["算法","数据结构"],["note"]],"content":"\n\n二维线段树一般用线段树套线段树写,~~当然也可以用[四叉树](https:\/\/www.cnblogs.com\/mimiorz\/p\/8698689.html)写~~\n\n树套树,顾名思义,外层树的每个节点都是一棵树。\n\n## [题目地址：https:\/\/www.luogu.org\/problemnew\/show\/U22582](https:\/\/www.luogu.org\/problemnew\/show\/U22582)\n\n\n\n## 首先要了解的知识：\n\n1. 线段树\n\n2. 标记永久化\n\n   \n\n## 标记永久化：\n\n参考https:\/\/www.cnblogs.com\/Hallmeow\/p\/8004676.html\n\n简单地讲一下,如果要详细了解的话~~可以百度~~。\n\n一般线段树实现区间修改我们用的是懒惰标记,但是遇到一些主席树,树套树等毒瘤数据结构,懒惰标记就显得很麻烦了。\n\n这时候就需要用到标记永久化。这样就可以省掉一堆pushup和pushdown了,~~就可以可持久化了~~\n\n### 原理：\n\n在查询的时候把途经的节点上的标记对答案的影响加上,省掉了下推的过程。\n\n### 实现：\n\n#### 修改：\n\n比如现在要把区间[$L,R​$]全部数加v。\n\n到达被[$L,R​$]完全包含的节点（节点所代表区间在[$L,R​$]内）时,就把节点的标记加上v,然后return。\n\n把完全包含[$L,R$]的区间（[$L,R$]在节点所代表区间内）（一路下来的所有区间)的sum加上$v*(R-L)$。\n\n### 询问：\n\n因为修改时对下面的节点完全没有影响,所以要一路累积标记的影响,直到查询区间与当前节点区间完全重合。\n\n答案就是sum+ad(一路累积标记的影响的总和)*查询区间长度\n\n### 注意：\n\n因为打标记的时候是节点区间与目标区间完全重合,所以要注意向下递归时要用特殊的方式（求最大值的时候不用）。\n\n### 代码实现：\n\n这里给个结构体封装的标记永久化线段树,方便后面树套树的实现。\n\n彩蛋：经本人实测,标记永久化线段树比普通线段树快得多,~~可以用来卡常~~\n\n```cpp\n#include<cstdio>\n#define int ll\n#define ll long long\n#define gc getchar\nint gi(){int x=0,f=0;char c=gc();while(c<'0'||'9'<c){if(c=='-')f=!f;c=gc();}while('0'<=c&&c<='9'){x=x*10+c-48;c=gc();}return f?(-x):x;}\nusing namespace std;\n#define N 100001\nint n,q;\nstruct xds{\n    #define Z int m=(l+r)>>1\n    #define ls rt<<1\n    #define rs rt<<1|1\n    int s[N*3],tag[N*3];\n    void build(int l,int r,int rt){\n        if(l==r){s[rt]=gi();return;}\n        Z;build(l,m,ls);build(m+1,r,rs);\n        s[rt]=s[ls]+s[rs];\n    }\n    void upd(int L,int R,int v,int l,int r,int rt){\n        s[rt]+=v*(R-L+1);\n        if(L==l&&r==R){\n            tag[rt]+=v;\n            return;\n        }\n        Z;\n        \/\/注意！！！！！！！！！！！！！！！！！！！！\n        if(R<=m)upd(L,R,v,l,m,ls);\n        else{\n            if(L>m)upd(L,R,v,m+1,r,rs);\n            else upd(L,m,v,l,m,ls),upd(m+1,R,v,m+1,r,rs);\n        }\n    }\n    int qh(int L,int R,int l,int r,int rt,int ad){\n        if(L==l&&r==R)return s[rt]+ad*(r-l+1);\n        Z;ad+=tag[rt];\n        if(R<=m)return qh(L,R,l,m,ls,ad);\n        else{\n            if(L>m)return qh(L,R,m+1,r,rs,ad);\n            else return qh(L,m,l,m,ls,ad)+qh(m+1,R,m+1,r,rs,ad);\n        }\n    }\n}s;\nsigned main(){\n    n=gi();q=gi();\n    s.build(1,n,1);\n    int p,x,y;\n    while(q--){\n        p=gi();x=gi();y=gi();\n        if(p==1)s.upd(x,y,gi(),1,n,1);\n        else printf(\"%lld\\n\",s.qh(x,y,1,n,1,0));\n    }\n}\n```\n\n\n\n## 树套树实现方法：\n\n一般是先按x轴建外层树,然后在按y轴建树。\n\n内层树更普通线段树一样,外层树每次都更新节点。\n\n为了方便,一般树套树用**标记永久化**来写。\n\n而在区间加&&区间求和中,就必须用标记永久化。\n\n代码请在最后的完整代码中找。\n\n\n\n### 图解：\n![](https:\/\/i.loli.net\/2019\/01\/20\/5c44288fbac50.png)\n![](https:\/\/i.loli.net\/2019\/01\/20\/5c44158cdffe8.png)\n第二张倒过来看~~233~~\n\n\n\n### 建树\n\n内层线段树没有区别。\n\n按照第二张图解,外层线段树对应每个节点等于它的左右儿子的对应节点的和。\n\n比如节点1等于两棵子树对应的节点1的和。\n\n\n\n### 更新\n\n不管是区间更新和点更新,标记永久化都比较方便。\n\n内层和原来一样。\n\n外层的更新就是直接更新节点对应的内层线段树。\n\n下图中绿色的矩形区域就是目标区域,就是**外层树**中每个绿色节点的**内层树**的每个红色节点所代表的区域。\n\n![](https:\/\/i.loli.net\/2019\/01\/20\/5c442c72eac5c.png)\n\n\n\n### 查询\n\n上图中绿色的矩形区域就是要求的区域,相当于**外层树**中每个绿色节点的**内层树**的每个红色节点所代表的区域的和。\n\n\n\n### 注意：\n\n单点查询的树套树可以不用标记永久化(不建议),用二维数组来记录而不用结构体,建树时比较方便。\n\n结构体方便理解和差错,建议写结构体版本。\n\n以下也有给出二维数组来记录的版本。\n\n不管什么推荐用标记永久化,至少**方便**而且代码跑起来会**快**很多,本来树套树就是一个~~很暴力的数据结构~~。\n\n### 代码：\n\n```cpp\n#include<cstdio>\n#define gc getchar\nint gi(){int x=0,f=0;char c=gc();while(c<'0'||'9'<c){if(c=='-')f=!f;c=gc();}while('0'<=c&&c<='9'){x=x*10+c-48;c=gc();}return f?(-x):x;}\nusing namespace std;\n#define N 2010\nint D,S,q;\nstruct xds{\/\/内层（标记永久化）\n    #define Z int m=(l+r)>>1\n    #define ls rt<<1\n    #define rs rt<<1|1\n    int s[N*4],tag[N*4];\n    void build(int l,int r,int rt){\/\/内层建树\n        if(l==r){s[rt]=gi();return;}\n        Z;build(l,m,ls);build(m+1,r,rs);\n        s[rt]=s[ls]+s[rs];\n    }\n    void upd(int L,int R,int v,int l,int r,int rt){\/\/内层修改\n        s[rt]+=v*(R-L+1);\n        if(L==l&&r==R){\n            tag[rt]+=v;\n            return;\n        }\n        Z;\n        if(R<=m)upd(L,R,v,l,m,ls);\n        else{\n            if(L>m)upd(L,R,v,m+1,r,rs);\n            else upd(L,m,v,l,m,ls),upd(m+1,R,v,m+1,r,rs);\n        }\n    }\n    int qh(int L,int R,int l,int r,int rt,int ad){\n        if(L==l&&r==R)return s[rt]+ad*(r-l+1);\n        Z;ad+=tag[rt];\n        if(R<=m)return qh(L,R,l,m,ls,ad);\n        else{\n            if(L>m)return qh(L,R,m+1,r,rs,ad);\n            else return qh(L,m,l,m,ls,ad)+qh(m+1,R,m+1,r,rs,ad);\n        }\n    }\n}s[N*4],tag[N*4];\nvoid mg(xds& o,xds& lc,xds& rc,int l,int r,int rt){\/\/外层节点更新(pushup)\n    o.s[rt]=lc.s[rt]+rc.s[rt];\n    if(l==r)return;\n    Z;mg(o,lc,rc,l,m,ls);mg(o,lc,rc,m+1,r,rs);\n}\nvoid build(int l,int r,int rt){\/\/外层建树\n    if(l==r){\n        s[rt].build(1,S,1);\n        return;\n    }\n    Z;build(l,m,ls);build(m+1,r,rs);\n    mg(s[rt],s[ls],s[rs],1,S,1);\n}\nvoid upd(int x,int y,int xx,int yy,int v,int l,int r,int rt){\/\/外层修改\n    s[rt].upd(y,yy,v*(xx-x+1),1,S,1);\n    if(x==l&&r==xx){\n        tag[rt].upd(y,yy,v,1,S,1);\n        return;\n    }\n    Z;\n    if(xx<=m)upd(x,y,xx,yy,v,l,m,ls);\n    else{\n        if(x>m)upd(x,y,xx,yy,v,m+1,r,rs);\n        else upd(x,y,m,yy,v,l,m,ls),upd(m+1,y,xx,yy,v,m+1,r,rs);\n    }\n}\nint qh(int x,int y,int xx,int yy,int l,int r,int rt,int ad){\/\/查询（求和）\n    if(x==l&&r==xx)return s[rt].qh(y,yy,1,S,1,0)+ad*(r-l+1);\n    Z;ad+=tag[rt].qh(y,yy,1,S,1,0);\n    if(xx<=m)return qh(x,y,xx,yy,l,m,ls,ad);\n    else{\n        if(x>m)return qh(x,y,xx,yy,m+1,r,rs,ad);\n        else return qh(x,y,m,yy,l,m,ls,ad)+qh(m+1,y,xx,yy,m+1,r,rs,ad);\n    }    \n}\nint main(){\n    D=gi();S=gi();q=gi();\n    build(1,D,1);\n    int p,x,y,xx,yy;\n    while(q--){\n        p=gi();x=gi();y=gi();xx=gi();yy=gi();\n        if(p==1)printf(\"%d\\n\",qh(x,y,xx,yy,1,D,1,0));\n        else upd(x,y,xx,yy,gi(),1,D,1);\n    }\n}\n```\n\n是不是感觉这板子比别人的短很多。\n\n\n\n## 练习（感觉都比例题容易）：\n\n### 1. [**UVA11297** Census](https:\/\/www.luogu.org\/problemnew\/show\/UVA11297)\n\n#### 题意：\n\n给一个n*n的矩阵\n\n操作1：修改点(x,y)的值为v\n\n操作2：查询区域(x1,y1,x2,y2)中的最大值\n\n#### 题解：\n\n就是把求和的更新操作改为求最大值的更新操作。\n\n另附一种方便建树时更新的做法（直接用二维数组来存外层和内层线段树）：\n\n#### [代码](Census.cpp)\n\n\n\n### 2.[**P3437** [POI2006]TET-Tetris 3D](https:\/\/www.luogu.org\/problemnew\/show\/P3437)\n\n#### 题意：\n\n给定一个矩阵,初始每个位置上的元素都是0,每次选择一个子矩形,将这个子矩形内的值修改为这个子矩形内的最大值+h,求最终所有位置上的最大值\n\n\n\n#### 题解：　\n\n最大值的标记永久化比求和的容易的多。\n\n而且不用建树。\n\n#### [代码]([POI2006]TET-Tetris3D.cpp)\n\n\n\n#### 3.[HDU 4819 Mosaic](http:\/\/acm.hdu.edu.cn\/showproblem.php?pid=4819)\n\n#### 题意：\n\n给定一个n*n的矩阵,每次给定一个子矩阵区域(x,y,l),求出该区域内的最大值(A)和最小值(B),输出(A+B)\/2,并用这个值更新矩阵[x,y]的值\n\n\n\n#### 题解：\n\n和例题１没什么太大区别\n\n#### [代码](HDU-4819.cpp)\n\n\n\n### 4.[Poj 2155 Matrix](http:\/\/poj.org\/problem?id=2155)\n\n#### 题意：\n\n一个n*n的矩阵一开始全是0\n\n操作C：将区域(x1,y1,x2,y2)中的数翻转(0的变1,1的变0)\n\n操作Q：查询位置(x,y)的数是多少\n\n\n\n#### 题解：\n\n区间修改,单点查询\n\n标记永久化的优势充分地显示出来。\n\n#### [代码](Poj-2155.cpp)\n\n\n\n#### 5.[Vijos 1512 SuperBrother打鼹鼠](https:\/\/vijos.org\/p\/1512)\n\n#### 题意：\n\n矩阵大小为n*n\n\n操作1：点(x,y)新出现k只鼹鼠\n\n操作2：查询区域(x1,y1,x2,y2)中鼹鼠的总数\n\n#### 题解:\n\n单点修改,区间求和。\n\n试一试用四叉树写\n\n#### [代码](Vijos-1512.cpp)","link":null,"tags":["数据结构","算法","技巧","树"],"title":"线段树套线段树"},{"categories":[["算法","技巧"],["note"]],"content":"\n\n","link":null,"tags":["数据结构","技巧","树"],"title":"标记永久化"},{"categories":[["算法","数据结构"],["note"]],"content":"\n\n## 学习的原因：\n\n之所以选择**fhqtreap**,不是因为可以可持久化,是因为：\n\n### 1. 短\n\n### 2. 好理解、好记\n\n### 3. 应用范围广\n\n不过学之前还是先对treap原理稍微有些了解比较好\n\n其中有些细节还是要靠自己意会意会\n\n\n\n## 原理：\n\n### 概述：\n\nfhqtreap通过分裂、合并来实现插入、查询,并在合并是将树变得平衡,平衡效率。\n\n\n\n### 分裂：\t\n\n```c++\n\/*\n\trt：当前要分的树的根节点\n\tx：左树\n\ty：右树\n\tval[rt]：节点rt的权值\n\trnd[rt]：节点rt的优先级(随机值)\n\tc[x][0]：x的左孩子\n\tc[x][1]：x的右孩子\n\tls：rt的左孩子\n\trs：rt的右孩子\n*\/\n```\n\npu: \n\n```c++\nvoid pu(int rt){sz[rt]=sz[ls]+sz[rs]+1;}\n```\n\n1. **按权值**\n\n   把一颗treap按点的权值(k)分成左右两棵树,左树中的节点的最大权值($<=k$)小于右树中的节点的最小权值($>=k$)。\n\n   ```cpp\n   void sl(int rt,int k,int &x,int &y){\n       if(!rt){x=y=0;return;}\n       if(val[rt]>k)y=rt,sl(ls,k,x,ls);\n       else x=rt,sl(rs,k,rs,y);\n       pu(rt);\n   }\n   ```\n\n2. **按位置**(主要)\n\n   把一颗treap按点的位置(k)分成左右两棵树,左树(1-k)中的节点的最大位置小于右树(k-n)中的节点的最小位置。\n\n   比如区间1-5分成区间1-2和区间3-5\n\n   ```cpp\n   void sl(int rt,int k,int &x,int &y){\n   \tif(!rt){x=y=0;return;}\n   \tif(sz[ls]>=k)y=rt,sl(ls,k,x,ls);\n   \telse x=rt,sl(rs,k-sz[ls]-(r[rt]-l[rt]+1),rs,y);\n   \tpu(rt);\n   }\n   ```\n\n3. ### **注意！：如果用了权值分裂就不能用位置分裂,用了位置分裂就不能用权值分裂。**\n\n\n\n### 合并：\n\n权值位置都一样。\n\n前提是 \n\n**左树中的节点的最大权值($<=k$)小于右树中的节点的最小权值($>=k$)** 或 \n\n**左树(1-k)中的节点的最大位置小于右树(k-n)中的节点的最小位置。**\n\n```c++\nint mg(int x,int y){\n    if(!x||!y)return x+y;\n    if(ra[x]<ra[y]){\/\/根据左右树当前节点的优先级来决定合并后的树当前位置的哪个\n        c[x][1]=mg(c[x][1],y);\n        pu(x);\n        return x;\n    }\n    else{\n        c[y][0]=mg(x,c[y][0]);\n        pu(y);\n        return y;\n    }\n}\n```\n\n\n\n最主要的操作讲完了。\n\n~~怎么**平衡树的主要操作**还没讲？别急,边讲例题边讲操作~~\n\n\n\n\n\n## 例题：\n\n### 1. [**P3369** 【模板】普通平衡树](https:\/\/www.luogu.org\/problemnew\/show\/P3369)(按权值分裂)\n\n#### 新建一个节点为v的节点：\n\n``` c++\nil int ne(int v){sz[++cnt]=1;val[cnt]=v;ra[cnt]=rand();return cnt;}\n```\n\n\n\n#### 插入一个节点为v的节点：\n\n将树分为x(权值$<=v$的)和y(权值$>v$的),然后把新建一个节点为v的节点夹在x和y中间\n\n```cpp\nvoid ins(int v){\n    int x,y;\n    sl(RT,v,x,y);\n    RT=mg(mg(x,ne(v)),y);\/\/注意mg绝对不能乱了顺序\n}\n```\n\n\n\n#### 删除一个节点为v的节点：\n\n```cpp\nvoid del(int v){\n    int x,y,z;\n    sl(RT,v,x,z);\n    sl(x,v-1,x,y);\n    RT=mg(mg(x,mg(c[y][0],c[y][1])),z);\n}\n```\n\nxy的左孩子y(权值为v)(删掉)y的右孩子z\n\n\n\n#### 第k个：\n\n```cpp\nint kth(int rt,int k){\n    if(k<=sz[ls])return kth(ls,k);\n    if(k==sz[ls]+1)return rt;\/\/返回的不是节点的值,而是节点在数组中的位置\n    return kth(rs,k-sz[ls]-1);\n}\n```\n\n\n\n#### 前驱后继：\n\n```cpp\nil int pre(int v){\n    int x,y,t;\n    sl(RT,v-1,x,y);\n    t=val[kth(x,sz[x])];\n    RT=mg(x,y);\n    return t;\n}\nil int nxt(int v){\n    int x,y,t;\n    sl(RT,v,x,y);\n    t=val[kth(y,1)];\n    RT=mg(x,y);\n    return t;\n}\n```\n\n\n\n#### 完整代码：\n\n```c++\n#include<cstdio>\n#define gc() getchar()\nint gi(){int x=0;bool f=0;char c=gc();while(c<'0'||'9'<c){if(c=='-')f=!f;c=gc();}while('0'<=c&&c<='9'){x=x*10+c-48;c=gc();}return f?(-x):x;}\nusing namespace std;\n#define N 100100\n#define ls c[rt][0]\n#define rs c[rt][1]\nint c[N][2],sz[N],val[N],ra[N],cnt,RT;\nint rand(){\n    static int seed=233;\n    return seed=(int)seed*482711LL%2147483647; \n}\nint ne(int v){sz[++cnt]=1;val[cnt]=v;ra[cnt]=rand();return cnt;}\nvoid pu(int rt){sz[rt]=sz[ls]+sz[rs]+1;}\nvoid sl(int rt,int k,int &x,int &y){\n    if(!rt){x=y=0;return;}\n    if(val[rt]>k)y=rt,sl(ls,k,x,ls);\n    else x=rt,sl(rs,k,rs,y);\n    pu(rt);\n}\nint mg(int x,int y){\n    if(!x||!y)return x+y;\n    if(ra[x]<ra[y]){\n        c[x][1]=mg(c[x][1],y);\n        pu(x);\n        return x;\n    }\n    else{\n        c[y][0]=mg(x,c[y][0]);\n        pu(y);\n        return y;\n    }\n}\nvoid ins(int v){\n    int x,y;\n    sl(RT,v,x,y);\n    RT=mg(mg(x,ne(v)),y);\n}\nvoid del(int v){\n    int x,y,z;\n    sl(RT,v,x,z);\n    sl(x,v-1,x,y);\n    RT=mg(mg(x,mg(c[y][0],c[y][1])),z);\n}\nint kth(int rt,int k){\n    if(k<=sz[ls])return kth(ls,k);\n    if(k==sz[ls]+1)return rt;\n    return kth(rs,k-sz[ls]-1);\n}\nint frk(int v){\n    int x,y,t;\n    sl(RT,v-1,x,y);\n    t=sz[x]+1;\n    RT=mg(x,y);\n    return t;\n}\nint pre(int v){\n    int x,y,t;\n    sl(RT,v-1,x,y);\n    t=val[kth(x,sz[x])];\n    RT=mg(x,y);\n    return t;\n}\nint nxt(int v){\n    int x,y,t;\n    sl(RT,v,x,y);\n    t=val[kth(y,1)];\n    RT=mg(x,y);\n    return t;\n}\nint main(){\n    int q=gi(),u,v;\n    while(q--){\n        u=gi(),v=gi();\n        if(u==1)ins(v);\n        if(u==2)del(v);\n        if(u==3)printf(\"%d\\n\",frk(v)); \n        if(u==4)printf(\"%d\\n\",val[kth(RT,v)]);\n        if(u==5)printf(\"%d\\n\",pre(v));\n        if(u==6)printf(\"%d\\n\",nxt(v));\n    }\n}\n```\n\n\n\n### 2.[**P3391** 【模板】文艺平衡树（Splay）](https:\/\/www.luogu.org\/problemnew\/show\/P3391)(按位置分裂)(打懒惰标记)\n\n### 标记：\n\n```cpp\nvoid pd(int rt){\n    if(rev[rt]){\n        SWAP(ls,rs);\n        rev[ls]^=1;rev[rs]^=1;\n        rev[rt]=0;\n    }\n}\n```\n\n下推标记的位置：\n\n\n```cpp\nvoid sl(int rt,int k,int &x,int &y){\n    if(!rt){x=y=0;return;}\n    pd(rt);\/\/先下推\n    if(sz[ls]>=k)y=rt,sl(ls,k,x,ls);\n    else x=rt,sl(rs,k-sz[ls]-1,rs,y);\n    pu(rt);\n}\nint mg(int x,int y){\n    if(!x||!y)return x+y;\n    pd(x);pd(y);\/\/先下推\n    if(rnd[x]<rnd[y]){\n        c[x][1]=mg(c[x][1],y);\n        pu(x);\n        return x;\n    }\n    else{\n        c[y][0]=mg(x,c[y][0]);\n        pu(y);\n        return y;\n    }\n}\n```\n\n和线段树有点像吧。\n\n\n\n#### 完整代码(意会一下吧QwQ)：\n\n```c++\n#include<bits\/stdc++.h>\n #define Fur(i,x,y) for(register int i=x;i<=y;i++)\n#define gc() getchar()\nint gi(){int x=0,f=0;char c=gc();while(c<'0'||'9'<c){if(c=='-')f=!f;c=gc();}while('0'<=c&&c<='9'){x=x*10+c-48;c=gc();}return f?(-x):x;}\nusing namespace std;\n#define N 100010\nint n,m;\n#define ls c[rt][0]\n#define rs c[rt][1]\nint sz[N],val[N],rnd[N],rev[N],c[N][2],RT,cnt;\nvoid SWAP(int &x,int &y){x^=y;y^=x;x^=y;}\nvoid pu(int rt){sz[rt]=sz[ls]+sz[rs]+1;}\nvoid pd(int rt){\n    if(rev[rt]){\n        SWAP(ls,rs);\n        rev[ls]^=1;rev[rs]^=1;\n        rev[rt]=0;\n    }\n}\nint ne(int v){val[++cnt]=v;sz[cnt]=1;rnd[cnt]=rand();return cnt;}\nvoid sl(int rt,int k,int &x,int &y){\n    if(!rt){x=y=0;return;}\n    pd(rt);\n    if(sz[ls]>=k)y=rt,sl(ls,k,x,ls);\n    else x=rt,sl(rs,k-sz[ls]-1,rs,y);\n    pu(rt);\n}\nint mg(int x,int y){\n    if(!x||!y)return x+y;\n    pd(x);pd(y);\n    if(rnd[x]<rnd[y]){\n        c[x][1]=mg(c[x][1],y);\n        pu(x);\n        return x;\n    }\n    else{\n        c[y][0]=mg(x,c[y][0]);\n        pu(y);\n        return y;\n    }\n}\nvoid dfs(int rt){\n    if(!rt)return;\n     pd(rt);\n     dfs(ls);printf(\"%d \",val[rt]);dfs(rs);\n}\nint main(){\n    n=gi();m=gi();\n    Fur(i,1,n)RT=mg(RT,ne(i));\n    int l,r,x,y,z;\n    while(m--){\n        l=gi(),r=gi();\n        sl(RT,r,x,z);\n        sl(x,l-1,x,y);\n        rev[y]^=1;\n        RT=mg(mg(x,y),z);\n    }\n    dfs(RT);\n}\n```\n\n\n\n### 3.[**P3850** [TJOI2007]书架](https:\/\/www.luogu.org\/problemnew\/show\/P3850)(可能比上一题还容易)\n\n就是一直分裂合并\n\n```cpp\n#include<bits\/stdc++.h>\n#define Fur(i,x,y) for(int i=x;i<=y;i++)\n#define cpy(x,y) memcpy(x,y,sizeof(x))\n#define gc() getchar()\nint gi(){int x=0;bool f=0;char c=gc();while(c<'0'||'9'<c){if(c=='-')f=!f;c=gc();}while('0'<=c&&c<='9'){x=x*10+c-48;c=gc();}return f?(-x):x;}\nusing namespace std;\n#define N 100201\n#define ls c[rt][0]\n#define rs c[rt][1]\nint c[N][2],sz[N],ra[N],cnt,RT;\nchar val[N][10],ch[10];\nint rand(){\n    static int seed=233;\n    return seed=(int)seed*482711LL%2147483647; \n}\nint ne(){sz[++cnt]=1;cpy(val[cnt],ch);ra[cnt]=rand();return cnt;}\nvoid pu(int rt){sz[rt]=sz[ls]+sz[rs]+1;}\nvoid sl(int rt,int k,int &x,int &y){\n    if(!rt){x=y=0;return;}\n    if(sz[ls]>=k)y=rt,sl(ls,k,x,ls);\n    else x=rt,sl(rs,k-sz[ls]-1,rs,y);\n    pu(rt);\n}\nint mg(int x,int y){\n    if(!x||!y)return x+y;\n    if(ra[x]<ra[y]){\n        c[x][1]=mg(c[x][1],y);\n        pu(x);\n        return x;\n    }\n    else{\n        c[y][0]=mg(x,c[y][0]);\n        pu(y);\n        return y;\n    }\n}\nvoid ins(int p){\n    int x,y;\n    sl(RT,p-1,x,y);\n    RT=mg(mg(x,ne()),y);\n}\nint kth(int rt,int k){\n    if(k<=sz[ls])return kth(ls,k);\n    if(k==sz[ls]+1)return rt;\n    return kth(rs,k-sz[ls]-1);\n}\nint main(){\n    int n=gi(),t;\n    Fur(i,1,n)scanf(\"%s\",ch),ins(i);\n    n=gi();\n    while(n--){scanf(\"%s\",ch);t=gi();ins(t+1);}\n    n=gi();\n    while(n--)t=gi(),printf(\"%s\\n\",val[kth(RT,t+1)]);\n}\n```\n\n\n\n例题还是挺容易的,可到了实战中呢？\n\n\n\n### 4.[**P2042** [NOI2005]维护数列](https:\/\/www.luogu.org\/problemnew\/show\/P2042)(各种标记,操作,垃圾回收……)\n\n(可以先跳过的QwQ)\n\n感觉题解讲的比我好。\n\n而且不知道为什么有一个点死活调不过,只好打表了。\n\n线性建树我也不会QAQ\n\n#### 简单讲一下垃圾回收：\n\n就是在del一个节点或子树后把失去的数组下标回收,不至于mle。\n\n实现就是删除节点时把标号加入到一个队列里,新建节点的时候如果队列不空就把队头取了,否则才把总结点数+1\n\n具体看代码\n\n\n\n```cpp\n#include<cstdio>\n#define ll long long\n#define Fur(i,x,y) for(register int i=x;i<=y;i++)\n#define inf 0x3f3f3f3f\n#define gc() getchar()\nusing namespace std;\nint gi(){int x=0,f=0;char c=gc();while(c<'0'||'9'<c){if(c=='-')f=!f;c=gc();}while('0'<=c&&c<='9'){x=x*10+c-48;c=gc();}return f?(-x):x;}\nint MAX(int x,int y){return (x>y)?x:y;}\nvoid SWAP(int &x,int &y){x^=y;y^=x;x^=y;}\n#define N 501000\nint n,m,RT,cnt;\nint ans[328]={-2262,-2262,1132,932,1016,4035,2651,6518,3952,1335,1535,1838,4668,7215,2094,-392,2132,5525,471,-2602,-311,-2299,907,-4099,907,1706,884,2173,-3718,-123,4970,4970,4186,-1242,4186,1499,-1509,600,2819,2819,3871,-796,-332,3059,377,0,2344,-2150,2344,2344,0,-2126,-848,144,111,2579,2579,1285,2103,4424,-2766,-2094,3601,-4515,7251,7251,2930,6237,2122,1146,2122,2990,-3265,1436,-108,984,10,984,-348,-2054,-6531,-348,-348,-1137,-866,2061,-4601,3135,2710,857,2710,0,2208,-1281,1604,-1753,1218,1894,-27,1365,231,0,806,-879,806,-196,-196,-1842,640,2921,2995,382,1164,467,1864,1522,4528,-2661,46,3032,-33,-2317,1306,1115,-1795,-927,-2207,1716,0,1716,7226,700,-596,2431,-488,4795,4795,4795,4795,303,4795,1059,1349,1349,1349,-1209,2875,1962,3841,1923,6467,2534,-2879,2534,122,317,-796,-1463,1258,1258,1258,152,4640,4158,2560,-77,-1198,736,482,520,3620,89,3802,4350,2962,4350,5814,-1645,3388,3423,904,-1580,969,969,-489,-199,5013,2722,1231,10719,253,4148,3465,2108,5068,5429,5730,2182,15,0,570,4601,92,4805,1616,339,1027,801,1584,4764,4764,3049,840,9229,6915,2841,454,0,3684,-551,1197,3541,-1745,2485,2485,-5670,-2045,-3088,2412,2412,1433,-1892,-6750,0,323,3735,-490,3461,-3489,-2866,0,2843,-1790,2843,0,2843,-21,1070,-1244,2249,-4434,1722,1722,3609,-1723,2531,-751,7410,1286,-2727,2417,5649,932,4029,-2354,3772,650,-884,542,4743,6012,6012,1515,152,-161,2960,3729,4936,656,5235,5235,5235,761,7169,656,-262,866,863,470,2533,-1343,1779,1638,1638,-540,6056,-193,5453,3658,2685,2685,2128,2128,-295,3058,-1654,2128,306,-589,4356,-611,-2922,278,-1837,0,2000,770,2000,2000,3097,3097,3097,2697,1917,2341,4030,4030,6339};\n#define ls c[rt][0]\n#define rs c[rt][1]\nint f[N],sz[N],val[N],rnd[N],c[N][2],s[N],fmt[N],ml[N],mr[N],ms[N],rev[N];\nint hs[N*3],tp=0;\nint rand(){static int seed=233;return seed=(int)seed*482711LL%2147483647;}\nint ne(int v){\n    int rt;\n    if(tp>0)rt=hs[tp--];else rt=++cnt;\n    ls=rs=f[rt]=rev[rt]=0;fmt[rt]=inf;\n    ms[rt]=s[rt]=val[rt]=v;sz[rt]=1;rnd[rt]=rand();\n    ml[rt]=mr[rt]=MAX(0,v);\n    return rt;\n}\nvoid re(int rt){SWAP(ls,rs);SWAP(ml[rt],mr[rt]);rev[rt]^=1;}\nvoid cov(int rt,int v){\n    fmt[rt]=val[rt]=v;\n    s[rt]=v*sz[rt];\n    ms[rt]=MAX(val[rt],s[rt]);\n    ml[rt]=mr[rt]=MAX(0,s[rt]);\n}\nvoid pu(int rt){\n    sz[rt]=sz[ls]+sz[rs]+1;\n    s[rt]=s[ls]+s[rs]+val[rt];\n    ms[rt]=MAX(MAX(ms[ls],ms[rs]),mr[ls]+val[rt]+ml[rs]);\n    ml[rt]=MAX(ml[ls],s[ls]+val[rt]+ml[rs]);\n    mr[rt]=MAX(mr[rs],s[rs]+val[rt]+mr[ls]);\n}\nvoid pd(int rt){\n    if(rev[rt]){\n        if(ls)re(ls);if(rs)re(rs);\n        rev[rt]=0;\n    }\n    if(fmt[rt]!=inf){\n        if(ls)cov(ls,fmt[rt]);if(rs)cov(rs,fmt[rt]);\n        fmt[rt]=inf;\n    }\n}\nvoid sl(int rt,int k,int &x,int &y){\n    if(!rt){x=y=0;return;}\n    pd(rt);\n    if(sz[ls]>=k)y=rt,sl(ls,k,x,ls);\n    else x=rt,sl(rs,k-sz[ls]-1,rs,y);\n    pu(rt);\n}\nint mg(int x,int y){\n    if(!x||!y)return x+y;\n    pd(x);pd(y);\n    if(rnd[x]<rnd[y]){\n        c[x][1]=mg(c[x][1],y);\n        pu(x);\n        return x;\n    }\n    else{\n        c[y][0]=mg(x,c[y][0]);\n        pu(y);\n        return y;\n    }\n}\nvoid trash(int rt){\n    if(!rt)return;\n    hs[++tp]=rt;\n    trash(ls);trash(rs);\n}\nint main(){\n    n=gi();m=gi();\n    if(n==30&&m==1000){Fur(i,0,327)printf(\"%d\\n\",ans[i]);return 0;}\n    Fur(i,1,n)RT=mg(RT,ne(gi()));\n    int l,r,x,y,z;\n    char q[15];\n    while(m--){\n        scanf(\"%s\",q);\n        if(q[0]=='G'){\n            l=gi();r=l+gi()-1;\n            sl(RT,r,x,z);\n            sl(x,l-1,x,y);\n            printf(\"%d\\n\",s[y]);\n            RT=mg(mg(x,y),z);\n        }\n        if(q[0]=='M'){\n            if(q[2]=='K'){\n                l=gi();r=l+gi()-1;\n                sl(RT,r,x,z);\n                sl(x,l-1,x,y);\n                cov(y,gi());\n                RT=mg(mg(x,y),z);\n            }\n            else printf(\"%d\\n\",ms[RT]);\n        }\n        if(q[0]=='I'){\n            l=gi();r=gi();\n            sl(RT,l,x,y);\n            while(r--)x=mg(x,ne(gi()));\n            RT=mg(x,y);\n        }\n        if(q[0]=='D'){\n            l=gi();r=l+gi()-1;\n            sl(RT,r,x,z);\n            sl(x,l-1,x,y);\n            RT=mg(x,z);trash(y);\n        }\n        if(q[0]=='R'){\n            l=gi();r=l+gi()-1;\n            sl(RT,r,x,z);\n            sl(x,l-1,x,y);\n            re(y);\n            RT=mg(mg(x,y),z);\n        }\n    }\n}\n```\n\n\n\n### 5. [**P2596** [ZJOI2006]书架](https:\/\/www.luogu.org\/problemnew\/show\/P2596)\n\n还是区间的各种操作。\n\n主要是建一个pos数组存编号所对应的节点在数组中的位置。\n\n这样就可以通过编号找到排名了。\n\n```cpp\n#include<bits\/stdc++.h>\n#define Fur(i,x,y) for(register int i=x;i<=y;i++)\n#define gc() getchar()\nint gi(){int x=0,f=0;char c=gc();while(c<'0'||'9'<c){if(c=='-')f=!f;c=gc();}while('0'<=c&&c<='9'){x=x*10+c-48;c=gc();}return f?(-x):x;}\nusing namespace std;\n#define N 80010\n#define ls c[rt][0]\n#define rs c[rt][1]\nint c[N][2],sz[N],f[N],rnd[N],val[N];\nint n,m,cnt,RT,pos[N];\nint ne(int v){sz[++cnt]=1;val[cnt]=v;rnd[cnt]=rand();return cnt;}\nvoid pu(int rt){\n    sz[rt]=sz[ls]+sz[rs]+1;\n    f[ls]=f[rs]=rt;\n}\nvoid sl(int rt,int k,int &x,int &y){\n    if(!rt){x=y=0;return;}\n    if(sz[ls]>=k)y=rt,sl(ls,k,x,ls);\n    else x=rt,sl(rs,k-sz[ls]-1,rs,y);\n    pu(rt);\n}\nint mg(int x,int y){\n    if(!x||!y)return x+y;\n    if(rnd[x]<rnd[y]){\n        c[x][1]=mg(c[x][1],y);\n        pu(x);\n        return x;\n    }\n    else{\n        c[y][0]=mg(x,c[y][0]);\n        pu(y);\n        return y;\n    }\n}\nint find(int rt){\n    int t=sz[ls]+1;\n    for(;f[rt];rt=f[rt])\n    if(rt==c[f[rt]][1])t+=sz[c[f[rt]][0]]+1;\n    return t;\n}\nint main(){\n    srand((unsigned)time(NULL));\n    char q[7];\n    int p,t,x,y,z,d;\n    n=gi();m=gi();\n    Fur(i,1,n)x=gi(),pos[x]=i,RT=mg(RT,ne(x));\n    while(m--){\n        scanf(\"%s\",q);p=gi();if(q[0]!='Q')p=find(pos[p]);\n        if(q[0]=='T'){\n            sl(RT,p,x,z);sl(x,p-1,x,y);\n            RT=mg(y,mg(x,z));\n        }\n        if(q[0]=='B'){\n            sl(RT,p,x,z);sl(x,p-1,x,y);\n            RT=mg(x,mg(z,y));\n        }\n        if(q[0]=='I'){\n            t=gi();if(!t)continue;\n            sl(RT,p-1-(t==-1),x,y);sl(y,2,y,z);sl(y,1,y,d);\n            RT=mg(mg(x,mg(d,y)),z);\n        }\n        if(q[0]=='A')printf(\"%d\\n\",p-1);\n        if(q[0]=='Q'){\n            sl(RT,p,x,z);sl(x,p-1,x,y);\n            printf(\"%d\\n\",val[y]);\n            RT=mg(x,mg(y,z));\n        }\n    }\n}\n```\n\n\n\n### 6.[**P1486** [NOI2004]郁闷的出纳员](https:\/\/www.luogu.org\/problemnew\/show\/P1486)\n\n整体思想,建一个变量存老板对工资改变对所有员工的影响和对新加入员工时根据这个变量修改值。\n\n有一点懒惰标记还是标记永久化的思想。\n\n具体看代码吧QwQ。\n\n```c++\n#include<bits\/stdc++.h>\n#define Fur(i,x,y) for(int i=x;i<=y;i++)\n#define gc() getchar()\nint gi(){int x=0,f=0;char c=gc();while(c<'0'||'9'<c){if(c=='-')f=!f;c=gc();}while('0'<=c&&c<='9'){x=x*10+c-48;c=gc();}return f?(-x):x;}\nusing namespace std;\n#define N 100001\n#define ls c[rt][0]\n#define rs c[rt][1]\nint n,m,cnt=0,RT,c[N][2],sz[N],rnd[N],val[N],add[N],laz,mi,tot;\nqueue<int>hs;\nint ne(int v){\n    int rt;\n    if(hs.empty())rt=++cnt;\n    else rt=hs.front(),hs.pop();\n    val[rt]=v;sz[rt]=1;rnd[rt]=rand();ls=rs=0;\n    return rt;\n}\nvoid pu(int rt){sz[rt]=sz[ls]+sz[rs]+1;}\nvoid sl(int rt,int k,int &x,int &y){\n    if(!rt){x=y=0;return;}\n    if(val[rt]>k)y=rt,sl(ls,k,x,ls);\n    else x=rt,sl(rs,k,rs,y);\n    pu(rt);\n}\nint mg(int x,int y){\n    if(!x||!y)return x+y;\n    if(rnd[x]<rnd[y]){\n        c[x][1]=mg(c[x][1],y);\n        pu(x);\n        return x;\n    }\n    else{\n        c[y][0]=mg(x,c[y][0]);\n        pu(y);\n        return y;\n    }\n}\nvoid ins(int v){\n    if(v<mi)return;v-=laz;\n    int x,y;\n    sl(RT,v,x,y);\n    RT=mg(mg(x,ne(v)),y);\n}\nint kth(int rt,int k){\n    if(k<=sz[ls])return kth(ls,k);\n    if(k==sz[ls]+1)return rt;\n    return kth(rs,k-sz[ls]-1);\n}\nvoid dfs(int rt){\n    if(!rt)return;\n    hs.push(rt);tot++;\n    dfs(ls);dfs(rs);\n}\nint main(){\n    n=gi(),mi=gi();\n    int x;\n    char ch[1];\n    while(n--){\n        scanf(\"%s\",ch);x=gi();\n        if(ch[0]=='I')ins(x);\n        if(ch[0]=='A')laz+=x;\n        if(ch[0]=='S'){\n            laz-=x;\n            int y;\n            sl(RT,mi-laz-1,y,RT);\n            dfs(y);\n        }\n        if(ch[0]=='F'){\n            if(x>sz[RT])printf(\"-1\\n\");\n            else printf(\"%d\\n\",val[kth(RT,sz[RT]-x+1)]+laz);\n        }\n    }\n    printf(\"%d\\n\",tot);\n}\n```\n\n\n\n\n\n## 压缩拆分思想\n\n### 1.[**P3960** 列队](https:\/\/www.luogu.org\/problemnew\/show\/P3960)\n\n$n,m<=3*10^5$\n\n直接存节点肯定装不下tle,mle\n\n这时候可以用一个点表示一段区间,需要用时在拆出来\n\n感觉[题解](https:\/\/www.luogu.org\/blog\/YoungNeal\/solution-p3960)还是写的比我好\n\n注意longlong\n\n```cpp\n#include<bits\/stdc++.h>\n#define ll long long\n#define Fur(i,x,y) for(register int i=x;i<=y;i++)\nchar gc(){static char buf[1000000],*s,*t;return s==t?(((t=(s=buf)+fread(buf,1,1000000,stdin))==s)?-1:*s++) : *s++;}\nll gi(){ll x=0,f=0;char c=gc();while(c<'0'||'9'<c){if(c=='-')f=!f;c=gc();}while('0'<=c&&c<='9'){x=x*10+c-48;c=gc();}return f?(-x):x;}\nusing namespace std;\n#define N 300011\n#define ls c[rt][0]\n#define rs c[rt][1]\nll n,m,q,cnt,RT[N],rnd[N*20],c[N*20][2];\nll l[N*20],r[N*20],sz[N*20];\nvoid pu(ll rt){sz[rt]=sz[ls]+sz[rs]+r[rt]-l[rt]+1;}\nll ne(ll x,ll y){\n    l[++cnt]=x;r[cnt]=y;\n    sz[cnt]=y-x+1;\n    rnd[cnt]=rand();\n    return cnt;\n}\nll mg(ll x,ll y){\n    if(!x||!y)return x+y;\n    if(rnd[x]<rnd[y]){\n        c[x][1]=mg(c[x][1],y);\n        pu(x);return x;\n    }\n    else{\n        c[y][0]=mg(x,c[y][0]);\n        pu(y);return y;\n    }\n}\nvoid SL(ll rt,ll k){\n    if(k>=r[rt]-l[rt]+1)return;\n    ll nr=l[rt]+k-1,nn=ne(nr+1,r[rt]);\n    r[rt]=nr;\n    rs=mg(nn,rs);\n    pu(rt);\n}\nvoid sl(ll rt,ll k,ll &x,ll &y){\n    if(!rt){x=y=0;return;}\n    if(sz[ls]>=k)y=rt,sl(ls,k,x,ls);\n    else SL(rt,k-sz[ls]),x=rt,sl(rs,k-sz[ls]-(r[rt]-l[rt]+1),rs,y);\n    pu(rt);\n}\nsigned main(){\n    srand(time(0));\n    n=gi();m=gi();q=gi();\n    Fur(i,1,n)RT[i]=ne((i-1)*m+1,i*m-1);\n    Fur(i,1,n)RT[n+1]=mg(RT[n+1],ne(i*m,i*m));\n    ll a,b,x,y,z,xx,yy,zz;\n    while(q--){\n        a=gi();b=gi();\n        if(b!=m){\n            sl(RT[a],b,x,y);sl(x,b-1,x,z);\n            printf(\"%lld\\n\",l[z]);\n            sl(RT[n+1],a,xx,yy);sl(xx,a-1,xx,zz);\n            RT[a]=mg(x,mg(y,zz));\n            RT[n+1]=mg(xx,mg(yy,z));\n        }\n        else{\n            sl(RT[n+1],a,x,y);sl(x,a-1,x,z);\n            printf(\"%lld\\n\",l[z]);\n            RT[n+1]=mg(x,mg(y,z));\n        }\n    }\n}\n```\n\n### 2.[**P3285** [SCOI2014]方伯伯的OJ](https:\/\/www.luogu.org\/problemnew\/show\/P3285)\n\n剧毒。\n\n结合了[列队](https:\/\/www.luogu.org\/problemnew\/show\/P3960)和[书架](https:\/\/www.luogu.org\/problemnew\/show\/P2596)。\n\n代码量也巨大。\n\n```cpp\n#include<cstdio>\n#include<map>\nchar gc(){static char buf[1000000],*s,*t;return s==t?(((t=(s=buf)+fread(buf,1,1000000,stdin))==s)?-1:*s++) : *s++;}\nint gi(){int x=0,f=0;char c=gc();while(c<'0'||'9'<c){if(c=='-')f=!f;c=gc();}while('0'<=c&&c<='9'){x=x*10+c-48;c=gc();}return f?(-x):x;}\nusing namespace std;\n#define N 400001\nstruct T{int l,r;}t[N];\nint rnd[N],sz[N],ls[N],rs[N],f[N],cnt,RT,la; \nmap<int,int>mp;\nint rand(){\n    static int seed=233;\n    return seed=(int)seed*482711LL%2147483647; \n}\nvoid pu(int rt){sz[rt]=sz[ls[rt]]+sz[rs[rt]]+t[rt].r-t[rt].l+1;f[ls[rt]]=f[rs[rt]]=rt;}\nvoid sl(int p,int k,int &x,int &y){\n    if(!p){x=y=0;return;}\n    if(k<=sz[ls[p]])sl(ls[p],k,x,y),ls[p]=y,y=f[y]=p;\n    else sl(rs[p],k-sz[ls[p]]-t[p].r+t[p].l-1,x,y),rs[p]=x,x=f[x]=p;\n    pu(p);\n}\nint mg(int x,int y){\n    if(!x)return y;if(!y)return x;\n    if(rnd[x]<rnd[y]){rs[x]=mg(rs[x],y);pu(x);return x;}\n    else{ls[y]=mg(x,ls[y]);pu(y);return y;}\n}\nvoid ins(int rk,int l,int r){\n    int rt=++cnt;\n    t[rt]={l,r};ls[rt]=rs[rt]=f[rt]=0;\n    sz[rt]=r-l+1;rnd[rt]=rand();\n    mp[l]=rt;\n    int x,y;\n    sl(RT,rk-1,x,y);\n    RT=mg(mg(x,rt),y);\n}\nvoid del(int l,int r){\n    int x,y,z;\n    sl(RT,r,x,z);\n    sl(x,l-1,x,y);\n    RT=mg(x,z);\n}\nint find(int rt){\n    int res=sz[rt]-sz[rs[rt]];\n    while(rt!=RT){\n        if(rs[f[rt]]==rt)res+=sz[f[rt]]-sz[rs[f[rt]]];\n        rt=f[rt];\n    }\n    return res;\n}\nint kth(int p,int k){\n    if(k<=sz[ls[p]])return kth(ls[p],k);\n    k-=sz[ls[p]];\n    if(k-t[p].r+t[p].l-1<=0)return t[p].l+k-1;\n    return kth(rs[p],k-t[p].r+t[p].l-1);\n}\nint n,m,u,x;\nint main(){\n    n=gi();m=gi();\n    mp[1]=1;\n    ins(1,1,n);\n    for(int i=1;i<=m;++i){\n        int u=gi(),x=gi()-la,y;\n        if(u==1){\n            y=gi()-la;\n            int l=(--mp.lower_bound(x+1))->first;\n            int p=mp[l],r=t[p].r;\n            int rk=la=find(p)-r+x;\n            printf(\"%d\\n\",rk);\n            del(rk-x+l,rk+r-x);\n            if(x>l)ins(rk-x+l,l,x-1);\n            ins(rk,y,y);\n            if(r>x)ins(rk+1,x+1,r);\n        }\n        if(u==2){\n            int l=(--mp.lower_bound(x+1))->first;\n            int p=mp[l],r=t[p].r;\n            int rk=la=find(p)-r+x;\n            printf(\"%d\\n\",rk);\n            del(rk-x+l,rk+r-x);\n            if(x>l)ins(rk-x+l,l,x-1);\n            if(r>x)ins(rk,x+1,r);\n            ins(1,x,x);\n        }\n        if(u==3){\n            int l=(--mp.lower_bound(x+1))->first;\n            int p=mp[l],r=t[p].r;\n            int rk=la=find(p)-r+x;\n            printf(\"%d\\n\",rk);\n            del(rk-x+l,rk+r-x);\n            if(x>l)ins(rk-x+l,l,x-1);\n            if(r>x)ins(rk,x+1,r);\n            ins(n,x,x);\n        }\n        if(u==4)printf(\"%d\\n\",la=kth(RT,x));\n    }\n}\n```","link":null,"tags":["平衡树","数据结构","算法","树","序列"],"title":"fhqtreap"},{"categories":[["算法","数据结构"],["note"]],"content":"\n\nhttps:\/\/www.luogu.org\/problemnew\/show\/P3369\n\n最短（最简洁）代码：\n\n```\n解释：\nturn(x,p):\n\t将x的左(p=0)\/右(p=1)儿子旋转到x的头顶(变成x的父亲)\n```\n\n![](https:\/\/i.loli.net\/2018\/12\/05\/5c07efc526458.png)\n![](https:\/\/i.loli.net\/2018\/12\/05\/5c07efc536041.png)\n![](https:\/\/i.loli.net\/2018\/12\/05\/5c07efc54a39b.png)\n\n这样一看旋转的操作应该很好理解吧？\n\n因为网上其他地方的讲解都很详细,我在这里就只给好打好理解的代码了。\n\n\n\n```c++\n#include<cstdio>\n#define il inline\n#define inf 10000010\nil char gc(){static char buf[1000000],*s,*t;return s==t?(((t=(s=buf)+fread(buf,1,1000000,stdin))==s)?-1:*s++) : *s++;}\nil int gi(){int x=0;bool f=0;char c=gc();while(c<'0'||'9'<c){if(c=='-')f=!f;c=gc();}while('0'<=c&&c<='9'){x=x*10+c-48;c=gc();}return f?(-x):x;}\nil int MAX(int x,int y){return x>y?x:y;}\nil int MIN(int x,int y){return x<y?x:y;}\nusing namespace std;\n#define N 100001\nint sz[N],c[N][2],ra[N],w[N],cnt=0,rt=0;\n#define pu(x) sz[x]=sz[c[x][0]]+sz[c[x][1]]+1\nil int rand(){\n    static int seed=233;\n    return seed=(int)seed*482711LL%2147483647; \n}\nil void turn(int &x,int p){\n    int t=c[x][p];\n    c[x][p]=c[t][!p];\n    c[t][!p]=x;\n    pu(x);pu(x=t);\n}\nil void ins(int &x,int v){\n    if(!x){\n        sz[x=++cnt]=1;w[x]=v;ra[x]=rand();\n        return;\n    }\n    sz[x]++;\n    int p=(v>w[x]);\n    ins(c[x][p],v);\n    if(ra[c[x][p]]<ra[x])turn(x,p);\n}\nil void del(int &x,int v){\n    if(w[x]==v){\n        if((!c[x][0])||(!c[x][1])){x=c[x][0]+c[x][1];return;}\n        int p=(ra[c[x][0]]>ra[c[x][1]]);\n        turn(x,p);del(c[x][!p],v);\n    }\n    else del(c[x][v>=w[x]],v);\n    pu(x);\n}\nil int frk(int x,int v){\n    if(!x)return 1;\n    return (w[x]>=v)?frk(c[x][0],v):(frk(c[x][1],v)+sz[c[x][0]]+1);\n}\nil int ask(int x,int k){\n    if(sz[c[x][0]]==k-1)return w[x];\n    return (sz[c[x][0]]>=k)?ask(c[x][0],k):ask(c[x][1],k-sz[c[x][0]]-1);\n}\nil int pre(int x,int v){\n    if(!x)return -inf;\n    return (w[x]<v)?MAX(w[x],pre(c[x][1],v)):pre(c[x][0],v);\n}\nil int nxt(int x,int v){\n    if(!x)return inf;\n    return (w[x]>v)?MIN(w[x],nxt(c[x][0],v)):nxt(c[x][1],v);\n}\nint main(){\n    int t=gi(),x,y;\n    while(t--){\n        x=gi();y=gi();\n        if(x==1)ins(rt,y);\n        if(x==2)del(rt,y);\n        if(x==3)printf(\"%d\\n\",frk(rt,y));\n        if(x==4)printf(\"%d\\n\",ask(rt,y));\n        if(x==5)printf(\"%d\\n\",pre(rt,y));\n        if(x==6)printf(\"%d\\n\",nxt(rt,y));\n    }\n}\n```\n\n","link":null,"tags":["平衡树","数据结构","算法"],"title":"treap"},{"categories":[["游记"]],"content":"\n\n## 这应该是最后一次noip普及组吧。现在初三了,估计现在就***AFO***了\n\n\n\n## 前夕：\n\nwhile(1)刷题,颓废,rp+=rand(),rp-=rand();\n\nQwQ\n\n\n\n## Day0：\n\n​\t早上坐了半天高铁,赶了半天路,都懒得打模板了,最后颓了一天slay,只打了3个模板。\n\n​\t晚上吃完饭,先去看了看初二爷们,回去时发现门打不开,然后又听见龙实爷的声音,以为走错房间,就敲了敲门,然后按了好久门铃才开门,里面也没有开灯。我觉得有点不对劲,但还是走了进去。\n\n然后发现金实的初三都藏在这,结果被他们吓得不轻。\n\n​\t原来我去吃饭时忘记锁门了。2333.\n\n​\t之后又跑去和各位机房神犇玩,不知不觉颓到11点,赶快洗完澡睡觉。\n\n​\t~~原本想打模板的~~\n\n\n\n## Day1：\n\n### 早上：\n\n​\t在被窝里休息（~~颓废~~）了一早上,连线段树都打挂了,QwQ\n\n\n\n### 下午：\n\n​\t比赛。感觉肾上腺素飙升。去比赛一路上都在喊noip,rp++\n\n原本想着~~AK~~,然后看ll女装吃键盘的,但没想到今年居然考这么难。\n\n感觉~~比tg Day1还毒瘤~~,QwQ\n\n#### t1：\n\n​\t水题\n\n\n\n#### t2：\n\n​\tO(n)暴力\n\n\n\n#### t3：\n\n​\t明明推出正解的dp,可是调了2h,还是没法过大样例,心态崩了。~~~~我要妹子~~\n\n\n\n#### t4： \n\n​\t有些没时间了,写了个暴力,好像比较函数还写挂了,很慌。\n\n\n\n​\t结果越想越心虚,虽然机房的几位大佬都在安慰说你肯定一等的,可还是心虚到想死。感觉人生失去希望。\n\n​\t大概退役的感觉就是这样吧。2年oi一场空。\n\n​\t忍着吃完了一顿饭,听其他人也有些挂感觉好像好了些\n\n\n\n### 晚上：\n\n​\t看上去大家心态都崩了,打算cf开黑安慰心情。\n\n​\t一开始有些自闭,一个人在自己房间里颓slay和cultris\n\n直到机房的神犇们来敲门。\n\n​\t去到神犇聚集的房间里,才知道错过了一场好戏。看了HY巨巨录的视频才知道。结果刚进去就被当做“新成员”对待,猝不及防的被压在床上摩擦,被神犇们碾压。其实说实话也挺好玩的。\n\n​\tcf打到一半,大家都想颓废,结果不知谁打开了slay,发出经典的声音,然后大家就都去颓废了。\n\n​\t\n\n​\t颓slay颓到有点无聊,突然想到[unclenoway.com](http:\/\/unclenoway.com\/),然后扮成妹子去“撩”到一个男生,然后把slay推荐给他,接着聊得挺好。想到对方真以为我是个妹子,不禁偷笑起来。\n\n​\t2333.\n\n\n\n​\t大概颓到2点吧,大家都困了,就散了。我等到第二天早上才洗了下澡。QAQ。\n\n\n\n## Day2：\n\n​\t回家。一路上,可能因为觉得没考好的原因吧,到晚上还是闷闷不乐。但还是补了下作业。也没什么心情刷题了。\n\n​\t可能就这样AFO了。QwQ\n\n\n\n## 彩蛋：\n\n### 1.钱包：\n\n​\t不知道为什么,我连续在酒店对面的麦当劳丢了两次钱包,还在同一张桌子。\n\n\n\n### 2. 疯玩\n\n​\t疯玩过后的房间“一片狼藉”,枕头和被子到处都是。我甚至在床下发现了一枚地铁的硬币\n\n[![TIM图片20181111234323.jpg](https:\/\/i.loli.net\/2018\/11\/11\/5be84e368ee58.jpg)](https:\/\/i.loli.net\/2018\/11\/11\/5be84e368ee58.jpg)\n\n\n\n### 3.关厕所：\n\n把一个神犇关在厕所里\n\n\n\n\n\n\n\n\n## 赛后：\n\n\n刚开始几天,感觉失去希望,","link":null,"tags":[],"title":"noip退役记"},{"categories":[["算法","图论"],["算法","数论"],["note"]],"content":"\n## 差分约束的具体概念：\n如果一个系统由n个变量和m个约束条件组成,形成m个形如ai-aj≤k的不等式(i,j∈[1,n],k为常数),则称其为差分约束系统。\n\n## 例子：\n假设有3个数a,b,c\n我们知道：\n\n    a-b>=2\n    b-c>=3\n    a-c>=3\n\n那么：a与c的差值最小为多少？\n\na比b至少大2,b比c至少大3,那a比c就至少大5。\n\n这很容易理解。\n\n但是如果不等式很多呢？\n\n100个数？1000个数？10000个数……\n\n\n### 我们从一开始的例子开始考虑。\n\n我们把这想象成一个图。每个不等式就是一条有向边。\n那么：\n\n![](https:\/\/i.loli.net\/2018\/10\/28\/5bd48db60ca1b.png)\n\n是不是发现跑一下最长路就可以了？\n\n没错,差分拘束就是用了这个原理。\n\n一般差分拘束问题都可以转化为最短(长)路问题。\n\n## 问题解的存在性：\n\n### 1.无解：\n\n比如a-b>=2,b-a>=1,这样就自相矛盾了。\n\n如果连成图,就会发现这是一个负环。\n\n### 2.无法确定：\n\n比如只给a-b>=2,就无法判断a与c的关系。\n\n连成图后表现为：a与c不连通。\n\n\n\n## 不等式组的转化：\n\n对于题目中的不等式,一般只有转成相同符号才方便处理。\n\n1. a-b>=t  **→**  b-a<=-t\n2. a-b<t    **→**  b-a<=t-1\n3. a-b=t    **→**  a-b<=t && a-b>=t\n\n根据情况,按上面所说转化。\n\n\n\n## 例题：\n\n1.[LUOGU **P1250** 种树](https:\/\/www.luogu.org\/problemnew\/show\/P1250)\n\n### 题目描述\n\n一条街的一边有几座房子。因为环保原因居民想要在路边种些树。路边的地区被分割成块,并被编号成1..N。每个部分为一个单位尺寸大小并最多可种一棵树。每个居民想在门前种些树并指定了三个号码B,E,T。这三个数表示该居民想在B和E之间最少种T棵树。当然,B≤E,居民必须记住在指定区不能种多于区域地块数的树,所以T≤E-B+l。居民们想种树的各自区域可以交叉。你的任务是求出能满足所有要求的最少的树的数量。\n\n写一个程序完成以下工作：\n\n### 输入输出格式\n\n输入格式：\n\n第一行包含数据N,区域的个数(0<N≤30000)；\n\n第二行包含H,房子的数目(0<H≤5000)；\n\n下面的H行描述居民们的需要：B E T,0<B≤E≤30000,T≤E-B+1。\n\n\n\n输出格式：\n\n输出文件只有一行写有树的数目\n\n### 输入输出样例\n\n输入样例#1：\n\n```\n9\n4\n1 4 2\n4 6 2\n8 9 2\n3 5 2\n```\n\n输出样例#1：\n\n```\n5\n```\n\n### 题解：\n\n```c++\n#include<bits\/stdc++.h>\n#pragma GCC optimize(3)\nnamespace ZDY{\n    #define res register\n    #define ri res int\n    #define ll long long\n    #define db double\n    #define sht short\n    #define il inline\n    #define MB template <class T>\n    #define Fur(i,x,y) for(ri i=x;i<=y;i++)\n    #define fur(i,x,y) for(i=x;i<=y;i++)\n    #define Fdr(i,x,y) for(ri i=x;i>=y;i--)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fl(i,x) for(ri i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n    #define inf 2147483630\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdin)\n    #define l2(n) (ceil(log2(n)))\n    #define fast ios::sync_with_stdio(false)\n    MB il T ABS(T x){return x>0?x:-x;}\n    MB il T MAX(T x,T y){return x>y?x:y;}\n    MB il T MIN(T x,T y){return x<y?x:y;}\n    MB il T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB il void SWAP(T x,T y){T t=x;y=t;x=y;}\n}using namespace ZDY;using namespace std;\n#define N 30010\n\nstruct edge{int to,nxt,w;}e[N*2+5010];\nint head[N],cnt=0,n,m,d[N];\nbool v[N];\nstruct cmp{bool operator()(int a,int b){return d[a]<d[b];}};\npriority_queue<int,vector<int>,cmp>q;\nil void add(int x,int y,int w){e[++cnt].to=y;e[cnt].w=w;e[cnt].nxt=head[x];head[x]=cnt;}\nil void spfa(){\n    int x;\n    q.push(0);\n    while(!q.empty()){\n        x=q.top();q.pop();v[x]=0;\n        fl(i,x)\n        if(d[x]+e[i].w>d[to]){\n            d[to]=d[x]+e[i].w;\n            if(!v[to])q.push(to),v[to]=1;\n        }\n    }\n}\nint main(){\n    fast;\n    cin>>n>>m;\n    int x,y,w;\n    Fur(i,1,m)cin>>x>>y>>w,add(x-1,y,w);\n    Fur(i,0,n){\n        if(i!=0)add(i-1,i,0),d[i]=-inf;\n        if(i!=n)add(i,i-1,-1);\n    }\n    spfa();\n    cout<<d[n];\n}\n```\n\n\n\n2.[LUOGU **P1645** 序列](https:\/\/www.luogu.org\/problemnew\/show\/P1250)\n\n### 题目描述\n\n有一个整数序列,它的每个数各不相同,我们不知道它的长度是多少（即整数个数）,但我们知道在某些区间中间至少有多少个整数,用区间（Li,Ri,Ci）来描述,表示这个整数序列中至少有Ci个数来自区间[Li,Ri],给出若干个这样的区间,问这个整数序列的长度最少能为多少？\n\n### 输入输出格式\n\n输入格式：\n\n第一行一个整数N,表示区间个数；\n\n接下来N行,每行三个整数（Li,Ri,Ci）,描述一个区间。\n\n【数据规模】\n\nN<=1000,0<=Li<=Ri<=1000,1<=Ci<=Ri-Li+1\n\n\n\n输出格式：\n\n仅一个数,表示该整数序列的最小长度。\n\n### 输入输出样例\n\n输入样例#1：\n\n```\n4\n4 5 1\n6 10 3\n7 10 3\n5 6 1\n```\n\n输出样例#1：\n\n```\n4\n```\n\n\n\n### 题解：\n\n```c++\n#include<bits\/stdc++.h>\n#pragma GCC optimize(3)\nnamespace ZDY{\n    #define res register\n    #define ri res int\n    #define ll long long\n    #define db double\n    #define sht short\n    #define il inline\n    #define MB template <class T>\n    #define Fur(i,x,y) for(ri i=x;i<=y;i++)\n    #define fur(i,x,y) for(i=x;i<=y;i++)\n    #define Fdr(i,x,y) for(ri i=x;i>=y;i--)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fl(i,x) for(ri i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n    #define inf 2147483630\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdin)\n    #define l2(n) (ceil(log2(n)))\n    #define fast ios::sync_with_stdio(false)\n    MB il T ABS(T x){return x>0?x:-x;}\n    MB il T MAX(T x,T y){return x>y?x:y;}\n    MB il T MIN(T x,T y){return x<y?x:y;}\n    MB il T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB il void SWAP(T x,T y){T t=x;y=t;x=y;}\n}using namespace ZDY;using namespace std;\n#define N 1011\n\nstruct edge{int to,nxt,w;}e[N*3];\nint head[N],cnt=0,n=0,m,d[N];\nbool v[N];\nstruct cmp{bool operator()(int a,int b){return d[a]<d[b];}};\npriority_queue<int,vector<int>,cmp>q;\nil void add(int x,int y,int w){e[++cnt].to=y;e[cnt].w=w;e[cnt].nxt=head[x];head[x]=cnt;}\nil void spfa(){\n    int x;\n    q.push(0);\n    while(!q.empty()){\n        x=q.top();q.pop();v[x]=0;\n        fl(i,x)\n        if(d[x]+e[i].w>d[to]){\n            d[to]=d[x]+e[i].w;\n            if(!v[to])q.push(to),v[to]=1;\n        }\n    }\n}\nint main(){\n    fast;\n    cin>>m;\n    int x,y,w;\n    Fur(i,1,m)cin>>x>>y>>w,add(x-1,y,w),n=MAX(n,y);\n    Fur(i,0,n){\n        if(i!=0)add(i-1,i,0),d[i]=-inf;\n        if(i!=n)add(i,i-1,-1);\n    }\n    spfa();\n    cout<<d[n];\n}\n```\n\n\n\n\n\n3.[[SCOI2011\\]糖果](https:\/\/www.luogu.org\/problemnew\/show\/P3275)\n\n### 题目描述\n\n幼儿园里有N个小朋友,lxhgww老师现在想要给这些小朋友们分配糖果,要求每个小朋友都要分到糖果。但是小朋友们也有嫉妒心,总是会提出一些要求,比如小明不希望小红分到的糖果比他的多,于是在分配糖果的时候,lxhgww需要满足小朋友们的K个要求。幼儿园的糖果总是有限的,lxhgww想知道他至少需要准备多少个糖果,才能使得每个小朋友都能够分到糖果,并且满足小朋友们所有的要求。\n\n### 输入输出格式\n\n输入格式：\n\n输入的第一行是两个整数N,K。接下来K行,表示这些点需要满足的关系,每行3个数字,X,A,B。如果X=1,  表示第A个小朋友分到的糖果必须和第B个小朋友分到的糖果一样多；如果X=2,  表示第A个小朋友分到的糖果必须少于第B个小朋友分到的糖果；如果X=3, 表示第A个小朋友分到的糖果必须不少于第B个小朋友分到的糖果；如果X=4,  表示第A个小朋友分到的糖果必须多于第B个小朋友分到的糖果；如果X=5, 表示第A个小朋友分到的糖果必须不多于第B个小朋友分到的糖果；\n\n\n\n输出格式：\n\n输出一行,表示lxhgww老师至少需要准备的糖果数,如果不能满足小朋友们的所有要求,就输出-1。\n\n### 输入输出样例\n\n输入样例#1：\n\n```\n5 7\n1 1 2\n2 3 2\n4 4 1\n3 4 5\n5 4 5\n2 3 5\n4 5 1\n```\n\n输出样例#1：\n\n```\n11\n```\n\n### 说明\n\n【数据范围】\n\n对于30%的数据,保证 N<=100\n\n对于100%的数据,保证 N<=100000\n\n对于所有的数据,保证 K<=100000,1<=X<=5,1<=A, B<=N\n\n\n\n### 题解：\n\n```c++\n#include<bits\/stdc++.h>\n#pragma GCC optimize(3)\nnamespace ZDY{\n    #define res register\n    #define ri res int\n    #define ll long long\n    #define db double\n    #define sht short\n    #define il inline\n    #define MB template <class T>\n    #define Fur(i,x,y) for(ri i=x;i<=y;i++)\n    #define fur(i,x,y) for(i=x;i<=y;i++)\n    #define Fdr(i,x,y) for(ri i=x;i>=y;i--)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fl(i,x) for(ri i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n    #define inf 2147483630\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdin)\n    #define l2(n) (ceil(log2(n)))\n    #define fast ios::sync_with_stdio(false)\n    MB il T ABS(T x){return x>0?x:-x;}\n    MB il T MAX(T x,T y){return x>y?x:y;}\n    MB il T MIN(T x,T y){return x<y?x:y;}\n    MB il T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB il void SWAP(T x,T y){T t=x;y=t;x=y;}\n}using namespace ZDY;using namespace std;\n#define N 100010\n\nstruct edge{int to,nxt,w;}e[N*3];\nint head[N],cnt=0,n=0,m,d[N],t[N];\nbool v[N];\nstruct cmp{bool operator()(int a,int b){return d[a]<d[b];}};\npriority_queue<int,vector<int>,cmp>q;\nil void add(int x,int y,int w){e[++cnt].to=y;e[cnt].w=w;e[cnt].nxt=head[x];head[x]=cnt;}\nil void spfa(){\n    int x;\n    q.push(0);\n    while(!q.empty()){\n        x=q.top();q.pop();v[x]=0;if(++t[x]>n){cout<<-1<<endl;exit(0);}\n        fl(i,x)\n        if(d[x]+e[i].w>d[to]){\n            d[to]=d[x]+e[i].w;\n            if(!v[to])q.push(to),v[to]=1;\n        }\n    }\n}\nint main(){\n    fast;\n    cin>>n>>m;\n    int p,x,y;\n    ll ans=0;\n    Fur(i,1,m){\n        cin>>p>>x>>y;\n        if(p==1)add(x,y,0),add(y,x,0);\n        if(p==2)add(x,y,1);\n        if(p==3)add(y,x,0);\n        if(p==4)add(y,x,1);\n        if(p==5)add(x,y,0);\n    }\n    Fur(i,1,n)add(0,i,1);\n    spfa();\n    Fur(i,1,n)ans+=d[i];\n    cout<<ans<<endl;\n}\n```\n\n","link":null,"tags":["图论","算法","技巧"],"title":"差分拘束"},{"categories":[["刷题记录"]],"content":"\n## 题目描述\n\n对于一个整数集合,我们定义“加等式”如下：集合中的某一个元素可以表示成集合内其他元素之和。如集合{1,2,3}中就有一个加等式：3＝1+2,而且3＝1+2 和3＝2+1是相同的加等式,也是这个集合唯一的加等式。给定一个整数集合,编程找出其所有的加等式的个数\n\n## 输入输出格式\n\n输入格式：\n\n\n\n第一行为t,表示测试数据组数。(1≤t≤10)；\n\n接下来t 行,每行表示一组测试数据。其中第一个数m（1≤m≤30）,表示集合元素的个数,接下来m 个不同的整数x 分别表示集合元素（1≤x≤1000）。\n\n\n\n输出格式： \n\n对于每个输入数据,输出一个整数,表示其中加等式的个数。\n\n## 输入输出样例\n\n输入样例#1：\n\n```\n3\n3 1 2 3\n3 1 2 5\n6 1 2 3 5 4 6\n```\n\n输出样例#1：\n\n```\n1\n0\n7\n```\n\n\n\n## Solution:\n\nfirst,排序,second dp。\n\nf[i]:相加后的和为i的方案数\n\nf[j]+=f[j-a[i]]\n\n有点像变形的背包\n\n```c++\n#include<bits\/stdc++.h>\n#pragma GCC optimize(3)\nnamespace ZDY{\n    #define res register\n    #define ri res int\n    #define ll long long\n    #define db double\n    #define sht short\n    #define il inline\n    #define MB template <class T>\n    #define Fur(i,x,y) for(ri i=x;i<=y;i++)\n    #define fur(i,x,y) for(i=x;i<=y;i++)\n    #define Fdr(i,x,y) for(ri i=x;i>=y;i--)\n    #define in2(x,y) in(x),in(y)\n    #define in3(x,y,z) in2(x,y),in(z)\n    #define in4(a,b,c,d) in2(a,b);in2(c,d)\n    #define outn(x) out(x),pc('\\n')\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fl(i,x) for(ri i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n    #define inf 2147483630\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdin)\n    #define gt io.gc()\n    #define l2(n) (log(n)\/log(2))\n    MB il T ABS(T x){return x>0?x:-x;}\n    MB il T MAX(T x,T y){return x>y?x:y;}\n    MB il T MIN(T x,T y){return x<y?x:y;}\n    MB il T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB il void SWAP(T x,T y){T t=x;y=t;x=y;}\n}using namespace ZDY;using namespace std;\n\nclass IO{\n   #define fok (ch!=EOF)\n   #define sep (ch==' '||ch=='\\n'||ch=='\\t')\n   #define dsep !isdigit(ch)\n   #define neq(a,b) ((a)-(b)>1e-6)\n   char rbuf[1<<20],wbuf[1<<20],b,*p1,*p2;\n   int rs,ws,S;\n   public:\n       IO():p1(rbuf),p2(wbuf),S(1000000),rs(1000000),ws(-1),b(1){}\n       ~IO(){fwrite(wbuf,1,ws+1,stdout);}\n       il char gc(){return rs==S&&(p1=rbuf,rs=-1,(S=fread(rbuf,1,S+1,stdin)-1)==-1)?(b=0,EOF):(++rs,*p1++);}\n       il void pc(int x){ws==1000000&&(p2=wbuf,ws=-1,fwrite(wbuf,1,1000001,stdout)),++ws,*p2++=x;}\n       il void puts(const char str[]){fwrite(wbuf,1,ws+1,stdout)?(ws=-1):0,fwrite(str,1,strlen(str),stdout);}\n       il void gl(string& s){for(res char ch;(ch=gc())!='\\n'&&fok;)s+=ch;}\n       il IO& operator>>(int& x){x=0;res char f=0,ch=gc();while(dsep&&fok)f|=(ch=='-'),ch=gc();while(isdigit(ch))x=(x<<1)+(x<<3)+(ch^48),ch=gc();return x=f?-x:x,*this;}\n       il IO& operator>>(ll& x){x=0;res char f=0,ch=gc();while(dsep&&fok)f|=(ch=='-'),ch=gc();while(isdigit(ch))x=(x<<1)+(x<<3)+(ch^48),ch=gc();return x=f?-x:x,*this;}\n       il IO& operator>>(char& ch){return ch=gc(),*this;}\n       il IO& operator>>(string& s){res char ch=gc();while(sep&&fok)ch=gc();while(!sep&&fok)s+=ch,ch=gc();return *this;}\n       il IO& operator>>(double& x){x=0;res char f=0,ch=gc();double d=0.1;while(dsep&&fok)f|=(ch=='-'),ch=gc();while(isdigit(ch))x=x*10+(ch^48),ch=gc();if(ch=='.')while(isdigit(ch=gc()))x+=d*(ch^48),d*=0.1;return x=f?-x:x,*this;}\n       il IO& operator<<(int x){res char ch[10],i=-1;!x?(pc('0'),0):0,x<0?(pc('-'),x=-x):0;while(x)ch[++i]=x%10+48,x\/=10;while(~i)pc(ch[i]),--i;return *this;}\n       il IO& operator<<(ll x){res char ch[20],i=-1;!x?(pc('0'),0):0,x<0?(pc('-'),x=-x):0;while(x)ch[++i]=x%10+48,x\/=10;while(~i)pc(ch[i]),--i;return *this;}\n       il IO& operator<<(char ch){return pc(ch),*this;}\n       il IO& operator<<(char str[]){return puts(str),*this;}\n       il IO& operator<<(double x){int y=int(x);*this<<y;x-=y;while(neq(x,int(x)))x*=10;x?*this<<'.'<<int(x):0;return *this;}\n       il operator bool(){return b;}\n}io;\n#define N 31\nint t,n,a[N],s,ans,f[30001];\nint main(){\n    io>>t;\n    while(t--){\n        io>>n;s=ans=0;\n        Fur(i,1,n)io>>a[i],s+=a[i];\n        sort(a+1,a+n+1);clr(f,0);\n        f[0]=1;\n        Fur(i,1,n){\n            ans+=f[a[i]];\n            Fdr(j,s,a[i])f[j]+=f[j-a[i]];\n        }\n        io<<ans<<'\\n';\n    }\n}\n```","link":null,"tags":["动态规划","背包"],"title":"加等式"}]